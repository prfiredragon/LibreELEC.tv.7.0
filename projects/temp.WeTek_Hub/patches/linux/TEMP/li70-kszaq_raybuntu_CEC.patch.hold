From 3c2c49d414d5fa623e6444e5f051e33bcc745520 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Sun, 14 Aug 2016 10:36:17 +0200
Subject: [PATCH] drivers/amlogic/cec: Import libCEC driver from @Raybuntu

https://github.com/Raybuntu/linux/tree/9bc353507fbaf11a1e9551586d56174ab28fc3d3
---
 drivers/amlogic/cec/hdmi_ao_cec.c                | 433 +++++++++++++++++++++--
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c   |   3 +
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c   |   3 +
 include/linux/amlogic/hdmi_tx/hdmi_info_global.h |   4 +
 include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h   |  12 +
 5 files changed, 434 insertions(+), 21 deletions(-)

diff --git a/drivers/amlogic/cec/hdmi_ao_cec.c b/drivers/amlogic/cec/hdmi_ao_cec.c
index 024ff864..3a6da78 100644
--- a/drivers/amlogic/cec/hdmi_ao_cec.c
+++ b/drivers/amlogic/cec/hdmi_ao_cec.c
@@ -128,16 +128,16 @@ static unsigned char rx_len;
 static unsigned int  new_msg;
 static bool wake_ok = 1;
 static bool ee_cec;
-bool cec_msg_dbg_en = 0;
+bool cec_msg_dbg_en = 1;
 
-#define CEC_ERR(format, args...)				\
-	{if (cec_dev->dbg_dev)					\
-		dev_err(cec_dev->dbg_dev, format, ##args);	\
+#define CEC_ERR(format, args...)                \
+	{if (cec_dev->dbg_dev)                  \
+		dev_err(cec_dev->dbg_dev, "%s(): " format, __func__, ##args);  \
 	}
 
-#define CEC_INFO(format, args...)				\
-	{if (cec_msg_dbg_en && cec_dev->dbg_dev)		\
-		dev_info(cec_dev->dbg_dev, format, ##args);	\
+#define CEC_INFO(format, args...)               \
+	{if (cec_msg_dbg_en && cec_dev->dbg_dev)        \
+		dev_info(cec_dev->dbg_dev, "%s(): " format, __func__, ##args); \
 	}
 
 static unsigned char msg_log_buf[128] = { 0 };
@@ -153,6 +153,75 @@ static unsigned char msg_log_buf[128] = { 0 };
 		} \
 	} while (0)
 
+#define HR_DELAY(n)     (ktime_set(0, n * 1000 * 1000))
+__u16 cec_key_map[160] = {
+	KEY_ENTER, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
+	0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
+	0 , 0, 0, 0, 0, 0, 0, 0,//0x10
+	0 , 0, 0, 0, 0, 0, 0, 0,
+	KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
+	KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
+	KEY_CHANNELUP , KEY_CHANNELDOWN, KEY_CHANNEL, 0, 0, 0, 0, 0,//0x30
+	0 , 0, 0, 0, 0, 0, 0, 0,
+
+	KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+	KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
+	0 , 0, 0, KEY_PROGRAM, 0, 0, 0, 0,//0x50
+	0 , 0, 0, 0, 0, 0, 0, 0,
+	KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
+	0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
+	0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
+	0 , 0, 0, 0, 0, 0, 0, 0x2fd,
+	0 , 0, 0, 0, 0, 0, 0, 0,//0x80
+	0 , 0, 0, 0, 0, 0, 0, 0,
+	0 , KEY_EXIT, 0, 0, 0, 0, KEY_PVR, 0,//0x90  //samsung vendor buttons return and channel_list
+	0 , 0, 0, 0, 0, 0, 0, 0,
+};
+
+struct hrtimer cec_key_timer;
+static int last_key_irq = -1;
+static int key_value = 1;
+enum hrtimer_restart cec_key_up(struct hrtimer *timer)
+{
+	if (key_value == 1){
+		input_event(cec_dev->cec_info.remote_cec_dev,
+		EV_KEY, cec_key_map[last_key_irq], 0);
+	}
+	input_sync(cec_dev->cec_info.remote_cec_dev);
+	CEC_INFO("last:%d up\n", cec_key_map[last_key_irq]);
+	key_value = 2;
+
+	return HRTIMER_NORESTART;
+}
+
+void cec_user_control_pressed_irq(unsigned char message_irq)
+{
+	if (message_irq < 160) {
+		CEC_INFO("Key pressed: %d\n", message_irq);
+		input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY,
+				cec_key_map[message_irq], key_value);
+		input_sync(cec_dev->cec_info.remote_cec_dev);
+		last_key_irq = message_irq;
+		hrtimer_start(&cec_key_timer, HR_DELAY(200), HRTIMER_MODE_REL);
+		CEC_INFO(":key map:%d\n", cec_key_map[message_irq]);
+	}
+}
+
+void cec_user_control_released_irq(void)
+{
+	/*
+	 * key must be valid
+	 */
+	if (last_key_irq != -1) {
+		CEC_INFO("Key released: %d\n",last_key_irq);
+		hrtimer_cancel(&cec_key_timer);
+		input_event(cec_dev->cec_info.remote_cec_dev,
+				EV_KEY, cec_key_map[last_key_irq], 0);
+		input_sync(cec_dev->cec_info.remote_cec_dev);
+		key_value = 1;
+	}
+}
+
 void cec_set_reg_bits(unsigned int addr, unsigned int value,
 	unsigned int offset, unsigned int len)
 {
@@ -554,6 +623,41 @@ int cec_ll_rx(unsigned char *msg, unsigned char *len)
 	return ret;
 }
 
+void cec_polling_online_dev(int log_addr, int *bool)
+{
+	unsigned int r;
+	unsigned char msg[1];
+	int retry = 5;
+
+	msg[0] = (log_addr<<4) | log_addr;
+	/* set broadcast address first */
+	cec_logicaddr_set(0xf);
+	if (cec_msg_dbg_en == 1)
+		CEC_INFO("CEC_LOGICAL_ADDR0:0x%i\n",
+				 aocec_rd_reg(CEC_LOGICAL_ADDR0));
+	while (retry) {
+		r = cec_ll_tx(msg, 1);
+		if (r == CEC_FAIL_BUSY) {
+			retry--;
+			CEC_INFO("try log addr %x busy, retry:%d\n",
+					 log_addr, retry);
+			/*
+			 * try to reset CEC if tx busy is found
+			 */
+			cec_hw_reset();
+		} else
+			break;
+	}
+
+	if (r == CEC_FAIL_NACK) {
+		*bool = 0;
+	} else if (r == CEC_FAIL_NONE) {
+		*bool = 1;
+	}
+	CEC_INFO("CEC: poll online logic device: 0x%x BOOL: %d\n",
+			 log_addr, *bool);
+}
+
 /************************ cec arbitration cts code **************************/
 /* using the cec pin as fiq gpi to assist the bus arbitration */
 
@@ -837,6 +941,18 @@ unsigned int cec_phyaddr_config(unsigned int value, bool wr_flag)
 	return readl(cec_dev->cec_reg + AO_DEBUG_REG1);
 }
 
+/*
+ *wr_flag:1 write; value valid
+ *      0 read;  value invalid
+ */
+unsigned int cec_logicaddr_config(unsigned int value, bool wr_flag)
+{
+	if (wr_flag)
+		cec_set_reg_bits(AO_DEBUG_REG3, value, 0, 8);
+
+	return readl(cec_dev->cec_reg + AO_DEBUG_REG3);
+}
+
 void cec_keep_reset(void)
 {
 	writel(0x1, cec_dev->cec_reg + AO_CEC_GEN_CNTL);
@@ -967,6 +1083,27 @@ void cec_menu_status_smp(int dest, int status)
 	cec_ll_tx(msg, 3);
 }
 
+void cec_imageview_on_smp(void)
+{
+	unsigned char msg[2];
+	unsigned char index = cec_dev->cec_info.log_addr;
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_IMAGE_VIEW_ON;
+	cec_ll_tx(msg, 2);
+}
+
+void cec_get_menu_language_smp(void)
+{
+	unsigned char msg[2];
+	unsigned char index = cec_dev->cec_info.log_addr;
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_GET_MENU_LANGUAGE;
+
+	cec_ll_tx(msg, 2);
+}
+
 void cec_inactive_source(int dest)
 {
 	unsigned char index = cec_dev->cec_info.log_addr;
@@ -1051,6 +1188,149 @@ void cec_report_power_status(int dest, int status)
 	cec_ll_tx(msg, 3);
 }
 
+void cec_send_simplink_alive(void)
+{
+	unsigned char index = cec_dev->cec_info.log_addr;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x2;
+	msg[3] = 0x5;
+
+	cec_ll_tx(msg, 4);
+}
+
+void cec_send_simplink_ack(void)
+{
+	unsigned char index = cec_dev->cec_info.log_addr;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x5;
+	msg[3] = 0x1;
+
+	cec_ll_tx(msg, 4);
+}
+
+int cec_node_init(struct hdmitx_dev *hdmitx_device)
+{
+	unsigned char a, b, c, d;
+
+	int i, bool = 0;
+	int phy_addr_ok = 1;
+	const enum _cec_log_dev_addr_e player_dev[3] = {
+		CEC_RECORDING_DEVICE_1_ADDR,
+		CEC_RECORDING_DEVICE_2_ADDR,
+		CEC_RECORDING_DEVICE_3_ADDR,
+	};
+
+	unsigned long cec_phy_addr;
+
+	/* If no connect, return directly */
+	if ((hdmitx_device->cec_init_ready == 0) ||
+			(hdmitx_device->hpd_state == 0)) {
+		return -1;
+	}
+
+	if (wait_event_interruptible(hdmitx_device->hdmi_info.vsdb_phy_addr.waitq,
+		hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 1))
+	{
+		CEC_INFO("error during wait for a valid physical address\n");
+		return -ERESTARTSYS;
+	}
+
+	a = hdmitx_device->hdmi_info.vsdb_phy_addr.a;
+	b = hdmitx_device->hdmi_info.vsdb_phy_addr.b;
+	c = hdmitx_device->hdmi_info.vsdb_phy_addr.c;
+	d = hdmitx_device->hdmi_info.vsdb_phy_addr.d;
+
+	/* Don't init if switched to libcec mode*/
+	if ((cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL)))
+		return -1;
+
+	if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+		return -1;
+
+	CEC_INFO("cec_node_init started\n");
+
+	cec_phy_addr = ((a << 12) | (b << 8) | (c << 4) | (d << 0));
+
+	for (i = 0; i < 3; i++) {
+		CEC_INFO("CEC: start poll dev\n");
+		cec_polling_online_dev(player_dev[i], &bool);
+		CEC_INFO("player_dev[%d]:0x%x\n", i, player_dev[i]);
+		if (bool == 0) {   /* 0 means that no any respond */
+			/* If VSDB is not valid, use last or default physical address. */
+			cec_logicaddr_set(player_dev[i]);
+			if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
+				phy_addr_ok = 0;
+				CEC_INFO("invalid cec PhyAddr\n");
+				if (cec_phyaddr_config(0, 0)) {
+					CEC_INFO("use last physical address\n");
+				} else {
+					cec_phyaddr_config(0x2000, 1);
+					CEC_INFO("use Def Phy address\n");
+				}
+			} else
+				cec_phyaddr_config(cec_phy_addr, 1);
+
+			CEC_INFO("physical address:0x%x\n",
+					 cec_phyaddr_config(0, 0));
+
+			cec_dev->cec_info.power_status = TRANS_STANDBY_TO_ON;
+			cec_logicaddr_config(player_dev[i], 1);
+			cec_dev->cec_info.log_addr = player_dev[i];
+			/* Set Physical address */
+			cec_dev->phy_addr = cec_phy_addr;
+
+			cec_dev->cec_info.cec_version = CEC_VERSION_14A;
+			cec_dev->cec_info.vendor_id = cec_dev->v_data.vendor_id;
+			strcpy(cec_dev->cec_info.osd_name,
+				   cec_dev->v_data.cec_osd_string);
+			cec_logicaddr_set(player_dev[i]);
+
+			CEC_INFO("Set logical address: %d\n",
+					 player_dev[i]);
+
+			cec_dev->cec_info.power_status = POWER_ON;
+			if (cec_dev->cec_info.menu_status == DEVICE_MENU_INACTIVE)
+				break;
+			msleep(100);
+			if (phy_addr_ok) {
+				cec_report_physical_address_smp();
+				msleep(150);
+			}
+			cec_device_vendor_id();
+			cec_set_osd_name(0);
+
+			/* Disable switch TV on automatically */
+			if (!(hdmitx_device->cec_func_config &
+					(1 << AUTO_POWER_ON_MASK))) {
+				CEC_INFO("Auto TV switch on disabled\n");
+				break;
+			}
+
+			cec_active_source_smp();
+			cec_imageview_on_smp();
+
+			cec_menu_status_smp(CEC_TV_ADDR, DEVICE_MENU_ACTIVE);
+
+			msleep(100);
+			cec_get_menu_language_smp();
+			cec_dev->cec_info.menu_status = DEVICE_MENU_ACTIVE;
+			break;
+		}
+	}
+	if (bool == 1) {
+		CEC_INFO("Can't get a valid logical address\n");
+		return -1;
+	} else {
+		CEC_INFO("cec node init: cec features ok !\n");
+		return 0;
+	}
+}
 static void cec_rx_process(void)
 {
 	int len = rx_len;
@@ -1071,15 +1351,15 @@ static void cec_rx_process(void)
 	opcode = msg[1];
 	switch (opcode) {
 	case CEC_OC_ACTIVE_SOURCE:
-		if (wake_ok == 0) {
-			int phy_addr = msg[2] << 8 | msg[3];
-			if (phy_addr == 0xffff)
-				break;
-			wake_ok = 1;
-			phy_addr |= (initiator << 16);
-			writel(phy_addr, cec_dev->cec_reg + AO_RTI_STATUS_REG1);
-			CEC_INFO("found wake up source:%x", phy_addr);
-		}
+		//if (wake_ok == 0) {
+		//	int phy_addr = msg[2] << 8 | msg[3];
+		//	if (phy_addr == 0xffff)
+		//		break;
+		//	wake_ok = 1;
+		//	phy_addr |= (initiator << 16);
+		//	writel(phy_addr, cec_dev->cec_reg + AO_RTI_STATUS_REG1);
+		//	CEC_INFO("found wake up source:%x", phy_addr);
+		//}
 		break;
 
 	case CEC_OC_GET_CEC_VERSION:
@@ -1126,7 +1406,15 @@ static void cec_rx_process(void)
 			cec_report_power_status(initiator, POWER_ON);
 		break;
 
+
+	case CEC_OC_USER_CONTROL_RELEASED:
+		cec_user_control_released_irq();
+		break;
+
 	case CEC_OC_USER_CONTROL_PRESSED:
+		if (len < 3)
+			break;
+		cec_user_control_pressed_irq(msg[2]);
 		/* wake up by key function */
 		if (cec_dev->cec_suspend == CEC_EARLY_SUSPEND) {
 			if (msg[2] == 0x40 || msg[2] == 0x6d)
@@ -1134,12 +1422,87 @@ static void cec_rx_process(void)
 		}
 		break;
 
+	case CEC_OC_PLAY:
+		if (len < 3)
+			break;
+		switch (msg[2]) {
+		case 0x24:
+			input_event(cec_dev->cec_info.remote_cec_dev,
+						EV_KEY, KEY_PLAYPAUSE, 1);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			input_event(cec_dev->cec_info.remote_cec_dev,
+						EV_KEY, KEY_PLAYPAUSE, 0);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			break;
+		case 0x25:
+			input_event(cec_dev->cec_info.remote_cec_dev,
+						EV_KEY, KEY_PLAYPAUSE, 1);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			input_event(cec_dev->cec_info.remote_cec_dev,
+						EV_KEY, KEY_PLAYPAUSE, 0);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case CEC_OC_DECK_CONTROL:
+		if (len < 3)
+			break;
+		switch (msg[2]) {
+		case 0x3:
+			input_event(cec_dev->cec_info.remote_cec_dev,
+						EV_KEY, KEY_STOP, 1);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			input_event(cec_dev->cec_info.remote_cec_dev,
+						EV_KEY, KEY_STOP, 0);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+		if (len < 3)
+			break;
+		switch(msg[2]) {
+		//samsung vendor keys
+		case 0x91:
+			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 1);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 0);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			break;
+		case 0x96:
+			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 1);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 0);
+			input_sync(cec_dev->cec_info.remote_cec_dev);
+			break;
+		default:
+			break;
+		}
+		break;
 	case CEC_OC_MENU_REQUEST:
 		if (cec_dev->cec_suspend)
 			cec_menu_status_smp(initiator, DEVICE_MENU_INACTIVE);
 		else
 			cec_menu_status_smp(initiator, DEVICE_MENU_ACTIVE);
 		break;
+	case CEC_OC_VENDOR_COMMAND:
+		if (len < 3)
+			break;
+		if (msg[2] == 0x1) {
+			cec_report_power_status(initiator, cec_dev->cec_info.power_status);
+			cec_send_simplink_alive();
+		} else if (msg[2] == 0x4) {
+			cec_send_simplink_ack();
+		}
+		break;
+	case CEC_OC_DEVICE_VENDOR_ID:
+		break;
 
 	default:
 		CEC_ERR("unsupported command:%x\n", opcode);
@@ -1151,10 +1514,17 @@ static void cec_rx_process(void)
 static void cec_task(struct work_struct *work)
 {
 	struct delayed_work *dwork;
+	int ret;
 
 	dwork = &cec_dev->cec_work;
-	if (cec_dev && !wake_ok &&
-	   !(cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL))) {
+	if (cec_dev &&
+			!(cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL))) {
+		if (1 << cec_dev->cec_info.log_addr & (1 << 0x0 | 1 << 0xF)) {
+			ret = cec_node_init(cec_dev->tx_dev);
+			if (ret < 0) {
+				return;
+			}
+		}
 		cec_rx_process();
 	}
 	if (!ee_cec && !cec_late_check_rx_buffer())
@@ -1453,6 +1823,13 @@ static struct class_attribute aocec_class_attr[] = {
 /******************** cec hal interface ***************************/
 static int hdmitx_cec_open(struct inode *inode, struct file *file)
 {
+	if (wait_event_interruptible(cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.waitq,
+		cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.valid == 1))
+	{
+		CEC_INFO("error during wait for a valid physical address\n");
+		return -ERESTARTSYS;
+	}
+
 	cec_dev->cec_info.open_count++;
 	if (cec_dev->cec_info.open_count) {
 		cec_dev->cec_info.hal_ctl = 1;
@@ -1491,6 +1868,7 @@ static ssize_t hdmitx_cec_read(struct file *f, char __user *buf,
 
 	if (copy_to_user(buf, rx_msg, rx_len))
 		return -EINVAL;
+	CEC_INFO("RX len: %d\n", rx_len);
 	return rx_len;
 }
 
@@ -1509,7 +1887,14 @@ static ssize_t hdmitx_cec_write(struct file *f, const char __user *buf,
 		return -EINVAL;
 
 	ret = cec_ll_tx(tempbuf, size);
-	return ret;
+	/* delay a byte for continue message send */
+	msleep(25);
+	if (ret == CEC_FAIL_NACK) {
+		return -1;
+	}
+	else {
+		return size;
+	}
 }
 
 static void init_cec_port_info(struct hdmi_port_info *port,
@@ -1737,6 +2122,7 @@ static long hdmitx_cec_ioctl(struct file *f,
 
 	case CEC_IOC_ADD_LOGICAL_ADDR:
 		tmp = arg & 0xf;
+		CEC_INFO("CEC LA ARG:%ld", arg);
 		cec_logicaddr_set(tmp);
 		/* add by hal, to init some data structure */
 		cec_dev->cec_info.log_addr = tmp;
@@ -1834,6 +2220,7 @@ static void aocec_late_resume(struct early_suspend *h)
 
 static int aml_cec_probe(struct platform_device *pdev)
 {
+	int i;
 	struct device *cdev;
 #ifdef CONFIG_OF
 	struct device_node *node = pdev->dev.of_node;
@@ -1889,6 +2276,8 @@ static int aml_cec_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 	INIT_DELAYED_WORK(&cec_dev->cec_work, cec_task);
+	hrtimer_init(&cec_key_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	cec_key_timer.function = cec_key_up;
 	cec_dev->cec_info.remote_cec_dev = input_allocate_device();
 	if (!cec_dev->cec_info.remote_cec_dev)
 		CEC_INFO("No enough memory\n");
@@ -1903,8 +2292,8 @@ static int aml_cec_probe(struct platform_device *pdev)
 	cec_dev->cec_info.remote_cec_dev->id.product = 0x0cec;
 	cec_dev->cec_info.remote_cec_dev->id.version = 0x0001;
 
-	set_bit(KEY_POWER, cec_dev->cec_info.remote_cec_dev->keybit);
-
+	for (i = 0; i < 160; i++)
+		set_bit(cec_key_map[i], cec_dev->cec_info.remote_cec_dev->keybit);
 	if (input_register_device(cec_dev->cec_info.remote_cec_dev)) {
 		CEC_INFO("Failed to register device\n");
 		input_free_device(cec_dev->cec_info.remote_cec_dev);
@@ -2031,6 +2420,7 @@ static int aml_cec_probe(struct platform_device *pdev)
 	/* for init */
 	cec_pre_init();
 	queue_delayed_work(cec_dev->cec_thread, &cec_dev->cec_work, 0);
+	cec_dev->tx_dev->cec_init_ready = 1;
 	return 0;
 }
 
@@ -2038,6 +2428,7 @@ static int aml_cec_remove(struct platform_device *pdev)
 {
 	CEC_INFO("cec uninit!\n");
 	free_irq(cec_dev->irq_cec, (void *)cec_dev);
+	cec_dev->tx_dev->cec_init_ready = 0;
 
 	if (cec_dev->cec_thread) {
 		cancel_delayed_work_sync(&cec_dev->cec_work);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
index 4724366..f0e2b30 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
@@ -318,6 +318,9 @@ static void set_vsdb_phy_addr(struct vsdb_phyaddr *vsdb,
 	vsdb->d = (edid_offset[5] >> 0) & 0xf;
 	vsdb_local = *vsdb;
 	vsdb->valid = 1;
+#ifdef CONFIG_AML_AO_CEC
+	wake_up_interruptible(&vsdb->waitq);
+#endif
 }
 
 static void set_vsdb_dc_cap(struct rx_cap *pRXCap,
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
index 6b759d7..4c681a1 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
@@ -2739,6 +2739,9 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	HDMITX_Meson_Init(&hdmitx_device);
 	hdmitx_device.task = kthread_run(hdmi_task_handle,
 		&hdmitx_device, "kthread_hdmi");
+#ifdef CONFIG_AML_AO_CEC
+	init_waitqueue_head(&hdmitx_device.hdmi_info.vsdb_phy_addr.waitq);
+#endif
 
 	if (r < 0) {
 		hdmi_print(INF, SYS "register switch dev failed\n");
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_info_global.h b/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
index c5bed3d..d8d7ed6 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
@@ -19,6 +19,7 @@
 #define _HDMI_INFO_GLOBAL_H
 
 #include "hdmi_common.h"
+#include <linux/wait.h>
 
 /* old definitions move to hdmi_common.h */
 
@@ -269,6 +270,9 @@ struct vsdb_phyaddr {
 	unsigned char c:4;
 	unsigned char d:4;
 	unsigned char valid;
+#ifdef CONFIG_AML_AO_CEC
+	wait_queue_head_t waitq;
+#endif
 };
 
 struct hdmitx_clk {
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h
index f5b0fcd..e0df963 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h
@@ -333,6 +333,7 @@ void cec_arbit_bit_time_set(unsigned , unsigned , unsigned);
 void cec_clear_buf(unsigned int flag);
 void cec_keep_reset(void);
 void cec_logicaddr_set(int logicaddr);
+void cec_logicaddr_clear(void);
 void ao_cec_init(void);
 void tx_irq_handle(void);
 
@@ -340,6 +341,17 @@ unsigned int cec_config(unsigned int value, bool wr_flag);
 unsigned int cec_intr_stat(void);
 unsigned int cec_phyaddr_config(unsigned int value, bool wr_flag);
 unsigned int cec_logicaddr_config(unsigned int value, bool wr_flag);
+int  cec_node_init(struct hdmitx_dev *hdmitx_device);
+void cec_polling_online_dev(int log_addr, int *bool);
+void cec_imageview_on_smp(void);
+void cec_get_menu_language_smp(void);
+
+void cec_user_control_pressed_irq(unsigned char message_irq);
+void cec_user_control_released_irq(void);
+extern __u16 cec_key_map[160];
+void cec_active_source_smp(void);
+void cec_send_simplink_alive(void);
+void cec_send_simplink_ack(void);
 
 extern bool cec_msg_dbg_en;
 extern struct cec_global_info_t cec_info;
