From 5659d4dd7573e30f385e6425468476d85463ff3a Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Sun, 2 Oct 2016 22:19:28 +0800
Subject: [PATCH] Revert vh265.c

---
 drivers/amlogic/amports/vh265.c | 47 +++++------------------------------------
 1 file changed, 5 insertions(+), 42 deletions(-)

diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
index a1ecbc3..e962733 100644
--- a/drivers/amlogic/amports/vh265.c
+++ b/drivers/amlogic/amports/vh265.c
@@ -154,7 +154,7 @@ static u32 workaround_enable;
 static u32 force_w_h;
 #endif
 static u32 force_fps;
-static u32 pts_unstable;
+
 #define H265_DEBUG_BUFMGR                   0x01
 #define H265_DEBUG_BUFMGR_MORE              0x02
 #define H265_DEBUG_UCODE                    0x04
@@ -1351,7 +1351,7 @@ static unsigned int log2i(unsigned int val)
 static int init_buf_spec(struct hevc_state_s *hevc);
 
 /*USE_BUF_BLOCK*/
-static void uninit_buf_list(struct hevc_state_s *hevc, bool force_free)
+static void uninit_buf_list(struct hevc_state_s *hevc)
 {
 	int i;
 	unsigned char release_cma_flag = 0;
@@ -1364,12 +1364,6 @@ static void uninit_buf_list(struct hevc_state_s *hevc, bool force_free)
 
 	hevc->predisp_addr = 0;
 
-	if (force_free) {
-		blackout = 0;
-		buffer_mode_real = 0;
-		pr_info("maybe reuinit buf_list, free cma buffer\n");
-	}
-
 	if (buffer_mode_real & 1) {
 		if (blackout == 1)
 			release_cma_flag = 1;
@@ -1554,8 +1548,6 @@ static void init_buf_list(struct hevc_state_s *hevc)
 		}
 	}
 
-	pr_info("allocate begin\n");
-	get_cma_alloc_ref();
 	for (i = 0; i < hevc->used_buf_num; i++) {
 		if (((i + 1) * buf_size) > hevc->mc_buf->buf_size) {
 			if (use_cma)
@@ -1625,7 +1617,7 @@ static void init_buf_list(struct hevc_state_s *hevc)
 					hevc->m_BUF[i].cma_page_count = 0;
 					break;
 				}
-				pr_debug("allocate cma buffer[%d] (%d,%ld,%ld)\n",
+				pr_info("allocate cma buffer[%d] (%d,%ld,%ld)\n",
 						i,
 						hevc->m_BUF[i].cma_page_count,
 						hevc->m_BUF[i].alloc_addr,
@@ -1662,8 +1654,6 @@ static void init_buf_list(struct hevc_state_s *hevc)
 				   hevc->m_BUF[i].size);
 		}
 	}
-	put_cma_alloc_ref();
-	pr_info("allocate end\n");
 
 	hevc->buf_num = i;
 
@@ -4671,9 +4661,6 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		else
 			hevc->pts_hit++;
 #endif
-		if (pts_unstable && (hevc->frame_dur > 0)) {
-			hevc->pts_mode = PTS_NONE_REF_USE_DURATION;
-		}
 
 		if ((hevc->pts_mode == PTS_NORMAL) && (vf->pts != 0)
 			&& hevc->get_frame_dur) {
@@ -5849,7 +5836,6 @@ static int h265_task_handle(void *data)
 {
 	int ret = 0;
 	struct hevc_state_s *hevc = (struct hevc_state_s *)data;
-	set_user_nice(current, -10);
 	while (1) {
 		if (use_cma == 0) {
 			pr_info
@@ -5872,7 +5858,7 @@ static int h265_task_handle(void *data)
 
 		if (hevc->uninit_list) {
 			/*USE_BUF_BLOCK*/
-			uninit_buf_list(hevc, false);
+			uninit_buf_list(hevc);
 			pr_info("uninit list\n");
 			hevc->uninit_list = 0;
 		}
@@ -5883,25 +5869,6 @@ static int h265_task_handle(void *data)
 
 }
 
-void vh265_free_cmabuf(void)
-{
-	struct hevc_state_s *hevc = &gHevc;
-
-	mutex_lock(&vh265_mutex);
-
-	if (hevc->init_flag) {
-		mutex_unlock(&vh265_mutex);
-		return;
-	}
-
-	if (use_cma) {
-		pr_info("force uninit_buf_list\n");
-		uninit_buf_list(hevc, true);
-	}
-
-	mutex_unlock(&vh265_mutex);
-}
-
 int vh265_dec_status(struct vdec_status *vstatus)
 {
 	struct hevc_state_s *hevc = &gHevc;
@@ -6001,9 +5968,6 @@ static int vh265_local_init(struct hevc_state_s *hevc)
 		hevc->frame_ar = hevc->frame_height * 0x100 / hevc->frame_width;
 	hevc->error_watchdog_count = 0;
 	hevc->sei_present_flag = 0;
-	pts_unstable = ((unsigned long)hevc->vh265_amstream_dec_info.param
-		& 0x40) >> 6;
-	pr_info("h265:pts_unstable=%d\n", pts_unstable);
 /*
 TODO:FOR VERSION
 */
@@ -6484,8 +6448,7 @@ MODULE_PARM_DESC(max_decoding_time, "\n max_decoding_time\n");
 
 module_param(interlace_enable, uint, 0664);
 MODULE_PARM_DESC(interlace_enable, "\n interlace_enable\n");
-module_param(pts_unstable, uint, 0664);
-MODULE_PARM_DESC(pts_unstable, "\n amvdec_h265 pts_unstable\n");
+
 module_param(parser_sei_enable, uint, 0664);
 MODULE_PARM_DESC(parser_sei_enable, "\n parser_sei_enable\n");
 
-- 
1.9.1

