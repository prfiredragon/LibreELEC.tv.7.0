From 9c86d082bf6a89a412a036171f9fb488d13b09d4 Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Sun, 23 Oct 2016 19:21:43 +0800
Subject: [PATCH] alsa : Channel Mapping API implementation 
 This was missing in amlogic kernel and is required for proper channel layout in mpv.
 https://github.com/LibreELEC/linux-amlogic/commit/6456d384f14ce3a6e941a8b923a54f63b3f6a052
 https://github.com/LibreELEC/linux-amlogic/commit/1619cf2a264dbce5de1635b74600f0c18399ab33

---
 sound/soc/aml/m8/aml_i2s.h     |   4 +
 sound/soc/aml/m8/aml_i2s_dai.c | 245 ++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 248 insertions(+), 1 deletion(-)

diff --git a/sound/soc/aml/m8/aml_i2s.h b/sound/soc/aml/m8/aml_i2s.h
index 98128e0..a49f1c0 100644
--- a/sound/soc/aml/m8/aml_i2s.h
+++ b/sound/soc/aml/m8/aml_i2s.h
@@ -18,6 +18,8 @@
 #ifndef __AML_I2S_H__
 #define __AML_I2S_H__
 
+#include <linux/mutex.h>
+
 /* #define debug_printk */
 #ifdef debug_printk
 #define dug_printk(fmt, args...)  printk(fmt, ## args)
@@ -69,6 +71,8 @@ struct aml_runtime_data {
 	struct timer_list timer;	/* timeer for playback and capture */
 	struct hrtimer hrtimer;
 	void *buf; /* tmp buffer for playback or capture */
+	struct mutex chmap_lock;
+	int chmap_layout;
 };
 
 extern struct snd_soc_platform_driver aml_soc_platform;
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index cc6e5b6..813b962 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -38,6 +38,7 @@
 #include <sound/control.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
+#include <sound/tlv.h>
 #include "aml_i2s_dai.h"
 #include "aml_pcm.h"
 #include "aml_i2s.h"
@@ -60,6 +61,49 @@ static int i2s_pos_sync;
 /* extern int amaudio2_enable; */
 /* extern int kernel_android_50; */
 
+struct channel_speaker_allocation {
+        int channels;
+        int speakers[8];
+};
+
+#define NA	SNDRV_CHMAP_NA
+#define FL	SNDRV_CHMAP_FL
+#define FR	SNDRV_CHMAP_FR
+#define RL	SNDRV_CHMAP_RL
+#define RR	SNDRV_CHMAP_RR
+#define LFE	SNDRV_CHMAP_LFE
+#define FC	SNDRV_CHMAP_FC
+#define RLC	SNDRV_CHMAP_RLC
+#define RRC	SNDRV_CHMAP_RRC
+#define RC	SNDRV_CHMAP_RC
+#define FLC	SNDRV_CHMAP_FLC
+#define FRC	SNDRV_CHMAP_FRC
+#define FLH	SNDRV_CHMAP_TFL
+#define FRH	SNDRV_CHMAP_TFR
+#define FLW	SNDRV_CHMAP_FLW
+#define FRW	SNDRV_CHMAP_FRW
+#define TC	SNDRV_CHMAP_TC
+#define FCH	SNDRV_CHMAP_TFC
+
+static struct channel_speaker_allocation channel_allocations[] = {
+/*      	       channel:   7     6    5    4    3     2    1    0  */
+{ .channels = 2,  .speakers = {  NA,   NA,  NA,  NA,  NA,   NA,  FR,  FL } },
+                                 /* 2.1 */
+{ .channels = 3,  .speakers = {  NA,   NA,  NA,  NA,  NA,  LFE,  FR,  FL } },
+                                 /* surround40 */
+{ .channels = 4,  .speakers = {  NA,   NA,  RR,  RL,  NA,   NA,  FR,  FL } },
+                                 /* surround41 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  NA,  LFE,  FR,  FL } },
+                                 /* surround50 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  FC,   NA,  FR,  FL } },
+                                 /* surround51 */
+{ .channels = 6,  .speakers = {  NA,   NA,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* 6.1 */
+{ .channels = 7,  .speakers = {  NA,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* surround71 */
+{ .channels = 8,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+};
+
 /* extern int set_i2s_iec958_samesource(int enable); */
 #define DEFAULT_SAMPLERATE 48000
 #define DEFAULT_MCLK_RATIO_SR 256
@@ -100,14 +144,191 @@ static void aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 		   i2s_mode, runtime->channels);
 }
 
+static int aml_dai_i2s_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+                                     unsigned int size, unsigned int __user *tlv)
+{
+    unsigned int __user *dst;
+    int count = 0;
+    int i;
+
+    if (size < 8)
+        return -ENOMEM;
+
+    if (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))
+        return -EFAULT;
+
+    size -= 8;
+    dst = tlv + 2;
+
+    for (i = 0; i < ARRAY_SIZE(channel_allocations); i++)
+    {
+        struct channel_speaker_allocation *ch = &channel_allocations[i];
+        int num_chs = 0;
+        int chs_bytes;
+        int c;
+
+        for (c = 0; c < 8; c++)
+        {
+            if (ch->speakers[c])
+                num_chs++;
+        }
+
+        chs_bytes = num_chs * 4;
+        if (size < 8)
+            return -ENOMEM;
+
+        if (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||
+            put_user(chs_bytes, dst + 1))
+            return -EFAULT;
+
+        dst += 2;
+        size -= 8;
+        count += 8;
+
+        if (size < chs_bytes)
+            return -ENOMEM;
+
+        size -= chs_bytes;
+        count += chs_bytes;
+
+        for (c = 0; c < 8; c++)
+        {
+            int sp = ch->speakers[7 - c];
+            if (sp)
+            {
+                if (put_user(sp, dst))
+                    return -EFAULT;
+                dst++;
+            }
+        }
+    }
+
+    if (put_user(count, tlv + 1))
+        return -EFAULT;
+
+    return 0;
+}
+
+static int aml_dai_i2s_chmap_ctl_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    for (channel=0; channel<8; channel++)
+    {
+        ucontrol->value.integer.value[7 - channel] = channel_allocations[prtd->chmap_layout].speakers[channel];
+    }
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static int aml_dai_i2s_chmap_ctl_put(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel, layout, matches, matched_layout;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    // now check if the channel setup matches one of our layouts
+    for (layout = 0; layout < ARRAY_SIZE(channel_allocations); layout++)
+    {
+        matches = 1;
+
+        for (channel = 0; channel < substream->runtime->channels; channel++)
+        {
+            int sp = ucontrol->value.integer.value[channel];
+            int chan = channel_allocations[layout].speakers[7 - channel];
+
+            if (sp != chan)
+            {
+                matches = 0;
+                break;
+            }
+        }
+
+        if (matches)
+        {
+            matched_layout = layout;
+            break;
+        }
+    }
+
+
+    // default to first layout if we didnt find any
+    if (!matches)
+        matched_layout = 0;
+
+    pr_info("Setting a %d channel layout matching layout #%d\n", runtime->channels, matched_layout);
+
+    prtd->chmap_layout = matched_layout;
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static struct snd_kcontrol *aml_dai_i2s_chmap_kctrl_get(struct snd_pcm_substream *substream)
+{
+    int str;
+
+    if ((substream) && (substream->pcm))
+    {
+        for (str=0; str<2; str++)
+        {
+            if (substream->pcm->streams[str].chmap_kctl)
+            {
+                return substream->pcm->streams[str].chmap_kctl;
+            }
+        }
+    }
+
+    return 0;
+}
+
 static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-	int ret = 0;
+	int ret = 0, i;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd =
 	    (struct aml_runtime_data *)runtime->private_data;
 	struct audio_stream *s;
+	struct snd_pcm_chmap *chmap;
+	struct snd_kcontrol *kctl;
 	ALSA_TRACE();
 	if (prtd == NULL) {
 		prtd =
@@ -128,6 +349,28 @@ static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 	} else {
 		s->device_type = AML_AUDIO_I2SIN;
 	}
+
+	// Alsa Channel Mapping API handling
+	if (!aml_dai_i2s_chmap_kctrl_get(substream))
+	{
+	    ret = snd_pcm_add_chmap_ctls(substream->pcm, SNDRV_PCM_STREAM_PLAYBACK, NULL, 8, 0, &chmap);
+
+	    if (ret < 0)
+	    {
+	      pr_err("aml_dai_i2s_startup error %d\n", ret);
+	      goto out;
+	    }
+
+	    kctl = chmap->kctl;
+	    for (i = 0; i < kctl->count; i++)
+	      kctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_WRITE;
+
+	    kctl->get = aml_dai_i2s_chmap_ctl_get;
+	    kctl->put = aml_dai_i2s_chmap_ctl_put;
+	    kctl->tlv.c = aml_dai_i2s_chmap_ctl_tlv;
+	}
+
+	mutex_init(&prtd->chmap_lock);
 	return 0;
  out:
 	return ret;
-- 
1.9.1

