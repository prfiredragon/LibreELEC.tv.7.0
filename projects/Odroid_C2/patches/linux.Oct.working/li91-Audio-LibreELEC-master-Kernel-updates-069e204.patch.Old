From e78908140896dc0795a4ee0cc1871c08645e0d1d Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Sun, 9 Oct 2016 22:35:18 +0800
Subject: [PATCH] Audio LibreELEC master Kernel updates 069e204

---
 sound/soc/aml/m8/Kconfig               |   35 +-
 sound/soc/aml/m8/Makefile              |    2 +-
 sound/soc/aml/m8/aml_audio_hw.c        |  346 +++++++---
 sound/soc/aml/m8/aml_audio_hw.h        |   29 +-
 sound/soc/aml/m8/aml_audio_hw_pcm2bt.c |   73 +--
 sound/soc/aml/m8/aml_g9tv.c            | 1082 ++++++++++++++++++++++++++++++++
 sound/soc/aml/m8/aml_g9tv.h            |   69 ++
 sound/soc/aml/m8/aml_i2s.c             |  616 ++++++++++--------
 sound/soc/aml/m8/aml_i2s.h             |   25 +-
 sound/soc/aml/m8/aml_i2s_dai.c         |  350 +++++++++--
 sound/soc/aml/m8/aml_i2s_dai.h         |    1 +
 sound/soc/aml/m8/aml_m8.c              |  170 +++--
 sound/soc/aml/m8/aml_pcm.c             |   52 +-
 sound/soc/aml/m8/aml_pcm_dai.c         |   46 +-
 sound/soc/aml/m8/aml_spdif_codec.c     |   54 +-
 sound/soc/aml/m8/aml_spdif_dai.c       |  438 ++++++-------
 sound/soc/aml/m8/aml_spdif_dai.h       |    4 +-
 17 files changed, 2526 insertions(+), 866 deletions(-)
 create mode 100644 sound/soc/aml/m8/aml_g9tv.c
 create mode 100644 sound/soc/aml/m8/aml_g9tv.h

diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
index d182291..045f91e 100644
--- a/sound/soc/aml/m8/Kconfig
+++ b/sound/soc/aml/m8/Kconfig
@@ -3,17 +3,28 @@ menuconfig SND_AML_M8
 	depends on SND_AML_M8_SOC
 	select SWITCH
 	select SND_SOC_PCM2BT
-#	select SND_SOC_AML_M8_CODEC
-#	select SND_SOC_RT5616
 	select SND_SOC_DUMMY_CODEC
-#	select SND_SOC_RT5631
-#	select SND_SOC_AMLPMU3 if AML1218
-#	select SND_SOC_AMLPMU4 if AML1220
-#	select SND_SOC_ES8323
-
-menuconfig SND_AML_G9TV
-	tristate "AML-SND-G9TV Board"
-	depends on SND_AML_M8_SOC && SWITCH
-	select SND_SOC_DUMMY_CODEC
-	select SND_SOC_AMLPMU4 if AML1220
+	select SND_SOC_AMLPMU4 if AML_PMU4
 	select SND_SOC_TAS5707
+	select SND_SOC_TAS5717
+	select SND_SOC_TAS5731
+	select SND_SOC_AMLT9015
+	select SND_SOC_AMLT9015S
+
+if SND_AML_M8
+
+config SND_AML_SPLIT_MODE
+	tristate "AIU split mode, otherwise normal mode"
+	depends on SND_AML_M8_SOC
+	help
+		Say 'Y' to enable AIU split mode. If not, it's normal mode.
+
+config SND_AML_SPLIT_MODE_MMAP
+	tristate "AIU split mode, mmap"
+	depends on SND_AML_SPLIT_MODE
+	depends on SND_AML_M8_SOC
+	help
+		Say 'Y' or 'N' to enable/disable AIU split mmap
+
+endif
+
diff --git a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
index e6bfba1..da85a5c 100644
--- a/sound/soc/aml/m8/Makefile
+++ b/sound/soc/aml/m8/Makefile
@@ -26,4 +26,4 @@ obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
 
 #AML G9TV Machine support
 snd-soc-aml-g9tv-objs := aml_g9tv.o
-obj-$(CONFIG_SND_AML_G9TV) += snd-soc-aml-g9tv.o
+obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-g9tv.o
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 33268a2..70e3f70 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_audio_hw: " fmt
 
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -26,11 +27,20 @@
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
+#include <linux/amlogic/cpu_version.h>
 #include "aml_audio_hw.h"
 
+/* i2s mode 0: master 1: slave */
+/* source: 0: linein; 1: ATV; 2: HDMI-in */
 unsigned ENABLE_IEC958 = 1;
 unsigned IEC958_MODE = AIU_958_MODE_PCM16;
 unsigned I2S_MODE = AIU_I2S_MODE_PCM16;
+unsigned audio_in_source = 0;
+void set_i2s_source(unsigned source)
+{
+	audio_in_source = source;
+	return;
+}
 
 int audio_in_buf_ready = 0;
 int audio_out_buf_ready = 0;
@@ -137,21 +147,37 @@ int audio_clock_config_table[][13][2] = {
 
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffff00);
+	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffff00);
+#else
 	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
 	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+#endif
+
 	if (channel == 8) {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
+#endif
 	} else {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+#endif
 	}
 	/* Hold I2S */
 	aml_write_cbus(AIU_I2S_MISC, 0x0004);
 	/* No mute, no swap */
-	aml_write_cbus(AIU_I2S_MUTE_SWAP, 0x0000);
+	/*aml_write_cbus(AIU_I2S_MUTE_SWAP, 0x0000);*/
 	/* Release hold and force audio data to left or right */
 	aml_write_cbus(AIU_I2S_MISC, 0x0010);
 
@@ -159,29 +185,27 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 		pr_info("%s channel == 8\n", __func__);
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-		/*
-		*  [15: 8] chan_mem_mask.
+		/*  [15: 8] chan_mem_mask.
 		*  Each bit indicates which channels exist in memory
 		*/
-					(0xff << 8) |
-		/*
-		*  [ 7: 0] chan_rd_mask.
+			       (0xff << 8) |
+		/*  [ 7: 0] chan_rd_mask.
 		*  Each bit indicates which channels are READ from memory
 		*/
-					(0xff << 0));
-	} else
+			       (0xff << 0));
+	} else {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-		/* [15: 8] chan_mem_mask.
-		* Each bit indicates which channels exist in memory
-		*/
-					(0x3 << 8) |
-		/*
-		*  [ 7: 0] chan_rd_mask.
-		*  Each bit indicates which channels are READ from memory
-		*/
-					(0x3 << 0));
-
+			(0xff << 8) |
+			(0xff << 0));
+#else
+		/* [31:16] IRQ block. */
+		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
+			       (0x3 << 8) |
+			       (0x3 << 0));
+#endif
+	}
 	/* 16 bit PCM mode */
 	/* aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 6, 1); */
 	/* Set init high then low to initilize the I2S memory logic */
@@ -207,15 +231,32 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 				       addr & 0xffffffc0);
 		if (flag == 0) {
 			/* this is for 16bit 2 channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
+#else
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 64);
+#endif
 		} else {
 			/* this is for RAW mode */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 1);
+						(addr & 0xffffffc0) +
+						(size & 0xffffffc0) - 8);
+#else
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 1);
+#endif
 		}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0xffff);
+#else
 		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0x303);
-
+#endif
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 1);
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 0);
 
@@ -227,8 +268,7 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 /*
 i2s mode 0: master 1: slave
 */
-static void i2sin_fifo0_set_buf(u32 addr, u32 size,
-				u32 i2s_mode, u32 i2s_sync)
+static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
 {
 	unsigned char mode = 0;
 	unsigned int sync_mode = 0;
@@ -248,7 +288,7 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,
 		       /* DIN from i2sin */
 		       /* |(1<<6)    // 32 bits data in. */
 		       /* |(0<<7)    // put the 24bits data to  low 24 bits */
-		       |(4 << AUDIN_FIFO0_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
+		       | (4 << AUDIN_FIFO0_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
 		       |(2 << AUDIN_FIFO0_CHAN)	/* two channel */
 		       |(0 << 16)	/* to DDR */
 		       |(1 << AUDIN_FIFO0_UG)	/* Urgent request. */
@@ -256,34 +296,64 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,
 		       |(0 << 18)
 		       /* Audio in INT */
 		       /* |(1<<19)    // hold 0 enable */
-		       |(0 << AUDIN_FIFO0_UG)	/* hold0 to aififo */
+		       | (0 << AUDIN_FIFO0_UG)	/* hold0 to aififo */
 	    );
 
 	aml_write_cbus(AUDIN_FIFO0_CTRL1, 0 << 4	/* fifo0_dest_sel */
 		       | 2 << 2	/* fifo0_din_byte_num */
 		       | 0 << 0);	/* fifo0_din_pos */
 
-	aml_write_cbus(AUDIN_I2SIN_CTRL, (3 << I2SIN_SIZE)
-		       | (1 << I2SIN_CHAN_EN)	/* 2 channel */
-		       |(sync_mode << I2SIN_POS_SYNC)
-		       | (1 << I2SIN_LRCLK_SKEW)
-		       | (1 << I2SIN_LRCLK_INVT)
-		       | (!mode << I2SIN_CLK_SEL)
-		       | (!mode << I2SIN_LRCLK_SEL)
-		       | (!mode << I2SIN_DIR)
-	    );
+	if (audio_in_source == 0) {
+		if (is_meson_txl_cpu()) {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (0 << I2SIN_POS_SYNC)
+					| (0 << I2SIN_LRCLK_SEL)
+					| (0 << I2SIN_CLK_SEL)
+					| (0 << I2SIN_DIR));
+		} else {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (sync_mode << I2SIN_POS_SYNC)
+					| (!mode << I2SIN_LRCLK_SEL)
+					| (!mode << I2SIN_CLK_SEL)
+					| (!mode << I2SIN_DIR));
+		}
+	} else if (audio_in_source == 1) {
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+			       | (0 << I2SIN_SIZE)
+			       | (0 << I2SIN_LRCLK_INVT)
+			       | (0 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (0 << I2SIN_LRCLK_SEL)
+			       | (0 << I2SIN_CLK_SEL)
+			       | (0 << I2SIN_DIR));
+	} else if (audio_in_source == 2) {
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+			       | (3 << I2SIN_SIZE)
+			       | (1 << I2SIN_LRCLK_INVT)
+			       | (1 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (1 << I2SIN_LRCLK_SEL)
+			       | (1 << I2SIN_CLK_SEL)
+			       | (1 << I2SIN_DIR));
+	}
 
 }
 
 static void spdifin_reg_set(void)
 {
 	/* get clk81 clk_rate */
-	struct clk *clk_src = clk_get_sys("clk81", NULL);
-	u32 clk_rate = clk_get_rate(clk_src);
+	unsigned int clk_rate = clk81;
 	u32 spdif_clk_time = 54;	/* 54us */
-	u32 spdif_mode_14bit = ((clk_rate / 500000 + 1) >> 1) * spdif_clk_time;
+	u32 spdif_mode_14bit = (u32)((clk_rate / 500000 + 1) >> 1)
+					* spdif_clk_time;
 	/* sysclk/32(bit)/2(ch)/2(bmc) */
-	u32 period_data = (clk_rate / 64000 + 1) >> 1;
+	u32 period_data = (u32)(clk_rate / 64000 + 1) >> 1;
 	u32 period_32k = (period_data + (1 << 4)) >> 5;	/* 32k min period */
 	u32 period_44k = (period_data / 22 + 1) >> 1;	/* 44k min period */
 	u32 period_48k = (period_data / 24 + 1) >> 1;	/* 48k min period */
@@ -297,9 +367,8 @@ static void spdifin_reg_set(void)
 		       (spdif_mode_14bit << 0));
 	aml_write_cbus(AUDIN_SPDIF_FS_CLK_RLTN,
 		       (period_32k << 0) |
-		       (period_44k << 6) |
-		       (period_48k << 12) |
-				/* Spdif_fs_clk_rltn */
+		       (period_44k << 6) | (period_48k << 12) |
+		       /* Spdif_fs_clk_rltn */
 		       (period_96k << 18) | (period_192k << 24));
 
 }
@@ -319,7 +388,7 @@ static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 		       /* DIN from i2sin. */
 		       /* |(1<<6)   // 32 bits data in. */
 		       /* |(0<<7)   // put the 24bits data to  low 24 bits */
-		       |(4 << AUDIN_FIFO1_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
+		       | (4 << AUDIN_FIFO1_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
 		       |(2 << AUDIN_FIFO1_CHAN)	/* 2 channel */
 		       |(0 << 16)	/* to DDR */
 		       |(1 << AUDIN_FIFO1_UG)	/* Urgent request. */
@@ -327,16 +396,16 @@ static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 		       |(0 << 18)
 		       /* Audio in INT */
 		       /* |(1<<19)   //hold 0 enable */
-		       |(0 << AUDIN_FIFO1_UG)	/* hold0 to aififo */
+		       | (0 << AUDIN_FIFO1_UG)	/* hold0 to aififo */
 	    );
 
 	/*
-	*  according clk81 to set reg spdif_mode(0x2800)
-	*  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
-	*/
+	 *  according clk81 to set reg spdif_mode(0x2800)
+	 *  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
+	 */
 	spdifin_reg_set();
-
-	aml_write_cbus(AUDIN_FIFO1_CTRL1, 0xc);
+	/*3 byte mode, (27:4)*/
+	aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
 }
 
 void audio_in_i2s_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
@@ -367,7 +436,7 @@ void audio_in_i2s_enable(int flag)
 		rd = aml_read_cbus(AUDIN_FIFO0_PTR);
 		start = aml_read_cbus(AUDIN_FIFO0_START);
 		if (rd != start) {
-			pr_err("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n",
+			pr_err("error %08x, %08x !\n",
 			       rd, start);
 			goto reset_again;
 		}
@@ -391,8 +460,7 @@ void audio_in_spdif_enable(int flag)
 		rd = aml_read_cbus(AUDIN_FIFO1_PTR);
 		start = aml_read_cbus(AUDIN_FIFO1_START);
 		if (rd != start) {
-			pr_err("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n",
-			       rd, start);
+			pr_err("error %08x, %08x !\n", rd, start);
 			goto reset_again;
 		}
 		aml_write_cbus(AUDIN_SPDIF_MODE,
@@ -456,6 +524,77 @@ void audio_in_spdif_set_wrptr(unsigned int val)
 	aml_write_cbus(AUDIN_FIFO1_RDPTR, val);
 }
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+void audio_set_i2s_mode(u32 mode, unsigned int channel)
+{
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x800);
+
+	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0);
+
+	if (8 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 1);
+
+		if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			/* todo: to verify it */
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+
+		} else if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+
+			aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0x5);
+		}
+	} else if (2 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 0);
+
+		if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		}
+	}
+
+	/* In split mode, there are not mask control,
+	so aiu_mem_i2s_mask[15:0] must set 8'hffff_ffff. */
+	/*aml_write_cbus(AIU_MEM_I2S_MASKS,
+		(16 << 16) |
+		(0xff << 8) |
+		(0xff << 0));*/
+}
+#else
 void audio_set_i2s_mode(u32 mode)
 {
 	const unsigned short mask[4] = {
@@ -486,6 +625,7 @@ void audio_set_i2s_mode(u32 mode)
 		aml_cbus_update_bits(AIU_MEM_I2S_MASKS, 0xffff, mask[mode]);
 	}
 }
+#endif
 
 /*
  *  if normal clock, i2s clock is twice of 958 clock,
@@ -500,22 +640,24 @@ void audio_util_set_dac_format(unsigned format)
 	/* 958 divisor more, if true, divided by 2, 4, 6, 8. */
 	aml_write_cbus(AIU_CLK_CTRL, (0 << 12) |
 	/* alrclk skew: 1=alrclk transitions on the cycle before msb is sent */
-			(1 << 8) |
-			(1 << 6) |	/* invert aoclk */
-			(1 << 7) |	/* invert lrclk */
+		       (1 << 8) |
+		       (1 << 6) |
+	/* invert aoclk */
+		       (1 << 7) |
+	/* invert lrclk */
 #if OVERCLOCK == 1
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	       (1 << 4) |
+		       (1 << 4) |
 	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
-	       (3 << 2) |
+		       (3 << 2) |
 #else
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-			(1 << 4) |
+		       (1 << 4) |
 	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
-			(2 << 2) |
+		       (2 << 2) |
 #endif
-			(1 << 1) |	/* enable 958 clock */
-			(1 << 0));	/* enable I2S clock */
+		       (1 << 1) |	/* enable 958 clock */
+		       (1 << 0));	/* enable I2S clock */
 	if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP)
 		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 8, 1 << 8);
 	else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY)
@@ -569,11 +711,15 @@ void audio_util_set_dac_i2s_format(unsigned format)
 	if (dac_mute_const == 0x800000)
 		aml_write_cbus(AIU_I2S_DAC_CFG, 0x000f);
 	else
-	/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
+		/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
 		aml_write_cbus(AIU_I2S_DAC_CFG, 0x0007);
 
 	/* four 2-channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, (1 << 11));
+#else
 	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x0001);
+#endif
 }
 
 /* set sclk and lrclk, mclk = 256fs. */
@@ -584,7 +730,7 @@ void audio_set_i2s_clk_div(void)
 	/* Set mclk over sclk ratio */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x3f << 8, (4 - 1) << 8);
 	/* set dac/adc lrclk ratio over sclk----64fs */
-        aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
+	aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
 	aml_cbus_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (64 - 1));
 	/* Enable sclk */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 14, 1 << 14);
@@ -618,13 +764,13 @@ void audio_enable_ouput(int flag)
 
 int if_audio_out_enable(void)
 {
-	return aml_read_cbus(AIU_MEM_I2S_CONTROL) & (0x3<<1);
+	return aml_read_cbus(AIU_MEM_I2S_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_audio_out_enable);
 
 int if_958_audio_out_enable(void)
 {
-	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (0x3<<1);
+	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_958_audio_out_enable);
 
@@ -723,7 +869,7 @@ void audio_hw_958_raw(void)
 	pr_info("\tLENGTH: %x\n", IEC958_length);
 	pr_info("\tPADDSIZE: %x\n", IEC958_length);
 	pr_info("\tsyncword: %x, %x, %x\n\n", IEC958_syncword1,
-				IEC958_syncword2, IEC958_syncword3);
+		IEC958_syncword2, IEC958_syncword3);
 
 }
 
@@ -759,44 +905,53 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 			aml_write_cbus(AIU_958_MISC, 1);
 			/* raw */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 1 << 8);
+					     1 << 8, 1 << 8);
 			/* 8bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0x1 << 3);
+					     0x7 << 3, 0x1 << 3);
 		}
 
 		pr_info("IEC958 RAW\n");
 	} else if (mode == AIU_958_MODE_PCM32) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 		}
 		pr_info("IEC958 PCM32\n");
 	} else if (mode == AIU_958_MODE_PCM24) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 
 		}
 		pr_info("IEC958 24bit\n");
@@ -805,20 +960,29 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 		if (ENABLE_IEC958) {
 			aml_write_cbus(AIU_958_MISC, 0x2042);
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 1 << 7);
+					     1 << 7, 1 << 7);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 		}
 		pr_info("IEC958 16bit\n");
 	}
 
 	audio_hw_958_reset(0, 1);
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	if (mode == AIU_958_MODE_PCM32)
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 1 << 8, 1 << 8);
+#endif
+
 	aml_write_cbus(AIU_958_FORCE_LEFT, 1);
 }
 
@@ -827,11 +991,12 @@ void audio_out_i2s_enable(unsigned flag)
 	if (flag) {
 		aml_write_cbus(AIU_RST_SOFT, 0x01);
 		aml_read_cbus(AIU_I2S_SYNC);
-		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL,
-				0x3 << 1, 0x3 << 1);
+		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0x3 << 1);
 		/* Maybe cause POP noise */
 		/* audio_i2s_unmute(); */
 	} else {
+		aml_write_cbus(AIU_RST_SOFT, 0x01);
+		aml_read_cbus(AIU_I2S_SYNC);
 		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0);
 
 		/* Maybe cause POP noise */
@@ -850,6 +1015,8 @@ void audio_hw_958_enable(unsigned flag)
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0x3 << 1);
 		} else {
+			aml_write_cbus(AIU_RST_SOFT, 0x04);
+			aml_write_cbus(AIU_958_FORCE_LEFT, 0);
 			aml_write_cbus(AIU_958_DCU_FF_CTRL, 0);
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0);
@@ -870,12 +1037,19 @@ void audio_i2s_swap_left_right(unsigned int flag)
 		aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 1, flag << 1);
 
 	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3, flag);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3 << 2, flag << 2);
 }
 
 void audio_i2s_958_same_source(unsigned int same)
 {
 	aml_cbus_update_bits(AIU_I2S_MISC, 1 << 3, (!!same) << 3);
 }
+
+void set_hw_resample_source(int source)
+{
+	aml_cbus_update_bits(AUD_RESAMPLE_CTRL0, 1 << 29, source << 29);
+}
+EXPORT_SYMBOL(set_hw_resample_source);
 #if 0
 unsigned int audio_hdmi_init_ready(void)
 {
diff --git a/sound/soc/aml/m8/aml_audio_hw.h b/sound/soc/aml/m8/aml_audio_hw.h
index 90aee90..6b28d30 100644
--- a/sound/soc/aml/m8/aml_audio_hw.h
+++ b/sound/soc/aml/m8/aml_audio_hw.h
@@ -67,17 +67,17 @@ struct _aiu_958_raw_setting_t {
 
 enum {
 	I2SIN_MASTER_MODE = 0,
-	I2SIN_SLAVE_MODE  =   1<<0,
-	SPDIFIN_MODE   = 1<<1,
+	I2SIN_SLAVE_MODE = 1 << 0,
+	SPDIFIN_MODE = 1 << 1,
 };
 enum {
 	AML_AUDIO_NA = 0,
-	AML_AUDIO_SPDIFIN = 1<<0,
-	AML_AUDIO_SPDIFOUT = 1<<1,
-	AML_AUDIO_I2SIN = 1<<2,
-	AML_AUDIO_I2SOUT = 1<<3,
-	AML_AUDIO_PCMIN = 1<<4,
-	AML_AUDIO_PCMOUT = 1<<5,
+	AML_AUDIO_SPDIFIN = 1 << 0,
+	AML_AUDIO_SPDIFOUT = 1 << 1,
+	AML_AUDIO_I2SIN = 1 << 2,
+	AML_AUDIO_I2SOUT = 1 << 3,
+	AML_AUDIO_PCMIN = 1 << 4,
+	AML_AUDIO_PCMOUT = 1 << 5,
 };
 
 #define AUDIO_CLK_256FS             0
@@ -98,7 +98,6 @@ enum {
 #define AUDIO_CLK_FREQ_22		11
 #define AUDIO_CLK_FREQ_24		12
 
-
 #define AIU_958_MODE_RAW    0
 #define AIU_958_MODE_PCM16  1
 #define AIU_958_MODE_PCM24  2
@@ -115,7 +114,9 @@ enum {
 extern unsigned ENABLE_IEC958;
 extern unsigned IEC958_MODE;
 extern unsigned I2S_MODE;
+extern unsigned audio_in_source;
 
+void set_i2s_source(unsigned source);
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
 void audio_set_958outbuf(u32 addr, u32 size, int flag);
 void audio_in_i2s_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync);
@@ -125,7 +126,11 @@ void audio_in_spdif_enable(int flag);
 unsigned int audio_in_i2s_rd_ptr(void);
 unsigned int audio_in_i2s_wr_ptr(void);
 unsigned int audio_in_spdif_wr_ptr(void);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+void audio_set_i2s_mode(u32 mode, unsigned int channel);
+#else
 void audio_set_i2s_mode(u32 mode);
+#endif
 void audio_set_i2s_clk_div(void);
 void audio_set_spdif_clk_div(void);
 void audio_enable_ouput(int flag);
@@ -156,7 +161,7 @@ void audio_mute_left_right(unsigned flag);
 void audio_i2s_958_same_source(unsigned int same);
 
 extern unsigned int IEC958_mode_codec;
-
+extern unsigned int clk81;
 
 /*OVERCLOCK == 1,our SOC privide 512fs mclk,OVERCLOCK == 0 ,256fs*/
 #define OVERCLOCK 0
@@ -168,10 +173,10 @@ extern unsigned int IEC958_mode_codec;
 #define MCLKFS_RATIO 256
 #endif
 
-#define I2S_PLL_SRC         1   /* MPLL0 */
+#define I2S_PLL_SRC         1	/* MPLL0 */
 #define MPLL_I2S_CNTL		HHI_MPLL_MP0
 
-#define I958_PLL_SRC        2   /* MPLL1 */
+#define I958_PLL_SRC        2	/* MPLL1 */
 #define MPLL_958_CNTL		HHI_MPLL_MP1
 
 #endif
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
index 2e2782d..524cfb5 100644
--- a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
@@ -15,6 +15,8 @@
  *
 */
 
+#define pr_fmt(fmt) "audio_pcm" fmt
+
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/errno.h>
@@ -24,15 +26,6 @@
 #include <linux/amlogic/sound/audin_regs.h>
 #include "aml_audio_hw_pcm2bt.h"
 
-/* #define PCM_DEBUG */
-
-#ifdef PCM_DEBUG
-#define pcm_debug           pr_info
-#else
-#define pcm_debug(fmt, ...) \
-	do {} while (0)
-#endif
-
 static unsigned int pcmin_buffer_addr;
 static unsigned int pcmin_buffer_size;
 
@@ -46,22 +39,22 @@ static uint32_t aml_read_cbus_bits(uint32_t reg, const uint32_t start,
 
 static void pcm_in_register_show(void)
 {
-	pcm_debug("PCMIN registers show:\n");
-	pcm_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START,
+	pr_debug("PCMIN registers show:\n");
+	pr_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START,
 		  aml_read_cbus(AUDIN_FIFO1_START));
-	pcm_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END,
+	pr_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END,
 		  aml_read_cbus(AUDIN_FIFO1_END));
-	pcm_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR,
+	pr_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR,
 		  aml_read_cbus(AUDIN_FIFO1_PTR));
-	pcm_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR,
+	pr_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR,
 		  aml_read_cbus(AUDIN_FIFO1_RDPTR));
-	pcm_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL,
+	pr_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL,
 		  aml_read_cbus(AUDIN_FIFO1_CTRL));
-	pcm_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1,
+	pr_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1,
 		  aml_read_cbus(AUDIN_FIFO1_CTRL1));
-	pcm_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0,
+	pr_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0,
 		  aml_read_cbus(PCMIN_CTRL0));
-	pcm_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1,
+	pr_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1,
 		  aml_read_cbus(PCMIN_CTRL1));
 }
 
@@ -134,7 +127,7 @@ void pcm_in_enable(int flag)
 	       (1 << 0));	/* left justified */
 	}
 
-	pcm_debug("PCMIN %s\n", flag ? "enable" : "disable");
+	pr_debug("PCMIN %s\n", flag ? "enable" : "disable");
 	pcm_in_register_show();
 }
 
@@ -143,7 +136,7 @@ void pcm_in_set_buf(unsigned int addr, unsigned int size)
 	pcmin_buffer_addr = addr;
 	pcmin_buffer_size = size;
 
-	pcm_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n",
+	pr_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n",
 		  pcmin_buffer_addr, pcmin_buffer_size);
 }
 
@@ -157,7 +150,7 @@ int pcm_in_is_enable(void)
 unsigned int pcm_in_rd_ptr(void)
 {
 	unsigned int value = aml_read_cbus(AUDIN_FIFO1_RDPTR);
-	pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
+	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
 
 	return value;
 }
@@ -166,7 +159,7 @@ unsigned int pcm_in_set_rd_ptr(unsigned int value)
 {
 	unsigned int old = aml_read_cbus(AUDIN_FIFO1_RDPTR);
 	aml_write_cbus(AUDIN_FIFO1_RDPTR, value);
-	pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
+	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
 
 	return old;
 }
@@ -181,7 +174,7 @@ unsigned int pcm_in_wr_ptr(void)
 
 	aml_write_cbus(AUDIN_FIFO1_PTR, 1);
 	written = aml_read_cbus(AUDIN_FIFO1_PTR);
-	pcm_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
+	pr_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
 
 	/* value = written; */
 	value = written & (~0x07);
@@ -192,33 +185,33 @@ unsigned int pcm_in_fifo_int(void)
 {
 	unsigned int value = 0;
 	value = aml_read_cbus(AUDIN_FIFO_INT);
-	pcm_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
+	pr_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
 
 	return value;
 }
 
 static void pcm_out_register_show(void)
 {
-	pcm_debug("PCMOUT registers show:\n");
-	pcm_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA,
+	pr_debug("PCMOUT registers show:\n");
+	pr_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA,
 		  aml_read_cbus(AUDOUT_BUF0_STA));
-	pcm_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA,
+	pr_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA,
 		  aml_read_cbus(AUDOUT_BUF0_EDA));
-	pcm_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR,
+	pr_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR,
 		  aml_read_cbus(AUDOUT_BUF0_WPTR));
-	pcm_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR,
+	pr_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR,
 		  aml_read_cbus(AUDOUT_FIFO_RPTR));
-	pcm_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL,
+	pr_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL,
 		  aml_read_cbus(AUDOUT_CTRL));
-	pcm_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1,
+	pr_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1,
 		  aml_read_cbus(AUDOUT_CTRL1));
-	pcm_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0,
+	pr_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0,
 		  aml_read_cbus(PCMOUT_CTRL0));
-	pcm_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1,
+	pr_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1,
 		  aml_read_cbus(PCMOUT_CTRL1));
-	pcm_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2,
+	pr_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2,
 		  aml_read_cbus(PCMOUT_CTRL2));
-	pcm_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3,
+	pr_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3,
 		  aml_read_cbus(PCMOUT_CTRL3));
 }
 
@@ -313,7 +306,7 @@ void pcm_out_enable(int flag)
 			(0 << 0));
 	}
 
-	pcm_debug("PCMOUT %s\n", flag ? "enable" : "disable");
+	pr_debug("PCMOUT %s\n", flag ? "enable" : "disable");
 	pcm_out_register_show();
 }
 
@@ -328,7 +321,7 @@ void pcm_out_set_buf(unsigned int addr, unsigned int size)
 	pcmout_buffer_addr = addr;
 	pcmout_buffer_size = size;
 
-	pcm_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n",
+	pr_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n",
 		  pcmout_buffer_addr, pcmout_buffer_size);
 }
 
@@ -349,7 +342,7 @@ int pcm_out_is_mute(void)
 unsigned int pcm_out_rd_ptr(void)
 {
 	unsigned int value = aml_read_cbus(AUDOUT_FIFO_RPTR);
-	pcm_debug("PCMOUT read pointer: 0x%08x\n", value);
+	pr_debug("PCMOUT read pointer: 0x%08x\n", value);
 
 	return value;
 }
@@ -358,7 +351,7 @@ unsigned int pcm_out_wr_ptr(void)
 {
 	unsigned int value = 0;
 	value = aml_read_cbus(AUDOUT_BUF0_WPTR);
-	pcm_debug("PCMOUT write pointer: 0x%08x\n", value);
+	pr_debug("PCMOUT write pointer: 0x%08x\n", value);
 	return value;
 }
 
@@ -366,7 +359,7 @@ unsigned int pcm_out_set_wr_ptr(unsigned int value)
 {
 	unsigned int old = aml_read_cbus(AUDOUT_BUF0_WPTR);
 	aml_write_cbus(AUDOUT_BUF0_WPTR, value);
-	pcm_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
+	pr_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
 
 	return old;
 }
diff --git a/sound/soc/aml/m8/aml_g9tv.c b/sound/soc/aml/m8/aml_g9tv.c
new file mode 100644
index 0000000..c481d4f
--- /dev/null
+++ b/sound/soc/aml/m8/aml_g9tv.c
@@ -0,0 +1,1082 @@
+/*
+ * sound/soc/aml/g9tv/aml_g9tv.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define pr_fmt(fmt) "aml_g9tv: " fmt
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+#include <sound/tas57xx.h>
+#include <linux/switch.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/sound/audin_regs.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/io.h>
+#include <linux/amlogic/cpu_version.h>
+
+#include "aml_i2s.h"
+#include "aml_audio_hw.h"
+#include "aml_g9tv.h"
+
+#define DRV_NAME "aml_snd_card_g9tv"
+
+int aml_audio_Hardware_resample = 0;
+unsigned int clk_rate = 0;
+
+static const char *const audio_in_source_texts[] = { "LINEIN", "ATV", "HDMI" };
+
+static const struct soc_enum audio_in_source_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(audio_in_source_texts),
+			audio_in_source_texts);
+
+static int aml_audio_get_in_source(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	int value = aml_read_cbus(AUDIN_SOURCE_SEL) & 0x3;
+
+	if (value == 0)
+		ucontrol->value.enumerated.item[0] = 0;
+	else if (value == 1)
+		ucontrol->value.enumerated.item[0] = 1;
+	else if (value == 2)
+		ucontrol->value.enumerated.item[0] = 2;
+	return 0;
+}
+
+static int aml_audio_set_in_source(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		if (is_meson_txl_cpu()) {
+			/* select internal acodec output in TXL as I2S source */
+			aml_write_cbus(AUDIN_SOURCE_SEL, 3);
+		} else
+			/* select external codec output as I2S source */
+			aml_write_cbus(AUDIN_SOURCE_SEL, 0);
+		audio_in_source = 0;
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		/* select ATV output as I2S source */
+		aml_write_cbus(AUDIN_SOURCE_SEL, 1);
+		audio_in_source = 1;
+	} else if (ucontrol->value.enumerated.item[0] == 2) {
+		/* select HDMI-rx as I2S source */
+		/* [14:12]cntl_hdmirx_chsts_sel: */
+		/* 0=Report chan1 status; 1=Report chan2 status */
+		/* [11:8] cntl_hdmirx_chsts_en */
+		/* [5:4] spdif_src_sel:*/
+		/* 1=Select HDMIRX SPDIF output as AUDIN source */
+		/* [1:0] i2sin_src_sel: */
+		/*2=Select HDMIRX I2S output as AUDIN source */
+		aml_write_cbus(AUDIN_SOURCE_SEL, (0 << 12) |
+			       (0xf << 8) | (1 << 4) | (2 << 0));
+		audio_in_source = 2;
+	}
+	set_i2s_source(audio_in_source);
+	return 0;
+}
+
+/* i2s audio format detect: LPCM or NONE-LPCM */
+static const char *const i2s_audio_type_texts[] = {
+	"LPCM", "NONE-LPCM", "UN-KNOWN"
+};
+static const struct soc_enum i2s_audio_type_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(i2s_audio_type_texts),
+			i2s_audio_type_texts);
+
+static int aml_i2s_audio_type_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int ch_status = 0;
+
+	if ((aml_read_cbus(AUDIN_DECODE_CONTROL_STATUS) >> 24) & 0x1) {
+		ch_status = aml_read_cbus(AUDIN_DECODE_CHANNEL_STATUS_A_0);
+		if (ch_status & 2)
+			ucontrol->value.enumerated.item[0] = 1;
+		else
+			ucontrol->value.enumerated.item[0] = 0;
+	} else {
+		ucontrol->value.enumerated.item[0] = 2;
+	}
+	return 0;
+}
+
+static int aml_i2s_audio_type_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	return 0;
+}
+
+/* spdif in audio format detect: LPCM or NONE-LPCM */
+struct sppdif_audio_info {
+	unsigned char aud_type;
+	/*IEC61937 package presamble Pc value*/
+	short pc;
+	char *aud_type_str;
+};
+static const char *const spdif_audio_type_texts[] = {
+	"LPCM",
+	"AC3",
+	"EAC3",
+	"DTS",
+	"DTS-HD",
+	"TRUEHD",
+};
+static const struct sppdif_audio_info type_texts[] = {
+	{0, 0, "LPCM"},
+	{1, 0x1, "AC3"},
+	{2, 0x15, "EAC3"},
+	{3, 0xb, "DTS-I"},
+	{3, 0x0c, "DTS-II"},
+	{3, 0x0d, "DTS-III"},
+	{3, 0x11, "DTS-IV"},
+	{4, 0, "DTS-HD"},
+	{5, 0x16, "TRUEHD"},
+};
+static const struct soc_enum spdif_audio_type_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(spdif_audio_type_texts),
+			spdif_audio_type_texts);
+
+static int aml_spdif_audio_type_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int audio_type = 0;
+	int i;
+	int total_num = sizeof(type_texts)/sizeof(struct sppdif_audio_info);
+	int pc = aml_read_cbus(AUDIN_SPDIF_NPCM_PCPD)>>16;
+	pc = pc&0xff;
+	for (i = 0; i < total_num; i++) {
+		if (pc == type_texts[i].pc) {
+			audio_type = type_texts[i].aud_type;
+			break;
+		}
+	}
+	ucontrol->value.enumerated.item[0] = audio_type;
+	return 0;
+}
+
+static int aml_spdif_audio_type_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	return 0;
+}
+
+int hardware_resample_locked_flag = 0;
+#define RESAMPLE_BUFFER_SOURCE 1
+/*Cnt_ctrl = mclk/fs_out-1 ; fest 256fs */
+#define RESAMPLE_CNT_CONTROL 255
+
+static int hardware_resample_enable(int input_sr)
+{
+	u16 Avg_cnt_init = 0;
+	unsigned int clk_rate = clk81;
+
+	if (hardware_resample_locked_flag == 1)
+		return 0;
+
+	if (input_sr < 8000 || input_sr > 48000) {
+		pr_err("Error input sample rate,input_sr = %d!\n", input_sr);
+		return -1;
+	}
+
+	Avg_cnt_init = (u16)(clk_rate * 4 / input_sr);
+	pr_info("clk_rate = %u, input_sr = %d, Avg_cnt_init = %u\n",
+		clk_rate, input_sr, Avg_cnt_init);
+
+	if (is_meson_txl_cpu()) {
+		int pause_cnt_thd = 256;
+		aml_write_cbus(AUD_RESAMPLE_CTRL2,
+				(1 << 31)
+				| pause_cnt_thd);
+	}
+
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, (1 << 31));
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, 0);
+	aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				(1 << 29)
+				| (1 << 28)
+				| (0 << 26)
+				| (RESAMPLE_CNT_CONTROL << 16)
+				| Avg_cnt_init);
+
+	return 0;
+}
+
+static int hardware_resample_disable(void)
+{
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, 0);
+	return 0;
+}
+
+static const char *const hardware_resample_texts[] = {
+	"Disable",
+	"Enable:48K",
+	"Enable:44K",
+	"Enable:32K",
+	"Lock Resample",
+	"Unlock Resample"
+};
+
+static const struct soc_enum hardware_resample_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(hardware_resample_texts),
+			hardware_resample_texts);
+
+static int aml_hardware_resample_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = aml_audio_Hardware_resample;
+	return 0;
+}
+
+static int aml_hardware_resample_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		hardware_resample_disable();
+		aml_audio_Hardware_resample = 0;
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		hardware_resample_enable(48000);
+		aml_audio_Hardware_resample = 1;
+	} else if (ucontrol->value.enumerated.item[0] == 2) {
+		hardware_resample_enable(44100);
+		aml_audio_Hardware_resample = 2;
+	} else if (ucontrol->value.enumerated.item[0] == 3) {
+		hardware_resample_enable(32000);
+		aml_audio_Hardware_resample = 3;
+	} else if (ucontrol->value.enumerated.item[0] == 4) {
+		hardware_resample_disable();
+		aml_audio_Hardware_resample = 4;
+		hardware_resample_locked_flag = 1;
+	} else if (ucontrol->value.enumerated.item[0] == 5) {
+		hardware_resample_locked_flag = 0;
+		hardware_resample_enable(48000);
+		aml_audio_Hardware_resample = 5;
+	}
+	return 0;
+}
+
+static const char *const output_swap_texts[] = { "L/R", "L/L", "R/R", "R/L" };
+
+static const struct soc_enum output_swap_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(output_swap_texts),
+			output_swap_texts);
+
+static int aml_output_swap_get_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = read_i2s_mute_swap_reg();
+	return 0;
+}
+
+static int aml_output_swap_set_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	audio_i2s_swap_left_right(ucontrol->value.enumerated.item[0]);
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("LINEIN"),
+	SND_SOC_DAPM_OUTPUT("LINEOUT"),
+};
+
+int audio_in_GPIO = 0;
+struct gpio_desc *av_source;
+static const char * const audio_in_switch_texts[] = { "AV", "Karaok"};
+
+static const struct soc_enum audio_in_switch_enum = SOC_ENUM_SINGLE(
+		SND_SOC_NOPM, 0, ARRAY_SIZE(audio_in_switch_texts),
+		audio_in_switch_texts);
+
+static int aml_get_audio_in_switch(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol) {
+
+	if (audio_in_GPIO == 0) {
+		ucontrol->value.enumerated.item[0] = 0;
+		pr_info("audio in source: AV\n");
+	} else if (audio_in_GPIO == 1) {
+		ucontrol->value.enumerated.item[0] = 1;
+		pr_info("audio in source: Karaok\n");
+	}
+	return 0;
+}
+
+static int aml_set_audio_in_switch(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol) {
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		gpiod_direction_output(av_source,
+					   GPIOF_OUT_INIT_LOW);
+		audio_in_GPIO = 0;
+		pr_info("Set audio in source: AV\n");
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		gpiod_direction_output(av_source,
+					   GPIOF_OUT_INIT_HIGH);
+		audio_in_GPIO = 1;
+		pr_info("Set audio in source: Karaok\n");
+	}
+	return 0;
+}
+
+static const struct snd_kcontrol_new av_controls[] = {
+	SOC_ENUM_EXT("AudioIn Switch",
+			 audio_in_switch_enum,
+			 aml_get_audio_in_switch,
+			 aml_set_audio_in_switch),
+};
+
+static const struct snd_kcontrol_new aml_g9tv_controls[] = {
+	SOC_ENUM_EXT("Audio In Source",
+		     audio_in_source_enum,
+		     aml_audio_get_in_source,
+		     aml_audio_set_in_source),
+
+	SOC_ENUM_EXT("I2SIN Audio Type",
+		     i2s_audio_type_enum,
+		     aml_i2s_audio_type_get_enum,
+		     aml_i2s_audio_type_set_enum),
+
+	SOC_ENUM_EXT("SPDIFIN Audio Type",
+		     spdif_audio_type_enum,
+		     aml_spdif_audio_type_get_enum,
+		     aml_spdif_audio_type_set_enum),
+
+	SOC_ENUM_EXT("Hardware resample enable",
+		     hardware_resample_enum,
+		     aml_hardware_resample_get_enum,
+		     aml_hardware_resample_set_enum),
+
+	SOC_ENUM_EXT("Output Swap",
+		     output_swap_enum,
+		     aml_output_swap_get_enum,
+		     aml_output_swap_set_enum),
+};
+
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	pr_info("enter %s\n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+	pr_info("enter %s\n", __func__);
+	return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+	pr_info("enter %s\n", __func__);
+	return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	pr_info("enter %s\n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+	return 0;
+}
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai,
+				  SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_IB_NF
+				  | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0) {
+		pr_err("%s: set cpu dai fmt failed!\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+	.hw_params	= aml_asoc_hw_params,
+};
+
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct aml_audio_private_data *p_aml_audio;
+	int ret = 0;
+
+	pr_info("enter %s\n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+	ret = snd_soc_add_card_controls(codec->card, aml_g9tv_controls,
+					ARRAY_SIZE(aml_g9tv_controls));
+	if (ret)
+		return ret;
+
+	/* Add specific widgets */
+	snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+				  ARRAY_SIZE(aml_asoc_dapm_widgets));
+
+	return 0;
+}
+
+static void aml_g9tv_pinmux_init(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	p_aml_audio->pin_ctl =
+		devm_pinctrl_get_select(card->dev, "aml_snd_g9tv");
+	if (IS_ERR(p_aml_audio->pin_ctl)) {
+		pr_info("%s, aml_g9tv_pinmux_init error!\n", __func__);
+		return;
+	}
+
+	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		pr_info("%s, make avmute gpio high!\n", __func__);
+		gpiod_direction_output(p_aml_audio->mute_desc,
+					   GPIOF_OUT_INIT_HIGH);
+	}
+
+	av_source = gpiod_get(card->dev, "av_source");
+	if (!IS_ERR(av_source)) {
+		pr_info("%s, make av_source gpio low!\n", __func__);
+		gpiod_direction_output(av_source, GPIOF_OUT_INIT_LOW);
+		snd_soc_add_card_controls(card, av_controls,
+					ARRAY_SIZE(av_controls));
+	}
+	return;
+}
+
+static int aml_card_dai_parse_of(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 int (*init)(
+					 struct snd_soc_pcm_runtime *rtd),
+				 struct device_node *cpu_node,
+				 struct device_node *codec_node,
+				 struct device_node *plat_node)
+{
+	int ret;
+
+	/* get cpu dai->name */
+	ret = snd_soc_of_get_dai_name(cpu_node, &dai_link->cpu_dai_name);
+	if (ret < 0)
+		goto parse_error;
+
+	/* get codec dai->name */
+	ret = snd_soc_of_get_dai_name(codec_node, &dai_link->codec_dai_name);
+	if (ret < 0)
+		goto parse_error;
+
+	dai_link->name = dai_link->stream_name = dai_link->cpu_dai_name;
+	dai_link->codec_of_node = of_parse_phandle(codec_node, "sound-dai", 0);
+	dai_link->platform_of_node = plat_node;
+	dai_link->init = init;
+
+	return 0;
+
+parse_error:
+	return ret;
+}
+
+struct snd_soc_aux_dev g9tv_audio_aux_dev;
+static struct snd_soc_codec_conf g9tv_audio_codec_conf[] = {
+	{
+		.name_prefix = "AMP",
+	},
+};
+static struct codec_probe_priv prob_priv;
+static struct codec_info codec_info_aux;
+
+static int get_audio_codec_i2c_info(struct device_node *p_node,
+				struct aml_audio_codec_info *audio_codec_dev)
+{
+	const char *str;
+	int ret = 0;
+	unsigned i2c_addr;
+
+	ret = of_property_read_string(p_node, "codec_name",
+				      &audio_codec_dev->name);
+	if (ret) {
+		pr_info("get audio codec name failed!\n");
+		goto err_out;
+	}
+
+	ret = of_property_match_string(p_node, "status", "okay");
+	if (ret) {
+		pr_info("%s:this audio codec is disabled!\n",
+			audio_codec_dev->name);
+		goto err_out;
+	}
+
+	pr_debug("use audio aux codec %s\n", audio_codec_dev->name);
+
+	ret = of_property_read_string(p_node, "i2c_bus", &str);
+	if (ret) {
+		pr_err("%s: faild to get i2c_bus str,use default i2c bus!\n",
+		       audio_codec_dev->name);
+		audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
+	} else {
+		if (!strncmp(str, "i2c_bus_a", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_A;
+		else if (!strncmp(str, "i2c_bus_b", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_B;
+		else if (!strncmp(str, "i2c_bus_c", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_C;
+		else if (!strncmp(str, "i2c_bus_d", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
+		else if (!strncmp(str, "i2c_bus_ao", 10))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_AO;
+		else
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
+	}
+
+	ret = of_property_read_u32(p_node, "i2c_addr", &i2c_addr);
+	if (!ret)
+		audio_codec_dev->i2c_addr = i2c_addr;
+	/*pr_info("audio aux codec addr: 0x%x, audio codec i2c bus: %d\n",
+	 *      audio_codec_dev->i2c_addr, audio_codec_dev->i2c_bus_type);*/
+err_out:
+	return ret;
+}
+
+static char drc1_table[15] = "drc1_table_0";
+static char drc1_tko_table[20] = "drc1_tko_table_0";
+static char drc2_table[15] = "drc2_table_0";
+static char drc2_tko_table[20] = "drc2_tko_table_0";
+static int aml_drc_type_select(char *s)
+{
+	char *sel = s;
+
+	if (NULL != s) {
+		sprintf(drc1_table, "%s%s", "drc1_table_", sel);
+		sprintf(drc1_tko_table, "%s%s", "drc1_tko_table_", sel);
+		sprintf(drc2_table, "%s%s", "drc2_table_", sel);
+		sprintf(drc2_tko_table, "%s%s", "drc2_tko_table_", sel);
+		pr_info("select drc type: %s\n", sel);
+	}
+	return 0;
+}
+__setup("amp_drc_type=", aml_drc_type_select);
+
+static char table[10] = "table_0";
+static char wall[10] = "wall_0";
+static char sub_bq_table[20] = "sub_bq_table_0";
+static int aml_eq_type_select(char *s)
+{
+	char *sel = s;
+
+	if (NULL != s) {
+		sprintf(table, "%s%s", "table_", sel);
+		sprintf(wall, "%s%s", "wall_", sel);
+		sprintf(sub_bq_table, "%s%s", "sub_bq_table_", sel);
+		pr_info("select eq type: %s\n", sel);
+	}
+	return 0;
+}
+__setup("amp_eq_type=", aml_eq_type_select);
+
+static void *alloc_and_get_data_array(struct device_node *p_node, char *str,
+				      int *lenp)
+{
+	int ret = 0, length = 0;
+	char *p = NULL;
+
+	if (of_find_property(p_node, str, &length) == NULL) {
+		pr_err("DTD of %s not found!\n", str);
+		goto exit;
+	}
+	pr_debug("prop name=%s,length=%d\n", str, length);
+	p = kzalloc(length * sizeof(char *), GFP_KERNEL);
+	if (p == NULL) {
+		pr_err("ERROR, NO enough mem for %s!\n", str);
+		length = 0;
+		goto exit;
+	}
+
+	ret = of_property_read_u8_array(p_node, str, p, length);
+	if (ret) {
+		pr_err("no of property %s!\n", str);
+		kfree(p);
+		p = NULL;
+		goto exit;
+	}
+
+	*lenp = length;
+
+exit: return p;
+}
+
+static int of_get_eq_pdata(struct tas57xx_platform_data *pdata,
+			   struct device_node *p_node)
+{
+	int length = 0;
+	char *regs = NULL;
+	int ret = 0;
+
+	ret = of_property_read_u32(p_node, "eq_enable", &pdata->eq_enable);
+	if (pdata->eq_enable == 0 || ret != 0) {
+		pr_err("Fail to get eq_enable node or EQ disable!\n");
+		return -2;
+	}
+
+	prob_priv.num_eq = 2;
+	pdata->num_eq_cfgs = prob_priv.num_eq;
+
+	prob_priv.eq_configs = kzalloc(
+		prob_priv.num_eq * sizeof(struct tas57xx_eq_cfg), GFP_KERNEL);
+
+	regs = alloc_and_get_data_array(p_node, table, &length);
+	if (regs == NULL) {
+		kfree(prob_priv.eq_configs);
+		return -2;
+	}
+	strncpy(prob_priv.eq_configs[0].name, table, NAME_SIZE);
+	prob_priv.eq_configs[0].regs = regs;
+	prob_priv.eq_configs[0].reg_bytes = length;
+
+	regs = alloc_and_get_data_array(p_node, wall, &length);
+	if (regs == NULL) {
+		kfree(prob_priv.eq_configs);
+		return -2;
+	}
+	strncpy(prob_priv.eq_configs[1].name, wall, NAME_SIZE);
+	prob_priv.eq_configs[1].regs = regs;
+	prob_priv.eq_configs[1].reg_bytes = length;
+
+	pdata->eq_cfgs = prob_priv.eq_configs;
+	return 0;
+}
+
+static int of_get_drc_pdata(struct tas57xx_platform_data *pdata,
+			    struct device_node *p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+	int ret = 0;
+
+	ret = of_property_read_u32(p_node, "drc_enable", &pdata->drc_enable);
+	if (pdata->drc_enable == 0 || ret != 0) {
+		pr_err("Fail to get drc_enable node or DRC disable!\n");
+		return -2;
+	}
+
+	/* get drc1 table */
+	pd = alloc_and_get_data_array(p_node, drc1_table, &length);
+	if (pd == NULL)
+		return -2;
+	pdata->custom_drc1_table_len = length;
+	pdata->custom_drc1_table = pd;
+
+	/* get drc1 tko table */
+	length = 0;
+	pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, drc1_tko_table, &length);
+	if (pd == NULL)
+		return -2;
+	pdata->custom_drc1_tko_table_len = length;
+	pdata->custom_drc1_tko_table = pd;
+	pdata->enable_ch1_drc = 1;
+
+	/* get drc2 table */
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, drc2_table, &length);
+	if (pd == NULL)
+		return -1;
+	pdata->custom_drc2_table_len = length;
+	pdata->custom_drc2_table = pd;
+
+	/* get drc2 tko table */
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, drc2_tko_table, &length);
+	if (pd == NULL)
+		return -1;
+	pdata->custom_drc2_tko_table_len = length;
+	pdata->custom_drc2_tko_table = pd;
+	pdata->enable_ch2_drc = 1;
+
+	return 0;
+}
+
+static int of_get_init_pdata(struct tas57xx_platform_data *pdata,
+			     struct device_node *p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, "input_mux_reg_buf", &length);
+	if (pd == NULL) {
+		pr_err("%s : can't get input_mux_reg_buf\n", __func__);
+		return -1;
+	}
+
+	/*Now only support 0x20 input mux init*/
+	pdata->num_init_regs = length;
+	pdata->init_regs = pd;
+
+	if (of_property_read_u32(p_node, "master_vol",
+				 &pdata->custom_master_vol)) {
+		pr_err("%s fail to get master volume\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int of_get_resetpin_pdata(struct tas57xx_platform_data *pdata,
+				 struct device_node *p_node)
+{
+	struct gpio_desc *reset_desc;
+
+	reset_desc = of_get_named_gpiod_flags(p_node, "reset_pin", 0, NULL);
+	if (IS_ERR(reset_desc)) {
+		pr_err("%s fail to get reset pin from dts!\n", __func__);
+	} else {
+		int reset_pin = desc_to_gpio(reset_desc);
+		gpio_request(reset_pin, NULL);
+		gpio_direction_output(reset_pin, GPIOF_OUT_INIT_LOW);
+		pdata->reset_pin = reset_pin;
+		pr_info("%s pdata->reset_pin = %d!\n", __func__,
+			pdata->reset_pin);
+	}
+	return 0;
+}
+
+static int of_get_phonepin_pdata(struct tas57xx_platform_data *pdata,
+				 struct device_node *p_node)
+{
+	struct gpio_desc *phone_desc;
+	phone_desc = of_get_named_gpiod_flags(p_node, "phone_pin", 0, NULL);
+	if (IS_ERR(phone_desc)) {
+		pr_err("%s fail to get phone pin from dts!\n", __func__);
+	} else {
+		int phone_pin = desc_to_gpio(phone_desc);
+		gpio_request(phone_pin, NULL);
+		gpio_direction_output(phone_pin, GPIOF_OUT_INIT_LOW);
+		pdata->phone_pin = phone_pin;
+		pr_info("%s pdata->phone_pin = %d!\n", __func__,
+			pdata->phone_pin);
+	}
+	return 0;
+}
+static int of_get_scanpin_pdata(struct tas57xx_platform_data *pdata,
+				 struct device_node *p_node)
+{
+	struct gpio_desc *scan_desc;
+	scan_desc = of_get_named_gpiod_flags(p_node, "scan_pin", 0, NULL);
+	if (IS_ERR(scan_desc)) {
+		pr_err("%s fail to get scan pin from dts!\n", __func__);
+	} else {
+		int scan_pin = desc_to_gpio(scan_desc);
+		gpio_request(scan_pin, NULL);
+		gpio_direction_input(scan_pin);
+		pdata->scan_pin = scan_pin;
+		pr_info("%s pdata->scan_pin = %d!\n", __func__,
+			pdata->scan_pin);
+	}
+	return 0;
+}
+
+static int codec_get_of_pdata(struct tas57xx_platform_data *pdata,
+			      struct device_node *p_node)
+{
+	int ret = 0;
+
+	ret = of_get_resetpin_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec reset pin is not found in dts\n");
+	ret = of_get_phonepin_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec phone pin is not found in dtd\n");
+
+	ret = of_get_scanpin_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec scanp pin is not found in dtd\n");
+
+	ret = of_get_drc_pdata(pdata, p_node);
+	if (ret == -2)
+		pr_info("codec DRC configs are not found in dts\n");
+
+	ret = of_get_eq_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec EQ configs are not found in dts\n");
+
+	ret = of_get_init_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec init configs are not found in dts\n");
+	return ret;
+}
+
+static int aml_aux_dev_parse_of(struct snd_soc_card *card)
+{
+	struct device_node *audio_codec_node = card->dev->of_node;
+	struct device_node *child;
+	struct i2c_board_info board_info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	struct aml_audio_codec_info temp_audio_codec;
+	struct tas57xx_platform_data *pdata;
+	char tmp[I2C_NAME_SIZE];
+	const char *aux_dev;
+	if (of_property_read_string(audio_codec_node, "aux_dev", &aux_dev)) {
+		pr_info("no aux dev!\n");
+		return -ENODEV;
+	}
+	pr_info("aux name = %s\n", aux_dev);
+	child = of_get_child_by_name(audio_codec_node, aux_dev);
+	if (child == NULL) {
+		pr_info("error: failed to find aux dev node %s\n", aux_dev);
+		return -1;
+	}
+
+	memset(&temp_audio_codec, 0, sizeof(struct aml_audio_codec_info));
+	/*pr_info("%s, child name:%s\n", __func__, child->name);*/
+
+	if (get_audio_codec_i2c_info(child, &temp_audio_codec) == 0) {
+		memset(&board_info, 0, sizeof(board_info));
+		strncpy(board_info.type, temp_audio_codec.name, I2C_NAME_SIZE);
+		adapter = i2c_get_adapter(temp_audio_codec.i2c_bus_type);
+		board_info.addr = temp_audio_codec.i2c_addr;
+		board_info.platform_data = &temp_audio_codec;
+		client = i2c_new_device(adapter, &board_info);
+		snprintf(tmp, I2C_NAME_SIZE, "%s", temp_audio_codec.name);
+		strlcpy(codec_info_aux.name, tmp, I2C_NAME_SIZE);
+		snprintf(tmp, I2C_NAME_SIZE, "%s.%s", temp_audio_codec.name,
+				dev_name(&client->dev));
+		strlcpy(codec_info_aux.name_bus, tmp, I2C_NAME_SIZE);
+
+		g9tv_audio_aux_dev.name = codec_info_aux.name;
+		g9tv_audio_aux_dev.codec_name = codec_info_aux.name_bus;
+		g9tv_audio_codec_conf[0].dev_name = codec_info_aux.name_bus;
+
+		card->aux_dev = &g9tv_audio_aux_dev,
+		card->num_aux_devs = 1,
+		card->codec_conf = g9tv_audio_codec_conf,
+		card->num_configs = ARRAY_SIZE(g9tv_audio_codec_conf),
+
+		pdata =
+			kzalloc(sizeof(struct tas57xx_platform_data),
+				GFP_KERNEL);
+		if (!pdata) {
+			pr_err("error: malloc tas57xx_platform_data!\n");
+			return -ENOMEM;
+		}
+		codec_get_of_pdata(pdata, child);
+		client->dev.platform_data = pdata;
+	}
+	return 0;
+}
+static int aml_card_dais_parse_of(struct snd_soc_card *card)
+{
+	struct device_node *np = card->dev->of_node;
+	struct device_node *cpu_node, *codec_node, *plat_node;
+	struct device *dev = card->dev;
+	struct snd_soc_dai_link *dai_links;
+	int num_dai_links, cpu_num, codec_num, plat_num;
+	int i, ret;
+
+	int (*init)(struct snd_soc_pcm_runtime *rtd);
+
+	ret = of_count_phandle_with_args(np, "cpu_list", NULL);
+	if (ret < 0) {
+		dev_err(dev, "AML sound card no cpu_list errno: %d\n", ret);
+		goto err;
+	} else {
+		cpu_num = ret;
+	}
+	ret = of_count_phandle_with_args(np, "codec_list", NULL);
+	if (ret < 0) {
+		dev_err(dev, "AML sound card no codec_list errno: %d\n", ret);
+		goto err;
+	} else {
+		codec_num = ret;
+	}
+	ret = of_count_phandle_with_args(np, "plat_list", NULL);
+	if (ret < 0) {
+		dev_err(dev, "AML sound card no plat_list errno: %d\n", ret);
+		goto err;
+	} else {
+		plat_num = ret;
+	}
+	if ((cpu_num == codec_num) && (cpu_num == plat_num)) {
+		num_dai_links = cpu_num;
+	} else {
+		dev_err(dev,
+			"AML sound card cpu_dai num, codec_dai num, platform num don't match: %d\n",
+			ret);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	dai_links =
+		devm_kzalloc(dev,
+			     num_dai_links * sizeof(struct snd_soc_dai_link),
+			     GFP_KERNEL);
+	if (!dai_links) {
+		dev_err(dev, "Can't allocate snd_soc_dai_links\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	card->dai_link = dai_links;
+	card->num_links = num_dai_links;
+	for (i = 0; i < num_dai_links; i++) {
+		init = NULL;
+		/* CPU sub-node */
+		cpu_node = of_parse_phandle(np, "cpu_list", i);
+		if (cpu_node < 0) {
+			dev_err(dev, "parse aml sound card cpu list error\n");
+			return -EINVAL;
+		}
+		/* CODEC sub-node */
+		codec_node = of_parse_phandle(np, "codec_list", i);
+		if (codec_node < 0) {
+			dev_err(dev, "parse aml sound card codec list error\n");
+			return ret;
+		}
+		/* Platform sub-node */
+		plat_node = of_parse_phandle(np, "plat_list", i);
+		if (plat_node < 0) {
+			dev_err(dev,
+				"parse aml sound card platform list error\n");
+			return ret;
+		}
+		if (i == 0)
+			init = aml_asoc_init;
+
+		ret =
+			aml_card_dai_parse_of(dev, &dai_links[i], init,
+					      cpu_node,
+					      codec_node, plat_node);
+
+		dai_links[0].ops = &aml_asoc_ops;
+	}
+
+err:
+	return ret;
+}
+
+static int aml_g9tv_audio_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_soc_card *card;
+	struct aml_audio_private_data *p_aml_audio;
+	int ret;
+
+	p_aml_audio =
+		devm_kzalloc(dev, sizeof(struct aml_audio_private_data),
+			     GFP_KERNEL);
+	if (!p_aml_audio) {
+		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	card = devm_kzalloc(dev, sizeof(struct snd_soc_card), GFP_KERNEL);
+	if (!card) {
+		dev_err(dev, "Can't allocate snd_soc_card\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	snd_soc_card_set_drvdata(card, p_aml_audio);
+
+	card->dev = dev;
+	platform_set_drvdata(pdev, card);
+	ret = snd_soc_of_parse_card_name(card, "aml_sound_card,name");
+	if (ret < 0) {
+		dev_err(dev, "no specific snd_soc_card name\n");
+		goto err;
+	}
+
+	ret = aml_card_dais_parse_of(card);
+	if (ret < 0) {
+		dev_err(dev, "parse aml sound card dais error %d\n", ret);
+		goto err;
+	}
+	aml_aux_dev_parse_of(card);
+
+	card->suspend_pre = aml_suspend_pre,
+	card->suspend_post = aml_suspend_post,
+	card->resume_pre = aml_resume_pre,
+	card->resume_post = aml_resume_post,
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret < 0) {
+		dev_err(dev, "register aml sound card error %d\n", ret);
+		goto err;
+	}
+
+	aml_g9tv_pinmux_init(card);
+	return 0;
+err:
+	dev_err(dev, "Can't probe snd_soc_card\n");
+	return ret;
+}
+
+static const struct of_device_id amlogic_audio_of_match[] = {
+	{ .compatible = "aml, aml_snd_g9tv", },
+	{},
+};
+
+static struct platform_driver aml_g9tv_audio_driver = {
+	.driver			= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table = amlogic_audio_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe			= aml_g9tv_audio_probe,
+};
+
+module_platform_driver(aml_g9tv_audio_driver);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_G9TV audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/aml/m8/aml_g9tv.h b/sound/soc/aml/m8/aml_g9tv.h
new file mode 100644
index 0000000..223a028
--- /dev/null
+++ b/sound/soc/aml/m8/aml_g9tv.h
@@ -0,0 +1,69 @@
+/*
+ * sound/soc/aml/m8/aml_g9tv.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef AML_G9TV_H
+#define AML_G9TV_H
+
+#include <sound/soc.h>
+#include <linux/gpio/consumer.h>
+
+#define AML_I2C_BUS_AO 0
+#define AML_I2C_BUS_A 1
+#define AML_I2C_BUS_B 2
+#define AML_I2C_BUS_C 3
+#define AML_I2C_BUS_D 4
+
+struct aml_audio_private_data {
+	int clock_en;
+	bool suspended;
+	void *data;
+
+	struct pinctrl *pin_ctl;
+	struct timer_list timer;
+	struct gpio_desc *mute_desc;
+	struct clk *clk;
+
+	struct switch_dev sdev;	/* for android */
+	struct switch_dev mic_sdev;	/* for android */
+};
+
+struct aml_audio_codec_info {
+	const char *name;
+	const char *status;
+	struct device_node *p_node;
+	unsigned i2c_bus_type;
+	unsigned i2c_addr;
+	unsigned id_reg;
+	unsigned id_val;
+	unsigned capless;
+};
+
+struct codec_info {
+	char name[I2C_NAME_SIZE];
+	char name_bus[I2C_NAME_SIZE];
+};
+
+struct codec_probe_priv {
+	int num_eq;
+	struct tas57xx_eq_cfg *eq_configs;
+};
+
+extern struct device *spdif_dev;
+extern void aml_spdif_pinmux_init(struct device *pdev);
+extern void aml_spdif_pinmux_deinit(struct device *pdev);
+
+#endif
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index 64bed25..a2bf64e 100644
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -43,18 +43,12 @@
 #include "aml_spdif_dai.h"
 #include "aml_audio_hw.h"
 #include <linux/amlogic/sound/aiu_regs.h>
-#define USE_HRTIMER 0
-#define HRTIMER_PERIOD (1000000000UL/1000)
-/* #define DEBUG_ALSA_PLATFRORM */
-
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-platform]" fmt, ##args)
-#ifdef DEBUG_ALSA_PLATFRORM
-#define ALSA_DEBUG(fmt, args...) pr_info("[aml-platform]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-platform] enter func %s,line %d\n",\
-							__func__, __LINE__)
+
+#define USE_HW_TIMER
+#ifdef USE_HW_TIMER
+#define XRUN_NUM 100 /*1ms*100=100ms timeout*/
 #else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
+#define XRUN_NUM 10 /*10ms*10=100ms timeout*/
 #endif
 
 unsigned long aml_i2s_playback_start_addr = 0;
@@ -66,11 +60,8 @@ EXPORT_SYMBOL(aml_i2s_playback_phy_start_addr);
 unsigned long aml_i2s_alsa_write_addr = 0;
 EXPORT_SYMBOL(aml_i2s_alsa_write_addr);
 
-unsigned long aml_i2s_capture_phy_start_addr = 0;
-unsigned long aml_i2s_capture_start_addr = 0;
-
-static DEFINE_MUTEX(gate_mutex);
-static unsigned audio_gate_status;
+unsigned int aml_i2s_playback_channel = 2;
+EXPORT_SYMBOL(aml_i2s_playback_channel);
 
 static int trigger_underrun;
 void aml_audio_hw_trigger(void)
@@ -79,6 +70,8 @@ void aml_audio_hw_trigger(void)
 }
 EXPORT_SYMBOL(aml_audio_hw_trigger);
 
+static void aml_i2s_timer_callback(unsigned long data);
+
 /*--------------------------------------------------------------------------*\
  * Hardware definition
 \*--------------------------------------------------------------------------*/
@@ -86,9 +79,13 @@ EXPORT_SYMBOL(aml_audio_hw_trigger);
  *	 them against real values for AML
  */
 static const struct snd_pcm_hardware aml_i2s_hardware = {
-	.info = SNDRV_PCM_INFO_INTERLEAVED |
+	.info =
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	SNDRV_PCM_INFO_MMAP |
+	SNDRV_PCM_INFO_MMAP_VALID |
+#endif
+	SNDRV_PCM_INFO_INTERLEAVED |
 	    SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE,
-
 	.formats =
 	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
 	    SNDRV_PCM_FMTBIT_S32_LE,
@@ -103,7 +100,11 @@ static const struct snd_pcm_hardware aml_i2s_hardware = {
 	.rate_max = 48000,
 	.channels_min = 2,
 	.channels_max = 8,
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	.fifo_size = 4,
+#else
 	.fifo_size = 0,
+#endif
 };
 
 static const struct snd_pcm_hardware aml_i2s_capture = {
@@ -128,7 +129,7 @@ static const struct snd_pcm_hardware aml_i2s_capture = {
 
 static unsigned int period_sizes[] = {
 	64, 128, 256, 512, 1024, 2048, 4096, 8192,
-	16384, 32768, 65536, 65536 * 2,	65536 * 4
+	16384, 32768, 65536, 65536 * 2, 65536 * 4
 };
 
 static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
@@ -141,6 +142,28 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 /*--------------------------------------------------------------------------*\
  * Helper functions
 \*--------------------------------------------------------------------------*/
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = aml_i2s_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	buf->area = dmam_alloc_coherent(pcm->card->dev, size,
+			&buf->addr, GFP_KERNEL);
+	dev_info(pcm->card->dev, "aml-pcm %d: playback preallocate_dma_buffer: area=%p, addr=%p, size=%ld\n",
+		stream, (void *) buf->area, (void *) buf->addr, size);
+	if (!buf->area)
+		return -ENOMEM;
+
+	buf->bytes = size;
+	return 0;
+}
+#else
 static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 
@@ -151,12 +174,11 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 
 	tmp_buf = kzalloc(sizeof(struct aml_audio_buffer), GFP_KERNEL);
 	if (tmp_buf == NULL) {
-		pr_info("alloc tmp buffer struct error\n");
+		dev_err(pcm->card->dev, "allocate tmp buffer error\n");
 		return -ENOMEM;
 	}
 	buf->private_data = tmp_buf;
 
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* malloc DMA buffer */
 		size = aml_i2s_hardware.buffer_bytes_max;
@@ -168,7 +190,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 		buf->area = dma_alloc_coherent(pcm->card->dev, size + 4096,
 					       &buf->addr, GFP_KERNEL);
 		if (!buf->area) {
-			pr_info("alloc playback DMA buffer error\n");
+			dev_err(pcm->card->dev, "alloc playback DMA buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -178,7 +200,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 		size = aml_i2s_hardware.buffer_bytes_max;
 		tmp_buf->buffer_start = kzalloc(size, GFP_KERNEL);
 		if (tmp_buf->buffer_start == NULL) {
-			pr_info("alloc playback tmp buffer error\n");
+			dev_err(pcm->card->dev, "alloc playback tmp buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -194,7 +216,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 					       &buf->addr, GFP_KERNEL);
 
 		if (!buf->area) {
-			pr_info("alloc capture DMA buffer error\n");
+			dev_err(pcm->card->dev, "alloc capture DMA buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -204,7 +226,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 		size = aml_i2s_capture.period_bytes_max;
 		tmp_buf->buffer_start = kzalloc(size, GFP_KERNEL);
 		if (tmp_buf->buffer_start == NULL) {
-			pr_info("alloc capture tmp buffer error\n");
+			dev_err(pcm->card->dev, "alloc capture tmp buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -215,7 +237,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	return 0;
 
 }
-
+#endif
 /*--------------------------------------------------------------------------*\
  * ISR
 \*--------------------------------------------------------------------------*/
@@ -236,8 +258,6 @@ static int aml_i2s_hw_params(struct snd_pcm_substream *substream,
 	*/
 	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
 	runtime->dma_bytes = params_buffer_bytes(params);
-	ALSA_DEBUG("runtime dma_bytes %d,stream type %d\n", runtime->dma_bytes,
-		   substream->stream);
 	s->I2S_addr = runtime->dma_addr;
 
 	/*
@@ -268,50 +288,106 @@ static int aml_i2s_prepare(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct aml_audio_buffer *tmp_buf = buf->private_data;
 
-	ALSA_TRACE();
 	if (s && s->device_type == AML_AUDIO_I2SOUT && trigger_underrun) {
-		pr_info("clear i2s out trigger underrun\n");
+		dev_info(substream->pcm->card->dev, "clear i2s out trigger underrun\n");
 		trigger_underrun = 0;
 	}
+	if (s && s->device_type == AML_AUDIO_I2SOUT)
+		aml_i2s_playback_channel = runtime->channels;
+	tmp_buf->cached_len = 0;
+	return 0;
+}
+
+#ifdef USE_HW_TIMER
+int hw_timer_init = 0;
+static irqreturn_t audio_isr_handler(int irq, void *data)
+{
+	struct aml_runtime_data *prtd = data;
+	struct snd_pcm_substream *substream = prtd->substream;
+	aml_i2s_timer_callback((unsigned long)substream);
+	return IRQ_HANDLED;
+}
+
+static int snd_free_hw_timer_irq(void *data)
+{
+	free_irq(INT_TIMER_D, data);
+	return 0;
+}
+
+static int snd_request_hw_timer(void *data)
+{
+	int ret = 0;
+	if (hw_timer_init == 0) {
+		aml_write_cbus(ISA_TIMERD, TIMER_COUNT);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 3 << 6,
+					TIMERD_RESOLUTION << 6);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 15, TIMERD_MODE << 15);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 19, 1 << 19);
+		hw_timer_init = 1;
+	}
+	ret = request_irq(INT_TIMER_D, audio_isr_handler,
+				IRQF_SHARED, "timerd_irq", data);
+		if (ret < 0) {
+			pr_err("audio hw interrupt register fail\n");
+			return -1;
+		}
 	return 0;
 }
 
+#endif
+
+static void start_timer(struct aml_runtime_data *prtd)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&prtd->timer_lock, flags);
+	if (!prtd->active) {
+#ifndef USE_HW_TIMER
+		prtd->timer.expires = jiffies + 1;
+		add_timer(&prtd->timer);
+#endif
+		prtd->active = 1;
+		prtd->xrun_num = 0;
+	}
+	spin_unlock_irqrestore(&prtd->timer_lock, flags);
+
+}
+
+static void stop_timer(struct aml_runtime_data *prtd)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&prtd->timer_lock, flags);
+	if (prtd->active) {
+#ifndef USE_HW_TIMER
+		del_timer(&prtd->timer);
+#endif
+		prtd->active = 0;
+		prtd->xrun_num = 0;
+	}
+	spin_unlock_irqrestore(&prtd->timer_lock, flags);
+}
+
+
 static int aml_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	struct aml_runtime_data *prtd = rtd->private_data;
-	struct audio_stream *s = &prtd->s;
 	int ret = 0;
-	ALSA_TRACE();
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-
-#if USE_HRTIMER == 0
-		del_timer_sync(&prtd->timer);
-#endif
-		spin_lock(&s->lock);
-#if USE_HRTIMER == 0
-		prtd->timer.expires = jiffies + 1;
-		del_timer(&prtd->timer);
-		add_timer(&prtd->timer);
-#endif
-
-		s->xrun_num = 0;
-		s->active = 1;
-		spin_unlock(&s->lock);
+		start_timer(prtd);
 		break;		/* SNDRV_PCM_TRIGGER_START */
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_STOP:
-		/* TODO */
-		spin_lock(&s->lock);
-		s->active = 0;
-		s->xrun_num = 0;
-		spin_unlock(&s->lock);
+		stop_timer(prtd);
 		break;
 	default:
 		ret = -EINVAL;
@@ -347,128 +423,84 @@ static snd_pcm_uframes_t aml_i2s_pointer(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-#if USE_HRTIMER == 1
-static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer *timer)
+static void aml_i2s_timer_callback(unsigned long data)
 {
-	struct aml_runtime_data *prtd =
-	    container_of(timer, struct aml_runtime_data, hrtimer);
-	struct audio_stream *s = &prtd->s;
-	struct snd_pcm_substream *substream = prtd->substream;
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = NULL;
+	struct audio_stream *s = NULL;
+	int elapsed = 0;
+	unsigned int last_ptr, size = 0;
+	unsigned long flags = 0;
 
-	unsigned int last_ptr, size;
-	/* unsigned long flag; */
-	/* printk("------------->hrtimer start\n"); */
-	if (s->active == 0) {
-		hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-		return HRTIMER_RESTART;
-	}
-	/* spin_lock_irqsave(&s->lock, flag); */
+	if (runtime == NULL || runtime->private_data == NULL)
+		return;
+
+	prtd = runtime->private_data;
+	s = &prtd->s;
 
+	if (prtd->active == 0)
+		return;
+
+	spin_lock_irqsave(&prtd->timer_lock, flags);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		last_ptr = read_i2s_rd_ptr();
-		if (last_ptr < s->last_ptr)
-			size = runtime->dma_bytes + last_ptr - s->last_ptr;
+		if (s->device_type == AML_AUDIO_I2SOUT)
+			last_ptr = read_i2s_rd_ptr();
 		else
-			size = last_ptr - s->last_ptr;
-
+			last_ptr = read_iec958_rd_ptr();
+		if (last_ptr < s->last_ptr) {
+			size =
+				runtime->dma_bytes + last_ptr -
+				(s->last_ptr);
+		} else {
+			size = last_ptr - (s->last_ptr);
+		}
 		s->last_ptr = last_ptr;
 		s->size += bytes_to_frames(substream->runtime, size);
 		if (s->size >= runtime->period_size) {
 			s->size %= runtime->period_size;
-			snd_pcm_period_elapsed(substream);
+			elapsed = 1;
 		}
 	} else {
-		last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) / 2;
-		if (last_ptr < s->last_ptr)
-			size = runtime->dma_bytes + last_ptr - s->last_ptr;
+		if (s->device_type == AML_AUDIO_I2SIN)
+			last_ptr = audio_in_i2s_wr_ptr();
 		else
-			size = last_ptr - s->last_ptr;
-
+			last_ptr = audio_in_spdif_wr_ptr();
+		if (last_ptr < s->last_ptr) {
+			size =
+				runtime->dma_bytes + (last_ptr -
+						  (s->last_ptr)) / 2;
+			prtd->xrun_num = 0;
+		} else if (last_ptr == s->last_ptr) {
+			if (prtd->xrun_num++ > XRUN_NUM) {
+				/*dev_info(substream->pcm->card->dev,
+					"alsa capture long time no data, quit xrun!\n");
+				*/
+				prtd->xrun_num = 0;
+				s->size = runtime->period_size;
+			}
+		} else {
+			size = (last_ptr - (s->last_ptr)) / 2;
+			prtd->xrun_num = 0;
+		}
 		s->last_ptr = last_ptr;
-		s->size += bytes_to_frames(runtime, size);
+		s->size += bytes_to_frames(substream->runtime, size);
 		if (s->size >= runtime->period_size) {
 			s->size %= runtime->period_size;
-			snd_pcm_period_elapsed(substream);
+			elapsed = 1;
 		}
 	}
-	/* spin_unlock_irqrestore(&s->lock, flag); */
-	hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-	return HRTIMER_RESTART;
-}
+
+#ifndef USE_HW_TIMER
+	mod_timer(&prtd->timer, jiffies + 1);
 #endif
-static void aml_i2s_timer_callback(unsigned long data)
-{
-	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	struct audio_stream *s = &prtd->s;
 
-	unsigned int last_ptr, size = 0;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (s->active == 1) {
-			spin_lock(&s->lock);
-			if (s->device_type == AML_AUDIO_I2SOUT)
-				last_ptr = read_i2s_rd_ptr();
-			else
-				last_ptr = read_iec958_rd_ptr();
-			if (last_ptr < s->last_ptr) {
-				size =
-				    runtime->dma_bytes + last_ptr -
-				    (s->last_ptr);
-			} else {
-				size = last_ptr - (s->last_ptr);
-			}
-			s->last_ptr = last_ptr;
-			s->size += bytes_to_frames(substream->runtime, size);
-			if (s->size >= runtime->period_size) {
-				s->size %= runtime->period_size;
-				spin_unlock(&s->lock);
-				snd_pcm_period_elapsed(substream);
-				spin_lock(&s->lock);
-			}
-			mod_timer(&prtd->timer, jiffies + 1);
-			spin_unlock(&s->lock);
-		} else {
-			mod_timer(&prtd->timer, jiffies + 1);
-		}
-	} else {
-		if (s->active == 1) {
-			spin_lock(&s->lock);
-			if (s->device_type == AML_AUDIO_I2SIN)
-				last_ptr = audio_in_i2s_wr_ptr();
-			else
-				last_ptr = audio_in_spdif_wr_ptr();
-			if (last_ptr < s->last_ptr) {
-				size =
-				    runtime->dma_bytes + (last_ptr -
-							  (s->last_ptr)) / 2;
-			} else if (last_ptr == s->last_ptr) {
-				if (s->xrun_num++ > 100) {
-					pr_info("alsa capture long time no data, quit xrun!\n");
-					s->xrun_num = 0;
-					s->size = runtime->period_size;
-				}
-			} else {
-				size = (last_ptr - (s->last_ptr)) / 2;
-			}
-			s->last_ptr = last_ptr;
-			s->size += bytes_to_frames(substream->runtime, size);
-			if (s->size >= runtime->period_size) {
-				s->size %= runtime->period_size;
-				spin_unlock(&s->lock);
-				snd_pcm_period_elapsed(substream);
-				spin_lock(&s->lock);
-			}
-			mod_timer(&prtd->timer, jiffies + 1);
-			spin_unlock(&s->lock);
-		} else {
-			mod_timer(&prtd->timer, jiffies + 1);
-		}
-	}
+	spin_unlock_irqrestore(&prtd->timer_lock, flags);
+	if (elapsed)
+		snd_pcm_period_elapsed(substream);
 }
 
-static int num_clk_gate;
+
 static int aml_i2s_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -476,7 +508,7 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	struct audio_stream *s = &prtd->s;
 	int ret = 0;
-	ALSA_TRACE();
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		snd_soc_set_runtime_hwparams(substream, &aml_i2s_hardware);
 		if (s->device_type == AML_AUDIO_I2SOUT) {
@@ -485,10 +517,6 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 		}
 	} else {
 		snd_soc_set_runtime_hwparams(substream, &aml_i2s_capture);
-		if (s->device_type == AML_AUDIO_I2SIN) {
-			aml_i2s_capture_start_addr = (unsigned long)buf->area;
-			aml_i2s_capture_phy_start_addr = buf->addr;
-		}
 	}
 
 	/* ensure that peroid size is a multiple of 32bytes */
@@ -497,7 +525,8 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 				       SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
 				       &hw_constraints_period_sizes);
 	if (ret < 0) {
-		pr_info("set period bytes constraint error\n");
+		dev_err(substream->pcm->card->dev,
+			"set period bytes constraint error\n");
 		goto out;
 	}
 
@@ -505,47 +534,34 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 	ret = snd_pcm_hw_constraint_integer(runtime,
 					    SNDRV_PCM_HW_PARAM_PERIODS);
 	if (ret < 0) {
-		pr_info("set period error\n");
+		dev_err(substream->pcm->card->dev, "set period error\n");
 		goto out;
 	}
 	if (!prtd) {
 		prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
-			pr_info("alloc aml_runtime_data error\n");
+			dev_err(substream->pcm->card->dev, "alloc aml_runtime_data error\n");
 			ret = -ENOMEM;
 			goto out;
 		}
 		prtd->substream = substream;
 		runtime->private_data = prtd;
 	}
-/* WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1); */
-#if USE_HRTIMER == 0
+
+	spin_lock_init(&prtd->timer_lock);
+
+#ifndef USE_HW_TIMER
+	init_timer(&prtd->timer);
 	prtd->timer.function = &aml_i2s_timer_callback;
 	prtd->timer.data = (unsigned long)substream;
-	init_timer(&prtd->timer);
 #else
-	hrtimer_init(&prtd->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	prtd->hrtimer.function = aml_i2s_hrtimer_callback;
-	hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD),
-		      HRTIMER_MODE_REL);
-	pr_info("hrtimer inited..\n");
+	ret = snd_request_hw_timer(prtd);
+	if (ret < 0) {
+		dev_err(substream->pcm->card->dev, "request audio hw timer failed\n");
+		goto out;
+	}
 #endif
 
-	spin_lock_init(&prtd->s.lock);
-	s->xrun_num = 0;
-	/* WRITE_MPEG_REG_BITS(MPLL_I2S_CNTL, 1,14, 1); */
-	mutex_lock(&gate_mutex);
-	if (!num_clk_gate) {
-		num_clk_gate = 1;
-		if (audio_gate_status == 0) {
-			/* audio_aiu_pg_enable(1); */
-			ALSA_DEBUG("aml_pcm_open  device type %x\n",
-				   s->device_type);
-
-		}
-	}
-	audio_gate_status |= s->device_type;
-	mutex_unlock(&gate_mutex);
  out:
 	return ret;
 }
@@ -553,35 +569,17 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 static int aml_i2s_close(struct snd_pcm_substream *substream)
 {
 	struct aml_runtime_data *prtd = substream->runtime->private_data;
-	struct audio_stream *s = &prtd->s;
-	ALSA_TRACE();
-	mutex_lock(&gate_mutex);
-	audio_gate_status &= ~s->device_type;
-	if (audio_gate_status == 0) {
-		ALSA_DEBUG("aml_pcm_close  device type %x\n", s->device_type);
-		/* audio_aiu_pg_enable(0); */
-	}
-	mutex_unlock(&gate_mutex);
-/* if(s->device_type == AML_AUDIO_SPDIFOUT) */
-/* WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1); */
-#if USE_HRTIMER == 0
-	del_timer_sync(&prtd->timer);
-#else
-	hrtimer_cancel(&prtd->hrtimer);
-#endif
 
+#ifdef USE_HW_TIMER
+	snd_free_hw_timer_irq(prtd);
+#endif
 	kfree(prtd);
 	prtd = NULL;
-	substream->runtime->private_data = NULL;
 
 	return 0;
 }
 
-/* extern void audio_out_i2s_enable(unsigned flag); */
-/* extern void aml_hw_iec958_init(struct snd_pcm_substream *substream); */
-/* extern void audio_hw_958_enable(unsigned flag); */
-/* extern int kernel_android_50; */
-
+#ifndef CONFIG_SND_AML_SPLIT_MODE_MMAP
 static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 				 snd_pcm_uframes_t pos,
 				 void __user *buf, snd_pcm_uframes_t count,
@@ -589,28 +587,76 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 {
 	int res = 0;
 	int n;
+#ifndef CONFIG_SND_AML_SPLIT_MODE
 	int i = 0, j = 0;
-	int align = runtime->channels * 32 / runtime->byte_align;
-	char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+	int align = runtime->channels * 32;
+#endif
+	unsigned long offset = frames_to_bytes(runtime, pos);
+	char *hwbuf = runtime->dma_area + offset;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct snd_dma_buffer *buffer = &substream->dma_buffer;
 	struct aml_audio_buffer *tmp_buf = buffer->private_data;
 	void *ubuf = tmp_buf->buffer_start;
 	struct audio_stream *s = &prtd->s;
-
-	if (s->device_type == AML_AUDIO_I2SOUT)
-		aml_i2s_alsa_write_addr = frames_to_bytes(runtime, pos);
-
+	struct device *dev = substream->pcm->card->dev;
+#ifndef CONFIG_SND_AML_SPLIT_MODE
+	int cached_len = tmp_buf->cached_len;
+	char *cache_buffer_bytes = tmp_buf->cache_buffer_bytes;
+#endif
 	n = frames_to_bytes(runtime, count);
 	if (n > tmp_buf->buffer_size) {
-		pr_info("[%s]FATAL_ERR:UserData/%d > buffer_size/%d\n",
-				__func__ , n, tmp_buf->buffer_size);
+		dev_err(dev, "FATAL_ERR:UserData/%d > buffer_size/%d\n",
+				n, tmp_buf->buffer_size);
 		return -EFAULT;
 	}
 	res = copy_from_user(ubuf, buf, n);
 	if (res)
 		return -EFAULT;
+
+#ifndef CONFIG_SND_AML_SPLIT_MODE
+	/*mask align byte(64 or 256)*/
+	if ((cached_len != 0 || (n % align) != 0)) {
+		int byte_size = n;
+		int total_len;
+		int ouput_len;
+		int next_cached_len;
+		char cache_buffer_bytes_tmp[256];
+
+		offset -= cached_len;
+		hwbuf = runtime->dma_area + offset;
+
+		total_len = byte_size + cached_len;
+		ouput_len = total_len & (~(align - 1));
+		next_cached_len = total_len - ouput_len;
+
+		if (next_cached_len)
+			memcpy((void *)cache_buffer_bytes_tmp,
+				(void *)((char *)ubuf +
+				byte_size - next_cached_len),
+				next_cached_len);
+		memmove((void *)((char *)ubuf + cached_len),
+				(void *)ubuf, ouput_len - cached_len);
+		if (cached_len)
+			memcpy((void *)ubuf,
+				(void *)cache_buffer_bytes, cached_len);
+		if (next_cached_len)
+			memcpy((void *)cache_buffer_bytes,
+				(void *)cache_buffer_bytes_tmp,
+				next_cached_len);
+
+		tmp_buf->cached_len = next_cached_len;
+		n = ouput_len;
+	}
+	/*end of mask*/
+#endif
+
+	if (s->device_type == AML_AUDIO_I2SOUT)
+		aml_i2s_alsa_write_addr = offset;
+
 	if (access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		memcpy(hwbuf, ubuf, n);
+#else
 		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
 
 			int16_t *tfrom, *to, *left, *right;
@@ -619,10 +665,6 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 
 			left = to;
 			right = to + 16;
-			if (pos % align) {
-				pr_info("audio data unligned: pos=%d, n=%d, align=%d\n",
-				     (int)pos, n, align);
-			}
 
 			for (j = 0; j < n; j += 64) {
 				for (i = 0; i < 16; i++) {
@@ -641,10 +683,6 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 			left = to;
 			right = to + 8;
 
-			if (pos % align) {
-				pr_info("audio data unaligned: pos=%d, n=%d, align=%d\n",
-				     (int)pos, n, align);
-			}
 			for (j = 0; j < n; j += 64) {
 				for (i = 0; i < 8; i++) {
 					*left++ = (*tfrom++);
@@ -662,11 +700,6 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 			left = to;
 			right = to + 8;
 
-			if (pos % align) {
-				pr_info("audio data unaligned: pos=%d, n=%d, align=%d\n",
-				     (int)pos, n, align);
-			}
-
 			if (runtime->channels == 8) {
 				int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl,
 				    *sbr;
@@ -709,18 +742,13 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 				}
 			}
 		}
-
+#endif
 	} else {
 		res = -EFAULT;
 	}
 	return res;
 }
 
-static unsigned int aml_get_in_wr_ptr(void)
-{
-	return audio_in_i2s_wr_ptr() - aml_i2s_capture_phy_start_addr;
-}
-
 static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 				snd_pcm_uframes_t pos,
 				void __user *buf, snd_pcm_uframes_t count,
@@ -728,41 +756,26 @@ static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 {
 	unsigned int *tfrom, *left, *right;
 	unsigned short *to;
-	int res = 0, n = 0, i = 0, j = 0, size = 0;
+	int res = 0, n = 0, i = 0, j = 0;
 	unsigned int t1, t2;
 	unsigned char r_shift = 8;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	struct audio_stream *s = &prtd->s;
 	char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos) * 2;
 	struct snd_dma_buffer *buffer = &substream->dma_buffer;
 	struct aml_audio_buffer *tmp_buf = buffer->private_data;
 	void *ubuf = tmp_buf->buffer_start;
-	if (s->device_type == AML_AUDIO_I2SIN) {
-		unsigned int buffersize =
-		    (unsigned int)runtime->buffer_size * 8;
-		unsigned int hw_ptr = aml_get_in_wr_ptr();
-		unsigned int alsa_read_ptr = frames_to_bytes(runtime, pos) * 2;
-		size = (buffersize + hw_ptr - alsa_read_ptr) % buffersize;
-	}
-	if (s->device_type == AML_AUDIO_SPDIFIN) {	/* spdif in */
-		r_shift = 12;
-	}
+	struct device *dev = substream->pcm->card->dev;
 	to = (unsigned short *)ubuf;	/* tmp buf; */
 	tfrom = (unsigned int *)hwbuf;	/* 32bit buffer */
 	n = frames_to_bytes(runtime, count);
-	if (size < 2 * n && s->device_type == AML_AUDIO_I2SIN) {
-		pr_info("Alsa ptr is too close to HW ptr, Reset ALSA!\n");
-		return -EPIPE;
-	}
 	if (access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count))) {
 		if (runtime->channels == 2) {
 			left = tfrom;
 			right = tfrom + 8;
 			if (pos % 8)
-				pr_info("audio data unligned\n");
+				dev_err(dev, "audio data unligned\n");
 
 			if ((n * 2) % 64)
-				pr_info("audio data unaligned 64 bytes\n");
+				dev_err(dev, "audio data unaligned 64 bytes\n");
 
 			for (j = 0; j < n * 2; j += 64) {
 				for (i = 0; i < 8; i++) {
@@ -804,6 +817,7 @@ static int aml_i2s_copy(struct snd_pcm_substream *substream, int channel,
 	}
 	return ret;
 }
+#endif
 
 int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 		    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
@@ -811,7 +825,6 @@ int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 	char *ppos;
 	int n;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	ALSA_TRACE();
 
 	n = frames_to_bytes(runtime, count);
 	ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
@@ -819,6 +832,21 @@ int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 	return 0;
 }
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+static int aml_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	dev_info(substream->pcm->card->dev,
+		"\narea=%p,addr=%ld,bytes=%ld,rate:%d, channels:%d, subformat:%d\n",
+		runtime->dma_area, (long)runtime->dma_addr, runtime->dma_bytes,
+		runtime->rate, runtime->channels, runtime->subformat);
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+		runtime->dma_area, runtime->dma_addr, runtime->dma_bytes);
+}
+#endif
+
 static struct snd_pcm_ops aml_i2s_ops = {
 	.open = aml_i2s_open,
 	.close = aml_i2s_close,
@@ -828,7 +856,11 @@ static struct snd_pcm_ops aml_i2s_ops = {
 	.prepare = aml_i2s_prepare,
 	.trigger = aml_i2s_trigger,
 	.pointer = aml_i2s_pointer,
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	.mmap = aml_pcm_mmap,
+#else
 	.copy = aml_i2s_copy,
+#endif
 	.silence = aml_i2s_silence,
 };
 
@@ -842,7 +874,7 @@ static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
 	int ret = 0;
 	struct snd_soc_card *card = rtd->card;
 	struct snd_pcm *pcm = rtd->pcm;
-	ALSA_TRACE();
+
 	if (!card->dev->dma_mask)
 		card->dev->dma_mask = &aml_i2s_dmamask;
 	if (!card->dev->coherent_dma_mask)
@@ -856,7 +888,6 @@ static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
 	}
 
 	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		pr_debug("aml-i2s:" "Allocating i2s capture DMA buffer\n");
 		ret = aml_i2s_preallocate_dma_buffer(pcm,
 						     SNDRV_PCM_STREAM_CAPTURE);
 		if (ret)
@@ -873,7 +904,7 @@ static void aml_i2s_free_dma_buffers(struct snd_pcm *pcm)
 	struct snd_dma_buffer *buf;
 	struct aml_audio_buffer *tmp_buf;
 	int stream;
-	ALSA_TRACE();
+
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
 		if (!substream)
@@ -909,8 +940,6 @@ static int aml_i2s_suspend(struct snd_soc_dai *dai)
 
 	/* disable the PDC and save the PDC registers */
 	/* TODO */
-	pr_info("aml i2s suspend\n");
-
 	return 0;
 }
 
@@ -927,7 +956,6 @@ static int aml_i2s_resume(struct snd_soc_dai *dai)
 
 	/* restore the PDC registers and enable the PDC */
 	/* TODO */
-	pr_info("aml i2s resume\n");
 	return 0;
 }
 #else
@@ -935,18 +963,48 @@ static int aml_i2s_resume(struct snd_soc_dai *dai)
 #define aml_i2s_resume	NULL
 #endif
 
+bool aml_audio_i2s_mute_flag = 0;
+static int aml_audio_set_i2s_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	aml_audio_i2s_mute_flag = ucontrol->value.integer.value[0];
+	pr_info("aml_audio_i2s_mute_flag: flag=%d\n", aml_audio_i2s_mute_flag);
+	if (aml_audio_i2s_mute_flag)
+		aml_audio_i2s_mute();
+	else
+		aml_audio_i2s_unmute();
+	return 0;
+}
+
+static int aml_audio_get_i2s_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = aml_audio_i2s_mute_flag;
+	return 0;
+}
+
+static const struct snd_kcontrol_new aml_i2s_controls[] = {
+	SOC_SINGLE_BOOL_EXT("Audio i2s mute",
+				0, aml_audio_get_i2s_mute,
+				aml_audio_set_i2s_mute),
+};
+static int aml_i2s_probe(struct snd_soc_platform *platform)
+{
+	return snd_soc_add_platform_controls(platform,
+			aml_i2s_controls, ARRAY_SIZE(aml_i2s_controls));
+}
+
 struct snd_soc_platform_driver aml_soc_platform = {
+	.probe = aml_i2s_probe,
 	.ops = &aml_i2s_ops,
 	.pcm_new = aml_i2s_new,
 	.pcm_free = aml_i2s_free_dma_buffers,
 	.suspend = aml_i2s_suspend,
 	.resume = aml_i2s_resume,
 };
-EXPORT_SYMBOL_GPL(aml_soc_platform);
 
 static int aml_soc_platform_probe(struct platform_device *pdev)
 {
-	ALSA_TRACE();
 	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
 }
 
@@ -966,12 +1024,44 @@ static const struct of_device_id amlogic_audio_dt_match[] = {
 #define amlogic_audio_dt_match NULL
 #endif
 
+#ifdef CONFIG_HIBERNATION
+static unsigned long isa_timerd_saved;
+static unsigned long isa_timerd_mux_saved;
+static int aml_i2s_freeze(struct device *dev)
+{
+	isa_timerd_saved = aml_read_cbus(ISA_TIMERD);
+	isa_timerd_mux_saved = aml_read_cbus(ISA_TIMER_MUX);
+	return 0;
+}
+
+static int aml_i2s_thaw(struct device *dev)
+{
+	return 0;
+}
+
+static int aml_i2s_restore(struct device *dev)
+{
+	aml_write_cbus(ISA_TIMERD, isa_timerd_saved);
+	aml_write_cbus(ISA_TIMER_MUX, isa_timerd_mux_saved);
+	return 0;
+}
+
+const struct dev_pm_ops aml_i2s_pm = {
+	.freeze		= aml_i2s_freeze,
+	.thaw		= aml_i2s_thaw,
+	.restore	= aml_i2s_restore,
+};
+#endif
+
 static struct platform_driver aml_i2s_driver = {
 	.driver = {
-		   .name = "aml-i2s",
-		   .owner = THIS_MODULE,
-		   .of_match_table = amlogic_audio_dt_match,
-		   },
+		.name = "aml-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_audio_dt_match,
+#ifdef CONFIG_HIBERNATION
+		.pm     = &aml_i2s_pm,
+#endif
+		},
 
 	.probe = aml_soc_platform_probe,
 	.remove = aml_soc_platform_remove,
diff --git a/sound/soc/aml/m8/aml_i2s.h b/sound/soc/aml/m8/aml_i2s.h
index 98128e0..7614a8d 100644
--- a/sound/soc/aml/m8/aml_i2s.h
+++ b/sound/soc/aml/m8/aml_i2s.h
@@ -18,6 +18,8 @@
 #ifndef __AML_I2S_H__
 #define __AML_I2S_H__
 
+#include <linux/mutex.h>
+
 /* #define debug_printk */
 #ifdef debug_printk
 #define dug_printk(fmt, args...)  printk(fmt, ## args)
@@ -25,9 +27,18 @@
 #define dug_printk(fmt, args...)
 #endif
 
+#define BASE_IRQ                (32)
+#define AM_IRQ(reg)             (reg + BASE_IRQ)
+#define INT_TIMER_D             AM_IRQ(29)
+/* note: we use TIEMRD. MODE: 1: periodic, 0: one-shot*/
+#define TIMERD_MODE             1
+/* timerbase resolution: 00: 1us; 01: 10us; 10: 100us; 11: 1ms*/
+#define TIMERD_RESOLUTION       0x1
+/* timer count: 16bits*/
+#define TIMER_COUNT             100
+
 struct audio_stream {
 	int stream_id;
-	int active;
 	unsigned int last_ptr;
 	unsigned int size;
 	unsigned int sample_rate;
@@ -36,11 +47,12 @@ struct audio_stream {
 	struct snd_pcm_substream *stream;
 	unsigned i2s_mode; /* 0:master, 1:slave, */
 	unsigned device_type;
-	unsigned int xrun_num;
 };
 struct aml_audio_buffer {
 	void *buffer_start;
 	unsigned int buffer_size;
+	char cache_buffer_bytes[256];
+	int cached_len;
 };
 
 struct aml_i2s_dma_params {
@@ -67,11 +79,12 @@ struct aml_runtime_data {
 	struct snd_pcm_substream *substream;
 	struct audio_stream s;
 	struct timer_list timer;	/* timeer for playback and capture */
-	struct hrtimer hrtimer;
+	spinlock_t timer_lock;
 	void *buf; /* tmp buffer for playback or capture */
+	int active;
+	unsigned int xrun_num;
+	struct mutex chmap_lock;
+	int chmap_layout;
 };
 
-extern struct snd_soc_platform_driver aml_soc_platform;
-/* extern struct aml_audio_interface aml_i2s_interface; */
-
 #endif
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index cc6e5b6..63770a6 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -38,6 +38,7 @@
 #include <sound/control.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
+#include <sound/tlv.h>
 #include "aml_i2s_dai.h"
 #include "aml_pcm.h"
 #include "aml_i2s.h"
@@ -48,31 +49,54 @@
 struct aml_dai_info dai_info[3] = { {0} };
 
 static int i2s_pos_sync;
-/* #define AML_DAI_DEBUG */
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-i2s-dai]" fmt, ##args)
-#ifdef AML_DAI_DEBUG
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-i2s-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-i2s-dai] enter func %s\n", __func__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
-/* extern int amaudio2_enable; */
-/* extern int kernel_android_50; */
+
+struct channel_speaker_allocation {
+        int channels;
+        int speakers[8];
+};
+
+#define NA	SNDRV_CHMAP_NA
+#define FL	SNDRV_CHMAP_FL
+#define FR	SNDRV_CHMAP_FR
+#define RL	SNDRV_CHMAP_RL
+#define RR	SNDRV_CHMAP_RR
+#define LFE	SNDRV_CHMAP_LFE
+#define FC	SNDRV_CHMAP_FC
+#define RLC	SNDRV_CHMAP_RLC
+#define RRC	SNDRV_CHMAP_RRC
+#define RC	SNDRV_CHMAP_RC
+#define FLC	SNDRV_CHMAP_FLC
+#define FRC	SNDRV_CHMAP_FRC
+#define FLH	SNDRV_CHMAP_TFL
+#define FRH	SNDRV_CHMAP_TFR
+#define FLW	SNDRV_CHMAP_FLW
+#define FRW	SNDRV_CHMAP_FRW
+#define TC	SNDRV_CHMAP_TC
+#define FCH	SNDRV_CHMAP_TFC
+
+static struct channel_speaker_allocation channel_allocations[] = {
+/*      	       channel:   7     6    5    4    3     2    1    0  */
+{ .channels = 2,  .speakers = {  NA,   NA,  NA,  NA,  NA,   NA,  FR,  FL } },
+                                 /* 2.1 */
+{ .channels = 3,  .speakers = {  NA,   NA,  NA,  NA,  NA,  LFE,  FR,  FL } },
+                                 /* surround40 */
+{ .channels = 4,  .speakers = {  NA,   NA,  RR,  RL,  NA,   NA,  FR,  FL } },
+                                 /* surround41 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  NA,  LFE,  FR,  FL } },
+                                 /* surround50 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  FC,   NA,  FR,  FL } },
+                                 /* surround51 */
+{ .channels = 6,  .speakers = {  NA,   NA,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* 6.1 */
+{ .channels = 7,  .speakers = {  NA,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* surround71 */
+{ .channels = 8,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+};
+
 
 /* extern int set_i2s_iec958_samesource(int enable); */
 #define DEFAULT_SAMPLERATE 48000
 #define DEFAULT_MCLK_RATIO_SR 256
-static int i2sbuf[32 + 16];
-static void aml_i2s_play(void)
-{
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-	audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
-	memset(i2sbuf, 0, sizeof(i2sbuf));
-	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
-	audio_out_i2s_enable(1);
-
-}
 
 /*
 the I2S hw  and IEC958 PCM output initation,958 initation here,
@@ -92,29 +116,207 @@ static void aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 		i2s_mode = AIU_I2S_MODE_PCM16;
 		break;
 	}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(i2s_mode, runtime->channels);
+#else
 	audio_set_i2s_mode(i2s_mode);
+#endif
 	audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,
 			 runtime->channels);
-	ALSA_PRINT("i2s dma %p,phy addr %ld,mode %d,ch %d\n",
-		   runtime->dma_area, (long)runtime->dma_addr,
-		   i2s_mode, runtime->channels);
+}
+
+static int aml_dai_i2s_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+                                     unsigned int size, unsigned int __user *tlv)
+{
+    unsigned int __user *dst;
+    int count = 0;
+    int i;
+
+    if (size < 8)
+        return -ENOMEM;
+
+    if (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))
+        return -EFAULT;
+
+    size -= 8;
+    dst = tlv + 2;
+
+    for (i = 0; i < ARRAY_SIZE(channel_allocations); i++)
+    {
+        struct channel_speaker_allocation *ch = &channel_allocations[i];
+        int num_chs = 0;
+        int chs_bytes;
+        int c;
+
+        for (c = 0; c < 8; c++)
+        {
+            if (ch->speakers[c])
+                num_chs++;
+        }
+
+        chs_bytes = num_chs * 4;
+        if (size < 8)
+            return -ENOMEM;
+
+        if (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||
+            put_user(chs_bytes, dst + 1))
+            return -EFAULT;
+
+        dst += 2;
+        size -= 8;
+        count += 8;
+
+        if (size < chs_bytes)
+            return -ENOMEM;
+
+        size -= chs_bytes;
+        count += chs_bytes;
+
+        for (c = 0; c < 8; c++)
+        {
+            int sp = ch->speakers[7 - c];
+            if (sp)
+            {
+                if (put_user(sp, dst))
+                    return -EFAULT;
+                dst++;
+            }
+        }
+    }
+
+    if (put_user(count, tlv + 1))
+        return -EFAULT;
+
+    return 0;
+}
+
+static int aml_dai_i2s_chmap_ctl_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    for (channel=0; channel<8; channel++)
+    {
+        ucontrol->value.integer.value[7 - channel] = channel_allocations[prtd->chmap_layout].speakers[channel];
+    }
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static int aml_dai_i2s_chmap_ctl_put(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel, layout, matches, matched_layout;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    // now check if the channel setup matches one of our layouts
+    for (layout = 0; layout < ARRAY_SIZE(channel_allocations); layout++)
+    {
+        matches = 1;
+
+        for (channel = 0; channel < substream->runtime->channels; channel++)
+        {
+            int sp = ucontrol->value.integer.value[channel];
+            int chan = channel_allocations[layout].speakers[7 - channel];
+
+            if (sp != chan)
+            {
+                matches = 0;
+                break;
+            }
+        }
+
+        if (matches)
+        {
+            matched_layout = layout;
+            break;
+        }
+    }
+
+
+    // default to first layout if we didnt find any
+    if (!matches)
+        matched_layout = 0;
+
+    pr_info("Setting a %d channel layout matching layout #%d\n", runtime->channels, matched_layout);
+
+    prtd->chmap_layout = matched_layout;
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static struct snd_kcontrol *aml_dai_i2s_chmap_kctrl_get(struct snd_pcm_substream *substream)
+{
+    int str;
+
+    if ((substream) && (substream->pcm))
+    {
+        for (str=0; str<2; str++)
+        {
+            if (substream->pcm->streams[str].chmap_kctl)
+            {
+                return substream->pcm->streams[str].chmap_kctl;
+            }
+        }
+    }
+
+    return 0;
 }
 
 static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-	int ret = 0;
+        int ret = 0, i;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd =
 	    (struct aml_runtime_data *)runtime->private_data;
 	struct audio_stream *s;
-	ALSA_TRACE();
+	struct snd_pcm_chmap *chmap;
+	struct snd_kcontrol *kctl;
+
 	if (prtd == NULL) {
 		prtd =
 		    (struct aml_runtime_data *)
 		    kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
-			pr_info("alloc aml_runtime_data error\n");
+			dev_err(substream->pcm->card->dev, "alloc aml_runtime_data error\n");
 			ret = -ENOMEM;
 			goto out;
 		}
@@ -128,6 +330,29 @@ static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 	} else {
 		s->device_type = AML_AUDIO_I2SIN;
 	}
+
+
+	// Alsa Channel Mapping API handling
+	if (!aml_dai_i2s_chmap_kctrl_get(substream))
+	{
+	    ret = snd_pcm_add_chmap_ctls(substream->pcm, SNDRV_PCM_STREAM_PLAYBACK, NULL, 8, 0, &chmap);
+
+	    if (ret < 0)
+	    {
+	      pr_err("aml_dai_i2s_startup error %d\n", ret);
+	      goto out;
+	    }
+
+	    kctl = chmap->kctl;
+	    for (i = 0; i < kctl->count; i++)
+	      kctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_WRITE;
+
+	    kctl->get = aml_dai_i2s_chmap_ctl_get;
+	    kctl->put = aml_dai_i2s_chmap_ctl_put;
+	    kctl->tlv.c = aml_dai_i2s_chmap_ctl_tlv;
+	}
+
+	mutex_init(&prtd->chmap_lock);
 	return 0;
  out:
 	return ret;
@@ -137,7 +362,7 @@ static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
 	if (IEC958_mode_codec == 0)
-		aml_spdif_play();
+		aml_spdif_play(1);
 	return;
 }
 
@@ -147,22 +372,16 @@ static int aml_i2s_set_amclk(struct aml_i2s *i2s, unsigned long rate)
 	int ret = 0;
 
 	ret = clk_set_rate(i2s->clk_mpl0, rate * 10);
-	if (ret) {
-		pr_err("Can't set I2S mpll clock rate: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	ret = clk_set_parent(i2s->clk_mclk, i2s->clk_mpl0);
-	if (ret) {
-		pr_err("Can't set I2S mclk parent: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	ret = clk_set_rate(i2s->clk_mclk, rate);
-	if (ret) {
-		pr_err("Can't set I2S mclk clock rate: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	audio_set_i2s_clk_div();
 
@@ -175,13 +394,11 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
-	ALSA_TRACE();
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		audio_out_i2s_enable(0);
-
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	}
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		s->i2s_mode = dai_info[dai->id].i2s_mode;
 		audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes * 2,
@@ -197,19 +414,19 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 		s->device_type = AML_AUDIO_I2SIN;
 	} else {
 		s->device_type = AML_AUDIO_I2SOUT;
+		IEC958_mode_codec = 0;
 		aml_hw_i2s_init(runtime);
 		/* i2s/958 share the same audio hw buffer when PCM mode */
 		if (IEC958_mode_codec == 0) {
-			aml_hw_iec958_init(substream);
+			aml_hw_iec958_init(substream, 1);
 			/* use the hw same sync for i2s/958 */
-			pr_info("958 with i2s\n");
+			dev_info(substream->pcm->card->dev, "i2s/958 same source\n");
 			/* aml_set_spdif_clk(runtime->rate*512, 0); */
 			audio_i2s_958_same_source(1);
 		}
 	}
 	if (runtime->channels == 8) {
-		pr_info("[%s,%d]8ch PCM output->notify HDMI\n", __func__,
-		       __LINE__);
+		dev_info(substream->pcm->card->dev, "8ch PCM output->notify HDMI\n");
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 	return 0;
@@ -220,17 +437,17 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	int *ppp = NULL;
-	ALSA_TRACE();
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		/* TODO */
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu i2s playback enable\n");
+			dev_info(substream->pcm->card->dev, "I2S playback enable\n");
 			audio_out_i2s_enable(1);
 			if (IEC958_mode_codec == 0) {
-				pr_info("audio_hw_958_enable 1\n");
+				dev_info(substream->pcm->card->dev, "IEC958 playback enable\n");
 				audio_hw_958_enable(1);
 			}
 		} else {
@@ -244,10 +461,10 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu i2s playback disable\n");
+			dev_info(substream->pcm->card->dev, "I2S playback disable\n");
 			audio_out_i2s_enable(0);
 			if (IEC958_mode_codec == 0) {
-				pr_info("audio_hw_958_enable 0\n");
+				dev_info(substream->pcm->card->dev, "IEC958 playback disable\n");
 				audio_hw_958_enable(0);
 			}
 		} else {
@@ -280,7 +497,6 @@ static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
 
 static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	ALSA_TRACE();
 	if (fmt & SND_SOC_DAIFMT_CBS_CFS)	/* slave mode */
 		dai_info[dai->id].i2s_mode = I2S_SLAVE_MODE;
 
@@ -300,7 +516,6 @@ static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -308,7 +523,7 @@ static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
 {
 	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
 
-	if (i2s && i2s->clk_mclk)
+	if (i2s && i2s->clk_mclk && !i2s->disable_clk_suspend)
 		clk_disable_unprepare(i2s->clk_mclk);
 
 	return 0;
@@ -318,14 +533,15 @@ static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
 {
 	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
 
-	if (i2s && i2s->clk_mclk)
+	if (i2s && i2s->clk_mclk && !i2s->disable_clk_suspend)
 		clk_prepare_enable(i2s->clk_mclk);
 
 	return 0;
 }
 
-#define AML_DAI_I2S_RATES      SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
-#define AML_DAI_I2S_FORMATS    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
+#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_192000)
+#define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
+		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 static struct snd_soc_dai_ops aml_dai_i2s_ops = {
 	.startup = aml_dai_i2s_startup,
@@ -371,6 +587,7 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 {
 	struct aml_i2s *i2s = NULL;
 	struct reset_control *audio_reset;
+	struct device_node *pnode = pdev->dev.of_node;
 	int ret = 0, i;
 
 	/* enable AIU module power gate first */
@@ -391,6 +608,9 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 	}
 	dev_set_drvdata(&pdev->dev, i2s);
 
+	i2s->disable_clk_suspend =
+		of_property_read_bool(pnode, "disable_clk_suspend");
+
 	i2s->clk_mpl0 = devm_clk_get(&pdev->dev, "mpll0");
 	if (IS_ERR(i2s->clk_mpl0)) {
 		dev_err(&pdev->dev, "Can't retrieve mpll0 clock\n");
@@ -415,15 +635,14 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 
 	ret = clk_prepare_enable(i2s->clk_mclk);
 	if (ret) {
-		pr_err("Can't enable I2S mclk clock: %d\n", ret);
+		dev_err(&pdev->dev, "Can't enable I2S mclk clock: %d\n", ret);
 		goto err;
 	}
 
-	aml_i2s_play();
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_i2s_dai, ARRAY_SIZE(aml_i2s_dai));
 	if (ret) {
-		pr_err("Can't register i2s dai: %d\n", ret);
+		dev_err(&pdev->dev, "Can't register i2s dai: %d\n", ret);
 		goto err_clk_dis;
 	}
 	return 0;
@@ -444,6 +663,16 @@ static int aml_i2s_dai_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void aml_i2s_dai_shutdown(struct platform_device *pdev)
+{
+	struct aml_i2s *i2s = dev_get_drvdata(&pdev->dev);
+
+	if (i2s && i2s->clk_mclk)
+		clk_disable_unprepare(i2s->clk_mclk);
+
+	return;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_dai_dt_match[] = {
 	{.compatible = "amlogic, aml-i2s-dai",},
@@ -462,6 +691,7 @@ static struct platform_driver aml_i2s_dai_driver = {
 
 	.probe = aml_i2s_dai_probe,
 	.remove = aml_i2s_dai_remove,
+	.shutdown = aml_i2s_dai_shutdown,
 };
 
 static int __init aml_i2s_dai_modinit(void)
diff --git a/sound/soc/aml/m8/aml_i2s_dai.h b/sound/soc/aml/m8/aml_i2s_dai.h
index eea60e6..72d305c 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.h
+++ b/sound/soc/aml/m8/aml_i2s_dai.h
@@ -23,6 +23,7 @@ struct aml_i2s {
 	struct clk *clk_mpl0;
 	struct clk *clk_mclk;
 	int old_samplerate;
+	bool disable_clk_suspend;
 };
 
 #endif
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index 2012bba..c834d34 100644
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_snd_card: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -46,8 +47,27 @@
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/of_gpio.h>
 #include <linux/io.h>
-#define DRV_NAME "aml_snd_card"
-/* extern struct device *spdif_dev; */
+#include <linux/amlogic/jtag.h>
+
+
+#define DRV_NAME "aml_snd_m8_card"
+
+static int i2sbuf[32 + 16];
+static void aml_i2s_play(void)
+{
+#if 0
+	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(AIU_I2S_MODE_PCM16, 2);
+#else
+	audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
+#endif
+	memset(i2sbuf, 0, sizeof(i2sbuf));
+	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
+	audio_out_i2s_enable(1);
+
+#endif
+}
 
 static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio,
 				  unsigned long delay)
@@ -153,8 +173,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 		if (flag & 0x1) {
 			/* 1 :have mic ;  2 no mic */
 			switch_set_state(&p_aml_audio->sdev, 2);
-			pr_info(KERN_INFO
-			       "aml aduio hp pluged 3 jack_type: %d\n",
+			pr_info("aml aduio hp pluged 3 jack_type: %d\n",
 			       SND_JACK_HEADPHONE);
 			snd_soc_jack_report(&p_aml_audio->jack, status,
 					    SND_JACK_HEADPHONE);
@@ -164,8 +183,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 				if (flag & 0x8) {
 					switch_set_state(&p_aml_audio->mic_sdev,
 							 1);
-					pr_info(KERN_INFO
-					       "aml aduio mic pluged jack_type: %d\n",
+					pr_info("aml aduio mic pluged jack_type: %d\n",
 					       SND_JACK_MICROPHONE);
 					snd_soc_jack_report(&p_aml_audio->jack,
 						status, SND_JACK_HEADPHONE);
@@ -175,13 +193,12 @@ static void aml_asoc_work_func(struct work_struct *work)
 		} else if (flag & 0x2) {
 			/* 1 :have mic ;  2 no mic */
 			switch_set_state(&p_aml_audio->sdev, 1);
-			pr_info(KERN_INFO
-			       "aml aduio hp pluged 4 jack_type: %d\n",
+			pr_info("aml aduio hp pluged 4 jack_type: %d\n",
 			       SND_JACK_HEADSET);
 			snd_soc_jack_report(&p_aml_audio->jack, status,
 					    SND_JACK_HEADPHONE);
 		} else {
-			pr_info(KERN_INFO "aml audio hp unpluged\n");
+			pr_info("aml audio hp unpluged\n");
 			switch_set_state(&p_aml_audio->sdev, 0);
 			snd_soc_jack_report(&p_aml_audio->jack, 0,
 					    SND_JACK_HEADPHONE);
@@ -191,8 +208,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 				if (flag & 0x8) {
 					switch_set_state(&p_aml_audio->mic_sdev,
 							 1);
-					pr_info(KERN_INFO
-					       "aml aduio mic pluged jack_type: %d\n",
+					pr_info("aml aduio mic pluged jack_type: %d\n",
 					       SND_JACK_MICROPHONE);
 					snd_soc_jack_report(&p_aml_audio->jack,
 						status, SND_JACK_HEADPHONE);
@@ -217,14 +233,14 @@ static void aml_asoc_timer_func(unsigned long data)
 	mod_timer(&p_aml_audio->timer, jiffies + delay);
 }
 
-struct aml_audio_private_data *p_audio;
+static struct aml_audio_private_data *p_audio;
 static int aml_m8_spk_enabled;
 
 static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
 			  struct snd_ctl_elem_value *ucontrol)
 {
 	aml_m8_spk_enabled = ucontrol->value.integer.value[0];
-	pr_info(KERN_INFO "aml_m8_set_spk: aml_m8_spk_enabled=%d\n",
+	pr_info("aml_m8_set_spk: aml_m8_spk_enabled=%d\n",
 	       aml_m8_spk_enabled);
 
 	msleep_interruptible(10);
@@ -239,8 +255,6 @@ static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
 static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
 			  struct snd_ctl_elem_value *ucontrol)
 {
-	/* pr_info("***aml_m8_get_spk****aml_m8_spk_enabled=%d**\n",
-		aml_m8_spk_enabled); */
 	ucontrol->value.integer.value[0] = aml_m8_spk_enabled;
 	return 0;
 }
@@ -248,8 +262,10 @@ static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
 static int aml_suspend_pre(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
+	struct pinctrl_state *state;
+	int val = 0;
 
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	if (!p_aml_audio->hp_disable) {
 		/* stop timer */
@@ -260,20 +276,36 @@ static int aml_suspend_pre(struct snd_soc_card *card)
 
 		mutex_unlock(&p_aml_audio->lock);
 	}
+
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to suspend\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_suspend");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl suspend state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
+	}
+
+	if (p_aml_audio->mute_desc) {
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	};
+
 	return 0;
 }
 
 static int aml_suspend_post(struct snd_soc_card *card)
 {
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	/* if(ext_codec) */
-	/* i2s_gpio_set(card); */
+	pr_info("enter %s\n", __func__);
 	return 0;
 }
 
 static int aml_resume_pre(struct snd_soc_card *card)
 {
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 
 	return 0;
 }
@@ -281,8 +313,10 @@ static int aml_resume_pre(struct snd_soc_card *card)
 static int aml_resume_post(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
+	struct pinctrl_state *state;
+	int val = 0;
 
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	if (!p_aml_audio->hp_disable) {
 		mutex_lock(&p_aml_audio->lock);
@@ -294,22 +328,50 @@ static int aml_resume_post(struct snd_soc_card *card)
 		mutex_unlock(&p_aml_audio->lock);
 	}
 
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to resume\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_m8");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl working state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
+	}
+
+	if (p_aml_audio->mute_desc) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	}
 	return 0;
 }
 
 static int speaker_events(struct snd_soc_dapm_widget *w,
 			  struct snd_kcontrol *kcontrol, int event)
 {
+	int val = 0;
+
+	if (p_audio->mute_desc == NULL) {
+		pr_info("no mute_gpio setting");
+		return 0;
+	}
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
-		pr_info("speaker_events--mute =1\n");
+		pr_info("audio speaker on\n");
+		val = p_audio->mute_inv ?
+			GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
 		gpiod_direction_output(p_audio->mute_desc, 1);
 		aml_m8_spk_enabled = 1;
 		msleep(p_audio->sleep_time);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
-		pr_info("speaker_events--mute =0\n");
-		gpiod_direction_output(p_audio->mute_desc, 0);
+		pr_info("audio speaker off\n");
+		val = p_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_audio->mute_desc, val);
 		aml_m8_spk_enabled = 0;
 		break;
 	}
@@ -350,7 +412,6 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	int ret = 0;
 	int hp_paraments[5];
 
-	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	ret = snd_soc_add_card_controls(codec->card, aml_m8_controls,
 					ARRAY_SIZE(aml_m8_controls));
@@ -363,7 +424,7 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	p_aml_audio->hp_disable =
 	    of_property_read_bool(card->dev->of_node, "hp_disable");
 
-	pr_info("p_aml_audio->hp_disable=%d\n", p_aml_audio->hp_disable);
+	pr_info("headphone detection disable=%d\n", p_aml_audio->hp_disable);
 
 	if (!p_aml_audio->hp_disable) {
 		/* for report headphone to android */
@@ -445,46 +506,43 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	    of_property_read_u32(card->dev->of_node, "sleep_time",
 				 &p_aml_audio->sleep_time);
 	if (ret)
-		pr_info("falied to get spk event delay time\n");
-
-	pr_info("spk_event delay_time = %d\n",
-	       p_aml_audio->sleep_time);
+		pr_info("no spk event delay time set\n");
 
 	return 0;
 }
-static int ao_jtag_on;
+
 static void aml_m8_pinmux_init(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
 	int val;
-	if (ao_jtag_on)
-		return;
+
 	p_aml_audio = snd_soc_card_get_drvdata(card);
+	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
+	p_aml_audio->mute_inv =
+	    of_property_read_bool(card->dev->of_node, "mute_inv");
+	if (p_aml_audio->mute_desc) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	}
+
+	if (is_jtag_apao())
+		return;
 	val = aml_read_sec_reg(0xda004004);
 	pr_info("audio use jtag pinmux as i2s output, read val =%x\n",
 		aml_read_sec_reg(0xda004004));
 	val = val & (~((1<<8) | (1<<1)));
 	aml_write_sec_reg(0xda004004, val);
+
 	p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "aml_snd_m8");
 	if (IS_ERR(p_aml_audio->pin_ctl)) {
 		pr_info("%s,aml_m8_pinmux_init error!\n", __func__);
 		return;
 	}
-	/* p_audio = p_aml_audio; */
-
-	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
-
-	p_aml_audio->mute_inv =
-	    of_property_read_bool(card->dev->of_node, "mute_inv");
-	gpiod_direction_output(p_aml_audio->mute_desc, GPIOF_OUT_INIT_LOW);
-
-}
-static int __init ao_jtag_func(char *buf)
-{
-	ao_jtag_on = 1;
-	return 0;
 }
-early_param("ao_jtag_on", ao_jtag_func);
+
 static int aml_card_dai_parse_of(struct device *dev,
 				 struct snd_soc_dai_link *dai_link,
 				 int (*init)(struct snd_soc_pcm_runtime *rtd),
@@ -660,6 +718,7 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	aml_i2s_play();
 	aml_m8_pinmux_init(card);
 	return 0;
  err:
@@ -667,6 +726,22 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static void aml_audio_shutdown(struct platform_device *pdev)
+{
+	struct pinctrl_state *state;
+
+	if (IS_ERR_OR_NULL(p_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to shutdown\n");
+		return;
+	}
+
+	state = pinctrl_lookup_state(p_audio->pin_ctl, "aml_snd_suspend");
+	if (!IS_ERR(state))
+		pinctrl_select_state(p_audio->pin_ctl, state);
+
+	return;
+}
+
 static const struct of_device_id amlogic_audio_of_match[] = {
 	{.compatible = "aml, aml_snd_m8",},
 	{},
@@ -682,6 +757,7 @@ static struct platform_driver aml_m8_audio_driver = {
 		   .pm = &snd_soc_pm_ops,
 		   },
 	.probe = aml_m8_audio_probe,
+	.shutdown = aml_audio_shutdown,
 };
 
 module_platform_driver(aml_m8_audio_driver);
diff --git a/sound/soc/aml/m8/aml_pcm.c b/sound/soc/aml/m8/aml_pcm.c
index ef71c8b..13d4064 100644
--- a/sound/soc/aml/m8/aml_pcm.c
+++ b/sound/soc/aml/m8/aml_pcm.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_pcm: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -41,18 +42,6 @@
 #include "aml_pcm.h"
 #include "aml_audio_hw_pcm2bt.h"
 
-#define USE_HRTIMER 0
-#define HRTIMER_PERIOD (1000000000UL/1000)
-#define DEBUG_ALSA_PLATFRORM
-
-/* #define PCM_DEBUG */
-
-#ifdef PCM_DEBUG
-#define pcm_debug(fmt, args...)  printk(fmt, ## args)
-#else
-#define pcm_debug(fmt, args...)
-#endif
-
 /*--------------------------------------------------------------------------*\
  * Hardware definition
 \*--------------------------------------------------------------------------*/
@@ -106,7 +95,7 @@ static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
 	else if (diff >= prtd->buffer_size)
 		diff = prtd->buffer_size;
 
-	pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __func__,
+	pr_debug("%s value: 0x%08x offset: 0x%08x\n", __func__,
 		  value, diff);
 	return (unsigned int)diff;
 }
@@ -123,7 +112,7 @@ static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
 	else if (diff >= prtd->buffer_size)
 		diff = prtd->buffer_size;
 
-	pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __func__,
+	pr_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __func__,
 		  value, diff);
 	return (unsigned int)diff;
 }
@@ -178,7 +167,7 @@ static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
 
 static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
 {
-	pcm_debug("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	spin_lock(&prtd->lock);
 	aml_pcm2bt_timer_rearm(prtd);
 	prtd->running = 1;
@@ -188,7 +177,7 @@ static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
 
 static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
 {
-	pcm_debug("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	spin_lock(&prtd->lock);
 	prtd->running = 0;
 	del_timer(&prtd->timer);
@@ -229,7 +218,7 @@ static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 
-	pcm_debug("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	init_timer(&prtd->timer);
 	prtd->timer_period = 1;
 	prtd->timer.data = (unsigned long)substream;
@@ -253,8 +242,6 @@ aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
 	else {
 		prtd->buffer_start = runtime->dma_addr;
 		prtd->buffer_size = runtime->dma_bytes;
-		pcm_debug("%s dma_addr: 0x%08x dma_bytes: 0x%x\n",
-			  __func__, runtime->dma_addr, runtime->dma_bytes);
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
@@ -271,7 +258,7 @@ aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
 
 static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
 {
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	snd_pcm_lib_free_pages(substream);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
@@ -295,7 +282,7 @@ static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	int ret = 0;
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -321,7 +308,7 @@ static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	snd_pcm_uframes_t frames;
 
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	frames = bytes_to_frames(runtime, (ssize_t) prtd->buffer_offset);
 
 	return frames;
@@ -332,7 +319,7 @@ static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd;
 	int ret;
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 
 	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
 
@@ -394,7 +381,7 @@ aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	unsigned int wrptr = 0;
 	int ret = 0;
 
-	pcm_debug("enter %s channel: %d pos: %ld count: %ld\n",
+	pr_debug("enter %s channel: %d pos: %ld count: %ld\n",
 		  __func__, channel, pos, count);
 
 	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
@@ -423,7 +410,7 @@ aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 	unsigned int rdptr = 0;
 	int ret = 0;
 
-	pcm_debug("enter %s channel: %d pos: %ld count: %ld\n",
+	pr_debug("enter %s channel: %d pos: %ld count: %ld\n",
 		  __func__, channel, pos, count);
 
 	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
@@ -468,7 +455,7 @@ static int aml_pcm2bt_silence(struct snd_pcm_substream *substream,
 	unsigned char *ppos = NULL;
 	ssize_t n;
 
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	n = frames_to_bytes(runtime, count);
 	ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
 	memset(ppos, 0, n);
@@ -501,15 +488,13 @@ static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
 
-	pr_info("enter %s stream: %d\n", __func__, stream);
-
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
 	buf->private_data = NULL;
 	buf->area = dma_alloc_coherent(pcm->card->dev, size,
 				       &buf->addr, GFP_KERNEL);
 	if (!buf->area) {
-		pr_info("%s dma_alloc_coherent failed!\n", __func__);
+		dev_err(pcm->dev, "aml_pcm alloc failed!\n");
 		return -ENOMEM;
 	}
 
@@ -520,13 +505,13 @@ static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 
 static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
 {
-	/* pcm_debug("enter %s\n", __FUNCTION__); */
+	/* pr_debug("enter %s\n", __FUNCTION__); */
 	int ret = 0;
 	struct snd_soc_card *card = rtd->card;
 	struct snd_pcm *pcm = rtd->pcm;
 	struct snd_soc_dai *dai;
 	dai = rtd->cpu_dai;
-	pcm_debug("enter %s dai->name: %s dai->id: %d\n", __func__,
+	pr_debug("enter %s dai->name: %s dai->id: %d\n", __func__,
 		  dai->name, dai->id);
 
 	if (!card->dev->dma_mask)
@@ -558,7 +543,7 @@ static void aml_pcm2bt_free(struct snd_pcm *pcm)
 	struct snd_dma_buffer *buf;
 	int stream;
 
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
 		if (!substream)
@@ -585,7 +570,6 @@ EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
 
 static int aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
 {
-	pr_info("enter %s\n", __func__);
 	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
 }
 
@@ -618,13 +602,11 @@ static struct platform_driver aml_platform_pcm2bt_driver = {
 
 static int __init aml_alsa_bt_init(void)
 {
-	/* aml_pcm_init_debugfs(); */
 	return platform_driver_register(&aml_platform_pcm2bt_driver);
 }
 
 static void __exit aml_alsa_bt_exit(void)
 {
-	/* aml_pcm_cleanup_debugfs(); */
 	platform_driver_unregister(&aml_platform_pcm2bt_driver);
 }
 
diff --git a/sound/soc/aml/m8/aml_pcm_dai.c b/sound/soc/aml/m8/aml_pcm_dai.c
index da2a960..ed5e021 100644
--- a/sound/soc/aml/m8/aml_pcm_dai.c
+++ b/sound/soc/aml/m8/aml_pcm_dai.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_pcm_dai: " fmt
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -38,45 +39,26 @@
 
 #define DEV_NAME "aml-pcm-dai"
 
-/* static aml_dai_info_t dai_info[3] = {{0}}; */
-#define AML_DAI_DEBUG
-
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-pcm-dai]" fmt, ##args)
-#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-pcm-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-pcm-dai] enter func %s\n", __func__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
-
 static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
 static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 }
 
 static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-/* #if 1 */
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		pr_info(
@@ -101,8 +83,6 @@ static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
 static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 			       struct snd_soc_dai *dai)
 {
-	ALSA_DEBUG();
-	/* struct snd_pcm_runtime *rtd = substream->runtime; */
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -137,17 +117,13 @@ static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *dai)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s:%s\n", __FILE__, __func__);
 	return 0;
 }
 
 static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 	if (fmt & SND_SOC_DAIFMT_CBS_CFS)
 		snd_soc_dai_get_drvdata(dai);
 	return 0;
@@ -156,9 +132,7 @@ static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
@@ -166,13 +140,13 @@ static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
 static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
 {
 
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
 static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
 {
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
@@ -223,7 +197,7 @@ static int aml_pcm_dai_probe(struct platform_device *pdev)
 {
 	struct pinctrl *pin_ctl;
 
-	pr_info("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 
 	pin_ctl = devm_pinctrl_get_select(&pdev->dev, "aml_audio_btpcm");
 	if (IS_ERR(pin_ctl))
diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
index 85f2833..ac76ef6 100644
--- a/sound/soc/aml/m8/aml_spdif_codec.c
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -26,10 +26,9 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES     SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
-#define STUB_FORMATS   SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
-
-static struct snd_soc_codec_driver soc_codec_spdif_dit;
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 struct pinctrl *pin_spdif_ctl;
 struct device *spdif_dev;
@@ -59,20 +58,55 @@ void aml_spdif_pinmux_init(struct device *dev)
 		pin_spdif_ctl = devm_pinctrl_get_select(dev, "aml_audio_spdif");
 		if (IS_ERR(pin_spdif_ctl)) {
 			pin_spdif_ctl = NULL;
-			pr_info("aml_spdif_pinmux_init can't get pinctrl\n");
+			dev_err(dev, "aml_spdif_pinmux_init can't get pinctrl\n");
 		}
 	}
 }
 
 void aml_spdif_pinmux_deinit(struct device *dev)
 {
-	pr_info(KERN_INFO "aml_spdif_mute\n");
+	dev_dbg(dev, "aml_spdif_mute\n");
 	if (spdif_pinmux) {
 		spdif_pinmux = 0;
 		if (pin_spdif_ctl)
 			devm_pinctrl_put(pin_spdif_ctl);
 	}
 }
+bool aml_audio_spdif_mute_flag = 0;
+static int aml_audio_set_spdif_mute(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	aml_audio_spdif_mute_flag = ucontrol->value.integer.value[0];
+	pr_info("aml_audio_set_spdif_mute: flag=%d\n",
+		aml_audio_spdif_mute_flag);
+	if (aml_audio_spdif_mute_flag)
+		aml_spdif_pinmux_deinit(spdif_dev);
+	else
+		aml_spdif_pinmux_init(spdif_dev);
+	return 0;
+}
+
+static int aml_audio_get_spdif_mute(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = aml_audio_spdif_mute_flag;
+	return 0;
+}
+
+static const struct snd_kcontrol_new spdif_controls[] = {
+	SOC_SINGLE_BOOL_EXT("Audio spdif mute",
+			    0, aml_audio_get_spdif_mute,
+			    aml_audio_set_spdif_mute),
+};
+
+static int spdif_probe(struct snd_soc_codec *codec)
+{
+	return snd_soc_add_codec_controls(codec,
+			spdif_controls, ARRAY_SIZE(spdif_controls));
+}
+static struct snd_soc_codec_driver soc_codec_spdif_dit = {
+	.probe =	spdif_probe,
+};
 
 static ssize_t spdif_mute_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
@@ -93,7 +127,7 @@ static ssize_t spdif_mute_set(struct device *dev,
 	else if (strncmp(buf, "spdif_unmute", 12))
 		aml_spdif_pinmux_deinit(dev);
 	else
-		pr_info("spdif set the wrong value\n");
+		dev_err(dev, "spdif set the wrong value\n");
 
 	return count;
 }
@@ -103,12 +137,14 @@ static DEVICE_ATTR(spdif_mute, 0660, spdif_mute_show, spdif_mute_set);
 static int spdif_dit_probe(struct platform_device *pdev)
 {
 	int ret = device_create_file(&pdev->dev, &dev_attr_spdif_mute);
-	pr_info("enter spdif_dit_probe\n");
+
 	spdif_dev = &pdev->dev;
 
 	aml_spdif_pinmux_init(&pdev->dev);
 	if (ret < 0)
-		pr_info("spdif: failed to add spdif_mute sysfs: %d\n", ret);
+		dev_err(&pdev->dev,
+			"spdif: failed to add spdif_mute sysfs: %d\n", ret);
+
 	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
 				      &dit_stub_dai, 1);
 }
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index 7b42d2d..405d223 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_spdif_dai: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -45,17 +46,8 @@
 #include "aml_i2s.h"
 #include <linux/amlogic/sound/aout_notify.h>
 #include <linux/amlogic/sound/aiu_regs.h>
+#include <linux/amlogic/cpu_version.h>
 
-/* #define DEBUG_ALSA_SPDIF_DAI */
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-spdif-dai]" fmt, ##args)
-#ifdef DEBUG_ALSA_SPDIF_DAI
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-spdif-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-spdif-dai] enter func %s,line %d\n",\
-		__func__, __LINE__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
 /*
  0 --  other formats except(DD,DD+,DTS)
  1 --  DTS
@@ -70,70 +62,72 @@ struct aml_spdif {
 	struct clk *clk_i958;
 	struct clk *clk_mclk;
 	struct clk *clk_spdif;
+	struct clk *clk_81;
 	int old_samplerate;
 };
 struct aml_spdif *spdif_p;
 unsigned int clk81 = 0;
 EXPORT_SYMBOL(clk81);
 
-static int iec958buf[32 + 16];
 static int old_samplerate = -1;
+static int flag_samesrc = -1;
 
-void aml_spdif_play(void)
+void aml_spdif_play(int samesrc)
 {
-#if 1
-	struct _aiu_958_raw_setting_t set;
-	struct _aiu_958_channel_status_t chstat;
-	struct snd_pcm_substream substream;
-	struct snd_pcm_runtime runtime;
-	substream.runtime = &runtime;
-	runtime.rate = 48000;
-	runtime.format = SNDRV_PCM_FORMAT_S16_LE;
-	runtime.channels = 2;
-	runtime.sample_bits = 16;
-	memset((void *)(&set), 0, sizeof(set));
-	memset((void *)(&chstat), 0, sizeof(chstat));
-	set.chan_stat = &chstat;
-	set.chan_stat->chstat0_l = 0x0100;
-	set.chan_stat->chstat0_r = 0x0100;
-	set.chan_stat->chstat1_l = 0X200;
-	set.chan_stat->chstat1_r = 0X200;
-	audio_hw_958_enable(0);
-	if (old_samplerate != AUDIO_CLK_FREQ_48) {
-		pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
-		__func__, old_samplerate, AUDIO_CLK_FREQ_48);
-		old_samplerate = AUDIO_CLK_FREQ_48;
-		aml_set_spdif_clk(48000 * 512, 0);
-	}
-	/* Todo, div can be changed, for most case, div = 2 */
-	/* audio_set_spdif_clk_div(); */
-	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
-	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
-		pr_info("set 4x audio clk for 958\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (0) {
-		pr_info("share the same clock\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
-	} else {
-		pr_info("set normal 512 fs /4 fs\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
+#if 0
+	if (is_meson_gxtvbb_cpu() == false) {
+		static int iec958buf[32 + 16];
+		struct _aiu_958_raw_setting_t set;
+		struct _aiu_958_channel_status_t chstat;
+		struct snd_pcm_substream substream;
+		struct snd_pcm_runtime runtime;
+		substream.runtime = &runtime;
+		runtime.rate = 48000;
+		runtime.format = SNDRV_PCM_FORMAT_S16_LE;
+		runtime.channels = 2;
+		runtime.sample_bits = 16;
+		memset((void *)(&set), 0, sizeof(set));
+		memset((void *)(&chstat), 0, sizeof(chstat));
+		set.chan_stat = &chstat;
+		set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+		audio_hw_958_enable(0);
+		if (old_samplerate != AUDIO_CLK_FREQ_48
+				|| samesrc != flag_samesrc) {
+			pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
+			__func__, old_samplerate, AUDIO_CLK_FREQ_48);
+			old_samplerate = AUDIO_CLK_FREQ_48;
+			flag_samesrc = samesrc;
+			aml_set_spdif_clk(48000 * 512, samesrc);
+		}
+		/* Todo, div can be changed, for most case, div = 2 */
+		/* audio_set_spdif_clk_div(); */
+		/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+		if (IEC958_mode_codec == 4	|| IEC958_mode_codec == 5 ||
+		IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+			pr_info("set 4x audio clk for 958\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+		} else if (samesrc) {
+			pr_info("share the same clock\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+		} else {
+			pr_info("set normal 512 fs /4 fs\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
+		}
+		/* enable 958 divider */
+		aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
+		audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+		/*clear the same source function as new raw data output */
+		audio_i2s_958_same_source(0);
+		memset(iec958buf, 0, sizeof(iec958buf));
+		audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63),
+					128, 0);
+		audio_set_958_mode(AIU_958_MODE_PCM16, &set);
+		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
+		audio_hw_958_enable(1);
 	}
-	/* enable 958 divider */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
-	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-	memset(iec958buf, 0, sizeof(iec958buf));
-	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 0);
-	audio_set_958_mode(AIU_958_MODE_PCM16, &set);
-#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1
-	/* 512fs divide 4 == 128fs */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x3 << 4);
-#else
-	/* 256fs divide 2 == 128fs */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x1 << 4);
-#endif
-	aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
-	audio_hw_958_enable(1);
 #endif
 }
 
@@ -145,7 +139,6 @@ static void aml_spdif_play_stop(void)
 static int aml_dai_spdif_set_sysclk(struct snd_soc_dai *cpu_dai,
 				    int clk_id, unsigned int freq, int dir)
 {
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -155,18 +148,16 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 
 	struct snd_soc_pcm_runtime *rtd = NULL;
 
-	ALSA_TRACE();
-
 	rtd = (struct snd_soc_pcm_runtime *)substream->private_data;
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			ALSA_PRINT("aiu 958 playback enable\n");
+			pr_info("aiu 958 playback enable\n");
 			audio_hw_958_enable(1);
 		} else {
-			ALSA_PRINT("spdif in capture enable\n");
+			pr_info("spdif in capture enable\n");
 			audio_in_spdif_enable(1);
 		}
 		break;
@@ -174,10 +165,10 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			ALSA_PRINT("aiu 958 playback disable\n");
+			pr_info("aiu 958 playback disable\n");
 			audio_hw_958_enable(0);
 		} else {
-			ALSA_PRINT("spdif in capture disable\n");
+			pr_info("spdif in capture disable\n");
 			audio_in_spdif_enable(0);
 		}
 		break;
@@ -188,89 +179,77 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-void aml_hw_iec958_init(struct snd_pcm_substream *substream)
+void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 {
 	struct _aiu_958_raw_setting_t set;
 	struct _aiu_958_channel_status_t chstat;
-	unsigned i2s_mode, iec958_mode;
-	unsigned start, size;
-	int sample_rate;
+	unsigned iec958_mode;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (buf == NULL && runtime == NULL) {
+	if (buf == NULL || runtime == NULL) {
 		pr_info("buf/%p runtime/%p\n", buf, runtime);
 		return;
 	}
 
-	i2s_mode = AIU_I2S_MODE_PCM16;
-	sample_rate = AUDIO_CLK_FREQ_48;
+	iec958_mode = AIU_958_MODE_PCM16;
 	memset((void *)(&set), 0, sizeof(set));
 	memset((void *)(&chstat), 0, sizeof(chstat));
 	set.chan_stat = &chstat;
-	switch (runtime->rate) {
-	case 192000:
-		sample_rate = AUDIO_CLK_FREQ_192;
-		break;
-	case 176400:
-		sample_rate = AUDIO_CLK_FREQ_1764;
-		break;
-	case 96000:
-		sample_rate = AUDIO_CLK_FREQ_96;
-		break;
-	case 88200:
-		sample_rate = AUDIO_CLK_FREQ_882;
-		break;
-	case 48000:
-		sample_rate = AUDIO_CLK_FREQ_48;
-		break;
-	case 44100:
-		sample_rate = AUDIO_CLK_FREQ_441;
-		break;
-	case 32000:
-		sample_rate = AUDIO_CLK_FREQ_32;
-		break;
-	case 8000:
-		sample_rate = AUDIO_CLK_FREQ_8;
-		break;
-	case 11025:
-		sample_rate = AUDIO_CLK_FREQ_11;
-		break;
-	case 16000:
-		sample_rate = AUDIO_CLK_FREQ_16;
-		break;
-	case 22050:
-		sample_rate = AUDIO_CLK_FREQ_22;
-		break;
-	case 12000:
-		sample_rate = AUDIO_CLK_FREQ_12;
-		break;
-	case 24000:
-		sample_rate = AUDIO_CLK_FREQ_22;
-		break;
-	default:
-		sample_rate = AUDIO_CLK_FREQ_441;
-		break;
-	};
+
+	if (!samesrc) {
+		unsigned i2s_mode = AIU_I2S_MODE_PCM16;
+		switch (runtime->format) {
+		case SNDRV_PCM_FORMAT_S32:
+			i2s_mode = AIU_I2S_MODE_PCM32;
+			break;
+		case SNDRV_PCM_FORMAT_S24:
+			i2s_mode = AIU_I2S_MODE_PCM24;
+			break;
+		case SNDRV_PCM_FORMAT_S16:
+			i2s_mode = AIU_I2S_MODE_PCM16;
+			break;
+		}
+		audio_out_i2s_enable(0);
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		audio_set_i2s_mode(i2s_mode, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
+#else
+		audio_set_i2s_mode(i2s_mode);
+#endif
+		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
+	}
+
 	audio_hw_958_enable(0);
-	pr_info("----aml_hw_iec958_init,runtime->rate=%d,sample_rate=%d--\n",
-	       runtime->rate, sample_rate);
-	/* int srate; */
-	/* srate = params_rate(params); */
-	if (old_samplerate != sample_rate) {
-		old_samplerate = sample_rate;
-		aml_set_spdif_clk(runtime->rate * 512, 0);
+	pr_info("aml_hw_iec958_init,runtime->rate=%d, runtime->channels=%d, same source mode(%d)\n",
+	       runtime->rate, runtime->channels, samesrc);
+
+	if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		aml_set_spdif_clk((runtime->rate >> 2) * 512, samesrc); /* EAC3 */
+	} else {
+		aml_set_spdif_clk(runtime->rate * 512, samesrc);
 	}
+
 	/* Todo, div can be changed, for most case, div = 2 */
 	/* audio_set_spdif_clk_div(); */
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
-	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+	if (runtime->rate == 192000 && runtime->channels == 8 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
+		pr_info("set 4x audio clk for 958\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+	} else if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 4; /* EAC3 */
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (0) {
+	} else if (samesrc) {
+		IEC958_mode_codec = 0;
 		pr_info("share the same clock\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+	} else if (runtime->rate == 48000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 2; /* AC3/DTS */
+		pr_info("set normal 512 fs /4 fs\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	} else {
+		IEC958_mode_codec = 0;
 		pr_info("set normal 512 fs /4 fs\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	}
@@ -281,127 +260,62 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 	audio_i2s_958_same_source(0);
 
 	switch (runtime->format) {
-	case SNDRV_PCM_FORMAT_S32_LE:
-		i2s_mode = AIU_I2S_MODE_PCM32;
+	case SNDRV_PCM_FORMAT_S32:
+		iec958_mode = AIU_958_MODE_PCM32;
 		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		i2s_mode = AIU_I2S_MODE_PCM24;
+	case SNDRV_PCM_FORMAT_S24:
+		iec958_mode = AIU_958_MODE_PCM24;
 		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		i2s_mode = AIU_I2S_MODE_PCM16;
+	case SNDRV_PCM_FORMAT_S16:
+		iec958_mode = AIU_958_MODE_PCM16;
 		break;
 	}
+	if (IEC958_mode_codec > 0) {
+		iec958_mode = AIU_958_MODE_PCM_RAW;
+	}
 
-	/* audio_set_i2s_mode(i2s_mode); */
-	/* case 1,raw mode enabled */
-	if (IEC958_mode_codec) {
-		if (IEC958_mode_codec == 1) {
-			/* dts, use raw sync-word mode */
-			iec958_mode = AIU_958_MODE_RAW;
-			pr_info("iec958 mode RAW\n");
-		} else {
-			/* ac3,use the same pcm mode as i2s configuration */
-			iec958_mode = AIU_958_MODE_PCM_RAW;
-			pr_info("iec958 mode %s\n",
-				(i2s_mode == AIU_I2S_MODE_PCM32) ? "PCM32_RAW"
-				: ((I2S_MODE == AIU_I2S_MODE_PCM24) ?
-				"PCM24_RAW"	: "PCM16_RAW"));
-		}
+	/* AES1+0 */
+	if (iec958_mode == AIU_958_MODE_PCM_RAW) {
+		set.chan_stat->chstat0_l = 0x8206;
 	} else {
-		if (i2s_mode == AIU_I2S_MODE_PCM32)
-			iec958_mode = AIU_958_MODE_PCM32;
-		else if (i2s_mode == AIU_I2S_MODE_PCM24)
-			iec958_mode = AIU_958_MODE_PCM24;
-		else
-			iec958_mode = AIU_958_MODE_PCM16;
-		pr_info("iec958 mode %s\n",
-		       (i2s_mode ==
-			AIU_I2S_MODE_PCM32) ? "PCM32" : ((i2s_mode ==
-							  AIU_I2S_MODE_PCM24) ?
-							 "PCM24" : "PCM16"));
+		set.chan_stat->chstat0_l = 0x8204;
 	}
-	if (iec958_mode == AIU_958_MODE_PCM16
-	    || iec958_mode == AIU_958_MODE_PCM24
-	    || iec958_mode == AIU_958_MODE_PCM32) {
-		set.chan_stat->chstat0_l = 0x0100;
-		set.chan_stat->chstat0_r = 0x0100;
-		set.chan_stat->chstat1_l = 0x200;
-		set.chan_stat->chstat1_r = 0x200;
-		if (sample_rate == AUDIO_CLK_FREQ_882) {
-			pr_info("----sample_rate==AUDIO_CLK_FREQ_882---\n");
-			set.chan_stat->chstat1_l = 0x800;
-			set.chan_stat->chstat1_r = 0x800;
-		}
-
-		if (sample_rate == AUDIO_CLK_FREQ_96) {
-			pr_info("----sample_rate==AUDIO_CLK_FREQ_96---\n");
-			set.chan_stat->chstat1_l = 0xa00;
-			set.chan_stat->chstat1_r = 0xa00;
-		}
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size, 0);
-		/* audio_set_i2s_mode(AIU_I2S_MODE_PCM16); */
-		/* audio_set_aiubuf(start, size); */
+	set.chan_stat->chstat0_r = set.chan_stat->chstat0_l;
+
+	/* AES3+2 */
+	if (IEC958_mode_codec == 8) {
+		set.chan_stat->chstat1_l = 0x0900;
+	} else if (runtime->rate == 192000) {
+		set.chan_stat->chstat1_l = 0x0e00;
+	} else if (runtime->rate == 176400) {
+		set.chan_stat->chstat1_l = 0x0c00;
+	} else if (runtime->rate == 96000) {
+		set.chan_stat->chstat1_l = 0x0a00;
+	} else if (runtime->rate == 88200) {
+		set.chan_stat->chstat1_l = 0x0800;
+	} else if (runtime->rate == 48000) {
+		set.chan_stat->chstat1_l = 0x0200;
+	} else if (runtime->rate == 44100) {
+		set.chan_stat->chstat1_l = 0x0000;
+	} else if (runtime->rate == 32000) {
+		set.chan_stat->chstat1_l = 0x0300;
 	} else {
-
-		set.chan_stat->chstat0_l = 0x1902;
-		set.chan_stat->chstat0_r = 0x1902;
-		if (IEC958_mode_codec == 4 || IEC958_mode_codec == 5) {
-			/* DD+ */
-			if (runtime->rate == 32000) {
-				set.chan_stat->chstat1_l = 0x300;
-				set.chan_stat->chstat1_r = 0x300;
-			} else if (runtime->rate == 44100) {
-				set.chan_stat->chstat1_l = 0xc00;
-				set.chan_stat->chstat1_r = 0xc00;
-			} else {
-				set.chan_stat->chstat1_l = 0Xe00;
-				set.chan_stat->chstat1_r = 0Xe00;
-			}
-		} else {
-			/* DTS,DD */
-			if (runtime->rate == 32000) {
-				set.chan_stat->chstat1_l = 0x300;
-				set.chan_stat->chstat1_r = 0x300;
-			} else if (runtime->rate == 44100) {
-				set.chan_stat->chstat1_l = 0;
-				set.chan_stat->chstat1_r = 0;
-			} else {
-				set.chan_stat->chstat1_l = 0x200;
-				set.chan_stat->chstat1_r = 0x200;
-			}
-		}
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size,
-				    (iec958_mode == AIU_958_MODE_RAW) ? 1 : 0);
-		memset((void *)buf->area, 0, size);
+		set.chan_stat->chstat1_l = 0x0100;
 	}
-	ALSA_DEBUG("aiu 958 pcm buffer size %d\n", size);
+	set.chan_stat->chstat1_r = set.chan_stat->chstat1_l;
+
+	audio_set_958outbuf(buf->addr, snd_pcm_lib_buffer_bytes(substream), 0);
 	audio_set_958_mode(iec958_mode, &set);
 
-	if (IEC958_mode_codec == 2) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_AC_3, substream);
-	} else if (IEC958_mode_codec == 3) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS, substream);
-	} else if (IEC958_mode_codec == 4) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS,
-					 substream);
-	} else if (IEC958_mode_codec == 5) {
+	/* notify hdmi to set audio type */
+	if (IEC958_mode_codec == 8) {
+		/* TrueHD/DTS-HD MA */
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA, substream);
+	} else if (iec958_mode == AIU_958_MODE_PCM_RAW) {
+		/* AC3/DTS/EAC3 */
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD, substream);
-	} else if (IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
-		aml_write_cbus(AIU_958_CHSTAT_L0, 0x1902);
-		aml_write_cbus(AIU_958_CHSTAT_L1, 0x900);
-		aml_write_cbus(AIU_958_CHSTAT_R0, 0x1902);
-		aml_write_cbus(AIU_958_CHSTAT_R1, 0x900);
-		if (IEC958_mode_codec == 8)
-			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA,
-			substream);
-		else
-			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP,
-			substream);
 	} else {
+		/* PCM */
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 }
@@ -418,7 +332,6 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 
 void aml_alsa_hw_reprepare(void)
 {
-	ALSA_TRACE();
 	/* M8 disable it */
 #if 0
 	/* diable 958 module before call initiation */
@@ -438,7 +351,6 @@ static int aml_dai_spdif_startup(struct snd_pcm_substream *substream,
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s;
 
-	ALSA_TRACE();
 	if (!prtd) {
 		prtd =
 		    (struct aml_runtime_data *)
@@ -471,17 +383,14 @@ static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
 
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	/* struct snd_dma_buffer *buf = &substream->dma_buffer; */
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		memset((void *)runtime->dma_area, 0,
 		       snd_pcm_lib_buffer_bytes(substream));
-		if (IEC958_mode_codec == 6) {
-			pr_info
-			    ("[%s %d]8chPCM output:disable aml_spdif_play()\n",
-			     __func__, __LINE__);
-		} else {
-			aml_spdif_play();
-		}
+		if (IEC958_mode_codec == 6)
+			pr_info("8chPCM output:disable aml_spdif_play\n");
+		else
+			;/*aml_spdif_play();*/
+
 		/* audio_spdifout_pg_enable(0); */
 	}
 
@@ -496,9 +405,8 @@ static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 	/* struct aml_runtime_data *prtd = runtime->private_data; */
 	/* audio_stream_t *s = &prtd->s; */
 
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		aml_hw_iec958_init(substream);
+		aml_hw_iec958_init(substream, 0);
 	} else {
 		audio_in_spdif_set_buf(runtime->dma_addr,
 				       runtime->dma_bytes * 2);
@@ -519,7 +427,7 @@ static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 int aml_set_spdif_clk(unsigned long rate, bool src_i2s)
 {
 	int ret = 0;
-	pr_info("aml_set_spdif_clk rate\n");
+
 	if (src_i2s) {
 		ret = clk_set_parent(spdif_p->clk_spdif, spdif_p->clk_mclk);
 		if (ret) {
@@ -563,7 +471,6 @@ static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
 	srate = params_rate(params);
 	aml_set_spdif_clk(srate * 512, 0);
 #endif
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -641,7 +548,6 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 	struct reset_control *spdif_reset;
 	struct aml_spdif *spdif_priv;
 
-	pr_info("aml_spdif_probe\n");
 	/* enable spdif power gate first */
 	for (i = 0; i < ARRAY_SIZE(gate_names); i++) {
 		spdif_reset = devm_reset_control_get(&pdev->dev, gate_names[i]);
@@ -708,7 +614,15 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	aml_spdif_play();
+	spdif_priv->clk_81 = devm_clk_get(&pdev->dev, "clk_81");
+	if (IS_ERR(spdif_priv->clk_81)) {
+		dev_err(&pdev->dev, "Can't get clk81\n");
+		ret = PTR_ERR(spdif_priv->clk_81);
+		goto err;
+	}
+	clk81 = clk_get_rate(spdif_priv->clk_81);
+
+	aml_spdif_play(0);
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_spdif_dai,
 					  ARRAY_SIZE(aml_spdif_dai));
@@ -733,6 +647,16 @@ static int aml_dai_spdif_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void aml_spdif_dai_shutdown(struct platform_device *pdev)
+{
+	struct aml_spdif *spdif_priv = dev_get_drvdata(&pdev->dev);
+
+	if (spdif_priv && spdif_priv->clk_spdif)
+		clk_disable_unprepare(spdif_priv->clk_spdif);
+
+	return;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_spdif_dai_dt_match[] = {
 	{.compatible = "amlogic, aml-spdif-dai",
@@ -746,6 +670,7 @@ static const struct of_device_id amlogic_spdif_dai_dt_match[] = {
 static struct platform_driver aml_spdif_dai_driver = {
 	.probe = aml_dai_spdif_probe,
 	.remove = aml_dai_spdif_remove,
+	.shutdown = aml_spdif_dai_shutdown,
 	.driver = {
 		   .name = "aml-spdif-dai",
 		   .owner = THIS_MODULE,
@@ -755,7 +680,6 @@ static struct platform_driver aml_spdif_dai_driver = {
 
 static int __init aml_dai_spdif_init(void)
 {
-	ALSA_PRINT("enter aml_dai_spdif_init\n");
 	return platform_driver_register(&aml_spdif_dai_driver);
 }
 
diff --git a/sound/soc/aml/m8/aml_spdif_dai.h b/sound/soc/aml/m8/aml_spdif_dai.h
index fd11637..a098171 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.h
+++ b/sound/soc/aml/m8/aml_spdif_dai.h
@@ -45,7 +45,7 @@ extern unsigned int IEC958_mode_codec;
 * 3)PCM  output for audios except ac3/dts,
 * when raw output mode is selected by user
 */
-void aml_hw_iec958_init(struct snd_pcm_substream *substream);
+void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc);
 int aml_set_spdif_clk(unsigned long rate, bool src_i2s);
-void aml_spdif_play(void);
+void aml_spdif_play(int samesrc);
 #endif  /* _AML_SPDIF_DAI_H */
-- 
1.9.1

