From c02659a0cc22be5fb9ba5637263f06ea219b84a0 Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Mon, 10 Oct 2016 15:25:58 +0800
Subject: [PATCH] sound mods kernel-069e204

---
 sound/soc/aml/m8/aml_audio_hw.c  | 346 +++++++++++++++++++++++--------
 sound/soc/aml/m8/aml_i2s.h       |  25 ++-
 sound/soc/aml/m8/aml_i2s_dai.c   | 345 ++++++++++++++++++++++++------
 sound/soc/aml/m8/aml_m8.c        | 170 ++++++++++-----
 sound/soc/aml/m8/aml_spdif_dai.c | 438 ++++++++++++++++-----------------------
 5 files changed, 870 insertions(+), 454 deletions(-)

diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 33268a2..70e3f70 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_audio_hw: " fmt
 
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -26,11 +27,20 @@
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
+#include <linux/amlogic/cpu_version.h>
 #include "aml_audio_hw.h"
 
+/* i2s mode 0: master 1: slave */
+/* source: 0: linein; 1: ATV; 2: HDMI-in */
 unsigned ENABLE_IEC958 = 1;
 unsigned IEC958_MODE = AIU_958_MODE_PCM16;
 unsigned I2S_MODE = AIU_I2S_MODE_PCM16;
+unsigned audio_in_source = 0;
+void set_i2s_source(unsigned source)
+{
+	audio_in_source = source;
+	return;
+}
 
 int audio_in_buf_ready = 0;
 int audio_out_buf_ready = 0;
@@ -137,21 +147,37 @@ int audio_clock_config_table[][13][2] = {
 
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffff00);
+	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffff00);
+#else
 	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
 	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+#endif
+
 	if (channel == 8) {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
+#endif
 	} else {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+#endif
 	}
 	/* Hold I2S */
 	aml_write_cbus(AIU_I2S_MISC, 0x0004);
 	/* No mute, no swap */
-	aml_write_cbus(AIU_I2S_MUTE_SWAP, 0x0000);
+	/*aml_write_cbus(AIU_I2S_MUTE_SWAP, 0x0000);*/
 	/* Release hold and force audio data to left or right */
 	aml_write_cbus(AIU_I2S_MISC, 0x0010);
 
@@ -159,29 +185,27 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 		pr_info("%s channel == 8\n", __func__);
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-		/*
-		*  [15: 8] chan_mem_mask.
+		/*  [15: 8] chan_mem_mask.
 		*  Each bit indicates which channels exist in memory
 		*/
-					(0xff << 8) |
-		/*
-		*  [ 7: 0] chan_rd_mask.
+			       (0xff << 8) |
+		/*  [ 7: 0] chan_rd_mask.
 		*  Each bit indicates which channels are READ from memory
 		*/
-					(0xff << 0));
-	} else
+			       (0xff << 0));
+	} else {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-		/* [15: 8] chan_mem_mask.
-		* Each bit indicates which channels exist in memory
-		*/
-					(0x3 << 8) |
-		/*
-		*  [ 7: 0] chan_rd_mask.
-		*  Each bit indicates which channels are READ from memory
-		*/
-					(0x3 << 0));
-
+			(0xff << 8) |
+			(0xff << 0));
+#else
+		/* [31:16] IRQ block. */
+		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
+			       (0x3 << 8) |
+			       (0x3 << 0));
+#endif
+	}
 	/* 16 bit PCM mode */
 	/* aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 6, 1); */
 	/* Set init high then low to initilize the I2S memory logic */
@@ -207,15 +231,32 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 				       addr & 0xffffffc0);
 		if (flag == 0) {
 			/* this is for 16bit 2 channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
+#else
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 64);
+#endif
 		} else {
 			/* this is for RAW mode */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 1);
+						(addr & 0xffffffc0) +
+						(size & 0xffffffc0) - 8);
+#else
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 1);
+#endif
 		}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0xffff);
+#else
 		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0x303);
-
+#endif
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 1);
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 0);
 
@@ -227,8 +268,7 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 /*
 i2s mode 0: master 1: slave
 */
-static void i2sin_fifo0_set_buf(u32 addr, u32 size,
-				u32 i2s_mode, u32 i2s_sync)
+static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
 {
 	unsigned char mode = 0;
 	unsigned int sync_mode = 0;
@@ -248,7 +288,7 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,
 		       /* DIN from i2sin */
 		       /* |(1<<6)    // 32 bits data in. */
 		       /* |(0<<7)    // put the 24bits data to  low 24 bits */
-		       |(4 << AUDIN_FIFO0_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
+		       | (4 << AUDIN_FIFO0_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
 		       |(2 << AUDIN_FIFO0_CHAN)	/* two channel */
 		       |(0 << 16)	/* to DDR */
 		       |(1 << AUDIN_FIFO0_UG)	/* Urgent request. */
@@ -256,34 +296,64 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,
 		       |(0 << 18)
 		       /* Audio in INT */
 		       /* |(1<<19)    // hold 0 enable */
-		       |(0 << AUDIN_FIFO0_UG)	/* hold0 to aififo */
+		       | (0 << AUDIN_FIFO0_UG)	/* hold0 to aififo */
 	    );
 
 	aml_write_cbus(AUDIN_FIFO0_CTRL1, 0 << 4	/* fifo0_dest_sel */
 		       | 2 << 2	/* fifo0_din_byte_num */
 		       | 0 << 0);	/* fifo0_din_pos */
 
-	aml_write_cbus(AUDIN_I2SIN_CTRL, (3 << I2SIN_SIZE)
-		       | (1 << I2SIN_CHAN_EN)	/* 2 channel */
-		       |(sync_mode << I2SIN_POS_SYNC)
-		       | (1 << I2SIN_LRCLK_SKEW)
-		       | (1 << I2SIN_LRCLK_INVT)
-		       | (!mode << I2SIN_CLK_SEL)
-		       | (!mode << I2SIN_LRCLK_SEL)
-		       | (!mode << I2SIN_DIR)
-	    );
+	if (audio_in_source == 0) {
+		if (is_meson_txl_cpu()) {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (0 << I2SIN_POS_SYNC)
+					| (0 << I2SIN_LRCLK_SEL)
+					| (0 << I2SIN_CLK_SEL)
+					| (0 << I2SIN_DIR));
+		} else {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (sync_mode << I2SIN_POS_SYNC)
+					| (!mode << I2SIN_LRCLK_SEL)
+					| (!mode << I2SIN_CLK_SEL)
+					| (!mode << I2SIN_DIR));
+		}
+	} else if (audio_in_source == 1) {
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+			       | (0 << I2SIN_SIZE)
+			       | (0 << I2SIN_LRCLK_INVT)
+			       | (0 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (0 << I2SIN_LRCLK_SEL)
+			       | (0 << I2SIN_CLK_SEL)
+			       | (0 << I2SIN_DIR));
+	} else if (audio_in_source == 2) {
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+			       | (3 << I2SIN_SIZE)
+			       | (1 << I2SIN_LRCLK_INVT)
+			       | (1 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (1 << I2SIN_LRCLK_SEL)
+			       | (1 << I2SIN_CLK_SEL)
+			       | (1 << I2SIN_DIR));
+	}
 
 }
 
 static void spdifin_reg_set(void)
 {
 	/* get clk81 clk_rate */
-	struct clk *clk_src = clk_get_sys("clk81", NULL);
-	u32 clk_rate = clk_get_rate(clk_src);
+	unsigned int clk_rate = clk81;
 	u32 spdif_clk_time = 54;	/* 54us */
-	u32 spdif_mode_14bit = ((clk_rate / 500000 + 1) >> 1) * spdif_clk_time;
+	u32 spdif_mode_14bit = (u32)((clk_rate / 500000 + 1) >> 1)
+					* spdif_clk_time;
 	/* sysclk/32(bit)/2(ch)/2(bmc) */
-	u32 period_data = (clk_rate / 64000 + 1) >> 1;
+	u32 period_data = (u32)(clk_rate / 64000 + 1) >> 1;
 	u32 period_32k = (period_data + (1 << 4)) >> 5;	/* 32k min period */
 	u32 period_44k = (period_data / 22 + 1) >> 1;	/* 44k min period */
 	u32 period_48k = (period_data / 24 + 1) >> 1;	/* 48k min period */
@@ -297,9 +367,8 @@ static void spdifin_reg_set(void)
 		       (spdif_mode_14bit << 0));
 	aml_write_cbus(AUDIN_SPDIF_FS_CLK_RLTN,
 		       (period_32k << 0) |
-		       (period_44k << 6) |
-		       (period_48k << 12) |
-				/* Spdif_fs_clk_rltn */
+		       (period_44k << 6) | (period_48k << 12) |
+		       /* Spdif_fs_clk_rltn */
 		       (period_96k << 18) | (period_192k << 24));
 
 }
@@ -319,7 +388,7 @@ static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 		       /* DIN from i2sin. */
 		       /* |(1<<6)   // 32 bits data in. */
 		       /* |(0<<7)   // put the 24bits data to  low 24 bits */
-		       |(4 << AUDIN_FIFO1_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
+		       | (4 << AUDIN_FIFO1_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
 		       |(2 << AUDIN_FIFO1_CHAN)	/* 2 channel */
 		       |(0 << 16)	/* to DDR */
 		       |(1 << AUDIN_FIFO1_UG)	/* Urgent request. */
@@ -327,16 +396,16 @@ static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 		       |(0 << 18)
 		       /* Audio in INT */
 		       /* |(1<<19)   //hold 0 enable */
-		       |(0 << AUDIN_FIFO1_UG)	/* hold0 to aififo */
+		       | (0 << AUDIN_FIFO1_UG)	/* hold0 to aififo */
 	    );
 
 	/*
-	*  according clk81 to set reg spdif_mode(0x2800)
-	*  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
-	*/
+	 *  according clk81 to set reg spdif_mode(0x2800)
+	 *  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
+	 */
 	spdifin_reg_set();
-
-	aml_write_cbus(AUDIN_FIFO1_CTRL1, 0xc);
+	/*3 byte mode, (27:4)*/
+	aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
 }
 
 void audio_in_i2s_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
@@ -367,7 +436,7 @@ void audio_in_i2s_enable(int flag)
 		rd = aml_read_cbus(AUDIN_FIFO0_PTR);
 		start = aml_read_cbus(AUDIN_FIFO0_START);
 		if (rd != start) {
-			pr_err("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n",
+			pr_err("error %08x, %08x !\n",
 			       rd, start);
 			goto reset_again;
 		}
@@ -391,8 +460,7 @@ void audio_in_spdif_enable(int flag)
 		rd = aml_read_cbus(AUDIN_FIFO1_PTR);
 		start = aml_read_cbus(AUDIN_FIFO1_START);
 		if (rd != start) {
-			pr_err("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n",
-			       rd, start);
+			pr_err("error %08x, %08x !\n", rd, start);
 			goto reset_again;
 		}
 		aml_write_cbus(AUDIN_SPDIF_MODE,
@@ -456,6 +524,77 @@ void audio_in_spdif_set_wrptr(unsigned int val)
 	aml_write_cbus(AUDIN_FIFO1_RDPTR, val);
 }
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+void audio_set_i2s_mode(u32 mode, unsigned int channel)
+{
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x800);
+
+	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0);
+
+	if (8 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 1);
+
+		if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			/* todo: to verify it */
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+
+		} else if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+
+			aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0x5);
+		}
+	} else if (2 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 0);
+
+		if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		}
+	}
+
+	/* In split mode, there are not mask control,
+	so aiu_mem_i2s_mask[15:0] must set 8'hffff_ffff. */
+	/*aml_write_cbus(AIU_MEM_I2S_MASKS,
+		(16 << 16) |
+		(0xff << 8) |
+		(0xff << 0));*/
+}
+#else
 void audio_set_i2s_mode(u32 mode)
 {
 	const unsigned short mask[4] = {
@@ -486,6 +625,7 @@ void audio_set_i2s_mode(u32 mode)
 		aml_cbus_update_bits(AIU_MEM_I2S_MASKS, 0xffff, mask[mode]);
 	}
 }
+#endif
 
 /*
  *  if normal clock, i2s clock is twice of 958 clock,
@@ -500,22 +640,24 @@ void audio_util_set_dac_format(unsigned format)
 	/* 958 divisor more, if true, divided by 2, 4, 6, 8. */
 	aml_write_cbus(AIU_CLK_CTRL, (0 << 12) |
 	/* alrclk skew: 1=alrclk transitions on the cycle before msb is sent */
-			(1 << 8) |
-			(1 << 6) |	/* invert aoclk */
-			(1 << 7) |	/* invert lrclk */
+		       (1 << 8) |
+		       (1 << 6) |
+	/* invert aoclk */
+		       (1 << 7) |
+	/* invert lrclk */
 #if OVERCLOCK == 1
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	       (1 << 4) |
+		       (1 << 4) |
 	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
-	       (3 << 2) |
+		       (3 << 2) |
 #else
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-			(1 << 4) |
+		       (1 << 4) |
 	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
-			(2 << 2) |
+		       (2 << 2) |
 #endif
-			(1 << 1) |	/* enable 958 clock */
-			(1 << 0));	/* enable I2S clock */
+		       (1 << 1) |	/* enable 958 clock */
+		       (1 << 0));	/* enable I2S clock */
 	if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP)
 		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 8, 1 << 8);
 	else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY)
@@ -569,11 +711,15 @@ void audio_util_set_dac_i2s_format(unsigned format)
 	if (dac_mute_const == 0x800000)
 		aml_write_cbus(AIU_I2S_DAC_CFG, 0x000f);
 	else
-	/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
+		/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
 		aml_write_cbus(AIU_I2S_DAC_CFG, 0x0007);
 
 	/* four 2-channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, (1 << 11));
+#else
 	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x0001);
+#endif
 }
 
 /* set sclk and lrclk, mclk = 256fs. */
@@ -584,7 +730,7 @@ void audio_set_i2s_clk_div(void)
 	/* Set mclk over sclk ratio */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x3f << 8, (4 - 1) << 8);
 	/* set dac/adc lrclk ratio over sclk----64fs */
-        aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
+	aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
 	aml_cbus_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (64 - 1));
 	/* Enable sclk */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 14, 1 << 14);
@@ -618,13 +764,13 @@ void audio_enable_ouput(int flag)
 
 int if_audio_out_enable(void)
 {
-	return aml_read_cbus(AIU_MEM_I2S_CONTROL) & (0x3<<1);
+	return aml_read_cbus(AIU_MEM_I2S_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_audio_out_enable);
 
 int if_958_audio_out_enable(void)
 {
-	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (0x3<<1);
+	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_958_audio_out_enable);
 
@@ -723,7 +869,7 @@ void audio_hw_958_raw(void)
 	pr_info("\tLENGTH: %x\n", IEC958_length);
 	pr_info("\tPADDSIZE: %x\n", IEC958_length);
 	pr_info("\tsyncword: %x, %x, %x\n\n", IEC958_syncword1,
-				IEC958_syncword2, IEC958_syncword3);
+		IEC958_syncword2, IEC958_syncword3);
 
 }
 
@@ -759,44 +905,53 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 			aml_write_cbus(AIU_958_MISC, 1);
 			/* raw */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 1 << 8);
+					     1 << 8, 1 << 8);
 			/* 8bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0x1 << 3);
+					     0x7 << 3, 0x1 << 3);
 		}
 
 		pr_info("IEC958 RAW\n");
 	} else if (mode == AIU_958_MODE_PCM32) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 		}
 		pr_info("IEC958 PCM32\n");
 	} else if (mode == AIU_958_MODE_PCM24) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 
 		}
 		pr_info("IEC958 24bit\n");
@@ -805,20 +960,29 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 		if (ENABLE_IEC958) {
 			aml_write_cbus(AIU_958_MISC, 0x2042);
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 1 << 7);
+					     1 << 7, 1 << 7);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 		}
 		pr_info("IEC958 16bit\n");
 	}
 
 	audio_hw_958_reset(0, 1);
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	if (mode == AIU_958_MODE_PCM32)
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 1 << 8, 1 << 8);
+#endif
+
 	aml_write_cbus(AIU_958_FORCE_LEFT, 1);
 }
 
@@ -827,11 +991,12 @@ void audio_out_i2s_enable(unsigned flag)
 	if (flag) {
 		aml_write_cbus(AIU_RST_SOFT, 0x01);
 		aml_read_cbus(AIU_I2S_SYNC);
-		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL,
-				0x3 << 1, 0x3 << 1);
+		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0x3 << 1);
 		/* Maybe cause POP noise */
 		/* audio_i2s_unmute(); */
 	} else {
+		aml_write_cbus(AIU_RST_SOFT, 0x01);
+		aml_read_cbus(AIU_I2S_SYNC);
 		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0);
 
 		/* Maybe cause POP noise */
@@ -850,6 +1015,8 @@ void audio_hw_958_enable(unsigned flag)
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0x3 << 1);
 		} else {
+			aml_write_cbus(AIU_RST_SOFT, 0x04);
+			aml_write_cbus(AIU_958_FORCE_LEFT, 0);
 			aml_write_cbus(AIU_958_DCU_FF_CTRL, 0);
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0);
@@ -870,12 +1037,19 @@ void audio_i2s_swap_left_right(unsigned int flag)
 		aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 1, flag << 1);
 
 	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3, flag);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3 << 2, flag << 2);
 }
 
 void audio_i2s_958_same_source(unsigned int same)
 {
 	aml_cbus_update_bits(AIU_I2S_MISC, 1 << 3, (!!same) << 3);
 }
+
+void set_hw_resample_source(int source)
+{
+	aml_cbus_update_bits(AUD_RESAMPLE_CTRL0, 1 << 29, source << 29);
+}
+EXPORT_SYMBOL(set_hw_resample_source);
 #if 0
 unsigned int audio_hdmi_init_ready(void)
 {
diff --git a/sound/soc/aml/m8/aml_i2s.h b/sound/soc/aml/m8/aml_i2s.h
index 98128e0..7614a8d 100644
--- a/sound/soc/aml/m8/aml_i2s.h
+++ b/sound/soc/aml/m8/aml_i2s.h
@@ -18,6 +18,8 @@
 #ifndef __AML_I2S_H__
 #define __AML_I2S_H__
 
+#include <linux/mutex.h>
+
 /* #define debug_printk */
 #ifdef debug_printk
 #define dug_printk(fmt, args...)  printk(fmt, ## args)
@@ -25,9 +27,18 @@
 #define dug_printk(fmt, args...)
 #endif
 
+#define BASE_IRQ                (32)
+#define AM_IRQ(reg)             (reg + BASE_IRQ)
+#define INT_TIMER_D             AM_IRQ(29)
+/* note: we use TIEMRD. MODE: 1: periodic, 0: one-shot*/
+#define TIMERD_MODE             1
+/* timerbase resolution: 00: 1us; 01: 10us; 10: 100us; 11: 1ms*/
+#define TIMERD_RESOLUTION       0x1
+/* timer count: 16bits*/
+#define TIMER_COUNT             100
+
 struct audio_stream {
 	int stream_id;
-	int active;
 	unsigned int last_ptr;
 	unsigned int size;
 	unsigned int sample_rate;
@@ -36,11 +47,12 @@ struct audio_stream {
 	struct snd_pcm_substream *stream;
 	unsigned i2s_mode; /* 0:master, 1:slave, */
 	unsigned device_type;
-	unsigned int xrun_num;
 };
 struct aml_audio_buffer {
 	void *buffer_start;
 	unsigned int buffer_size;
+	char cache_buffer_bytes[256];
+	int cached_len;
 };
 
 struct aml_i2s_dma_params {
@@ -67,11 +79,12 @@ struct aml_runtime_data {
 	struct snd_pcm_substream *substream;
 	struct audio_stream s;
 	struct timer_list timer;	/* timeer for playback and capture */
-	struct hrtimer hrtimer;
+	spinlock_t timer_lock;
 	void *buf; /* tmp buffer for playback or capture */
+	int active;
+	unsigned int xrun_num;
+	struct mutex chmap_lock;
+	int chmap_layout;
 };
 
-extern struct snd_soc_platform_driver aml_soc_platform;
-/* extern struct aml_audio_interface aml_i2s_interface; */
-
 #endif
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index 5dfbaf1..63770a6 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -38,6 +38,7 @@
 #include <sound/control.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
+#include <sound/tlv.h>
 #include "aml_i2s_dai.h"
 #include "aml_pcm.h"
 #include "aml_i2s.h"
@@ -48,31 +49,54 @@
 struct aml_dai_info dai_info[3] = { {0} };
 
 static int i2s_pos_sync;
-/* #define AML_DAI_DEBUG */
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-i2s-dai]" fmt, ##args)
-#ifdef AML_DAI_DEBUG
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-i2s-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-i2s-dai] enter func %s\n", __func__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
-/* extern int amaudio2_enable; */
-/* extern int kernel_android_50; */
+
+struct channel_speaker_allocation {
+        int channels;
+        int speakers[8];
+};
+
+#define NA	SNDRV_CHMAP_NA
+#define FL	SNDRV_CHMAP_FL
+#define FR	SNDRV_CHMAP_FR
+#define RL	SNDRV_CHMAP_RL
+#define RR	SNDRV_CHMAP_RR
+#define LFE	SNDRV_CHMAP_LFE
+#define FC	SNDRV_CHMAP_FC
+#define RLC	SNDRV_CHMAP_RLC
+#define RRC	SNDRV_CHMAP_RRC
+#define RC	SNDRV_CHMAP_RC
+#define FLC	SNDRV_CHMAP_FLC
+#define FRC	SNDRV_CHMAP_FRC
+#define FLH	SNDRV_CHMAP_TFL
+#define FRH	SNDRV_CHMAP_TFR
+#define FLW	SNDRV_CHMAP_FLW
+#define FRW	SNDRV_CHMAP_FRW
+#define TC	SNDRV_CHMAP_TC
+#define FCH	SNDRV_CHMAP_TFC
+
+static struct channel_speaker_allocation channel_allocations[] = {
+/*      	       channel:   7     6    5    4    3     2    1    0  */
+{ .channels = 2,  .speakers = {  NA,   NA,  NA,  NA,  NA,   NA,  FR,  FL } },
+                                 /* 2.1 */
+{ .channels = 3,  .speakers = {  NA,   NA,  NA,  NA,  NA,  LFE,  FR,  FL } },
+                                 /* surround40 */
+{ .channels = 4,  .speakers = {  NA,   NA,  RR,  RL,  NA,   NA,  FR,  FL } },
+                                 /* surround41 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  NA,  LFE,  FR,  FL } },
+                                 /* surround50 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  FC,   NA,  FR,  FL } },
+                                 /* surround51 */
+{ .channels = 6,  .speakers = {  NA,   NA,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* 6.1 */
+{ .channels = 7,  .speakers = {  NA,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* surround71 */
+{ .channels = 8,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+};
+
 
 /* extern int set_i2s_iec958_samesource(int enable); */
 #define DEFAULT_SAMPLERATE 48000
 #define DEFAULT_MCLK_RATIO_SR 256
-static int i2sbuf[32 + 16];
-static void aml_i2s_play(void)
-{
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-	audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
-	memset(i2sbuf, 0, sizeof(i2sbuf));
-	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
-	audio_out_i2s_enable(1);
-
-}
 
 /*
 the I2S hw  and IEC958 PCM output initation,958 initation here,
@@ -92,29 +116,207 @@ static void aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 		i2s_mode = AIU_I2S_MODE_PCM16;
 		break;
 	}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(i2s_mode, runtime->channels);
+#else
 	audio_set_i2s_mode(i2s_mode);
+#endif
 	audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,
 			 runtime->channels);
-	ALSA_PRINT("i2s dma %p,phy addr %ld,mode %d,ch %d\n",
-		   runtime->dma_area, (long)runtime->dma_addr,
-		   i2s_mode, runtime->channels);
+}
+
+static int aml_dai_i2s_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+                                     unsigned int size, unsigned int __user *tlv)
+{
+    unsigned int __user *dst;
+    int count = 0;
+    int i;
+
+    if (size < 8)
+        return -ENOMEM;
+
+    if (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))
+        return -EFAULT;
+
+    size -= 8;
+    dst = tlv + 2;
+
+    for (i = 0; i < ARRAY_SIZE(channel_allocations); i++)
+    {
+        struct channel_speaker_allocation *ch = &channel_allocations[i];
+        int num_chs = 0;
+        int chs_bytes;
+        int c;
+
+        for (c = 0; c < 8; c++)
+        {
+            if (ch->speakers[c])
+                num_chs++;
+        }
+
+        chs_bytes = num_chs * 4;
+        if (size < 8)
+            return -ENOMEM;
+
+        if (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||
+            put_user(chs_bytes, dst + 1))
+            return -EFAULT;
+
+        dst += 2;
+        size -= 8;
+        count += 8;
+
+        if (size < chs_bytes)
+            return -ENOMEM;
+
+        size -= chs_bytes;
+        count += chs_bytes;
+
+        for (c = 0; c < 8; c++)
+        {
+            int sp = ch->speakers[7 - c];
+            if (sp)
+            {
+                if (put_user(sp, dst))
+                    return -EFAULT;
+                dst++;
+            }
+        }
+    }
+
+    if (put_user(count, tlv + 1))
+        return -EFAULT;
+
+    return 0;
+}
+
+static int aml_dai_i2s_chmap_ctl_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    for (channel=0; channel<8; channel++)
+    {
+        ucontrol->value.integer.value[7 - channel] = channel_allocations[prtd->chmap_layout].speakers[channel];
+    }
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static int aml_dai_i2s_chmap_ctl_put(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel, layout, matches, matched_layout;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    // now check if the channel setup matches one of our layouts
+    for (layout = 0; layout < ARRAY_SIZE(channel_allocations); layout++)
+    {
+        matches = 1;
+
+        for (channel = 0; channel < substream->runtime->channels; channel++)
+        {
+            int sp = ucontrol->value.integer.value[channel];
+            int chan = channel_allocations[layout].speakers[7 - channel];
+
+            if (sp != chan)
+            {
+                matches = 0;
+                break;
+            }
+        }
+
+        if (matches)
+        {
+            matched_layout = layout;
+            break;
+        }
+    }
+
+
+    // default to first layout if we didnt find any
+    if (!matches)
+        matched_layout = 0;
+
+    pr_info("Setting a %d channel layout matching layout #%d\n", runtime->channels, matched_layout);
+
+    prtd->chmap_layout = matched_layout;
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static struct snd_kcontrol *aml_dai_i2s_chmap_kctrl_get(struct snd_pcm_substream *substream)
+{
+    int str;
+
+    if ((substream) && (substream->pcm))
+    {
+        for (str=0; str<2; str++)
+        {
+            if (substream->pcm->streams[str].chmap_kctl)
+            {
+                return substream->pcm->streams[str].chmap_kctl;
+            }
+        }
+    }
+
+    return 0;
 }
 
 static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-	int ret = 0;
+        int ret = 0, i;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd =
 	    (struct aml_runtime_data *)runtime->private_data;
 	struct audio_stream *s;
-	ALSA_TRACE();
+	struct snd_pcm_chmap *chmap;
+	struct snd_kcontrol *kctl;
+
 	if (prtd == NULL) {
 		prtd =
 		    (struct aml_runtime_data *)
 		    kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
-			pr_info("alloc aml_runtime_data error\n");
+			dev_err(substream->pcm->card->dev, "alloc aml_runtime_data error\n");
 			ret = -ENOMEM;
 			goto out;
 		}
@@ -128,6 +330,29 @@ static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 	} else {
 		s->device_type = AML_AUDIO_I2SIN;
 	}
+
+
+	// Alsa Channel Mapping API handling
+	if (!aml_dai_i2s_chmap_kctrl_get(substream))
+	{
+	    ret = snd_pcm_add_chmap_ctls(substream->pcm, SNDRV_PCM_STREAM_PLAYBACK, NULL, 8, 0, &chmap);
+
+	    if (ret < 0)
+	    {
+	      pr_err("aml_dai_i2s_startup error %d\n", ret);
+	      goto out;
+	    }
+
+	    kctl = chmap->kctl;
+	    for (i = 0; i < kctl->count; i++)
+	      kctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_WRITE;
+
+	    kctl->get = aml_dai_i2s_chmap_ctl_get;
+	    kctl->put = aml_dai_i2s_chmap_ctl_put;
+	    kctl->tlv.c = aml_dai_i2s_chmap_ctl_tlv;
+	}
+
+	mutex_init(&prtd->chmap_lock);
 	return 0;
  out:
 	return ret;
@@ -137,7 +362,7 @@ static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
 	if (IEC958_mode_codec == 0)
-		aml_spdif_play();
+		aml_spdif_play(1);
 	return;
 }
 
@@ -147,22 +372,16 @@ static int aml_i2s_set_amclk(struct aml_i2s *i2s, unsigned long rate)
 	int ret = 0;
 
 	ret = clk_set_rate(i2s->clk_mpl0, rate * 10);
-	if (ret) {
-		pr_err("Can't set I2S mpll clock rate: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	ret = clk_set_parent(i2s->clk_mclk, i2s->clk_mpl0);
-	if (ret) {
-		pr_err("Can't set I2S mclk parent: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	ret = clk_set_rate(i2s->clk_mclk, rate);
-	if (ret) {
-		pr_err("Can't set I2S mclk clock rate: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	audio_set_i2s_clk_div();
 
@@ -175,13 +394,11 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
-	ALSA_TRACE();
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		audio_out_i2s_enable(0);
-
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	}
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		s->i2s_mode = dai_info[dai->id].i2s_mode;
 		audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes * 2,
@@ -197,19 +414,19 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 		s->device_type = AML_AUDIO_I2SIN;
 	} else {
 		s->device_type = AML_AUDIO_I2SOUT;
+		IEC958_mode_codec = 0;
 		aml_hw_i2s_init(runtime);
 		/* i2s/958 share the same audio hw buffer when PCM mode */
 		if (IEC958_mode_codec == 0) {
-			aml_hw_iec958_init(substream);
+			aml_hw_iec958_init(substream, 1);
 			/* use the hw same sync for i2s/958 */
-			pr_info("958 with i2s\n");
+			dev_info(substream->pcm->card->dev, "i2s/958 same source\n");
 			/* aml_set_spdif_clk(runtime->rate*512, 0); */
 			audio_i2s_958_same_source(1);
 		}
 	}
 	if (runtime->channels == 8) {
-		pr_info("[%s,%d]8ch PCM output->notify HDMI\n", __func__,
-		       __LINE__);
+		dev_info(substream->pcm->card->dev, "8ch PCM output->notify HDMI\n");
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 	return 0;
@@ -220,17 +437,17 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	int *ppp = NULL;
-	ALSA_TRACE();
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		/* TODO */
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu i2s playback enable\n");
+			dev_info(substream->pcm->card->dev, "I2S playback enable\n");
 			audio_out_i2s_enable(1);
 			if (IEC958_mode_codec == 0) {
-				pr_info("audio_hw_958_enable 1\n");
+				dev_info(substream->pcm->card->dev, "IEC958 playback enable\n");
 				audio_hw_958_enable(1);
 			}
 		} else {
@@ -244,10 +461,10 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu i2s playback disable\n");
+			dev_info(substream->pcm->card->dev, "I2S playback disable\n");
 			audio_out_i2s_enable(0);
 			if (IEC958_mode_codec == 0) {
-				pr_info("audio_hw_958_enable 0\n");
+				dev_info(substream->pcm->card->dev, "IEC958 playback disable\n");
 				audio_hw_958_enable(0);
 			}
 		} else {
@@ -280,7 +497,6 @@ static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
 
 static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	ALSA_TRACE();
 	if (fmt & SND_SOC_DAIFMT_CBS_CFS)	/* slave mode */
 		dai_info[dai->id].i2s_mode = I2S_SLAVE_MODE;
 
@@ -300,7 +516,6 @@ static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -308,7 +523,7 @@ static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
 {
 	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
 
-	if (i2s && i2s->clk_mclk)
+	if (i2s && i2s->clk_mclk && !i2s->disable_clk_suspend)
 		clk_disable_unprepare(i2s->clk_mclk);
 
 	return 0;
@@ -318,7 +533,7 @@ static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
 {
 	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
 
-	if (i2s && i2s->clk_mclk)
+	if (i2s && i2s->clk_mclk && !i2s->disable_clk_suspend)
 		clk_prepare_enable(i2s->clk_mclk);
 
 	return 0;
@@ -372,6 +587,7 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 {
 	struct aml_i2s *i2s = NULL;
 	struct reset_control *audio_reset;
+	struct device_node *pnode = pdev->dev.of_node;
 	int ret = 0, i;
 
 	/* enable AIU module power gate first */
@@ -392,6 +608,9 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 	}
 	dev_set_drvdata(&pdev->dev, i2s);
 
+	i2s->disable_clk_suspend =
+		of_property_read_bool(pnode, "disable_clk_suspend");
+
 	i2s->clk_mpl0 = devm_clk_get(&pdev->dev, "mpll0");
 	if (IS_ERR(i2s->clk_mpl0)) {
 		dev_err(&pdev->dev, "Can't retrieve mpll0 clock\n");
@@ -416,15 +635,14 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 
 	ret = clk_prepare_enable(i2s->clk_mclk);
 	if (ret) {
-		pr_err("Can't enable I2S mclk clock: %d\n", ret);
+		dev_err(&pdev->dev, "Can't enable I2S mclk clock: %d\n", ret);
 		goto err;
 	}
 
-	aml_i2s_play();
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_i2s_dai, ARRAY_SIZE(aml_i2s_dai));
 	if (ret) {
-		pr_err("Can't register i2s dai: %d\n", ret);
+		dev_err(&pdev->dev, "Can't register i2s dai: %d\n", ret);
 		goto err_clk_dis;
 	}
 	return 0;
@@ -445,6 +663,16 @@ static int aml_i2s_dai_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void aml_i2s_dai_shutdown(struct platform_device *pdev)
+{
+	struct aml_i2s *i2s = dev_get_drvdata(&pdev->dev);
+
+	if (i2s && i2s->clk_mclk)
+		clk_disable_unprepare(i2s->clk_mclk);
+
+	return;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_dai_dt_match[] = {
 	{.compatible = "amlogic, aml-i2s-dai",},
@@ -463,6 +691,7 @@ static struct platform_driver aml_i2s_dai_driver = {
 
 	.probe = aml_i2s_dai_probe,
 	.remove = aml_i2s_dai_remove,
+	.shutdown = aml_i2s_dai_shutdown,
 };
 
 static int __init aml_i2s_dai_modinit(void)
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index 2012bba..c834d34 100644
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_snd_card: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -46,8 +47,27 @@
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/of_gpio.h>
 #include <linux/io.h>
-#define DRV_NAME "aml_snd_card"
-/* extern struct device *spdif_dev; */
+#include <linux/amlogic/jtag.h>
+
+
+#define DRV_NAME "aml_snd_m8_card"
+
+static int i2sbuf[32 + 16];
+static void aml_i2s_play(void)
+{
+#if 0
+	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(AIU_I2S_MODE_PCM16, 2);
+#else
+	audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
+#endif
+	memset(i2sbuf, 0, sizeof(i2sbuf));
+	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
+	audio_out_i2s_enable(1);
+
+#endif
+}
 
 static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio,
 				  unsigned long delay)
@@ -153,8 +173,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 		if (flag & 0x1) {
 			/* 1 :have mic ;  2 no mic */
 			switch_set_state(&p_aml_audio->sdev, 2);
-			pr_info(KERN_INFO
-			       "aml aduio hp pluged 3 jack_type: %d\n",
+			pr_info("aml aduio hp pluged 3 jack_type: %d\n",
 			       SND_JACK_HEADPHONE);
 			snd_soc_jack_report(&p_aml_audio->jack, status,
 					    SND_JACK_HEADPHONE);
@@ -164,8 +183,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 				if (flag & 0x8) {
 					switch_set_state(&p_aml_audio->mic_sdev,
 							 1);
-					pr_info(KERN_INFO
-					       "aml aduio mic pluged jack_type: %d\n",
+					pr_info("aml aduio mic pluged jack_type: %d\n",
 					       SND_JACK_MICROPHONE);
 					snd_soc_jack_report(&p_aml_audio->jack,
 						status, SND_JACK_HEADPHONE);
@@ -175,13 +193,12 @@ static void aml_asoc_work_func(struct work_struct *work)
 		} else if (flag & 0x2) {
 			/* 1 :have mic ;  2 no mic */
 			switch_set_state(&p_aml_audio->sdev, 1);
-			pr_info(KERN_INFO
-			       "aml aduio hp pluged 4 jack_type: %d\n",
+			pr_info("aml aduio hp pluged 4 jack_type: %d\n",
 			       SND_JACK_HEADSET);
 			snd_soc_jack_report(&p_aml_audio->jack, status,
 					    SND_JACK_HEADPHONE);
 		} else {
-			pr_info(KERN_INFO "aml audio hp unpluged\n");
+			pr_info("aml audio hp unpluged\n");
 			switch_set_state(&p_aml_audio->sdev, 0);
 			snd_soc_jack_report(&p_aml_audio->jack, 0,
 					    SND_JACK_HEADPHONE);
@@ -191,8 +208,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 				if (flag & 0x8) {
 					switch_set_state(&p_aml_audio->mic_sdev,
 							 1);
-					pr_info(KERN_INFO
-					       "aml aduio mic pluged jack_type: %d\n",
+					pr_info("aml aduio mic pluged jack_type: %d\n",
 					       SND_JACK_MICROPHONE);
 					snd_soc_jack_report(&p_aml_audio->jack,
 						status, SND_JACK_HEADPHONE);
@@ -217,14 +233,14 @@ static void aml_asoc_timer_func(unsigned long data)
 	mod_timer(&p_aml_audio->timer, jiffies + delay);
 }
 
-struct aml_audio_private_data *p_audio;
+static struct aml_audio_private_data *p_audio;
 static int aml_m8_spk_enabled;
 
 static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
 			  struct snd_ctl_elem_value *ucontrol)
 {
 	aml_m8_spk_enabled = ucontrol->value.integer.value[0];
-	pr_info(KERN_INFO "aml_m8_set_spk: aml_m8_spk_enabled=%d\n",
+	pr_info("aml_m8_set_spk: aml_m8_spk_enabled=%d\n",
 	       aml_m8_spk_enabled);
 
 	msleep_interruptible(10);
@@ -239,8 +255,6 @@ static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
 static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
 			  struct snd_ctl_elem_value *ucontrol)
 {
-	/* pr_info("***aml_m8_get_spk****aml_m8_spk_enabled=%d**\n",
-		aml_m8_spk_enabled); */
 	ucontrol->value.integer.value[0] = aml_m8_spk_enabled;
 	return 0;
 }
@@ -248,8 +262,10 @@ static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
 static int aml_suspend_pre(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
+	struct pinctrl_state *state;
+	int val = 0;
 
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	if (!p_aml_audio->hp_disable) {
 		/* stop timer */
@@ -260,20 +276,36 @@ static int aml_suspend_pre(struct snd_soc_card *card)
 
 		mutex_unlock(&p_aml_audio->lock);
 	}
+
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to suspend\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_suspend");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl suspend state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
+	}
+
+	if (p_aml_audio->mute_desc) {
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	};
+
 	return 0;
 }
 
 static int aml_suspend_post(struct snd_soc_card *card)
 {
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	/* if(ext_codec) */
-	/* i2s_gpio_set(card); */
+	pr_info("enter %s\n", __func__);
 	return 0;
 }
 
 static int aml_resume_pre(struct snd_soc_card *card)
 {
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 
 	return 0;
 }
@@ -281,8 +313,10 @@ static int aml_resume_pre(struct snd_soc_card *card)
 static int aml_resume_post(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
+	struct pinctrl_state *state;
+	int val = 0;
 
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	if (!p_aml_audio->hp_disable) {
 		mutex_lock(&p_aml_audio->lock);
@@ -294,22 +328,50 @@ static int aml_resume_post(struct snd_soc_card *card)
 		mutex_unlock(&p_aml_audio->lock);
 	}
 
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to resume\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_m8");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl working state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
+	}
+
+	if (p_aml_audio->mute_desc) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	}
 	return 0;
 }
 
 static int speaker_events(struct snd_soc_dapm_widget *w,
 			  struct snd_kcontrol *kcontrol, int event)
 {
+	int val = 0;
+
+	if (p_audio->mute_desc == NULL) {
+		pr_info("no mute_gpio setting");
+		return 0;
+	}
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
-		pr_info("speaker_events--mute =1\n");
+		pr_info("audio speaker on\n");
+		val = p_audio->mute_inv ?
+			GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
 		gpiod_direction_output(p_audio->mute_desc, 1);
 		aml_m8_spk_enabled = 1;
 		msleep(p_audio->sleep_time);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
-		pr_info("speaker_events--mute =0\n");
-		gpiod_direction_output(p_audio->mute_desc, 0);
+		pr_info("audio speaker off\n");
+		val = p_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_audio->mute_desc, val);
 		aml_m8_spk_enabled = 0;
 		break;
 	}
@@ -350,7 +412,6 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	int ret = 0;
 	int hp_paraments[5];
 
-	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	ret = snd_soc_add_card_controls(codec->card, aml_m8_controls,
 					ARRAY_SIZE(aml_m8_controls));
@@ -363,7 +424,7 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	p_aml_audio->hp_disable =
 	    of_property_read_bool(card->dev->of_node, "hp_disable");
 
-	pr_info("p_aml_audio->hp_disable=%d\n", p_aml_audio->hp_disable);
+	pr_info("headphone detection disable=%d\n", p_aml_audio->hp_disable);
 
 	if (!p_aml_audio->hp_disable) {
 		/* for report headphone to android */
@@ -445,46 +506,43 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	    of_property_read_u32(card->dev->of_node, "sleep_time",
 				 &p_aml_audio->sleep_time);
 	if (ret)
-		pr_info("falied to get spk event delay time\n");
-
-	pr_info("spk_event delay_time = %d\n",
-	       p_aml_audio->sleep_time);
+		pr_info("no spk event delay time set\n");
 
 	return 0;
 }
-static int ao_jtag_on;
+
 static void aml_m8_pinmux_init(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
 	int val;
-	if (ao_jtag_on)
-		return;
+
 	p_aml_audio = snd_soc_card_get_drvdata(card);
+	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
+	p_aml_audio->mute_inv =
+	    of_property_read_bool(card->dev->of_node, "mute_inv");
+	if (p_aml_audio->mute_desc) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	}
+
+	if (is_jtag_apao())
+		return;
 	val = aml_read_sec_reg(0xda004004);
 	pr_info("audio use jtag pinmux as i2s output, read val =%x\n",
 		aml_read_sec_reg(0xda004004));
 	val = val & (~((1<<8) | (1<<1)));
 	aml_write_sec_reg(0xda004004, val);
+
 	p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "aml_snd_m8");
 	if (IS_ERR(p_aml_audio->pin_ctl)) {
 		pr_info("%s,aml_m8_pinmux_init error!\n", __func__);
 		return;
 	}
-	/* p_audio = p_aml_audio; */
-
-	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
-
-	p_aml_audio->mute_inv =
-	    of_property_read_bool(card->dev->of_node, "mute_inv");
-	gpiod_direction_output(p_aml_audio->mute_desc, GPIOF_OUT_INIT_LOW);
-
-}
-static int __init ao_jtag_func(char *buf)
-{
-	ao_jtag_on = 1;
-	return 0;
 }
-early_param("ao_jtag_on", ao_jtag_func);
+
 static int aml_card_dai_parse_of(struct device *dev,
 				 struct snd_soc_dai_link *dai_link,
 				 int (*init)(struct snd_soc_pcm_runtime *rtd),
@@ -660,6 +718,7 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	aml_i2s_play();
 	aml_m8_pinmux_init(card);
 	return 0;
  err:
@@ -667,6 +726,22 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static void aml_audio_shutdown(struct platform_device *pdev)
+{
+	struct pinctrl_state *state;
+
+	if (IS_ERR_OR_NULL(p_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to shutdown\n");
+		return;
+	}
+
+	state = pinctrl_lookup_state(p_audio->pin_ctl, "aml_snd_suspend");
+	if (!IS_ERR(state))
+		pinctrl_select_state(p_audio->pin_ctl, state);
+
+	return;
+}
+
 static const struct of_device_id amlogic_audio_of_match[] = {
 	{.compatible = "aml, aml_snd_m8",},
 	{},
@@ -682,6 +757,7 @@ static struct platform_driver aml_m8_audio_driver = {
 		   .pm = &snd_soc_pm_ops,
 		   },
 	.probe = aml_m8_audio_probe,
+	.shutdown = aml_audio_shutdown,
 };
 
 module_platform_driver(aml_m8_audio_driver);
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index 7b42d2d..405d223 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_spdif_dai: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -45,17 +46,8 @@
 #include "aml_i2s.h"
 #include <linux/amlogic/sound/aout_notify.h>
 #include <linux/amlogic/sound/aiu_regs.h>
+#include <linux/amlogic/cpu_version.h>
 
-/* #define DEBUG_ALSA_SPDIF_DAI */
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-spdif-dai]" fmt, ##args)
-#ifdef DEBUG_ALSA_SPDIF_DAI
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-spdif-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-spdif-dai] enter func %s,line %d\n",\
-		__func__, __LINE__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
 /*
  0 --  other formats except(DD,DD+,DTS)
  1 --  DTS
@@ -70,70 +62,72 @@ struct aml_spdif {
 	struct clk *clk_i958;
 	struct clk *clk_mclk;
 	struct clk *clk_spdif;
+	struct clk *clk_81;
 	int old_samplerate;
 };
 struct aml_spdif *spdif_p;
 unsigned int clk81 = 0;
 EXPORT_SYMBOL(clk81);
 
-static int iec958buf[32 + 16];
 static int old_samplerate = -1;
+static int flag_samesrc = -1;
 
-void aml_spdif_play(void)
+void aml_spdif_play(int samesrc)
 {
-#if 1
-	struct _aiu_958_raw_setting_t set;
-	struct _aiu_958_channel_status_t chstat;
-	struct snd_pcm_substream substream;
-	struct snd_pcm_runtime runtime;
-	substream.runtime = &runtime;
-	runtime.rate = 48000;
-	runtime.format = SNDRV_PCM_FORMAT_S16_LE;
-	runtime.channels = 2;
-	runtime.sample_bits = 16;
-	memset((void *)(&set), 0, sizeof(set));
-	memset((void *)(&chstat), 0, sizeof(chstat));
-	set.chan_stat = &chstat;
-	set.chan_stat->chstat0_l = 0x0100;
-	set.chan_stat->chstat0_r = 0x0100;
-	set.chan_stat->chstat1_l = 0X200;
-	set.chan_stat->chstat1_r = 0X200;
-	audio_hw_958_enable(0);
-	if (old_samplerate != AUDIO_CLK_FREQ_48) {
-		pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
-		__func__, old_samplerate, AUDIO_CLK_FREQ_48);
-		old_samplerate = AUDIO_CLK_FREQ_48;
-		aml_set_spdif_clk(48000 * 512, 0);
-	}
-	/* Todo, div can be changed, for most case, div = 2 */
-	/* audio_set_spdif_clk_div(); */
-	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
-	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
-		pr_info("set 4x audio clk for 958\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (0) {
-		pr_info("share the same clock\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
-	} else {
-		pr_info("set normal 512 fs /4 fs\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
+#if 0
+	if (is_meson_gxtvbb_cpu() == false) {
+		static int iec958buf[32 + 16];
+		struct _aiu_958_raw_setting_t set;
+		struct _aiu_958_channel_status_t chstat;
+		struct snd_pcm_substream substream;
+		struct snd_pcm_runtime runtime;
+		substream.runtime = &runtime;
+		runtime.rate = 48000;
+		runtime.format = SNDRV_PCM_FORMAT_S16_LE;
+		runtime.channels = 2;
+		runtime.sample_bits = 16;
+		memset((void *)(&set), 0, sizeof(set));
+		memset((void *)(&chstat), 0, sizeof(chstat));
+		set.chan_stat = &chstat;
+		set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+		audio_hw_958_enable(0);
+		if (old_samplerate != AUDIO_CLK_FREQ_48
+				|| samesrc != flag_samesrc) {
+			pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
+			__func__, old_samplerate, AUDIO_CLK_FREQ_48);
+			old_samplerate = AUDIO_CLK_FREQ_48;
+			flag_samesrc = samesrc;
+			aml_set_spdif_clk(48000 * 512, samesrc);
+		}
+		/* Todo, div can be changed, for most case, div = 2 */
+		/* audio_set_spdif_clk_div(); */
+		/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+		if (IEC958_mode_codec == 4	|| IEC958_mode_codec == 5 ||
+		IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+			pr_info("set 4x audio clk for 958\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+		} else if (samesrc) {
+			pr_info("share the same clock\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+		} else {
+			pr_info("set normal 512 fs /4 fs\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
+		}
+		/* enable 958 divider */
+		aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
+		audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+		/*clear the same source function as new raw data output */
+		audio_i2s_958_same_source(0);
+		memset(iec958buf, 0, sizeof(iec958buf));
+		audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63),
+					128, 0);
+		audio_set_958_mode(AIU_958_MODE_PCM16, &set);
+		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
+		audio_hw_958_enable(1);
 	}
-	/* enable 958 divider */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
-	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-	memset(iec958buf, 0, sizeof(iec958buf));
-	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 0);
-	audio_set_958_mode(AIU_958_MODE_PCM16, &set);
-#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1
-	/* 512fs divide 4 == 128fs */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x3 << 4);
-#else
-	/* 256fs divide 2 == 128fs */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x1 << 4);
-#endif
-	aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
-	audio_hw_958_enable(1);
 #endif
 }
 
@@ -145,7 +139,6 @@ static void aml_spdif_play_stop(void)
 static int aml_dai_spdif_set_sysclk(struct snd_soc_dai *cpu_dai,
 				    int clk_id, unsigned int freq, int dir)
 {
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -155,18 +148,16 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 
 	struct snd_soc_pcm_runtime *rtd = NULL;
 
-	ALSA_TRACE();
-
 	rtd = (struct snd_soc_pcm_runtime *)substream->private_data;
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			ALSA_PRINT("aiu 958 playback enable\n");
+			pr_info("aiu 958 playback enable\n");
 			audio_hw_958_enable(1);
 		} else {
-			ALSA_PRINT("spdif in capture enable\n");
+			pr_info("spdif in capture enable\n");
 			audio_in_spdif_enable(1);
 		}
 		break;
@@ -174,10 +165,10 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			ALSA_PRINT("aiu 958 playback disable\n");
+			pr_info("aiu 958 playback disable\n");
 			audio_hw_958_enable(0);
 		} else {
-			ALSA_PRINT("spdif in capture disable\n");
+			pr_info("spdif in capture disable\n");
 			audio_in_spdif_enable(0);
 		}
 		break;
@@ -188,89 +179,77 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-void aml_hw_iec958_init(struct snd_pcm_substream *substream)
+void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 {
 	struct _aiu_958_raw_setting_t set;
 	struct _aiu_958_channel_status_t chstat;
-	unsigned i2s_mode, iec958_mode;
-	unsigned start, size;
-	int sample_rate;
+	unsigned iec958_mode;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (buf == NULL && runtime == NULL) {
+	if (buf == NULL || runtime == NULL) {
 		pr_info("buf/%p runtime/%p\n", buf, runtime);
 		return;
 	}
 
-	i2s_mode = AIU_I2S_MODE_PCM16;
-	sample_rate = AUDIO_CLK_FREQ_48;
+	iec958_mode = AIU_958_MODE_PCM16;
 	memset((void *)(&set), 0, sizeof(set));
 	memset((void *)(&chstat), 0, sizeof(chstat));
 	set.chan_stat = &chstat;
-	switch (runtime->rate) {
-	case 192000:
-		sample_rate = AUDIO_CLK_FREQ_192;
-		break;
-	case 176400:
-		sample_rate = AUDIO_CLK_FREQ_1764;
-		break;
-	case 96000:
-		sample_rate = AUDIO_CLK_FREQ_96;
-		break;
-	case 88200:
-		sample_rate = AUDIO_CLK_FREQ_882;
-		break;
-	case 48000:
-		sample_rate = AUDIO_CLK_FREQ_48;
-		break;
-	case 44100:
-		sample_rate = AUDIO_CLK_FREQ_441;
-		break;
-	case 32000:
-		sample_rate = AUDIO_CLK_FREQ_32;
-		break;
-	case 8000:
-		sample_rate = AUDIO_CLK_FREQ_8;
-		break;
-	case 11025:
-		sample_rate = AUDIO_CLK_FREQ_11;
-		break;
-	case 16000:
-		sample_rate = AUDIO_CLK_FREQ_16;
-		break;
-	case 22050:
-		sample_rate = AUDIO_CLK_FREQ_22;
-		break;
-	case 12000:
-		sample_rate = AUDIO_CLK_FREQ_12;
-		break;
-	case 24000:
-		sample_rate = AUDIO_CLK_FREQ_22;
-		break;
-	default:
-		sample_rate = AUDIO_CLK_FREQ_441;
-		break;
-	};
+
+	if (!samesrc) {
+		unsigned i2s_mode = AIU_I2S_MODE_PCM16;
+		switch (runtime->format) {
+		case SNDRV_PCM_FORMAT_S32:
+			i2s_mode = AIU_I2S_MODE_PCM32;
+			break;
+		case SNDRV_PCM_FORMAT_S24:
+			i2s_mode = AIU_I2S_MODE_PCM24;
+			break;
+		case SNDRV_PCM_FORMAT_S16:
+			i2s_mode = AIU_I2S_MODE_PCM16;
+			break;
+		}
+		audio_out_i2s_enable(0);
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		audio_set_i2s_mode(i2s_mode, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
+#else
+		audio_set_i2s_mode(i2s_mode);
+#endif
+		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
+	}
+
 	audio_hw_958_enable(0);
-	pr_info("----aml_hw_iec958_init,runtime->rate=%d,sample_rate=%d--\n",
-	       runtime->rate, sample_rate);
-	/* int srate; */
-	/* srate = params_rate(params); */
-	if (old_samplerate != sample_rate) {
-		old_samplerate = sample_rate;
-		aml_set_spdif_clk(runtime->rate * 512, 0);
+	pr_info("aml_hw_iec958_init,runtime->rate=%d, runtime->channels=%d, same source mode(%d)\n",
+	       runtime->rate, runtime->channels, samesrc);
+
+	if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		aml_set_spdif_clk((runtime->rate >> 2) * 512, samesrc); /* EAC3 */
+	} else {
+		aml_set_spdif_clk(runtime->rate * 512, samesrc);
 	}
+
 	/* Todo, div can be changed, for most case, div = 2 */
 	/* audio_set_spdif_clk_div(); */
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
-	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+	if (runtime->rate == 192000 && runtime->channels == 8 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
+		pr_info("set 4x audio clk for 958\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+	} else if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 4; /* EAC3 */
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (0) {
+	} else if (samesrc) {
+		IEC958_mode_codec = 0;
 		pr_info("share the same clock\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+	} else if (runtime->rate == 48000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 2; /* AC3/DTS */
+		pr_info("set normal 512 fs /4 fs\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	} else {
+		IEC958_mode_codec = 0;
 		pr_info("set normal 512 fs /4 fs\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	}
@@ -281,127 +260,62 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 	audio_i2s_958_same_source(0);
 
 	switch (runtime->format) {
-	case SNDRV_PCM_FORMAT_S32_LE:
-		i2s_mode = AIU_I2S_MODE_PCM32;
+	case SNDRV_PCM_FORMAT_S32:
+		iec958_mode = AIU_958_MODE_PCM32;
 		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		i2s_mode = AIU_I2S_MODE_PCM24;
+	case SNDRV_PCM_FORMAT_S24:
+		iec958_mode = AIU_958_MODE_PCM24;
 		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		i2s_mode = AIU_I2S_MODE_PCM16;
+	case SNDRV_PCM_FORMAT_S16:
+		iec958_mode = AIU_958_MODE_PCM16;
 		break;
 	}
+	if (IEC958_mode_codec > 0) {
+		iec958_mode = AIU_958_MODE_PCM_RAW;
+	}
 
-	/* audio_set_i2s_mode(i2s_mode); */
-	/* case 1,raw mode enabled */
-	if (IEC958_mode_codec) {
-		if (IEC958_mode_codec == 1) {
-			/* dts, use raw sync-word mode */
-			iec958_mode = AIU_958_MODE_RAW;
-			pr_info("iec958 mode RAW\n");
-		} else {
-			/* ac3,use the same pcm mode as i2s configuration */
-			iec958_mode = AIU_958_MODE_PCM_RAW;
-			pr_info("iec958 mode %s\n",
-				(i2s_mode == AIU_I2S_MODE_PCM32) ? "PCM32_RAW"
-				: ((I2S_MODE == AIU_I2S_MODE_PCM24) ?
-				"PCM24_RAW"	: "PCM16_RAW"));
-		}
+	/* AES1+0 */
+	if (iec958_mode == AIU_958_MODE_PCM_RAW) {
+		set.chan_stat->chstat0_l = 0x8206;
 	} else {
-		if (i2s_mode == AIU_I2S_MODE_PCM32)
-			iec958_mode = AIU_958_MODE_PCM32;
-		else if (i2s_mode == AIU_I2S_MODE_PCM24)
-			iec958_mode = AIU_958_MODE_PCM24;
-		else
-			iec958_mode = AIU_958_MODE_PCM16;
-		pr_info("iec958 mode %s\n",
-		       (i2s_mode ==
-			AIU_I2S_MODE_PCM32) ? "PCM32" : ((i2s_mode ==
-							  AIU_I2S_MODE_PCM24) ?
-							 "PCM24" : "PCM16"));
+		set.chan_stat->chstat0_l = 0x8204;
 	}
-	if (iec958_mode == AIU_958_MODE_PCM16
-	    || iec958_mode == AIU_958_MODE_PCM24
-	    || iec958_mode == AIU_958_MODE_PCM32) {
-		set.chan_stat->chstat0_l = 0x0100;
-		set.chan_stat->chstat0_r = 0x0100;
-		set.chan_stat->chstat1_l = 0x200;
-		set.chan_stat->chstat1_r = 0x200;
-		if (sample_rate == AUDIO_CLK_FREQ_882) {
-			pr_info("----sample_rate==AUDIO_CLK_FREQ_882---\n");
-			set.chan_stat->chstat1_l = 0x800;
-			set.chan_stat->chstat1_r = 0x800;
-		}
-
-		if (sample_rate == AUDIO_CLK_FREQ_96) {
-			pr_info("----sample_rate==AUDIO_CLK_FREQ_96---\n");
-			set.chan_stat->chstat1_l = 0xa00;
-			set.chan_stat->chstat1_r = 0xa00;
-		}
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size, 0);
-		/* audio_set_i2s_mode(AIU_I2S_MODE_PCM16); */
-		/* audio_set_aiubuf(start, size); */
+	set.chan_stat->chstat0_r = set.chan_stat->chstat0_l;
+
+	/* AES3+2 */
+	if (IEC958_mode_codec == 8) {
+		set.chan_stat->chstat1_l = 0x0900;
+	} else if (runtime->rate == 192000) {
+		set.chan_stat->chstat1_l = 0x0e00;
+	} else if (runtime->rate == 176400) {
+		set.chan_stat->chstat1_l = 0x0c00;
+	} else if (runtime->rate == 96000) {
+		set.chan_stat->chstat1_l = 0x0a00;
+	} else if (runtime->rate == 88200) {
+		set.chan_stat->chstat1_l = 0x0800;
+	} else if (runtime->rate == 48000) {
+		set.chan_stat->chstat1_l = 0x0200;
+	} else if (runtime->rate == 44100) {
+		set.chan_stat->chstat1_l = 0x0000;
+	} else if (runtime->rate == 32000) {
+		set.chan_stat->chstat1_l = 0x0300;
 	} else {
-
-		set.chan_stat->chstat0_l = 0x1902;
-		set.chan_stat->chstat0_r = 0x1902;
-		if (IEC958_mode_codec == 4 || IEC958_mode_codec == 5) {
-			/* DD+ */
-			if (runtime->rate == 32000) {
-				set.chan_stat->chstat1_l = 0x300;
-				set.chan_stat->chstat1_r = 0x300;
-			} else if (runtime->rate == 44100) {
-				set.chan_stat->chstat1_l = 0xc00;
-				set.chan_stat->chstat1_r = 0xc00;
-			} else {
-				set.chan_stat->chstat1_l = 0Xe00;
-				set.chan_stat->chstat1_r = 0Xe00;
-			}
-		} else {
-			/* DTS,DD */
-			if (runtime->rate == 32000) {
-				set.chan_stat->chstat1_l = 0x300;
-				set.chan_stat->chstat1_r = 0x300;
-			} else if (runtime->rate == 44100) {
-				set.chan_stat->chstat1_l = 0;
-				set.chan_stat->chstat1_r = 0;
-			} else {
-				set.chan_stat->chstat1_l = 0x200;
-				set.chan_stat->chstat1_r = 0x200;
-			}
-		}
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size,
-				    (iec958_mode == AIU_958_MODE_RAW) ? 1 : 0);
-		memset((void *)buf->area, 0, size);
+		set.chan_stat->chstat1_l = 0x0100;
 	}
-	ALSA_DEBUG("aiu 958 pcm buffer size %d\n", size);
+	set.chan_stat->chstat1_r = set.chan_stat->chstat1_l;
+
+	audio_set_958outbuf(buf->addr, snd_pcm_lib_buffer_bytes(substream), 0);
 	audio_set_958_mode(iec958_mode, &set);
 
-	if (IEC958_mode_codec == 2) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_AC_3, substream);
-	} else if (IEC958_mode_codec == 3) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS, substream);
-	} else if (IEC958_mode_codec == 4) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS,
-					 substream);
-	} else if (IEC958_mode_codec == 5) {
+	/* notify hdmi to set audio type */
+	if (IEC958_mode_codec == 8) {
+		/* TrueHD/DTS-HD MA */
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA, substream);
+	} else if (iec958_mode == AIU_958_MODE_PCM_RAW) {
+		/* AC3/DTS/EAC3 */
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD, substream);
-	} else if (IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
-		aml_write_cbus(AIU_958_CHSTAT_L0, 0x1902);
-		aml_write_cbus(AIU_958_CHSTAT_L1, 0x900);
-		aml_write_cbus(AIU_958_CHSTAT_R0, 0x1902);
-		aml_write_cbus(AIU_958_CHSTAT_R1, 0x900);
-		if (IEC958_mode_codec == 8)
-			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA,
-			substream);
-		else
-			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP,
-			substream);
 	} else {
+		/* PCM */
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 }
@@ -418,7 +332,6 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 
 void aml_alsa_hw_reprepare(void)
 {
-	ALSA_TRACE();
 	/* M8 disable it */
 #if 0
 	/* diable 958 module before call initiation */
@@ -438,7 +351,6 @@ static int aml_dai_spdif_startup(struct snd_pcm_substream *substream,
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s;
 
-	ALSA_TRACE();
 	if (!prtd) {
 		prtd =
 		    (struct aml_runtime_data *)
@@ -471,17 +383,14 @@ static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
 
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	/* struct snd_dma_buffer *buf = &substream->dma_buffer; */
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		memset((void *)runtime->dma_area, 0,
 		       snd_pcm_lib_buffer_bytes(substream));
-		if (IEC958_mode_codec == 6) {
-			pr_info
-			    ("[%s %d]8chPCM output:disable aml_spdif_play()\n",
-			     __func__, __LINE__);
-		} else {
-			aml_spdif_play();
-		}
+		if (IEC958_mode_codec == 6)
+			pr_info("8chPCM output:disable aml_spdif_play\n");
+		else
+			;/*aml_spdif_play();*/
+
 		/* audio_spdifout_pg_enable(0); */
 	}
 
@@ -496,9 +405,8 @@ static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 	/* struct aml_runtime_data *prtd = runtime->private_data; */
 	/* audio_stream_t *s = &prtd->s; */
 
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		aml_hw_iec958_init(substream);
+		aml_hw_iec958_init(substream, 0);
 	} else {
 		audio_in_spdif_set_buf(runtime->dma_addr,
 				       runtime->dma_bytes * 2);
@@ -519,7 +427,7 @@ static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 int aml_set_spdif_clk(unsigned long rate, bool src_i2s)
 {
 	int ret = 0;
-	pr_info("aml_set_spdif_clk rate\n");
+
 	if (src_i2s) {
 		ret = clk_set_parent(spdif_p->clk_spdif, spdif_p->clk_mclk);
 		if (ret) {
@@ -563,7 +471,6 @@ static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
 	srate = params_rate(params);
 	aml_set_spdif_clk(srate * 512, 0);
 #endif
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -641,7 +548,6 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 	struct reset_control *spdif_reset;
 	struct aml_spdif *spdif_priv;
 
-	pr_info("aml_spdif_probe\n");
 	/* enable spdif power gate first */
 	for (i = 0; i < ARRAY_SIZE(gate_names); i++) {
 		spdif_reset = devm_reset_control_get(&pdev->dev, gate_names[i]);
@@ -708,7 +614,15 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	aml_spdif_play();
+	spdif_priv->clk_81 = devm_clk_get(&pdev->dev, "clk_81");
+	if (IS_ERR(spdif_priv->clk_81)) {
+		dev_err(&pdev->dev, "Can't get clk81\n");
+		ret = PTR_ERR(spdif_priv->clk_81);
+		goto err;
+	}
+	clk81 = clk_get_rate(spdif_priv->clk_81);
+
+	aml_spdif_play(0);
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_spdif_dai,
 					  ARRAY_SIZE(aml_spdif_dai));
@@ -733,6 +647,16 @@ static int aml_dai_spdif_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void aml_spdif_dai_shutdown(struct platform_device *pdev)
+{
+	struct aml_spdif *spdif_priv = dev_get_drvdata(&pdev->dev);
+
+	if (spdif_priv && spdif_priv->clk_spdif)
+		clk_disable_unprepare(spdif_priv->clk_spdif);
+
+	return;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_spdif_dai_dt_match[] = {
 	{.compatible = "amlogic, aml-spdif-dai",
@@ -746,6 +670,7 @@ static const struct of_device_id amlogic_spdif_dai_dt_match[] = {
 static struct platform_driver aml_spdif_dai_driver = {
 	.probe = aml_dai_spdif_probe,
 	.remove = aml_dai_spdif_remove,
+	.shutdown = aml_spdif_dai_shutdown,
 	.driver = {
 		   .name = "aml-spdif-dai",
 		   .owner = THIS_MODULE,
@@ -755,7 +680,6 @@ static struct platform_driver aml_spdif_dai_driver = {
 
 static int __init aml_dai_spdif_init(void)
 {
-	ALSA_PRINT("enter aml_dai_spdif_init\n");
 	return platform_driver_register(&aml_spdif_dai_driver);
 }
 
-- 
1.9.1

