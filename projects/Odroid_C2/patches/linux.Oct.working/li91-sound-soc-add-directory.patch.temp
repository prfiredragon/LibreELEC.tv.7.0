From a52345a55b40f801848d67beab7f62aa62e1c8b9 Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Mon, 10 Oct 2016 13:34:56 +0800
Subject: [PATCH] sound/soc add directory

---
 sound/soc/aml/m8/Kconfig               |   35 +-
 sound/soc/aml/m8/Makefile              |    2 +-
 sound/soc/aml/m8/aml_audio_hw.c        |  346 +++++++---
 sound/soc/aml/m8/aml_audio_hw.h        |   29 +-
 sound/soc/aml/m8/aml_audio_hw_pcm2bt.c |   73 +--
 sound/soc/aml/m8/aml_g9tv.c            | 1082 ++++++++++++++++++++++++++++++++
 sound/soc/aml/m8/aml_g9tv.h            |   69 ++
 sound/soc/aml/m8/aml_i2s.c             |  616 ++++++++++--------
 sound/soc/aml/m8/aml_i2s.h             |   25 +-
 sound/soc/aml/m8/aml_i2s_dai.c         |  345 ++++++++--
 sound/soc/aml/m8/aml_i2s_dai.h         |    1 +
 sound/soc/aml/m8/aml_m8.c              |  170 +++--
 sound/soc/aml/m8/aml_pcm.c             |   52 +-
 sound/soc/aml/m8/aml_pcm_dai.c         |   46 +-
 sound/soc/aml/m8/aml_spdif_codec.c     |   49 +-
 sound/soc/aml/m8/aml_spdif_dai.c       |  438 ++++++-------
 sound/soc/aml/m8/aml_spdif_dai.h       |    4 +-
 sound/soc/aml/m8/odroid_dac.h          |   31 -
 sound/soc/atmel/atmel_ssc_dai.c        |   18 +-
 sound/soc/codecs/Kconfig               |   24 +
 sound/soc/codecs/Makefile              |   12 +
 sound/soc/codecs/adav80x.c             |    4 +-
 sound/soc/codecs/ak4641.c              |    4 +-
 sound/soc/codecs/aml_codec_t9015.c     |  535 ++++++++++++++++
 sound/soc/codecs/aml_codec_t9015.h     |   55 ++
 sound/soc/codecs/aml_codec_t9015S.c    |  627 ++++++++++++++++++
 sound/soc/codecs/aml_codec_t9015S.h    |   79 +++
 sound/soc/codecs/aml_pmu4_codec.c      |  566 +++++++++++++++++
 sound/soc/codecs/aml_pmu4_codec.h      |   83 +++
 sound/soc/codecs/arizona.c             |    2 +-
 sound/soc/codecs/cs4271.c              |    4 +-
 sound/soc/codecs/dummy_codec.c         |    1 -
 sound/soc/codecs/mc13783.c             |    4 +-
 sound/soc/codecs/pcm1681.c             |    6 +-
 sound/soc/codecs/pcm2bt.c              |    3 +-
 sound/soc/codecs/sgtl5000.c            |   11 +-
 sound/soc/codecs/tas5086.c             |    4 +-
 sound/soc/codecs/tas5707.c             |  705 +++++++++++++++++++++
 sound/soc/codecs/tas5707.h             |   91 +++
 sound/soc/codecs/tas5717.c             |  921 +++++++++++++++++++++++++++
 sound/soc/codecs/tas5717.h             |   95 +++
 sound/soc/codecs/tas5731.c             |  770 +++++++++++++++++++++++
 sound/soc/codecs/tas5731.h             |   91 +++
 sound/soc/codecs/wm2000.c              |    8 +-
 sound/soc/codecs/wm5102.c              |    2 +-
 sound/soc/codecs/wm5110.c              |    2 +-
 sound/soc/codecs/wm8731.c              |    4 +-
 sound/soc/codecs/wm8737.c              |    6 +-
 sound/soc/codecs/wm8903.c              |    4 +-
 sound/soc/codecs/wm8903.h              |    2 +-
 sound/soc/codecs/wm8904.c              |    4 +-
 sound/soc/codecs/wm8955.c              |    6 +-
 sound/soc/codecs/wm8958-dsp2.c         |    8 +-
 sound/soc/codecs/wm8960.c              |   10 +-
 sound/soc/codecs/wm8962.c              |    4 +-
 sound/soc/codecs/wm8974.c              |    1 -
 sound/soc/codecs/wm8994.c              |    6 +-
 sound/soc/codecs/wm8997.c              |    2 +-
 sound/soc/davinci/davinci-evm.c        |   10 +
 sound/soc/dwc/designware_i2s.c         |    4 +-
 sound/soc/fsl/fsl_esai.h               |    2 +-
 sound/soc/fsl/imx-wm8962.c             |    2 +-
 sound/soc/jz4740/Makefile              |    2 +
 sound/soc/omap/omap-mcbsp.c            |    2 +-
 sound/soc/omap/omap-pcm.c              |    2 +-
 sound/soc/pxa/Kconfig                  |    2 +
 sound/soc/pxa/pxa2xx-ac97.c            |    4 +-
 sound/soc/soc-compress.c               |   32 +-
 sound/soc/soc-pcm.c                    |    3 +-
 69 files changed, 7273 insertions(+), 989 deletions(-)
 create mode 100644 sound/soc/aml/m8/aml_g9tv.c
 create mode 100644 sound/soc/aml/m8/aml_g9tv.h
 delete mode 100644 sound/soc/aml/m8/odroid_dac.h
 create mode 100644 sound/soc/codecs/aml_codec_t9015.c
 create mode 100644 sound/soc/codecs/aml_codec_t9015.h
 create mode 100644 sound/soc/codecs/aml_codec_t9015S.c
 create mode 100644 sound/soc/codecs/aml_codec_t9015S.h
 create mode 100644 sound/soc/codecs/aml_pmu4_codec.c
 create mode 100644 sound/soc/codecs/aml_pmu4_codec.h
 create mode 100644 sound/soc/codecs/tas5707.c
 create mode 100644 sound/soc/codecs/tas5707.h
 create mode 100644 sound/soc/codecs/tas5717.c
 create mode 100644 sound/soc/codecs/tas5717.h
 create mode 100644 sound/soc/codecs/tas5731.c
 create mode 100644 sound/soc/codecs/tas5731.h

diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
index d182291..045f91e 100644
--- a/sound/soc/aml/m8/Kconfig
+++ b/sound/soc/aml/m8/Kconfig
@@ -3,17 +3,28 @@ menuconfig SND_AML_M8
 	depends on SND_AML_M8_SOC
 	select SWITCH
 	select SND_SOC_PCM2BT
-#	select SND_SOC_AML_M8_CODEC
-#	select SND_SOC_RT5616
 	select SND_SOC_DUMMY_CODEC
-#	select SND_SOC_RT5631
-#	select SND_SOC_AMLPMU3 if AML1218
-#	select SND_SOC_AMLPMU4 if AML1220
-#	select SND_SOC_ES8323
-
-menuconfig SND_AML_G9TV
-	tristate "AML-SND-G9TV Board"
-	depends on SND_AML_M8_SOC && SWITCH
-	select SND_SOC_DUMMY_CODEC
-	select SND_SOC_AMLPMU4 if AML1220
+	select SND_SOC_AMLPMU4 if AML_PMU4
 	select SND_SOC_TAS5707
+	select SND_SOC_TAS5717
+	select SND_SOC_TAS5731
+	select SND_SOC_AMLT9015
+	select SND_SOC_AMLT9015S
+
+if SND_AML_M8
+
+config SND_AML_SPLIT_MODE
+	tristate "AIU split mode, otherwise normal mode"
+	depends on SND_AML_M8_SOC
+	help
+		Say 'Y' to enable AIU split mode. If not, it's normal mode.
+
+config SND_AML_SPLIT_MODE_MMAP
+	tristate "AIU split mode, mmap"
+	depends on SND_AML_SPLIT_MODE
+	depends on SND_AML_M8_SOC
+	help
+		Say 'Y' or 'N' to enable/disable AIU split mmap
+
+endif
+
diff --git a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
index e6bfba1..da85a5c 100644
--- a/sound/soc/aml/m8/Makefile
+++ b/sound/soc/aml/m8/Makefile
@@ -26,4 +26,4 @@ obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
 
 #AML G9TV Machine support
 snd-soc-aml-g9tv-objs := aml_g9tv.o
-obj-$(CONFIG_SND_AML_G9TV) += snd-soc-aml-g9tv.o
+obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-g9tv.o
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 33268a2..70e3f70 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_audio_hw: " fmt
 
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -26,11 +27,20 @@
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
+#include <linux/amlogic/cpu_version.h>
 #include "aml_audio_hw.h"
 
+/* i2s mode 0: master 1: slave */
+/* source: 0: linein; 1: ATV; 2: HDMI-in */
 unsigned ENABLE_IEC958 = 1;
 unsigned IEC958_MODE = AIU_958_MODE_PCM16;
 unsigned I2S_MODE = AIU_I2S_MODE_PCM16;
+unsigned audio_in_source = 0;
+void set_i2s_source(unsigned source)
+{
+	audio_in_source = source;
+	return;
+}
 
 int audio_in_buf_ready = 0;
 int audio_out_buf_ready = 0;
@@ -137,21 +147,37 @@ int audio_clock_config_table[][13][2] = {
 
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffff00);
+	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffff00);
+#else
 	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
 	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+#endif
+
 	if (channel == 8) {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
+#endif
 	} else {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
+			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+#else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+#endif
 	}
 	/* Hold I2S */
 	aml_write_cbus(AIU_I2S_MISC, 0x0004);
 	/* No mute, no swap */
-	aml_write_cbus(AIU_I2S_MUTE_SWAP, 0x0000);
+	/*aml_write_cbus(AIU_I2S_MUTE_SWAP, 0x0000);*/
 	/* Release hold and force audio data to left or right */
 	aml_write_cbus(AIU_I2S_MISC, 0x0010);
 
@@ -159,29 +185,27 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 		pr_info("%s channel == 8\n", __func__);
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-		/*
-		*  [15: 8] chan_mem_mask.
+		/*  [15: 8] chan_mem_mask.
 		*  Each bit indicates which channels exist in memory
 		*/
-					(0xff << 8) |
-		/*
-		*  [ 7: 0] chan_rd_mask.
+			       (0xff << 8) |
+		/*  [ 7: 0] chan_rd_mask.
 		*  Each bit indicates which channels are READ from memory
 		*/
-					(0xff << 0));
-	} else
+			       (0xff << 0));
+	} else {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 		/* [31:16] IRQ block. */
 		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
-		/* [15: 8] chan_mem_mask.
-		* Each bit indicates which channels exist in memory
-		*/
-					(0x3 << 8) |
-		/*
-		*  [ 7: 0] chan_rd_mask.
-		*  Each bit indicates which channels are READ from memory
-		*/
-					(0x3 << 0));
-
+			(0xff << 8) |
+			(0xff << 0));
+#else
+		/* [31:16] IRQ block. */
+		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
+			       (0x3 << 8) |
+			       (0x3 << 0));
+#endif
+	}
 	/* 16 bit PCM mode */
 	/* aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 6, 1); */
 	/* Set init high then low to initilize the I2S memory logic */
@@ -207,15 +231,32 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 				       addr & 0xffffffc0);
 		if (flag == 0) {
 			/* this is for 16bit 2 channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
+#else
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 64);
+#endif
 		} else {
 			/* this is for RAW mode */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-				(addr & 0xffffffc0) + (size & 0xffffffc0) - 1);
+						(addr & 0xffffffc0) +
+						(size & 0xffffffc0) - 8);
+#else
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 1);
+#endif
 		}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0xffff);
+#else
 		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0x303);
-
+#endif
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 1);
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 0);
 
@@ -227,8 +268,7 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 /*
 i2s mode 0: master 1: slave
 */
-static void i2sin_fifo0_set_buf(u32 addr, u32 size,
-				u32 i2s_mode, u32 i2s_sync)
+static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
 {
 	unsigned char mode = 0;
 	unsigned int sync_mode = 0;
@@ -248,7 +288,7 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,
 		       /* DIN from i2sin */
 		       /* |(1<<6)    // 32 bits data in. */
 		       /* |(0<<7)    // put the 24bits data to  low 24 bits */
-		       |(4 << AUDIN_FIFO0_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
+		       | (4 << AUDIN_FIFO0_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
 		       |(2 << AUDIN_FIFO0_CHAN)	/* two channel */
 		       |(0 << 16)	/* to DDR */
 		       |(1 << AUDIN_FIFO0_UG)	/* Urgent request. */
@@ -256,34 +296,64 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,
 		       |(0 << 18)
 		       /* Audio in INT */
 		       /* |(1<<19)    // hold 0 enable */
-		       |(0 << AUDIN_FIFO0_UG)	/* hold0 to aififo */
+		       | (0 << AUDIN_FIFO0_UG)	/* hold0 to aififo */
 	    );
 
 	aml_write_cbus(AUDIN_FIFO0_CTRL1, 0 << 4	/* fifo0_dest_sel */
 		       | 2 << 2	/* fifo0_din_byte_num */
 		       | 0 << 0);	/* fifo0_din_pos */
 
-	aml_write_cbus(AUDIN_I2SIN_CTRL, (3 << I2SIN_SIZE)
-		       | (1 << I2SIN_CHAN_EN)	/* 2 channel */
-		       |(sync_mode << I2SIN_POS_SYNC)
-		       | (1 << I2SIN_LRCLK_SKEW)
-		       | (1 << I2SIN_LRCLK_INVT)
-		       | (!mode << I2SIN_CLK_SEL)
-		       | (!mode << I2SIN_LRCLK_SEL)
-		       | (!mode << I2SIN_DIR)
-	    );
+	if (audio_in_source == 0) {
+		if (is_meson_txl_cpu()) {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (0 << I2SIN_POS_SYNC)
+					| (0 << I2SIN_LRCLK_SEL)
+					| (0 << I2SIN_CLK_SEL)
+					| (0 << I2SIN_DIR));
+		} else {
+			aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+					| (3 << I2SIN_SIZE)
+					| (1 << I2SIN_LRCLK_INVT)
+					| (1 << I2SIN_LRCLK_SKEW)
+					| (sync_mode << I2SIN_POS_SYNC)
+					| (!mode << I2SIN_LRCLK_SEL)
+					| (!mode << I2SIN_CLK_SEL)
+					| (!mode << I2SIN_DIR));
+		}
+	} else if (audio_in_source == 1) {
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+			       | (0 << I2SIN_SIZE)
+			       | (0 << I2SIN_LRCLK_INVT)
+			       | (0 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (0 << I2SIN_LRCLK_SEL)
+			       | (0 << I2SIN_CLK_SEL)
+			       | (0 << I2SIN_DIR));
+	} else if (audio_in_source == 2) {
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+			       | (3 << I2SIN_SIZE)
+			       | (1 << I2SIN_LRCLK_INVT)
+			       | (1 << I2SIN_LRCLK_SKEW)
+			       | (sync_mode << I2SIN_POS_SYNC)
+			       | (1 << I2SIN_LRCLK_SEL)
+			       | (1 << I2SIN_CLK_SEL)
+			       | (1 << I2SIN_DIR));
+	}
 
 }
 
 static void spdifin_reg_set(void)
 {
 	/* get clk81 clk_rate */
-	struct clk *clk_src = clk_get_sys("clk81", NULL);
-	u32 clk_rate = clk_get_rate(clk_src);
+	unsigned int clk_rate = clk81;
 	u32 spdif_clk_time = 54;	/* 54us */
-	u32 spdif_mode_14bit = ((clk_rate / 500000 + 1) >> 1) * spdif_clk_time;
+	u32 spdif_mode_14bit = (u32)((clk_rate / 500000 + 1) >> 1)
+					* spdif_clk_time;
 	/* sysclk/32(bit)/2(ch)/2(bmc) */
-	u32 period_data = (clk_rate / 64000 + 1) >> 1;
+	u32 period_data = (u32)(clk_rate / 64000 + 1) >> 1;
 	u32 period_32k = (period_data + (1 << 4)) >> 5;	/* 32k min period */
 	u32 period_44k = (period_data / 22 + 1) >> 1;	/* 44k min period */
 	u32 period_48k = (period_data / 24 + 1) >> 1;	/* 48k min period */
@@ -297,9 +367,8 @@ static void spdifin_reg_set(void)
 		       (spdif_mode_14bit << 0));
 	aml_write_cbus(AUDIN_SPDIF_FS_CLK_RLTN,
 		       (period_32k << 0) |
-		       (period_44k << 6) |
-		       (period_48k << 12) |
-				/* Spdif_fs_clk_rltn */
+		       (period_44k << 6) | (period_48k << 12) |
+		       /* Spdif_fs_clk_rltn */
 		       (period_96k << 18) | (period_192k << 24));
 
 }
@@ -319,7 +388,7 @@ static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 		       /* DIN from i2sin. */
 		       /* |(1<<6)   // 32 bits data in. */
 		       /* |(0<<7)   // put the 24bits data to  low 24 bits */
-		       |(4 << AUDIN_FIFO1_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
+		       | (4 << AUDIN_FIFO1_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
 		       |(2 << AUDIN_FIFO1_CHAN)	/* 2 channel */
 		       |(0 << 16)	/* to DDR */
 		       |(1 << AUDIN_FIFO1_UG)	/* Urgent request. */
@@ -327,16 +396,16 @@ static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 		       |(0 << 18)
 		       /* Audio in INT */
 		       /* |(1<<19)   //hold 0 enable */
-		       |(0 << AUDIN_FIFO1_UG)	/* hold0 to aififo */
+		       | (0 << AUDIN_FIFO1_UG)	/* hold0 to aififo */
 	    );
 
 	/*
-	*  according clk81 to set reg spdif_mode(0x2800)
-	*  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
-	*/
+	 *  according clk81 to set reg spdif_mode(0x2800)
+	 *  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
+	 */
 	spdifin_reg_set();
-
-	aml_write_cbus(AUDIN_FIFO1_CTRL1, 0xc);
+	/*3 byte mode, (27:4)*/
+	aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
 }
 
 void audio_in_i2s_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync)
@@ -367,7 +436,7 @@ void audio_in_i2s_enable(int flag)
 		rd = aml_read_cbus(AUDIN_FIFO0_PTR);
 		start = aml_read_cbus(AUDIN_FIFO0_START);
 		if (rd != start) {
-			pr_err("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n",
+			pr_err("error %08x, %08x !\n",
 			       rd, start);
 			goto reset_again;
 		}
@@ -391,8 +460,7 @@ void audio_in_spdif_enable(int flag)
 		rd = aml_read_cbus(AUDIN_FIFO1_PTR);
 		start = aml_read_cbus(AUDIN_FIFO1_START);
 		if (rd != start) {
-			pr_err("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n",
-			       rd, start);
+			pr_err("error %08x, %08x !\n", rd, start);
 			goto reset_again;
 		}
 		aml_write_cbus(AUDIN_SPDIF_MODE,
@@ -456,6 +524,77 @@ void audio_in_spdif_set_wrptr(unsigned int val)
 	aml_write_cbus(AUDIN_FIFO1_RDPTR, val);
 }
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+void audio_set_i2s_mode(u32 mode, unsigned int channel)
+{
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x800);
+
+	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0);
+
+	if (8 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 1);
+
+		if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			/* todo: to verify it */
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+
+		} else if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+
+			aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0x5);
+		}
+	} else if (2 == channel) {
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 0);
+
+		if (mode == AIU_I2S_MODE_PCM16) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+						1 << 6);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM24) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
+		} else if (mode == AIU_I2S_MODE_PCM32) {
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+		}
+	}
+
+	/* In split mode, there are not mask control,
+	so aiu_mem_i2s_mask[15:0] must set 8'hffff_ffff. */
+	/*aml_write_cbus(AIU_MEM_I2S_MASKS,
+		(16 << 16) |
+		(0xff << 8) |
+		(0xff << 0));*/
+}
+#else
 void audio_set_i2s_mode(u32 mode)
 {
 	const unsigned short mask[4] = {
@@ -486,6 +625,7 @@ void audio_set_i2s_mode(u32 mode)
 		aml_cbus_update_bits(AIU_MEM_I2S_MASKS, 0xffff, mask[mode]);
 	}
 }
+#endif
 
 /*
  *  if normal clock, i2s clock is twice of 958 clock,
@@ -500,22 +640,24 @@ void audio_util_set_dac_format(unsigned format)
 	/* 958 divisor more, if true, divided by 2, 4, 6, 8. */
 	aml_write_cbus(AIU_CLK_CTRL, (0 << 12) |
 	/* alrclk skew: 1=alrclk transitions on the cycle before msb is sent */
-			(1 << 8) |
-			(1 << 6) |	/* invert aoclk */
-			(1 << 7) |	/* invert lrclk */
+		       (1 << 8) |
+		       (1 << 6) |
+	/* invert aoclk */
+		       (1 << 7) |
+	/* invert lrclk */
 #if OVERCLOCK == 1
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	       (1 << 4) |
+		       (1 << 4) |
 	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
-	       (3 << 2) |
+		       (3 << 2) |
 #else
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-			(1 << 4) |
+		       (1 << 4) |
 	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
-			(2 << 2) |
+		       (2 << 2) |
 #endif
-			(1 << 1) |	/* enable 958 clock */
-			(1 << 0));	/* enable I2S clock */
+		       (1 << 1) |	/* enable 958 clock */
+		       (1 << 0));	/* enable I2S clock */
 	if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP)
 		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 8, 1 << 8);
 	else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY)
@@ -569,11 +711,15 @@ void audio_util_set_dac_i2s_format(unsigned format)
 	if (dac_mute_const == 0x800000)
 		aml_write_cbus(AIU_I2S_DAC_CFG, 0x000f);
 	else
-	/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
+		/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
 		aml_write_cbus(AIU_I2S_DAC_CFG, 0x0007);
 
 	/* four 2-channel */
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, (1 << 11));
+#else
 	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x0001);
+#endif
 }
 
 /* set sclk and lrclk, mclk = 256fs. */
@@ -584,7 +730,7 @@ void audio_set_i2s_clk_div(void)
 	/* Set mclk over sclk ratio */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x3f << 8, (4 - 1) << 8);
 	/* set dac/adc lrclk ratio over sclk----64fs */
-        aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
+	aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
 	aml_cbus_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (64 - 1));
 	/* Enable sclk */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 14, 1 << 14);
@@ -618,13 +764,13 @@ void audio_enable_ouput(int flag)
 
 int if_audio_out_enable(void)
 {
-	return aml_read_cbus(AIU_MEM_I2S_CONTROL) & (0x3<<1);
+	return aml_read_cbus(AIU_MEM_I2S_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_audio_out_enable);
 
 int if_958_audio_out_enable(void)
 {
-	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (0x3<<1);
+	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_958_audio_out_enable);
 
@@ -723,7 +869,7 @@ void audio_hw_958_raw(void)
 	pr_info("\tLENGTH: %x\n", IEC958_length);
 	pr_info("\tPADDSIZE: %x\n", IEC958_length);
 	pr_info("\tsyncword: %x, %x, %x\n\n", IEC958_syncword1,
-				IEC958_syncword2, IEC958_syncword3);
+		IEC958_syncword2, IEC958_syncword3);
 
 }
 
@@ -759,44 +905,53 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 			aml_write_cbus(AIU_958_MISC, 1);
 			/* raw */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 1 << 8);
+					     1 << 8, 1 << 8);
 			/* 8bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0x1 << 3);
+					     0x7 << 3, 0x1 << 3);
 		}
 
 		pr_info("IEC958 RAW\n");
 	} else if (mode == AIU_958_MODE_PCM32) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 		}
 		pr_info("IEC958 PCM32\n");
 	} else if (mode == AIU_958_MODE_PCM24) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
 			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 
 		}
 		pr_info("IEC958 24bit\n");
@@ -805,20 +960,29 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 		if (ENABLE_IEC958) {
 			aml_write_cbus(AIU_958_MISC, 0x2042);
 			/* pcm */
-			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 8, 0);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
+#else
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+#endif
 			/* 16bit */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						1 << 7, 1 << 7);
+					     1 << 7, 1 << 7);
 			/* endian */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
-						0x7 << 3, 0);
+					     0x7 << 3, 0);
 		}
 		pr_info("IEC958 16bit\n");
 	}
 
 	audio_hw_958_reset(0, 1);
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	if (mode == AIU_958_MODE_PCM32)
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 1 << 8, 1 << 8);
+#endif
+
 	aml_write_cbus(AIU_958_FORCE_LEFT, 1);
 }
 
@@ -827,11 +991,12 @@ void audio_out_i2s_enable(unsigned flag)
 	if (flag) {
 		aml_write_cbus(AIU_RST_SOFT, 0x01);
 		aml_read_cbus(AIU_I2S_SYNC);
-		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL,
-				0x3 << 1, 0x3 << 1);
+		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0x3 << 1);
 		/* Maybe cause POP noise */
 		/* audio_i2s_unmute(); */
 	} else {
+		aml_write_cbus(AIU_RST_SOFT, 0x01);
+		aml_read_cbus(AIU_I2S_SYNC);
 		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0);
 
 		/* Maybe cause POP noise */
@@ -850,6 +1015,8 @@ void audio_hw_958_enable(unsigned flag)
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0x3 << 1);
 		} else {
+			aml_write_cbus(AIU_RST_SOFT, 0x04);
+			aml_write_cbus(AIU_958_FORCE_LEFT, 0);
 			aml_write_cbus(AIU_958_DCU_FF_CTRL, 0);
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 					     0);
@@ -870,12 +1037,19 @@ void audio_i2s_swap_left_right(unsigned int flag)
 		aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 1, flag << 1);
 
 	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3, flag);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3 << 2, flag << 2);
 }
 
 void audio_i2s_958_same_source(unsigned int same)
 {
 	aml_cbus_update_bits(AIU_I2S_MISC, 1 << 3, (!!same) << 3);
 }
+
+void set_hw_resample_source(int source)
+{
+	aml_cbus_update_bits(AUD_RESAMPLE_CTRL0, 1 << 29, source << 29);
+}
+EXPORT_SYMBOL(set_hw_resample_source);
 #if 0
 unsigned int audio_hdmi_init_ready(void)
 {
diff --git a/sound/soc/aml/m8/aml_audio_hw.h b/sound/soc/aml/m8/aml_audio_hw.h
index 90aee90..6b28d30 100644
--- a/sound/soc/aml/m8/aml_audio_hw.h
+++ b/sound/soc/aml/m8/aml_audio_hw.h
@@ -67,17 +67,17 @@ struct _aiu_958_raw_setting_t {
 
 enum {
 	I2SIN_MASTER_MODE = 0,
-	I2SIN_SLAVE_MODE  =   1<<0,
-	SPDIFIN_MODE   = 1<<1,
+	I2SIN_SLAVE_MODE = 1 << 0,
+	SPDIFIN_MODE = 1 << 1,
 };
 enum {
 	AML_AUDIO_NA = 0,
-	AML_AUDIO_SPDIFIN = 1<<0,
-	AML_AUDIO_SPDIFOUT = 1<<1,
-	AML_AUDIO_I2SIN = 1<<2,
-	AML_AUDIO_I2SOUT = 1<<3,
-	AML_AUDIO_PCMIN = 1<<4,
-	AML_AUDIO_PCMOUT = 1<<5,
+	AML_AUDIO_SPDIFIN = 1 << 0,
+	AML_AUDIO_SPDIFOUT = 1 << 1,
+	AML_AUDIO_I2SIN = 1 << 2,
+	AML_AUDIO_I2SOUT = 1 << 3,
+	AML_AUDIO_PCMIN = 1 << 4,
+	AML_AUDIO_PCMOUT = 1 << 5,
 };
 
 #define AUDIO_CLK_256FS             0
@@ -98,7 +98,6 @@ enum {
 #define AUDIO_CLK_FREQ_22		11
 #define AUDIO_CLK_FREQ_24		12
 
-
 #define AIU_958_MODE_RAW    0
 #define AIU_958_MODE_PCM16  1
 #define AIU_958_MODE_PCM24  2
@@ -115,7 +114,9 @@ enum {
 extern unsigned ENABLE_IEC958;
 extern unsigned IEC958_MODE;
 extern unsigned I2S_MODE;
+extern unsigned audio_in_source;
 
+void set_i2s_source(unsigned source);
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
 void audio_set_958outbuf(u32 addr, u32 size, int flag);
 void audio_in_i2s_set_buf(u32 addr, u32 size, u32 i2s_mode, u32 i2s_sync);
@@ -125,7 +126,11 @@ void audio_in_spdif_enable(int flag);
 unsigned int audio_in_i2s_rd_ptr(void);
 unsigned int audio_in_i2s_wr_ptr(void);
 unsigned int audio_in_spdif_wr_ptr(void);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+void audio_set_i2s_mode(u32 mode, unsigned int channel);
+#else
 void audio_set_i2s_mode(u32 mode);
+#endif
 void audio_set_i2s_clk_div(void);
 void audio_set_spdif_clk_div(void);
 void audio_enable_ouput(int flag);
@@ -156,7 +161,7 @@ void audio_mute_left_right(unsigned flag);
 void audio_i2s_958_same_source(unsigned int same);
 
 extern unsigned int IEC958_mode_codec;
-
+extern unsigned int clk81;
 
 /*OVERCLOCK == 1,our SOC privide 512fs mclk,OVERCLOCK == 0 ,256fs*/
 #define OVERCLOCK 0
@@ -168,10 +173,10 @@ extern unsigned int IEC958_mode_codec;
 #define MCLKFS_RATIO 256
 #endif
 
-#define I2S_PLL_SRC         1   /* MPLL0 */
+#define I2S_PLL_SRC         1	/* MPLL0 */
 #define MPLL_I2S_CNTL		HHI_MPLL_MP0
 
-#define I958_PLL_SRC        2   /* MPLL1 */
+#define I958_PLL_SRC        2	/* MPLL1 */
 #define MPLL_958_CNTL		HHI_MPLL_MP1
 
 #endif
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
index 2e2782d..524cfb5 100644
--- a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
@@ -15,6 +15,8 @@
  *
 */
 
+#define pr_fmt(fmt) "audio_pcm" fmt
+
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/errno.h>
@@ -24,15 +26,6 @@
 #include <linux/amlogic/sound/audin_regs.h>
 #include "aml_audio_hw_pcm2bt.h"
 
-/* #define PCM_DEBUG */
-
-#ifdef PCM_DEBUG
-#define pcm_debug           pr_info
-#else
-#define pcm_debug(fmt, ...) \
-	do {} while (0)
-#endif
-
 static unsigned int pcmin_buffer_addr;
 static unsigned int pcmin_buffer_size;
 
@@ -46,22 +39,22 @@ static uint32_t aml_read_cbus_bits(uint32_t reg, const uint32_t start,
 
 static void pcm_in_register_show(void)
 {
-	pcm_debug("PCMIN registers show:\n");
-	pcm_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START,
+	pr_debug("PCMIN registers show:\n");
+	pr_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START,
 		  aml_read_cbus(AUDIN_FIFO1_START));
-	pcm_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END,
+	pr_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END,
 		  aml_read_cbus(AUDIN_FIFO1_END));
-	pcm_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR,
+	pr_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR,
 		  aml_read_cbus(AUDIN_FIFO1_PTR));
-	pcm_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR,
+	pr_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR,
 		  aml_read_cbus(AUDIN_FIFO1_RDPTR));
-	pcm_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL,
+	pr_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL,
 		  aml_read_cbus(AUDIN_FIFO1_CTRL));
-	pcm_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1,
+	pr_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1,
 		  aml_read_cbus(AUDIN_FIFO1_CTRL1));
-	pcm_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0,
+	pr_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0,
 		  aml_read_cbus(PCMIN_CTRL0));
-	pcm_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1,
+	pr_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1,
 		  aml_read_cbus(PCMIN_CTRL1));
 }
 
@@ -134,7 +127,7 @@ void pcm_in_enable(int flag)
 	       (1 << 0));	/* left justified */
 	}
 
-	pcm_debug("PCMIN %s\n", flag ? "enable" : "disable");
+	pr_debug("PCMIN %s\n", flag ? "enable" : "disable");
 	pcm_in_register_show();
 }
 
@@ -143,7 +136,7 @@ void pcm_in_set_buf(unsigned int addr, unsigned int size)
 	pcmin_buffer_addr = addr;
 	pcmin_buffer_size = size;
 
-	pcm_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n",
+	pr_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n",
 		  pcmin_buffer_addr, pcmin_buffer_size);
 }
 
@@ -157,7 +150,7 @@ int pcm_in_is_enable(void)
 unsigned int pcm_in_rd_ptr(void)
 {
 	unsigned int value = aml_read_cbus(AUDIN_FIFO1_RDPTR);
-	pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
+	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
 
 	return value;
 }
@@ -166,7 +159,7 @@ unsigned int pcm_in_set_rd_ptr(unsigned int value)
 {
 	unsigned int old = aml_read_cbus(AUDIN_FIFO1_RDPTR);
 	aml_write_cbus(AUDIN_FIFO1_RDPTR, value);
-	pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
+	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
 
 	return old;
 }
@@ -181,7 +174,7 @@ unsigned int pcm_in_wr_ptr(void)
 
 	aml_write_cbus(AUDIN_FIFO1_PTR, 1);
 	written = aml_read_cbus(AUDIN_FIFO1_PTR);
-	pcm_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
+	pr_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
 
 	/* value = written; */
 	value = written & (~0x07);
@@ -192,33 +185,33 @@ unsigned int pcm_in_fifo_int(void)
 {
 	unsigned int value = 0;
 	value = aml_read_cbus(AUDIN_FIFO_INT);
-	pcm_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
+	pr_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
 
 	return value;
 }
 
 static void pcm_out_register_show(void)
 {
-	pcm_debug("PCMOUT registers show:\n");
-	pcm_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA,
+	pr_debug("PCMOUT registers show:\n");
+	pr_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA,
 		  aml_read_cbus(AUDOUT_BUF0_STA));
-	pcm_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA,
+	pr_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA,
 		  aml_read_cbus(AUDOUT_BUF0_EDA));
-	pcm_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR,
+	pr_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR,
 		  aml_read_cbus(AUDOUT_BUF0_WPTR));
-	pcm_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR,
+	pr_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR,
 		  aml_read_cbus(AUDOUT_FIFO_RPTR));
-	pcm_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL,
+	pr_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL,
 		  aml_read_cbus(AUDOUT_CTRL));
-	pcm_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1,
+	pr_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1,
 		  aml_read_cbus(AUDOUT_CTRL1));
-	pcm_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0,
+	pr_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0,
 		  aml_read_cbus(PCMOUT_CTRL0));
-	pcm_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1,
+	pr_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1,
 		  aml_read_cbus(PCMOUT_CTRL1));
-	pcm_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2,
+	pr_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2,
 		  aml_read_cbus(PCMOUT_CTRL2));
-	pcm_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3,
+	pr_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3,
 		  aml_read_cbus(PCMOUT_CTRL3));
 }
 
@@ -313,7 +306,7 @@ void pcm_out_enable(int flag)
 			(0 << 0));
 	}
 
-	pcm_debug("PCMOUT %s\n", flag ? "enable" : "disable");
+	pr_debug("PCMOUT %s\n", flag ? "enable" : "disable");
 	pcm_out_register_show();
 }
 
@@ -328,7 +321,7 @@ void pcm_out_set_buf(unsigned int addr, unsigned int size)
 	pcmout_buffer_addr = addr;
 	pcmout_buffer_size = size;
 
-	pcm_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n",
+	pr_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n",
 		  pcmout_buffer_addr, pcmout_buffer_size);
 }
 
@@ -349,7 +342,7 @@ int pcm_out_is_mute(void)
 unsigned int pcm_out_rd_ptr(void)
 {
 	unsigned int value = aml_read_cbus(AUDOUT_FIFO_RPTR);
-	pcm_debug("PCMOUT read pointer: 0x%08x\n", value);
+	pr_debug("PCMOUT read pointer: 0x%08x\n", value);
 
 	return value;
 }
@@ -358,7 +351,7 @@ unsigned int pcm_out_wr_ptr(void)
 {
 	unsigned int value = 0;
 	value = aml_read_cbus(AUDOUT_BUF0_WPTR);
-	pcm_debug("PCMOUT write pointer: 0x%08x\n", value);
+	pr_debug("PCMOUT write pointer: 0x%08x\n", value);
 	return value;
 }
 
@@ -366,7 +359,7 @@ unsigned int pcm_out_set_wr_ptr(unsigned int value)
 {
 	unsigned int old = aml_read_cbus(AUDOUT_BUF0_WPTR);
 	aml_write_cbus(AUDOUT_BUF0_WPTR, value);
-	pcm_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
+	pr_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
 
 	return old;
 }
diff --git a/sound/soc/aml/m8/aml_g9tv.c b/sound/soc/aml/m8/aml_g9tv.c
new file mode 100644
index 0000000..c481d4f
--- /dev/null
+++ b/sound/soc/aml/m8/aml_g9tv.c
@@ -0,0 +1,1082 @@
+/*
+ * sound/soc/aml/g9tv/aml_g9tv.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define pr_fmt(fmt) "aml_g9tv: " fmt
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+#include <sound/tas57xx.h>
+#include <linux/switch.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/sound/audin_regs.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/io.h>
+#include <linux/amlogic/cpu_version.h>
+
+#include "aml_i2s.h"
+#include "aml_audio_hw.h"
+#include "aml_g9tv.h"
+
+#define DRV_NAME "aml_snd_card_g9tv"
+
+int aml_audio_Hardware_resample = 0;
+unsigned int clk_rate = 0;
+
+static const char *const audio_in_source_texts[] = { "LINEIN", "ATV", "HDMI" };
+
+static const struct soc_enum audio_in_source_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(audio_in_source_texts),
+			audio_in_source_texts);
+
+static int aml_audio_get_in_source(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	int value = aml_read_cbus(AUDIN_SOURCE_SEL) & 0x3;
+
+	if (value == 0)
+		ucontrol->value.enumerated.item[0] = 0;
+	else if (value == 1)
+		ucontrol->value.enumerated.item[0] = 1;
+	else if (value == 2)
+		ucontrol->value.enumerated.item[0] = 2;
+	return 0;
+}
+
+static int aml_audio_set_in_source(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		if (is_meson_txl_cpu()) {
+			/* select internal acodec output in TXL as I2S source */
+			aml_write_cbus(AUDIN_SOURCE_SEL, 3);
+		} else
+			/* select external codec output as I2S source */
+			aml_write_cbus(AUDIN_SOURCE_SEL, 0);
+		audio_in_source = 0;
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		/* select ATV output as I2S source */
+		aml_write_cbus(AUDIN_SOURCE_SEL, 1);
+		audio_in_source = 1;
+	} else if (ucontrol->value.enumerated.item[0] == 2) {
+		/* select HDMI-rx as I2S source */
+		/* [14:12]cntl_hdmirx_chsts_sel: */
+		/* 0=Report chan1 status; 1=Report chan2 status */
+		/* [11:8] cntl_hdmirx_chsts_en */
+		/* [5:4] spdif_src_sel:*/
+		/* 1=Select HDMIRX SPDIF output as AUDIN source */
+		/* [1:0] i2sin_src_sel: */
+		/*2=Select HDMIRX I2S output as AUDIN source */
+		aml_write_cbus(AUDIN_SOURCE_SEL, (0 << 12) |
+			       (0xf << 8) | (1 << 4) | (2 << 0));
+		audio_in_source = 2;
+	}
+	set_i2s_source(audio_in_source);
+	return 0;
+}
+
+/* i2s audio format detect: LPCM or NONE-LPCM */
+static const char *const i2s_audio_type_texts[] = {
+	"LPCM", "NONE-LPCM", "UN-KNOWN"
+};
+static const struct soc_enum i2s_audio_type_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(i2s_audio_type_texts),
+			i2s_audio_type_texts);
+
+static int aml_i2s_audio_type_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int ch_status = 0;
+
+	if ((aml_read_cbus(AUDIN_DECODE_CONTROL_STATUS) >> 24) & 0x1) {
+		ch_status = aml_read_cbus(AUDIN_DECODE_CHANNEL_STATUS_A_0);
+		if (ch_status & 2)
+			ucontrol->value.enumerated.item[0] = 1;
+		else
+			ucontrol->value.enumerated.item[0] = 0;
+	} else {
+		ucontrol->value.enumerated.item[0] = 2;
+	}
+	return 0;
+}
+
+static int aml_i2s_audio_type_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	return 0;
+}
+
+/* spdif in audio format detect: LPCM or NONE-LPCM */
+struct sppdif_audio_info {
+	unsigned char aud_type;
+	/*IEC61937 package presamble Pc value*/
+	short pc;
+	char *aud_type_str;
+};
+static const char *const spdif_audio_type_texts[] = {
+	"LPCM",
+	"AC3",
+	"EAC3",
+	"DTS",
+	"DTS-HD",
+	"TRUEHD",
+};
+static const struct sppdif_audio_info type_texts[] = {
+	{0, 0, "LPCM"},
+	{1, 0x1, "AC3"},
+	{2, 0x15, "EAC3"},
+	{3, 0xb, "DTS-I"},
+	{3, 0x0c, "DTS-II"},
+	{3, 0x0d, "DTS-III"},
+	{3, 0x11, "DTS-IV"},
+	{4, 0, "DTS-HD"},
+	{5, 0x16, "TRUEHD"},
+};
+static const struct soc_enum spdif_audio_type_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(spdif_audio_type_texts),
+			spdif_audio_type_texts);
+
+static int aml_spdif_audio_type_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int audio_type = 0;
+	int i;
+	int total_num = sizeof(type_texts)/sizeof(struct sppdif_audio_info);
+	int pc = aml_read_cbus(AUDIN_SPDIF_NPCM_PCPD)>>16;
+	pc = pc&0xff;
+	for (i = 0; i < total_num; i++) {
+		if (pc == type_texts[i].pc) {
+			audio_type = type_texts[i].aud_type;
+			break;
+		}
+	}
+	ucontrol->value.enumerated.item[0] = audio_type;
+	return 0;
+}
+
+static int aml_spdif_audio_type_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	return 0;
+}
+
+int hardware_resample_locked_flag = 0;
+#define RESAMPLE_BUFFER_SOURCE 1
+/*Cnt_ctrl = mclk/fs_out-1 ; fest 256fs */
+#define RESAMPLE_CNT_CONTROL 255
+
+static int hardware_resample_enable(int input_sr)
+{
+	u16 Avg_cnt_init = 0;
+	unsigned int clk_rate = clk81;
+
+	if (hardware_resample_locked_flag == 1)
+		return 0;
+
+	if (input_sr < 8000 || input_sr > 48000) {
+		pr_err("Error input sample rate,input_sr = %d!\n", input_sr);
+		return -1;
+	}
+
+	Avg_cnt_init = (u16)(clk_rate * 4 / input_sr);
+	pr_info("clk_rate = %u, input_sr = %d, Avg_cnt_init = %u\n",
+		clk_rate, input_sr, Avg_cnt_init);
+
+	if (is_meson_txl_cpu()) {
+		int pause_cnt_thd = 256;
+		aml_write_cbus(AUD_RESAMPLE_CTRL2,
+				(1 << 31)
+				| pause_cnt_thd);
+	}
+
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, (1 << 31));
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, 0);
+	aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				(1 << 29)
+				| (1 << 28)
+				| (0 << 26)
+				| (RESAMPLE_CNT_CONTROL << 16)
+				| Avg_cnt_init);
+
+	return 0;
+}
+
+static int hardware_resample_disable(void)
+{
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, 0);
+	return 0;
+}
+
+static const char *const hardware_resample_texts[] = {
+	"Disable",
+	"Enable:48K",
+	"Enable:44K",
+	"Enable:32K",
+	"Lock Resample",
+	"Unlock Resample"
+};
+
+static const struct soc_enum hardware_resample_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(hardware_resample_texts),
+			hardware_resample_texts);
+
+static int aml_hardware_resample_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = aml_audio_Hardware_resample;
+	return 0;
+}
+
+static int aml_hardware_resample_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		hardware_resample_disable();
+		aml_audio_Hardware_resample = 0;
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		hardware_resample_enable(48000);
+		aml_audio_Hardware_resample = 1;
+	} else if (ucontrol->value.enumerated.item[0] == 2) {
+		hardware_resample_enable(44100);
+		aml_audio_Hardware_resample = 2;
+	} else if (ucontrol->value.enumerated.item[0] == 3) {
+		hardware_resample_enable(32000);
+		aml_audio_Hardware_resample = 3;
+	} else if (ucontrol->value.enumerated.item[0] == 4) {
+		hardware_resample_disable();
+		aml_audio_Hardware_resample = 4;
+		hardware_resample_locked_flag = 1;
+	} else if (ucontrol->value.enumerated.item[0] == 5) {
+		hardware_resample_locked_flag = 0;
+		hardware_resample_enable(48000);
+		aml_audio_Hardware_resample = 5;
+	}
+	return 0;
+}
+
+static const char *const output_swap_texts[] = { "L/R", "L/L", "R/R", "R/L" };
+
+static const struct soc_enum output_swap_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(output_swap_texts),
+			output_swap_texts);
+
+static int aml_output_swap_get_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = read_i2s_mute_swap_reg();
+	return 0;
+}
+
+static int aml_output_swap_set_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	audio_i2s_swap_left_right(ucontrol->value.enumerated.item[0]);
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("LINEIN"),
+	SND_SOC_DAPM_OUTPUT("LINEOUT"),
+};
+
+int audio_in_GPIO = 0;
+struct gpio_desc *av_source;
+static const char * const audio_in_switch_texts[] = { "AV", "Karaok"};
+
+static const struct soc_enum audio_in_switch_enum = SOC_ENUM_SINGLE(
+		SND_SOC_NOPM, 0, ARRAY_SIZE(audio_in_switch_texts),
+		audio_in_switch_texts);
+
+static int aml_get_audio_in_switch(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol) {
+
+	if (audio_in_GPIO == 0) {
+		ucontrol->value.enumerated.item[0] = 0;
+		pr_info("audio in source: AV\n");
+	} else if (audio_in_GPIO == 1) {
+		ucontrol->value.enumerated.item[0] = 1;
+		pr_info("audio in source: Karaok\n");
+	}
+	return 0;
+}
+
+static int aml_set_audio_in_switch(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol) {
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		gpiod_direction_output(av_source,
+					   GPIOF_OUT_INIT_LOW);
+		audio_in_GPIO = 0;
+		pr_info("Set audio in source: AV\n");
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		gpiod_direction_output(av_source,
+					   GPIOF_OUT_INIT_HIGH);
+		audio_in_GPIO = 1;
+		pr_info("Set audio in source: Karaok\n");
+	}
+	return 0;
+}
+
+static const struct snd_kcontrol_new av_controls[] = {
+	SOC_ENUM_EXT("AudioIn Switch",
+			 audio_in_switch_enum,
+			 aml_get_audio_in_switch,
+			 aml_set_audio_in_switch),
+};
+
+static const struct snd_kcontrol_new aml_g9tv_controls[] = {
+	SOC_ENUM_EXT("Audio In Source",
+		     audio_in_source_enum,
+		     aml_audio_get_in_source,
+		     aml_audio_set_in_source),
+
+	SOC_ENUM_EXT("I2SIN Audio Type",
+		     i2s_audio_type_enum,
+		     aml_i2s_audio_type_get_enum,
+		     aml_i2s_audio_type_set_enum),
+
+	SOC_ENUM_EXT("SPDIFIN Audio Type",
+		     spdif_audio_type_enum,
+		     aml_spdif_audio_type_get_enum,
+		     aml_spdif_audio_type_set_enum),
+
+	SOC_ENUM_EXT("Hardware resample enable",
+		     hardware_resample_enum,
+		     aml_hardware_resample_get_enum,
+		     aml_hardware_resample_set_enum),
+
+	SOC_ENUM_EXT("Output Swap",
+		     output_swap_enum,
+		     aml_output_swap_get_enum,
+		     aml_output_swap_set_enum),
+};
+
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	pr_info("enter %s\n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+	pr_info("enter %s\n", __func__);
+	return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+	pr_info("enter %s\n", __func__);
+	return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	pr_info("enter %s\n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+	return 0;
+}
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai,
+				  SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_IB_NF
+				  | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0) {
+		pr_err("%s: set cpu dai fmt failed!\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+	.hw_params	= aml_asoc_hw_params,
+};
+
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct aml_audio_private_data *p_aml_audio;
+	int ret = 0;
+
+	pr_info("enter %s\n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+	ret = snd_soc_add_card_controls(codec->card, aml_g9tv_controls,
+					ARRAY_SIZE(aml_g9tv_controls));
+	if (ret)
+		return ret;
+
+	/* Add specific widgets */
+	snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+				  ARRAY_SIZE(aml_asoc_dapm_widgets));
+
+	return 0;
+}
+
+static void aml_g9tv_pinmux_init(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	p_aml_audio->pin_ctl =
+		devm_pinctrl_get_select(card->dev, "aml_snd_g9tv");
+	if (IS_ERR(p_aml_audio->pin_ctl)) {
+		pr_info("%s, aml_g9tv_pinmux_init error!\n", __func__);
+		return;
+	}
+
+	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
+	if (!IS_ERR(p_aml_audio->mute_desc)) {
+		pr_info("%s, make avmute gpio high!\n", __func__);
+		gpiod_direction_output(p_aml_audio->mute_desc,
+					   GPIOF_OUT_INIT_HIGH);
+	}
+
+	av_source = gpiod_get(card->dev, "av_source");
+	if (!IS_ERR(av_source)) {
+		pr_info("%s, make av_source gpio low!\n", __func__);
+		gpiod_direction_output(av_source, GPIOF_OUT_INIT_LOW);
+		snd_soc_add_card_controls(card, av_controls,
+					ARRAY_SIZE(av_controls));
+	}
+	return;
+}
+
+static int aml_card_dai_parse_of(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 int (*init)(
+					 struct snd_soc_pcm_runtime *rtd),
+				 struct device_node *cpu_node,
+				 struct device_node *codec_node,
+				 struct device_node *plat_node)
+{
+	int ret;
+
+	/* get cpu dai->name */
+	ret = snd_soc_of_get_dai_name(cpu_node, &dai_link->cpu_dai_name);
+	if (ret < 0)
+		goto parse_error;
+
+	/* get codec dai->name */
+	ret = snd_soc_of_get_dai_name(codec_node, &dai_link->codec_dai_name);
+	if (ret < 0)
+		goto parse_error;
+
+	dai_link->name = dai_link->stream_name = dai_link->cpu_dai_name;
+	dai_link->codec_of_node = of_parse_phandle(codec_node, "sound-dai", 0);
+	dai_link->platform_of_node = plat_node;
+	dai_link->init = init;
+
+	return 0;
+
+parse_error:
+	return ret;
+}
+
+struct snd_soc_aux_dev g9tv_audio_aux_dev;
+static struct snd_soc_codec_conf g9tv_audio_codec_conf[] = {
+	{
+		.name_prefix = "AMP",
+	},
+};
+static struct codec_probe_priv prob_priv;
+static struct codec_info codec_info_aux;
+
+static int get_audio_codec_i2c_info(struct device_node *p_node,
+				struct aml_audio_codec_info *audio_codec_dev)
+{
+	const char *str;
+	int ret = 0;
+	unsigned i2c_addr;
+
+	ret = of_property_read_string(p_node, "codec_name",
+				      &audio_codec_dev->name);
+	if (ret) {
+		pr_info("get audio codec name failed!\n");
+		goto err_out;
+	}
+
+	ret = of_property_match_string(p_node, "status", "okay");
+	if (ret) {
+		pr_info("%s:this audio codec is disabled!\n",
+			audio_codec_dev->name);
+		goto err_out;
+	}
+
+	pr_debug("use audio aux codec %s\n", audio_codec_dev->name);
+
+	ret = of_property_read_string(p_node, "i2c_bus", &str);
+	if (ret) {
+		pr_err("%s: faild to get i2c_bus str,use default i2c bus!\n",
+		       audio_codec_dev->name);
+		audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
+	} else {
+		if (!strncmp(str, "i2c_bus_a", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_A;
+		else if (!strncmp(str, "i2c_bus_b", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_B;
+		else if (!strncmp(str, "i2c_bus_c", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_C;
+		else if (!strncmp(str, "i2c_bus_d", 9))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
+		else if (!strncmp(str, "i2c_bus_ao", 10))
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_AO;
+		else
+			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
+	}
+
+	ret = of_property_read_u32(p_node, "i2c_addr", &i2c_addr);
+	if (!ret)
+		audio_codec_dev->i2c_addr = i2c_addr;
+	/*pr_info("audio aux codec addr: 0x%x, audio codec i2c bus: %d\n",
+	 *      audio_codec_dev->i2c_addr, audio_codec_dev->i2c_bus_type);*/
+err_out:
+	return ret;
+}
+
+static char drc1_table[15] = "drc1_table_0";
+static char drc1_tko_table[20] = "drc1_tko_table_0";
+static char drc2_table[15] = "drc2_table_0";
+static char drc2_tko_table[20] = "drc2_tko_table_0";
+static int aml_drc_type_select(char *s)
+{
+	char *sel = s;
+
+	if (NULL != s) {
+		sprintf(drc1_table, "%s%s", "drc1_table_", sel);
+		sprintf(drc1_tko_table, "%s%s", "drc1_tko_table_", sel);
+		sprintf(drc2_table, "%s%s", "drc2_table_", sel);
+		sprintf(drc2_tko_table, "%s%s", "drc2_tko_table_", sel);
+		pr_info("select drc type: %s\n", sel);
+	}
+	return 0;
+}
+__setup("amp_drc_type=", aml_drc_type_select);
+
+static char table[10] = "table_0";
+static char wall[10] = "wall_0";
+static char sub_bq_table[20] = "sub_bq_table_0";
+static int aml_eq_type_select(char *s)
+{
+	char *sel = s;
+
+	if (NULL != s) {
+		sprintf(table, "%s%s", "table_", sel);
+		sprintf(wall, "%s%s", "wall_", sel);
+		sprintf(sub_bq_table, "%s%s", "sub_bq_table_", sel);
+		pr_info("select eq type: %s\n", sel);
+	}
+	return 0;
+}
+__setup("amp_eq_type=", aml_eq_type_select);
+
+static void *alloc_and_get_data_array(struct device_node *p_node, char *str,
+				      int *lenp)
+{
+	int ret = 0, length = 0;
+	char *p = NULL;
+
+	if (of_find_property(p_node, str, &length) == NULL) {
+		pr_err("DTD of %s not found!\n", str);
+		goto exit;
+	}
+	pr_debug("prop name=%s,length=%d\n", str, length);
+	p = kzalloc(length * sizeof(char *), GFP_KERNEL);
+	if (p == NULL) {
+		pr_err("ERROR, NO enough mem for %s!\n", str);
+		length = 0;
+		goto exit;
+	}
+
+	ret = of_property_read_u8_array(p_node, str, p, length);
+	if (ret) {
+		pr_err("no of property %s!\n", str);
+		kfree(p);
+		p = NULL;
+		goto exit;
+	}
+
+	*lenp = length;
+
+exit: return p;
+}
+
+static int of_get_eq_pdata(struct tas57xx_platform_data *pdata,
+			   struct device_node *p_node)
+{
+	int length = 0;
+	char *regs = NULL;
+	int ret = 0;
+
+	ret = of_property_read_u32(p_node, "eq_enable", &pdata->eq_enable);
+	if (pdata->eq_enable == 0 || ret != 0) {
+		pr_err("Fail to get eq_enable node or EQ disable!\n");
+		return -2;
+	}
+
+	prob_priv.num_eq = 2;
+	pdata->num_eq_cfgs = prob_priv.num_eq;
+
+	prob_priv.eq_configs = kzalloc(
+		prob_priv.num_eq * sizeof(struct tas57xx_eq_cfg), GFP_KERNEL);
+
+	regs = alloc_and_get_data_array(p_node, table, &length);
+	if (regs == NULL) {
+		kfree(prob_priv.eq_configs);
+		return -2;
+	}
+	strncpy(prob_priv.eq_configs[0].name, table, NAME_SIZE);
+	prob_priv.eq_configs[0].regs = regs;
+	prob_priv.eq_configs[0].reg_bytes = length;
+
+	regs = alloc_and_get_data_array(p_node, wall, &length);
+	if (regs == NULL) {
+		kfree(prob_priv.eq_configs);
+		return -2;
+	}
+	strncpy(prob_priv.eq_configs[1].name, wall, NAME_SIZE);
+	prob_priv.eq_configs[1].regs = regs;
+	prob_priv.eq_configs[1].reg_bytes = length;
+
+	pdata->eq_cfgs = prob_priv.eq_configs;
+	return 0;
+}
+
+static int of_get_drc_pdata(struct tas57xx_platform_data *pdata,
+			    struct device_node *p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+	int ret = 0;
+
+	ret = of_property_read_u32(p_node, "drc_enable", &pdata->drc_enable);
+	if (pdata->drc_enable == 0 || ret != 0) {
+		pr_err("Fail to get drc_enable node or DRC disable!\n");
+		return -2;
+	}
+
+	/* get drc1 table */
+	pd = alloc_and_get_data_array(p_node, drc1_table, &length);
+	if (pd == NULL)
+		return -2;
+	pdata->custom_drc1_table_len = length;
+	pdata->custom_drc1_table = pd;
+
+	/* get drc1 tko table */
+	length = 0;
+	pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, drc1_tko_table, &length);
+	if (pd == NULL)
+		return -2;
+	pdata->custom_drc1_tko_table_len = length;
+	pdata->custom_drc1_tko_table = pd;
+	pdata->enable_ch1_drc = 1;
+
+	/* get drc2 table */
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, drc2_table, &length);
+	if (pd == NULL)
+		return -1;
+	pdata->custom_drc2_table_len = length;
+	pdata->custom_drc2_table = pd;
+
+	/* get drc2 tko table */
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, drc2_tko_table, &length);
+	if (pd == NULL)
+		return -1;
+	pdata->custom_drc2_tko_table_len = length;
+	pdata->custom_drc2_tko_table = pd;
+	pdata->enable_ch2_drc = 1;
+
+	return 0;
+}
+
+static int of_get_init_pdata(struct tas57xx_platform_data *pdata,
+			     struct device_node *p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, "input_mux_reg_buf", &length);
+	if (pd == NULL) {
+		pr_err("%s : can't get input_mux_reg_buf\n", __func__);
+		return -1;
+	}
+
+	/*Now only support 0x20 input mux init*/
+	pdata->num_init_regs = length;
+	pdata->init_regs = pd;
+
+	if (of_property_read_u32(p_node, "master_vol",
+				 &pdata->custom_master_vol)) {
+		pr_err("%s fail to get master volume\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int of_get_resetpin_pdata(struct tas57xx_platform_data *pdata,
+				 struct device_node *p_node)
+{
+	struct gpio_desc *reset_desc;
+
+	reset_desc = of_get_named_gpiod_flags(p_node, "reset_pin", 0, NULL);
+	if (IS_ERR(reset_desc)) {
+		pr_err("%s fail to get reset pin from dts!\n", __func__);
+	} else {
+		int reset_pin = desc_to_gpio(reset_desc);
+		gpio_request(reset_pin, NULL);
+		gpio_direction_output(reset_pin, GPIOF_OUT_INIT_LOW);
+		pdata->reset_pin = reset_pin;
+		pr_info("%s pdata->reset_pin = %d!\n", __func__,
+			pdata->reset_pin);
+	}
+	return 0;
+}
+
+static int of_get_phonepin_pdata(struct tas57xx_platform_data *pdata,
+				 struct device_node *p_node)
+{
+	struct gpio_desc *phone_desc;
+	phone_desc = of_get_named_gpiod_flags(p_node, "phone_pin", 0, NULL);
+	if (IS_ERR(phone_desc)) {
+		pr_err("%s fail to get phone pin from dts!\n", __func__);
+	} else {
+		int phone_pin = desc_to_gpio(phone_desc);
+		gpio_request(phone_pin, NULL);
+		gpio_direction_output(phone_pin, GPIOF_OUT_INIT_LOW);
+		pdata->phone_pin = phone_pin;
+		pr_info("%s pdata->phone_pin = %d!\n", __func__,
+			pdata->phone_pin);
+	}
+	return 0;
+}
+static int of_get_scanpin_pdata(struct tas57xx_platform_data *pdata,
+				 struct device_node *p_node)
+{
+	struct gpio_desc *scan_desc;
+	scan_desc = of_get_named_gpiod_flags(p_node, "scan_pin", 0, NULL);
+	if (IS_ERR(scan_desc)) {
+		pr_err("%s fail to get scan pin from dts!\n", __func__);
+	} else {
+		int scan_pin = desc_to_gpio(scan_desc);
+		gpio_request(scan_pin, NULL);
+		gpio_direction_input(scan_pin);
+		pdata->scan_pin = scan_pin;
+		pr_info("%s pdata->scan_pin = %d!\n", __func__,
+			pdata->scan_pin);
+	}
+	return 0;
+}
+
+static int codec_get_of_pdata(struct tas57xx_platform_data *pdata,
+			      struct device_node *p_node)
+{
+	int ret = 0;
+
+	ret = of_get_resetpin_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec reset pin is not found in dts\n");
+	ret = of_get_phonepin_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec phone pin is not found in dtd\n");
+
+	ret = of_get_scanpin_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec scanp pin is not found in dtd\n");
+
+	ret = of_get_drc_pdata(pdata, p_node);
+	if (ret == -2)
+		pr_info("codec DRC configs are not found in dts\n");
+
+	ret = of_get_eq_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec EQ configs are not found in dts\n");
+
+	ret = of_get_init_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec init configs are not found in dts\n");
+	return ret;
+}
+
+static int aml_aux_dev_parse_of(struct snd_soc_card *card)
+{
+	struct device_node *audio_codec_node = card->dev->of_node;
+	struct device_node *child;
+	struct i2c_board_info board_info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	struct aml_audio_codec_info temp_audio_codec;
+	struct tas57xx_platform_data *pdata;
+	char tmp[I2C_NAME_SIZE];
+	const char *aux_dev;
+	if (of_property_read_string(audio_codec_node, "aux_dev", &aux_dev)) {
+		pr_info("no aux dev!\n");
+		return -ENODEV;
+	}
+	pr_info("aux name = %s\n", aux_dev);
+	child = of_get_child_by_name(audio_codec_node, aux_dev);
+	if (child == NULL) {
+		pr_info("error: failed to find aux dev node %s\n", aux_dev);
+		return -1;
+	}
+
+	memset(&temp_audio_codec, 0, sizeof(struct aml_audio_codec_info));
+	/*pr_info("%s, child name:%s\n", __func__, child->name);*/
+
+	if (get_audio_codec_i2c_info(child, &temp_audio_codec) == 0) {
+		memset(&board_info, 0, sizeof(board_info));
+		strncpy(board_info.type, temp_audio_codec.name, I2C_NAME_SIZE);
+		adapter = i2c_get_adapter(temp_audio_codec.i2c_bus_type);
+		board_info.addr = temp_audio_codec.i2c_addr;
+		board_info.platform_data = &temp_audio_codec;
+		client = i2c_new_device(adapter, &board_info);
+		snprintf(tmp, I2C_NAME_SIZE, "%s", temp_audio_codec.name);
+		strlcpy(codec_info_aux.name, tmp, I2C_NAME_SIZE);
+		snprintf(tmp, I2C_NAME_SIZE, "%s.%s", temp_audio_codec.name,
+				dev_name(&client->dev));
+		strlcpy(codec_info_aux.name_bus, tmp, I2C_NAME_SIZE);
+
+		g9tv_audio_aux_dev.name = codec_info_aux.name;
+		g9tv_audio_aux_dev.codec_name = codec_info_aux.name_bus;
+		g9tv_audio_codec_conf[0].dev_name = codec_info_aux.name_bus;
+
+		card->aux_dev = &g9tv_audio_aux_dev,
+		card->num_aux_devs = 1,
+		card->codec_conf = g9tv_audio_codec_conf,
+		card->num_configs = ARRAY_SIZE(g9tv_audio_codec_conf),
+
+		pdata =
+			kzalloc(sizeof(struct tas57xx_platform_data),
+				GFP_KERNEL);
+		if (!pdata) {
+			pr_err("error: malloc tas57xx_platform_data!\n");
+			return -ENOMEM;
+		}
+		codec_get_of_pdata(pdata, child);
+		client->dev.platform_data = pdata;
+	}
+	return 0;
+}
+static int aml_card_dais_parse_of(struct snd_soc_card *card)
+{
+	struct device_node *np = card->dev->of_node;
+	struct device_node *cpu_node, *codec_node, *plat_node;
+	struct device *dev = card->dev;
+	struct snd_soc_dai_link *dai_links;
+	int num_dai_links, cpu_num, codec_num, plat_num;
+	int i, ret;
+
+	int (*init)(struct snd_soc_pcm_runtime *rtd);
+
+	ret = of_count_phandle_with_args(np, "cpu_list", NULL);
+	if (ret < 0) {
+		dev_err(dev, "AML sound card no cpu_list errno: %d\n", ret);
+		goto err;
+	} else {
+		cpu_num = ret;
+	}
+	ret = of_count_phandle_with_args(np, "codec_list", NULL);
+	if (ret < 0) {
+		dev_err(dev, "AML sound card no codec_list errno: %d\n", ret);
+		goto err;
+	} else {
+		codec_num = ret;
+	}
+	ret = of_count_phandle_with_args(np, "plat_list", NULL);
+	if (ret < 0) {
+		dev_err(dev, "AML sound card no plat_list errno: %d\n", ret);
+		goto err;
+	} else {
+		plat_num = ret;
+	}
+	if ((cpu_num == codec_num) && (cpu_num == plat_num)) {
+		num_dai_links = cpu_num;
+	} else {
+		dev_err(dev,
+			"AML sound card cpu_dai num, codec_dai num, platform num don't match: %d\n",
+			ret);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	dai_links =
+		devm_kzalloc(dev,
+			     num_dai_links * sizeof(struct snd_soc_dai_link),
+			     GFP_KERNEL);
+	if (!dai_links) {
+		dev_err(dev, "Can't allocate snd_soc_dai_links\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	card->dai_link = dai_links;
+	card->num_links = num_dai_links;
+	for (i = 0; i < num_dai_links; i++) {
+		init = NULL;
+		/* CPU sub-node */
+		cpu_node = of_parse_phandle(np, "cpu_list", i);
+		if (cpu_node < 0) {
+			dev_err(dev, "parse aml sound card cpu list error\n");
+			return -EINVAL;
+		}
+		/* CODEC sub-node */
+		codec_node = of_parse_phandle(np, "codec_list", i);
+		if (codec_node < 0) {
+			dev_err(dev, "parse aml sound card codec list error\n");
+			return ret;
+		}
+		/* Platform sub-node */
+		plat_node = of_parse_phandle(np, "plat_list", i);
+		if (plat_node < 0) {
+			dev_err(dev,
+				"parse aml sound card platform list error\n");
+			return ret;
+		}
+		if (i == 0)
+			init = aml_asoc_init;
+
+		ret =
+			aml_card_dai_parse_of(dev, &dai_links[i], init,
+					      cpu_node,
+					      codec_node, plat_node);
+
+		dai_links[0].ops = &aml_asoc_ops;
+	}
+
+err:
+	return ret;
+}
+
+static int aml_g9tv_audio_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_soc_card *card;
+	struct aml_audio_private_data *p_aml_audio;
+	int ret;
+
+	p_aml_audio =
+		devm_kzalloc(dev, sizeof(struct aml_audio_private_data),
+			     GFP_KERNEL);
+	if (!p_aml_audio) {
+		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	card = devm_kzalloc(dev, sizeof(struct snd_soc_card), GFP_KERNEL);
+	if (!card) {
+		dev_err(dev, "Can't allocate snd_soc_card\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	snd_soc_card_set_drvdata(card, p_aml_audio);
+
+	card->dev = dev;
+	platform_set_drvdata(pdev, card);
+	ret = snd_soc_of_parse_card_name(card, "aml_sound_card,name");
+	if (ret < 0) {
+		dev_err(dev, "no specific snd_soc_card name\n");
+		goto err;
+	}
+
+	ret = aml_card_dais_parse_of(card);
+	if (ret < 0) {
+		dev_err(dev, "parse aml sound card dais error %d\n", ret);
+		goto err;
+	}
+	aml_aux_dev_parse_of(card);
+
+	card->suspend_pre = aml_suspend_pre,
+	card->suspend_post = aml_suspend_post,
+	card->resume_pre = aml_resume_pre,
+	card->resume_post = aml_resume_post,
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret < 0) {
+		dev_err(dev, "register aml sound card error %d\n", ret);
+		goto err;
+	}
+
+	aml_g9tv_pinmux_init(card);
+	return 0;
+err:
+	dev_err(dev, "Can't probe snd_soc_card\n");
+	return ret;
+}
+
+static const struct of_device_id amlogic_audio_of_match[] = {
+	{ .compatible = "aml, aml_snd_g9tv", },
+	{},
+};
+
+static struct platform_driver aml_g9tv_audio_driver = {
+	.driver			= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table = amlogic_audio_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe			= aml_g9tv_audio_probe,
+};
+
+module_platform_driver(aml_g9tv_audio_driver);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_G9TV audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/aml/m8/aml_g9tv.h b/sound/soc/aml/m8/aml_g9tv.h
new file mode 100644
index 0000000..223a028
--- /dev/null
+++ b/sound/soc/aml/m8/aml_g9tv.h
@@ -0,0 +1,69 @@
+/*
+ * sound/soc/aml/m8/aml_g9tv.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef AML_G9TV_H
+#define AML_G9TV_H
+
+#include <sound/soc.h>
+#include <linux/gpio/consumer.h>
+
+#define AML_I2C_BUS_AO 0
+#define AML_I2C_BUS_A 1
+#define AML_I2C_BUS_B 2
+#define AML_I2C_BUS_C 3
+#define AML_I2C_BUS_D 4
+
+struct aml_audio_private_data {
+	int clock_en;
+	bool suspended;
+	void *data;
+
+	struct pinctrl *pin_ctl;
+	struct timer_list timer;
+	struct gpio_desc *mute_desc;
+	struct clk *clk;
+
+	struct switch_dev sdev;	/* for android */
+	struct switch_dev mic_sdev;	/* for android */
+};
+
+struct aml_audio_codec_info {
+	const char *name;
+	const char *status;
+	struct device_node *p_node;
+	unsigned i2c_bus_type;
+	unsigned i2c_addr;
+	unsigned id_reg;
+	unsigned id_val;
+	unsigned capless;
+};
+
+struct codec_info {
+	char name[I2C_NAME_SIZE];
+	char name_bus[I2C_NAME_SIZE];
+};
+
+struct codec_probe_priv {
+	int num_eq;
+	struct tas57xx_eq_cfg *eq_configs;
+};
+
+extern struct device *spdif_dev;
+extern void aml_spdif_pinmux_init(struct device *pdev);
+extern void aml_spdif_pinmux_deinit(struct device *pdev);
+
+#endif
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index 64bed25..a2bf64e 100644
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -43,18 +43,12 @@
 #include "aml_spdif_dai.h"
 #include "aml_audio_hw.h"
 #include <linux/amlogic/sound/aiu_regs.h>
-#define USE_HRTIMER 0
-#define HRTIMER_PERIOD (1000000000UL/1000)
-/* #define DEBUG_ALSA_PLATFRORM */
-
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-platform]" fmt, ##args)
-#ifdef DEBUG_ALSA_PLATFRORM
-#define ALSA_DEBUG(fmt, args...) pr_info("[aml-platform]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-platform] enter func %s,line %d\n",\
-							__func__, __LINE__)
+
+#define USE_HW_TIMER
+#ifdef USE_HW_TIMER
+#define XRUN_NUM 100 /*1ms*100=100ms timeout*/
 #else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
+#define XRUN_NUM 10 /*10ms*10=100ms timeout*/
 #endif
 
 unsigned long aml_i2s_playback_start_addr = 0;
@@ -66,11 +60,8 @@ EXPORT_SYMBOL(aml_i2s_playback_phy_start_addr);
 unsigned long aml_i2s_alsa_write_addr = 0;
 EXPORT_SYMBOL(aml_i2s_alsa_write_addr);
 
-unsigned long aml_i2s_capture_phy_start_addr = 0;
-unsigned long aml_i2s_capture_start_addr = 0;
-
-static DEFINE_MUTEX(gate_mutex);
-static unsigned audio_gate_status;
+unsigned int aml_i2s_playback_channel = 2;
+EXPORT_SYMBOL(aml_i2s_playback_channel);
 
 static int trigger_underrun;
 void aml_audio_hw_trigger(void)
@@ -79,6 +70,8 @@ void aml_audio_hw_trigger(void)
 }
 EXPORT_SYMBOL(aml_audio_hw_trigger);
 
+static void aml_i2s_timer_callback(unsigned long data);
+
 /*--------------------------------------------------------------------------*\
  * Hardware definition
 \*--------------------------------------------------------------------------*/
@@ -86,9 +79,13 @@ EXPORT_SYMBOL(aml_audio_hw_trigger);
  *	 them against real values for AML
  */
 static const struct snd_pcm_hardware aml_i2s_hardware = {
-	.info = SNDRV_PCM_INFO_INTERLEAVED |
+	.info =
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	SNDRV_PCM_INFO_MMAP |
+	SNDRV_PCM_INFO_MMAP_VALID |
+#endif
+	SNDRV_PCM_INFO_INTERLEAVED |
 	    SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE,
-
 	.formats =
 	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
 	    SNDRV_PCM_FMTBIT_S32_LE,
@@ -103,7 +100,11 @@ static const struct snd_pcm_hardware aml_i2s_hardware = {
 	.rate_max = 48000,
 	.channels_min = 2,
 	.channels_max = 8,
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	.fifo_size = 4,
+#else
 	.fifo_size = 0,
+#endif
 };
 
 static const struct snd_pcm_hardware aml_i2s_capture = {
@@ -128,7 +129,7 @@ static const struct snd_pcm_hardware aml_i2s_capture = {
 
 static unsigned int period_sizes[] = {
 	64, 128, 256, 512, 1024, 2048, 4096, 8192,
-	16384, 32768, 65536, 65536 * 2,	65536 * 4
+	16384, 32768, 65536, 65536 * 2, 65536 * 4
 };
 
 static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
@@ -141,6 +142,28 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 /*--------------------------------------------------------------------------*\
  * Helper functions
 \*--------------------------------------------------------------------------*/
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = aml_i2s_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	buf->area = dmam_alloc_coherent(pcm->card->dev, size,
+			&buf->addr, GFP_KERNEL);
+	dev_info(pcm->card->dev, "aml-pcm %d: playback preallocate_dma_buffer: area=%p, addr=%p, size=%ld\n",
+		stream, (void *) buf->area, (void *) buf->addr, size);
+	if (!buf->area)
+		return -ENOMEM;
+
+	buf->bytes = size;
+	return 0;
+}
+#else
 static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 
@@ -151,12 +174,11 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 
 	tmp_buf = kzalloc(sizeof(struct aml_audio_buffer), GFP_KERNEL);
 	if (tmp_buf == NULL) {
-		pr_info("alloc tmp buffer struct error\n");
+		dev_err(pcm->card->dev, "allocate tmp buffer error\n");
 		return -ENOMEM;
 	}
 	buf->private_data = tmp_buf;
 
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* malloc DMA buffer */
 		size = aml_i2s_hardware.buffer_bytes_max;
@@ -168,7 +190,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 		buf->area = dma_alloc_coherent(pcm->card->dev, size + 4096,
 					       &buf->addr, GFP_KERNEL);
 		if (!buf->area) {
-			pr_info("alloc playback DMA buffer error\n");
+			dev_err(pcm->card->dev, "alloc playback DMA buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -178,7 +200,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 		size = aml_i2s_hardware.buffer_bytes_max;
 		tmp_buf->buffer_start = kzalloc(size, GFP_KERNEL);
 		if (tmp_buf->buffer_start == NULL) {
-			pr_info("alloc playback tmp buffer error\n");
+			dev_err(pcm->card->dev, "alloc playback tmp buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -194,7 +216,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 					       &buf->addr, GFP_KERNEL);
 
 		if (!buf->area) {
-			pr_info("alloc capture DMA buffer error\n");
+			dev_err(pcm->card->dev, "alloc capture DMA buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -204,7 +226,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 		size = aml_i2s_capture.period_bytes_max;
 		tmp_buf->buffer_start = kzalloc(size, GFP_KERNEL);
 		if (tmp_buf->buffer_start == NULL) {
-			pr_info("alloc capture tmp buffer error\n");
+			dev_err(pcm->card->dev, "alloc capture tmp buffer error\n");
 			kfree(tmp_buf);
 			buf->private_data = NULL;
 			return -ENOMEM;
@@ -215,7 +237,7 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	return 0;
 
 }
-
+#endif
 /*--------------------------------------------------------------------------*\
  * ISR
 \*--------------------------------------------------------------------------*/
@@ -236,8 +258,6 @@ static int aml_i2s_hw_params(struct snd_pcm_substream *substream,
 	*/
 	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
 	runtime->dma_bytes = params_buffer_bytes(params);
-	ALSA_DEBUG("runtime dma_bytes %d,stream type %d\n", runtime->dma_bytes,
-		   substream->stream);
 	s->I2S_addr = runtime->dma_addr;
 
 	/*
@@ -268,50 +288,106 @@ static int aml_i2s_prepare(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct aml_audio_buffer *tmp_buf = buf->private_data;
 
-	ALSA_TRACE();
 	if (s && s->device_type == AML_AUDIO_I2SOUT && trigger_underrun) {
-		pr_info("clear i2s out trigger underrun\n");
+		dev_info(substream->pcm->card->dev, "clear i2s out trigger underrun\n");
 		trigger_underrun = 0;
 	}
+	if (s && s->device_type == AML_AUDIO_I2SOUT)
+		aml_i2s_playback_channel = runtime->channels;
+	tmp_buf->cached_len = 0;
+	return 0;
+}
+
+#ifdef USE_HW_TIMER
+int hw_timer_init = 0;
+static irqreturn_t audio_isr_handler(int irq, void *data)
+{
+	struct aml_runtime_data *prtd = data;
+	struct snd_pcm_substream *substream = prtd->substream;
+	aml_i2s_timer_callback((unsigned long)substream);
+	return IRQ_HANDLED;
+}
+
+static int snd_free_hw_timer_irq(void *data)
+{
+	free_irq(INT_TIMER_D, data);
+	return 0;
+}
+
+static int snd_request_hw_timer(void *data)
+{
+	int ret = 0;
+	if (hw_timer_init == 0) {
+		aml_write_cbus(ISA_TIMERD, TIMER_COUNT);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 3 << 6,
+					TIMERD_RESOLUTION << 6);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 15, TIMERD_MODE << 15);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 19, 1 << 19);
+		hw_timer_init = 1;
+	}
+	ret = request_irq(INT_TIMER_D, audio_isr_handler,
+				IRQF_SHARED, "timerd_irq", data);
+		if (ret < 0) {
+			pr_err("audio hw interrupt register fail\n");
+			return -1;
+		}
 	return 0;
 }
 
+#endif
+
+static void start_timer(struct aml_runtime_data *prtd)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&prtd->timer_lock, flags);
+	if (!prtd->active) {
+#ifndef USE_HW_TIMER
+		prtd->timer.expires = jiffies + 1;
+		add_timer(&prtd->timer);
+#endif
+		prtd->active = 1;
+		prtd->xrun_num = 0;
+	}
+	spin_unlock_irqrestore(&prtd->timer_lock, flags);
+
+}
+
+static void stop_timer(struct aml_runtime_data *prtd)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&prtd->timer_lock, flags);
+	if (prtd->active) {
+#ifndef USE_HW_TIMER
+		del_timer(&prtd->timer);
+#endif
+		prtd->active = 0;
+		prtd->xrun_num = 0;
+	}
+	spin_unlock_irqrestore(&prtd->timer_lock, flags);
+}
+
+
 static int aml_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	struct aml_runtime_data *prtd = rtd->private_data;
-	struct audio_stream *s = &prtd->s;
 	int ret = 0;
-	ALSA_TRACE();
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-
-#if USE_HRTIMER == 0
-		del_timer_sync(&prtd->timer);
-#endif
-		spin_lock(&s->lock);
-#if USE_HRTIMER == 0
-		prtd->timer.expires = jiffies + 1;
-		del_timer(&prtd->timer);
-		add_timer(&prtd->timer);
-#endif
-
-		s->xrun_num = 0;
-		s->active = 1;
-		spin_unlock(&s->lock);
+		start_timer(prtd);
 		break;		/* SNDRV_PCM_TRIGGER_START */
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_STOP:
-		/* TODO */
-		spin_lock(&s->lock);
-		s->active = 0;
-		s->xrun_num = 0;
-		spin_unlock(&s->lock);
+		stop_timer(prtd);
 		break;
 	default:
 		ret = -EINVAL;
@@ -347,128 +423,84 @@ static snd_pcm_uframes_t aml_i2s_pointer(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-#if USE_HRTIMER == 1
-static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer *timer)
+static void aml_i2s_timer_callback(unsigned long data)
 {
-	struct aml_runtime_data *prtd =
-	    container_of(timer, struct aml_runtime_data, hrtimer);
-	struct audio_stream *s = &prtd->s;
-	struct snd_pcm_substream *substream = prtd->substream;
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = NULL;
+	struct audio_stream *s = NULL;
+	int elapsed = 0;
+	unsigned int last_ptr, size = 0;
+	unsigned long flags = 0;
 
-	unsigned int last_ptr, size;
-	/* unsigned long flag; */
-	/* printk("------------->hrtimer start\n"); */
-	if (s->active == 0) {
-		hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-		return HRTIMER_RESTART;
-	}
-	/* spin_lock_irqsave(&s->lock, flag); */
+	if (runtime == NULL || runtime->private_data == NULL)
+		return;
+
+	prtd = runtime->private_data;
+	s = &prtd->s;
 
+	if (prtd->active == 0)
+		return;
+
+	spin_lock_irqsave(&prtd->timer_lock, flags);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		last_ptr = read_i2s_rd_ptr();
-		if (last_ptr < s->last_ptr)
-			size = runtime->dma_bytes + last_ptr - s->last_ptr;
+		if (s->device_type == AML_AUDIO_I2SOUT)
+			last_ptr = read_i2s_rd_ptr();
 		else
-			size = last_ptr - s->last_ptr;
-
+			last_ptr = read_iec958_rd_ptr();
+		if (last_ptr < s->last_ptr) {
+			size =
+				runtime->dma_bytes + last_ptr -
+				(s->last_ptr);
+		} else {
+			size = last_ptr - (s->last_ptr);
+		}
 		s->last_ptr = last_ptr;
 		s->size += bytes_to_frames(substream->runtime, size);
 		if (s->size >= runtime->period_size) {
 			s->size %= runtime->period_size;
-			snd_pcm_period_elapsed(substream);
+			elapsed = 1;
 		}
 	} else {
-		last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) / 2;
-		if (last_ptr < s->last_ptr)
-			size = runtime->dma_bytes + last_ptr - s->last_ptr;
+		if (s->device_type == AML_AUDIO_I2SIN)
+			last_ptr = audio_in_i2s_wr_ptr();
 		else
-			size = last_ptr - s->last_ptr;
-
+			last_ptr = audio_in_spdif_wr_ptr();
+		if (last_ptr < s->last_ptr) {
+			size =
+				runtime->dma_bytes + (last_ptr -
+						  (s->last_ptr)) / 2;
+			prtd->xrun_num = 0;
+		} else if (last_ptr == s->last_ptr) {
+			if (prtd->xrun_num++ > XRUN_NUM) {
+				/*dev_info(substream->pcm->card->dev,
+					"alsa capture long time no data, quit xrun!\n");
+				*/
+				prtd->xrun_num = 0;
+				s->size = runtime->period_size;
+			}
+		} else {
+			size = (last_ptr - (s->last_ptr)) / 2;
+			prtd->xrun_num = 0;
+		}
 		s->last_ptr = last_ptr;
-		s->size += bytes_to_frames(runtime, size);
+		s->size += bytes_to_frames(substream->runtime, size);
 		if (s->size >= runtime->period_size) {
 			s->size %= runtime->period_size;
-			snd_pcm_period_elapsed(substream);
+			elapsed = 1;
 		}
 	}
-	/* spin_unlock_irqrestore(&s->lock, flag); */
-	hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-	return HRTIMER_RESTART;
-}
+
+#ifndef USE_HW_TIMER
+	mod_timer(&prtd->timer, jiffies + 1);
 #endif
-static void aml_i2s_timer_callback(unsigned long data)
-{
-	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	struct audio_stream *s = &prtd->s;
 
-	unsigned int last_ptr, size = 0;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (s->active == 1) {
-			spin_lock(&s->lock);
-			if (s->device_type == AML_AUDIO_I2SOUT)
-				last_ptr = read_i2s_rd_ptr();
-			else
-				last_ptr = read_iec958_rd_ptr();
-			if (last_ptr < s->last_ptr) {
-				size =
-				    runtime->dma_bytes + last_ptr -
-				    (s->last_ptr);
-			} else {
-				size = last_ptr - (s->last_ptr);
-			}
-			s->last_ptr = last_ptr;
-			s->size += bytes_to_frames(substream->runtime, size);
-			if (s->size >= runtime->period_size) {
-				s->size %= runtime->period_size;
-				spin_unlock(&s->lock);
-				snd_pcm_period_elapsed(substream);
-				spin_lock(&s->lock);
-			}
-			mod_timer(&prtd->timer, jiffies + 1);
-			spin_unlock(&s->lock);
-		} else {
-			mod_timer(&prtd->timer, jiffies + 1);
-		}
-	} else {
-		if (s->active == 1) {
-			spin_lock(&s->lock);
-			if (s->device_type == AML_AUDIO_I2SIN)
-				last_ptr = audio_in_i2s_wr_ptr();
-			else
-				last_ptr = audio_in_spdif_wr_ptr();
-			if (last_ptr < s->last_ptr) {
-				size =
-				    runtime->dma_bytes + (last_ptr -
-							  (s->last_ptr)) / 2;
-			} else if (last_ptr == s->last_ptr) {
-				if (s->xrun_num++ > 100) {
-					pr_info("alsa capture long time no data, quit xrun!\n");
-					s->xrun_num = 0;
-					s->size = runtime->period_size;
-				}
-			} else {
-				size = (last_ptr - (s->last_ptr)) / 2;
-			}
-			s->last_ptr = last_ptr;
-			s->size += bytes_to_frames(substream->runtime, size);
-			if (s->size >= runtime->period_size) {
-				s->size %= runtime->period_size;
-				spin_unlock(&s->lock);
-				snd_pcm_period_elapsed(substream);
-				spin_lock(&s->lock);
-			}
-			mod_timer(&prtd->timer, jiffies + 1);
-			spin_unlock(&s->lock);
-		} else {
-			mod_timer(&prtd->timer, jiffies + 1);
-		}
-	}
+	spin_unlock_irqrestore(&prtd->timer_lock, flags);
+	if (elapsed)
+		snd_pcm_period_elapsed(substream);
 }
 
-static int num_clk_gate;
+
 static int aml_i2s_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -476,7 +508,7 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	struct audio_stream *s = &prtd->s;
 	int ret = 0;
-	ALSA_TRACE();
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		snd_soc_set_runtime_hwparams(substream, &aml_i2s_hardware);
 		if (s->device_type == AML_AUDIO_I2SOUT) {
@@ -485,10 +517,6 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 		}
 	} else {
 		snd_soc_set_runtime_hwparams(substream, &aml_i2s_capture);
-		if (s->device_type == AML_AUDIO_I2SIN) {
-			aml_i2s_capture_start_addr = (unsigned long)buf->area;
-			aml_i2s_capture_phy_start_addr = buf->addr;
-		}
 	}
 
 	/* ensure that peroid size is a multiple of 32bytes */
@@ -497,7 +525,8 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 				       SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
 				       &hw_constraints_period_sizes);
 	if (ret < 0) {
-		pr_info("set period bytes constraint error\n");
+		dev_err(substream->pcm->card->dev,
+			"set period bytes constraint error\n");
 		goto out;
 	}
 
@@ -505,47 +534,34 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 	ret = snd_pcm_hw_constraint_integer(runtime,
 					    SNDRV_PCM_HW_PARAM_PERIODS);
 	if (ret < 0) {
-		pr_info("set period error\n");
+		dev_err(substream->pcm->card->dev, "set period error\n");
 		goto out;
 	}
 	if (!prtd) {
 		prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
-			pr_info("alloc aml_runtime_data error\n");
+			dev_err(substream->pcm->card->dev, "alloc aml_runtime_data error\n");
 			ret = -ENOMEM;
 			goto out;
 		}
 		prtd->substream = substream;
 		runtime->private_data = prtd;
 	}
-/* WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1); */
-#if USE_HRTIMER == 0
+
+	spin_lock_init(&prtd->timer_lock);
+
+#ifndef USE_HW_TIMER
+	init_timer(&prtd->timer);
 	prtd->timer.function = &aml_i2s_timer_callback;
 	prtd->timer.data = (unsigned long)substream;
-	init_timer(&prtd->timer);
 #else
-	hrtimer_init(&prtd->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	prtd->hrtimer.function = aml_i2s_hrtimer_callback;
-	hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD),
-		      HRTIMER_MODE_REL);
-	pr_info("hrtimer inited..\n");
+	ret = snd_request_hw_timer(prtd);
+	if (ret < 0) {
+		dev_err(substream->pcm->card->dev, "request audio hw timer failed\n");
+		goto out;
+	}
 #endif
 
-	spin_lock_init(&prtd->s.lock);
-	s->xrun_num = 0;
-	/* WRITE_MPEG_REG_BITS(MPLL_I2S_CNTL, 1,14, 1); */
-	mutex_lock(&gate_mutex);
-	if (!num_clk_gate) {
-		num_clk_gate = 1;
-		if (audio_gate_status == 0) {
-			/* audio_aiu_pg_enable(1); */
-			ALSA_DEBUG("aml_pcm_open  device type %x\n",
-				   s->device_type);
-
-		}
-	}
-	audio_gate_status |= s->device_type;
-	mutex_unlock(&gate_mutex);
  out:
 	return ret;
 }
@@ -553,35 +569,17 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 static int aml_i2s_close(struct snd_pcm_substream *substream)
 {
 	struct aml_runtime_data *prtd = substream->runtime->private_data;
-	struct audio_stream *s = &prtd->s;
-	ALSA_TRACE();
-	mutex_lock(&gate_mutex);
-	audio_gate_status &= ~s->device_type;
-	if (audio_gate_status == 0) {
-		ALSA_DEBUG("aml_pcm_close  device type %x\n", s->device_type);
-		/* audio_aiu_pg_enable(0); */
-	}
-	mutex_unlock(&gate_mutex);
-/* if(s->device_type == AML_AUDIO_SPDIFOUT) */
-/* WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1); */
-#if USE_HRTIMER == 0
-	del_timer_sync(&prtd->timer);
-#else
-	hrtimer_cancel(&prtd->hrtimer);
-#endif
 
+#ifdef USE_HW_TIMER
+	snd_free_hw_timer_irq(prtd);
+#endif
 	kfree(prtd);
 	prtd = NULL;
-	substream->runtime->private_data = NULL;
 
 	return 0;
 }
 
-/* extern void audio_out_i2s_enable(unsigned flag); */
-/* extern void aml_hw_iec958_init(struct snd_pcm_substream *substream); */
-/* extern void audio_hw_958_enable(unsigned flag); */
-/* extern int kernel_android_50; */
-
+#ifndef CONFIG_SND_AML_SPLIT_MODE_MMAP
 static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 				 snd_pcm_uframes_t pos,
 				 void __user *buf, snd_pcm_uframes_t count,
@@ -589,28 +587,76 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 {
 	int res = 0;
 	int n;
+#ifndef CONFIG_SND_AML_SPLIT_MODE
 	int i = 0, j = 0;
-	int align = runtime->channels * 32 / runtime->byte_align;
-	char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+	int align = runtime->channels * 32;
+#endif
+	unsigned long offset = frames_to_bytes(runtime, pos);
+	char *hwbuf = runtime->dma_area + offset;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct snd_dma_buffer *buffer = &substream->dma_buffer;
 	struct aml_audio_buffer *tmp_buf = buffer->private_data;
 	void *ubuf = tmp_buf->buffer_start;
 	struct audio_stream *s = &prtd->s;
-
-	if (s->device_type == AML_AUDIO_I2SOUT)
-		aml_i2s_alsa_write_addr = frames_to_bytes(runtime, pos);
-
+	struct device *dev = substream->pcm->card->dev;
+#ifndef CONFIG_SND_AML_SPLIT_MODE
+	int cached_len = tmp_buf->cached_len;
+	char *cache_buffer_bytes = tmp_buf->cache_buffer_bytes;
+#endif
 	n = frames_to_bytes(runtime, count);
 	if (n > tmp_buf->buffer_size) {
-		pr_info("[%s]FATAL_ERR:UserData/%d > buffer_size/%d\n",
-				__func__ , n, tmp_buf->buffer_size);
+		dev_err(dev, "FATAL_ERR:UserData/%d > buffer_size/%d\n",
+				n, tmp_buf->buffer_size);
 		return -EFAULT;
 	}
 	res = copy_from_user(ubuf, buf, n);
 	if (res)
 		return -EFAULT;
+
+#ifndef CONFIG_SND_AML_SPLIT_MODE
+	/*mask align byte(64 or 256)*/
+	if ((cached_len != 0 || (n % align) != 0)) {
+		int byte_size = n;
+		int total_len;
+		int ouput_len;
+		int next_cached_len;
+		char cache_buffer_bytes_tmp[256];
+
+		offset -= cached_len;
+		hwbuf = runtime->dma_area + offset;
+
+		total_len = byte_size + cached_len;
+		ouput_len = total_len & (~(align - 1));
+		next_cached_len = total_len - ouput_len;
+
+		if (next_cached_len)
+			memcpy((void *)cache_buffer_bytes_tmp,
+				(void *)((char *)ubuf +
+				byte_size - next_cached_len),
+				next_cached_len);
+		memmove((void *)((char *)ubuf + cached_len),
+				(void *)ubuf, ouput_len - cached_len);
+		if (cached_len)
+			memcpy((void *)ubuf,
+				(void *)cache_buffer_bytes, cached_len);
+		if (next_cached_len)
+			memcpy((void *)cache_buffer_bytes,
+				(void *)cache_buffer_bytes_tmp,
+				next_cached_len);
+
+		tmp_buf->cached_len = next_cached_len;
+		n = ouput_len;
+	}
+	/*end of mask*/
+#endif
+
+	if (s->device_type == AML_AUDIO_I2SOUT)
+		aml_i2s_alsa_write_addr = offset;
+
 	if (access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))) {
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		memcpy(hwbuf, ubuf, n);
+#else
 		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
 
 			int16_t *tfrom, *to, *left, *right;
@@ -619,10 +665,6 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 
 			left = to;
 			right = to + 16;
-			if (pos % align) {
-				pr_info("audio data unligned: pos=%d, n=%d, align=%d\n",
-				     (int)pos, n, align);
-			}
 
 			for (j = 0; j < n; j += 64) {
 				for (i = 0; i < 16; i++) {
@@ -641,10 +683,6 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 			left = to;
 			right = to + 8;
 
-			if (pos % align) {
-				pr_info("audio data unaligned: pos=%d, n=%d, align=%d\n",
-				     (int)pos, n, align);
-			}
 			for (j = 0; j < n; j += 64) {
 				for (i = 0; i < 8; i++) {
 					*left++ = (*tfrom++);
@@ -662,11 +700,6 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 			left = to;
 			right = to + 8;
 
-			if (pos % align) {
-				pr_info("audio data unaligned: pos=%d, n=%d, align=%d\n",
-				     (int)pos, n, align);
-			}
-
 			if (runtime->channels == 8) {
 				int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl,
 				    *sbr;
@@ -709,18 +742,13 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 				}
 			}
 		}
-
+#endif
 	} else {
 		res = -EFAULT;
 	}
 	return res;
 }
 
-static unsigned int aml_get_in_wr_ptr(void)
-{
-	return audio_in_i2s_wr_ptr() - aml_i2s_capture_phy_start_addr;
-}
-
 static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 				snd_pcm_uframes_t pos,
 				void __user *buf, snd_pcm_uframes_t count,
@@ -728,41 +756,26 @@ static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 {
 	unsigned int *tfrom, *left, *right;
 	unsigned short *to;
-	int res = 0, n = 0, i = 0, j = 0, size = 0;
+	int res = 0, n = 0, i = 0, j = 0;
 	unsigned int t1, t2;
 	unsigned char r_shift = 8;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	struct audio_stream *s = &prtd->s;
 	char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos) * 2;
 	struct snd_dma_buffer *buffer = &substream->dma_buffer;
 	struct aml_audio_buffer *tmp_buf = buffer->private_data;
 	void *ubuf = tmp_buf->buffer_start;
-	if (s->device_type == AML_AUDIO_I2SIN) {
-		unsigned int buffersize =
-		    (unsigned int)runtime->buffer_size * 8;
-		unsigned int hw_ptr = aml_get_in_wr_ptr();
-		unsigned int alsa_read_ptr = frames_to_bytes(runtime, pos) * 2;
-		size = (buffersize + hw_ptr - alsa_read_ptr) % buffersize;
-	}
-	if (s->device_type == AML_AUDIO_SPDIFIN) {	/* spdif in */
-		r_shift = 12;
-	}
+	struct device *dev = substream->pcm->card->dev;
 	to = (unsigned short *)ubuf;	/* tmp buf; */
 	tfrom = (unsigned int *)hwbuf;	/* 32bit buffer */
 	n = frames_to_bytes(runtime, count);
-	if (size < 2 * n && s->device_type == AML_AUDIO_I2SIN) {
-		pr_info("Alsa ptr is too close to HW ptr, Reset ALSA!\n");
-		return -EPIPE;
-	}
 	if (access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count))) {
 		if (runtime->channels == 2) {
 			left = tfrom;
 			right = tfrom + 8;
 			if (pos % 8)
-				pr_info("audio data unligned\n");
+				dev_err(dev, "audio data unligned\n");
 
 			if ((n * 2) % 64)
-				pr_info("audio data unaligned 64 bytes\n");
+				dev_err(dev, "audio data unaligned 64 bytes\n");
 
 			for (j = 0; j < n * 2; j += 64) {
 				for (i = 0; i < 8; i++) {
@@ -804,6 +817,7 @@ static int aml_i2s_copy(struct snd_pcm_substream *substream, int channel,
 	}
 	return ret;
 }
+#endif
 
 int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 		    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
@@ -811,7 +825,6 @@ int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 	char *ppos;
 	int n;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	ALSA_TRACE();
 
 	n = frames_to_bytes(runtime, count);
 	ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
@@ -819,6 +832,21 @@ int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 	return 0;
 }
 
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+static int aml_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	dev_info(substream->pcm->card->dev,
+		"\narea=%p,addr=%ld,bytes=%ld,rate:%d, channels:%d, subformat:%d\n",
+		runtime->dma_area, (long)runtime->dma_addr, runtime->dma_bytes,
+		runtime->rate, runtime->channels, runtime->subformat);
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+		runtime->dma_area, runtime->dma_addr, runtime->dma_bytes);
+}
+#endif
+
 static struct snd_pcm_ops aml_i2s_ops = {
 	.open = aml_i2s_open,
 	.close = aml_i2s_close,
@@ -828,7 +856,11 @@ static struct snd_pcm_ops aml_i2s_ops = {
 	.prepare = aml_i2s_prepare,
 	.trigger = aml_i2s_trigger,
 	.pointer = aml_i2s_pointer,
+#ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
+	.mmap = aml_pcm_mmap,
+#else
 	.copy = aml_i2s_copy,
+#endif
 	.silence = aml_i2s_silence,
 };
 
@@ -842,7 +874,7 @@ static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
 	int ret = 0;
 	struct snd_soc_card *card = rtd->card;
 	struct snd_pcm *pcm = rtd->pcm;
-	ALSA_TRACE();
+
 	if (!card->dev->dma_mask)
 		card->dev->dma_mask = &aml_i2s_dmamask;
 	if (!card->dev->coherent_dma_mask)
@@ -856,7 +888,6 @@ static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
 	}
 
 	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		pr_debug("aml-i2s:" "Allocating i2s capture DMA buffer\n");
 		ret = aml_i2s_preallocate_dma_buffer(pcm,
 						     SNDRV_PCM_STREAM_CAPTURE);
 		if (ret)
@@ -873,7 +904,7 @@ static void aml_i2s_free_dma_buffers(struct snd_pcm *pcm)
 	struct snd_dma_buffer *buf;
 	struct aml_audio_buffer *tmp_buf;
 	int stream;
-	ALSA_TRACE();
+
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
 		if (!substream)
@@ -909,8 +940,6 @@ static int aml_i2s_suspend(struct snd_soc_dai *dai)
 
 	/* disable the PDC and save the PDC registers */
 	/* TODO */
-	pr_info("aml i2s suspend\n");
-
 	return 0;
 }
 
@@ -927,7 +956,6 @@ static int aml_i2s_resume(struct snd_soc_dai *dai)
 
 	/* restore the PDC registers and enable the PDC */
 	/* TODO */
-	pr_info("aml i2s resume\n");
 	return 0;
 }
 #else
@@ -935,18 +963,48 @@ static int aml_i2s_resume(struct snd_soc_dai *dai)
 #define aml_i2s_resume	NULL
 #endif
 
+bool aml_audio_i2s_mute_flag = 0;
+static int aml_audio_set_i2s_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	aml_audio_i2s_mute_flag = ucontrol->value.integer.value[0];
+	pr_info("aml_audio_i2s_mute_flag: flag=%d\n", aml_audio_i2s_mute_flag);
+	if (aml_audio_i2s_mute_flag)
+		aml_audio_i2s_mute();
+	else
+		aml_audio_i2s_unmute();
+	return 0;
+}
+
+static int aml_audio_get_i2s_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = aml_audio_i2s_mute_flag;
+	return 0;
+}
+
+static const struct snd_kcontrol_new aml_i2s_controls[] = {
+	SOC_SINGLE_BOOL_EXT("Audio i2s mute",
+				0, aml_audio_get_i2s_mute,
+				aml_audio_set_i2s_mute),
+};
+static int aml_i2s_probe(struct snd_soc_platform *platform)
+{
+	return snd_soc_add_platform_controls(platform,
+			aml_i2s_controls, ARRAY_SIZE(aml_i2s_controls));
+}
+
 struct snd_soc_platform_driver aml_soc_platform = {
+	.probe = aml_i2s_probe,
 	.ops = &aml_i2s_ops,
 	.pcm_new = aml_i2s_new,
 	.pcm_free = aml_i2s_free_dma_buffers,
 	.suspend = aml_i2s_suspend,
 	.resume = aml_i2s_resume,
 };
-EXPORT_SYMBOL_GPL(aml_soc_platform);
 
 static int aml_soc_platform_probe(struct platform_device *pdev)
 {
-	ALSA_TRACE();
 	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
 }
 
@@ -966,12 +1024,44 @@ static const struct of_device_id amlogic_audio_dt_match[] = {
 #define amlogic_audio_dt_match NULL
 #endif
 
+#ifdef CONFIG_HIBERNATION
+static unsigned long isa_timerd_saved;
+static unsigned long isa_timerd_mux_saved;
+static int aml_i2s_freeze(struct device *dev)
+{
+	isa_timerd_saved = aml_read_cbus(ISA_TIMERD);
+	isa_timerd_mux_saved = aml_read_cbus(ISA_TIMER_MUX);
+	return 0;
+}
+
+static int aml_i2s_thaw(struct device *dev)
+{
+	return 0;
+}
+
+static int aml_i2s_restore(struct device *dev)
+{
+	aml_write_cbus(ISA_TIMERD, isa_timerd_saved);
+	aml_write_cbus(ISA_TIMER_MUX, isa_timerd_mux_saved);
+	return 0;
+}
+
+const struct dev_pm_ops aml_i2s_pm = {
+	.freeze		= aml_i2s_freeze,
+	.thaw		= aml_i2s_thaw,
+	.restore	= aml_i2s_restore,
+};
+#endif
+
 static struct platform_driver aml_i2s_driver = {
 	.driver = {
-		   .name = "aml-i2s",
-		   .owner = THIS_MODULE,
-		   .of_match_table = amlogic_audio_dt_match,
-		   },
+		.name = "aml-i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_audio_dt_match,
+#ifdef CONFIG_HIBERNATION
+		.pm     = &aml_i2s_pm,
+#endif
+		},
 
 	.probe = aml_soc_platform_probe,
 	.remove = aml_soc_platform_remove,
diff --git a/sound/soc/aml/m8/aml_i2s.h b/sound/soc/aml/m8/aml_i2s.h
index 98128e0..7614a8d 100644
--- a/sound/soc/aml/m8/aml_i2s.h
+++ b/sound/soc/aml/m8/aml_i2s.h
@@ -18,6 +18,8 @@
 #ifndef __AML_I2S_H__
 #define __AML_I2S_H__
 
+#include <linux/mutex.h>
+
 /* #define debug_printk */
 #ifdef debug_printk
 #define dug_printk(fmt, args...)  printk(fmt, ## args)
@@ -25,9 +27,18 @@
 #define dug_printk(fmt, args...)
 #endif
 
+#define BASE_IRQ                (32)
+#define AM_IRQ(reg)             (reg + BASE_IRQ)
+#define INT_TIMER_D             AM_IRQ(29)
+/* note: we use TIEMRD. MODE: 1: periodic, 0: one-shot*/
+#define TIMERD_MODE             1
+/* timerbase resolution: 00: 1us; 01: 10us; 10: 100us; 11: 1ms*/
+#define TIMERD_RESOLUTION       0x1
+/* timer count: 16bits*/
+#define TIMER_COUNT             100
+
 struct audio_stream {
 	int stream_id;
-	int active;
 	unsigned int last_ptr;
 	unsigned int size;
 	unsigned int sample_rate;
@@ -36,11 +47,12 @@ struct audio_stream {
 	struct snd_pcm_substream *stream;
 	unsigned i2s_mode; /* 0:master, 1:slave, */
 	unsigned device_type;
-	unsigned int xrun_num;
 };
 struct aml_audio_buffer {
 	void *buffer_start;
 	unsigned int buffer_size;
+	char cache_buffer_bytes[256];
+	int cached_len;
 };
 
 struct aml_i2s_dma_params {
@@ -67,11 +79,12 @@ struct aml_runtime_data {
 	struct snd_pcm_substream *substream;
 	struct audio_stream s;
 	struct timer_list timer;	/* timeer for playback and capture */
-	struct hrtimer hrtimer;
+	spinlock_t timer_lock;
 	void *buf; /* tmp buffer for playback or capture */
+	int active;
+	unsigned int xrun_num;
+	struct mutex chmap_lock;
+	int chmap_layout;
 };
 
-extern struct snd_soc_platform_driver aml_soc_platform;
-/* extern struct aml_audio_interface aml_i2s_interface; */
-
 #endif
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index 5dfbaf1..63770a6 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -38,6 +38,7 @@
 #include <sound/control.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
+#include <sound/tlv.h>
 #include "aml_i2s_dai.h"
 #include "aml_pcm.h"
 #include "aml_i2s.h"
@@ -48,31 +49,54 @@
 struct aml_dai_info dai_info[3] = { {0} };
 
 static int i2s_pos_sync;
-/* #define AML_DAI_DEBUG */
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-i2s-dai]" fmt, ##args)
-#ifdef AML_DAI_DEBUG
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-i2s-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-i2s-dai] enter func %s\n", __func__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
-/* extern int amaudio2_enable; */
-/* extern int kernel_android_50; */
+
+struct channel_speaker_allocation {
+        int channels;
+        int speakers[8];
+};
+
+#define NA	SNDRV_CHMAP_NA
+#define FL	SNDRV_CHMAP_FL
+#define FR	SNDRV_CHMAP_FR
+#define RL	SNDRV_CHMAP_RL
+#define RR	SNDRV_CHMAP_RR
+#define LFE	SNDRV_CHMAP_LFE
+#define FC	SNDRV_CHMAP_FC
+#define RLC	SNDRV_CHMAP_RLC
+#define RRC	SNDRV_CHMAP_RRC
+#define RC	SNDRV_CHMAP_RC
+#define FLC	SNDRV_CHMAP_FLC
+#define FRC	SNDRV_CHMAP_FRC
+#define FLH	SNDRV_CHMAP_TFL
+#define FRH	SNDRV_CHMAP_TFR
+#define FLW	SNDRV_CHMAP_FLW
+#define FRW	SNDRV_CHMAP_FRW
+#define TC	SNDRV_CHMAP_TC
+#define FCH	SNDRV_CHMAP_TFC
+
+static struct channel_speaker_allocation channel_allocations[] = {
+/*      	       channel:   7     6    5    4    3     2    1    0  */
+{ .channels = 2,  .speakers = {  NA,   NA,  NA,  NA,  NA,   NA,  FR,  FL } },
+                                 /* 2.1 */
+{ .channels = 3,  .speakers = {  NA,   NA,  NA,  NA,  NA,  LFE,  FR,  FL } },
+                                 /* surround40 */
+{ .channels = 4,  .speakers = {  NA,   NA,  RR,  RL,  NA,   NA,  FR,  FL } },
+                                 /* surround41 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  NA,  LFE,  FR,  FL } },
+                                 /* surround50 */
+{ .channels = 5,  .speakers = {  NA,   NA,  RR,  RL,  FC,   NA,  FR,  FL } },
+                                 /* surround51 */
+{ .channels = 6,  .speakers = {  NA,   NA,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* 6.1 */
+{ .channels = 7,  .speakers = {  NA,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+                                 /* surround71 */
+{ .channels = 8,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },
+};
+
 
 /* extern int set_i2s_iec958_samesource(int enable); */
 #define DEFAULT_SAMPLERATE 48000
 #define DEFAULT_MCLK_RATIO_SR 256
-static int i2sbuf[32 + 16];
-static void aml_i2s_play(void)
-{
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-	audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
-	memset(i2sbuf, 0, sizeof(i2sbuf));
-	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
-	audio_out_i2s_enable(1);
-
-}
 
 /*
 the I2S hw  and IEC958 PCM output initation,958 initation here,
@@ -92,29 +116,207 @@ static void aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 		i2s_mode = AIU_I2S_MODE_PCM16;
 		break;
 	}
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(i2s_mode, runtime->channels);
+#else
 	audio_set_i2s_mode(i2s_mode);
+#endif
 	audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,
 			 runtime->channels);
-	ALSA_PRINT("i2s dma %p,phy addr %ld,mode %d,ch %d\n",
-		   runtime->dma_area, (long)runtime->dma_addr,
-		   i2s_mode, runtime->channels);
+}
+
+static int aml_dai_i2s_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+                                     unsigned int size, unsigned int __user *tlv)
+{
+    unsigned int __user *dst;
+    int count = 0;
+    int i;
+
+    if (size < 8)
+        return -ENOMEM;
+
+    if (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))
+        return -EFAULT;
+
+    size -= 8;
+    dst = tlv + 2;
+
+    for (i = 0; i < ARRAY_SIZE(channel_allocations); i++)
+    {
+        struct channel_speaker_allocation *ch = &channel_allocations[i];
+        int num_chs = 0;
+        int chs_bytes;
+        int c;
+
+        for (c = 0; c < 8; c++)
+        {
+            if (ch->speakers[c])
+                num_chs++;
+        }
+
+        chs_bytes = num_chs * 4;
+        if (size < 8)
+            return -ENOMEM;
+
+        if (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||
+            put_user(chs_bytes, dst + 1))
+            return -EFAULT;
+
+        dst += 2;
+        size -= 8;
+        count += 8;
+
+        if (size < chs_bytes)
+            return -ENOMEM;
+
+        size -= chs_bytes;
+        count += chs_bytes;
+
+        for (c = 0; c < 8; c++)
+        {
+            int sp = ch->speakers[7 - c];
+            if (sp)
+            {
+                if (put_user(sp, dst))
+                    return -EFAULT;
+                dst++;
+            }
+        }
+    }
+
+    if (put_user(count, tlv + 1))
+        return -EFAULT;
+
+    return 0;
+}
+
+static int aml_dai_i2s_chmap_ctl_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    for (channel=0; channel<8; channel++)
+    {
+        ucontrol->value.integer.value[7 - channel] = channel_allocations[prtd->chmap_layout].speakers[channel];
+    }
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static int aml_dai_i2s_chmap_ctl_put(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+
+    struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+    unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+    struct snd_pcm_substream *substream = snd_pcm_chmap_substream(info, idx);
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+    int res = 0, channel, layout, matches, matched_layout;
+
+    if (mutex_lock_interruptible(&prtd->chmap_lock))
+        return -EINTR;
+
+    // we need 8 channels
+    if (runtime->channels != 8)
+    {
+        pr_err("channel count should be 8, we got %d aborting\n", runtime->channels);
+        res = -EINVAL;
+        goto unlock;
+    }
+
+    // now check if the channel setup matches one of our layouts
+    for (layout = 0; layout < ARRAY_SIZE(channel_allocations); layout++)
+    {
+        matches = 1;
+
+        for (channel = 0; channel < substream->runtime->channels; channel++)
+        {
+            int sp = ucontrol->value.integer.value[channel];
+            int chan = channel_allocations[layout].speakers[7 - channel];
+
+            if (sp != chan)
+            {
+                matches = 0;
+                break;
+            }
+        }
+
+        if (matches)
+        {
+            matched_layout = layout;
+            break;
+        }
+    }
+
+
+    // default to first layout if we didnt find any
+    if (!matches)
+        matched_layout = 0;
+
+    pr_info("Setting a %d channel layout matching layout #%d\n", runtime->channels, matched_layout);
+
+    prtd->chmap_layout = matched_layout;
+
+unlock:
+    mutex_unlock(&prtd->chmap_lock);
+    return res;
+}
+
+static struct snd_kcontrol *aml_dai_i2s_chmap_kctrl_get(struct snd_pcm_substream *substream)
+{
+    int str;
+
+    if ((substream) && (substream->pcm))
+    {
+        for (str=0; str<2; str++)
+        {
+            if (substream->pcm->streams[str].chmap_kctl)
+            {
+                return substream->pcm->streams[str].chmap_kctl;
+            }
+        }
+    }
+
+    return 0;
 }
 
 static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-	int ret = 0;
+        int ret = 0, i;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd =
 	    (struct aml_runtime_data *)runtime->private_data;
 	struct audio_stream *s;
-	ALSA_TRACE();
+	struct snd_pcm_chmap *chmap;
+	struct snd_kcontrol *kctl;
+
 	if (prtd == NULL) {
 		prtd =
 		    (struct aml_runtime_data *)
 		    kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
-			pr_info("alloc aml_runtime_data error\n");
+			dev_err(substream->pcm->card->dev, "alloc aml_runtime_data error\n");
 			ret = -ENOMEM;
 			goto out;
 		}
@@ -128,6 +330,29 @@ static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 	} else {
 		s->device_type = AML_AUDIO_I2SIN;
 	}
+
+
+	// Alsa Channel Mapping API handling
+	if (!aml_dai_i2s_chmap_kctrl_get(substream))
+	{
+	    ret = snd_pcm_add_chmap_ctls(substream->pcm, SNDRV_PCM_STREAM_PLAYBACK, NULL, 8, 0, &chmap);
+
+	    if (ret < 0)
+	    {
+	      pr_err("aml_dai_i2s_startup error %d\n", ret);
+	      goto out;
+	    }
+
+	    kctl = chmap->kctl;
+	    for (i = 0; i < kctl->count; i++)
+	      kctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_WRITE;
+
+	    kctl->get = aml_dai_i2s_chmap_ctl_get;
+	    kctl->put = aml_dai_i2s_chmap_ctl_put;
+	    kctl->tlv.c = aml_dai_i2s_chmap_ctl_tlv;
+	}
+
+	mutex_init(&prtd->chmap_lock);
 	return 0;
  out:
 	return ret;
@@ -137,7 +362,7 @@ static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
 	if (IEC958_mode_codec == 0)
-		aml_spdif_play();
+		aml_spdif_play(1);
 	return;
 }
 
@@ -147,22 +372,16 @@ static int aml_i2s_set_amclk(struct aml_i2s *i2s, unsigned long rate)
 	int ret = 0;
 
 	ret = clk_set_rate(i2s->clk_mpl0, rate * 10);
-	if (ret) {
-		pr_err("Can't set I2S mpll clock rate: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	ret = clk_set_parent(i2s->clk_mclk, i2s->clk_mpl0);
-	if (ret) {
-		pr_err("Can't set I2S mclk parent: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	ret = clk_set_rate(i2s->clk_mclk, rate);
-	if (ret) {
-		pr_err("Can't set I2S mclk clock rate: %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	audio_set_i2s_clk_div();
 
@@ -175,13 +394,11 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
-	ALSA_TRACE();
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		audio_out_i2s_enable(0);
-
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	}
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		s->i2s_mode = dai_info[dai->id].i2s_mode;
 		audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes * 2,
@@ -197,19 +414,19 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 		s->device_type = AML_AUDIO_I2SIN;
 	} else {
 		s->device_type = AML_AUDIO_I2SOUT;
+		IEC958_mode_codec = 0;
 		aml_hw_i2s_init(runtime);
 		/* i2s/958 share the same audio hw buffer when PCM mode */
 		if (IEC958_mode_codec == 0) {
-			aml_hw_iec958_init(substream);
+			aml_hw_iec958_init(substream, 1);
 			/* use the hw same sync for i2s/958 */
-			pr_info("958 with i2s\n");
+			dev_info(substream->pcm->card->dev, "i2s/958 same source\n");
 			/* aml_set_spdif_clk(runtime->rate*512, 0); */
 			audio_i2s_958_same_source(1);
 		}
 	}
 	if (runtime->channels == 8) {
-		pr_info("[%s,%d]8ch PCM output->notify HDMI\n", __func__,
-		       __LINE__);
+		dev_info(substream->pcm->card->dev, "8ch PCM output->notify HDMI\n");
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 	return 0;
@@ -220,17 +437,17 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	int *ppp = NULL;
-	ALSA_TRACE();
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		/* TODO */
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu i2s playback enable\n");
+			dev_info(substream->pcm->card->dev, "I2S playback enable\n");
 			audio_out_i2s_enable(1);
 			if (IEC958_mode_codec == 0) {
-				pr_info("audio_hw_958_enable 1\n");
+				dev_info(substream->pcm->card->dev, "IEC958 playback enable\n");
 				audio_hw_958_enable(1);
 			}
 		} else {
@@ -244,10 +461,10 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			pr_info("aiu i2s playback disable\n");
+			dev_info(substream->pcm->card->dev, "I2S playback disable\n");
 			audio_out_i2s_enable(0);
 			if (IEC958_mode_codec == 0) {
-				pr_info("audio_hw_958_enable 0\n");
+				dev_info(substream->pcm->card->dev, "IEC958 playback disable\n");
 				audio_hw_958_enable(0);
 			}
 		} else {
@@ -280,7 +497,6 @@ static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
 
 static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	ALSA_TRACE();
 	if (fmt & SND_SOC_DAIFMT_CBS_CFS)	/* slave mode */
 		dai_info[dai->id].i2s_mode = I2S_SLAVE_MODE;
 
@@ -300,7 +516,6 @@ static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -308,7 +523,7 @@ static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
 {
 	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
 
-	if (i2s && i2s->clk_mclk)
+	if (i2s && i2s->clk_mclk && !i2s->disable_clk_suspend)
 		clk_disable_unprepare(i2s->clk_mclk);
 
 	return 0;
@@ -318,7 +533,7 @@ static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
 {
 	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
 
-	if (i2s && i2s->clk_mclk)
+	if (i2s && i2s->clk_mclk && !i2s->disable_clk_suspend)
 		clk_prepare_enable(i2s->clk_mclk);
 
 	return 0;
@@ -372,6 +587,7 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 {
 	struct aml_i2s *i2s = NULL;
 	struct reset_control *audio_reset;
+	struct device_node *pnode = pdev->dev.of_node;
 	int ret = 0, i;
 
 	/* enable AIU module power gate first */
@@ -392,6 +608,9 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 	}
 	dev_set_drvdata(&pdev->dev, i2s);
 
+	i2s->disable_clk_suspend =
+		of_property_read_bool(pnode, "disable_clk_suspend");
+
 	i2s->clk_mpl0 = devm_clk_get(&pdev->dev, "mpll0");
 	if (IS_ERR(i2s->clk_mpl0)) {
 		dev_err(&pdev->dev, "Can't retrieve mpll0 clock\n");
@@ -416,15 +635,14 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 
 	ret = clk_prepare_enable(i2s->clk_mclk);
 	if (ret) {
-		pr_err("Can't enable I2S mclk clock: %d\n", ret);
+		dev_err(&pdev->dev, "Can't enable I2S mclk clock: %d\n", ret);
 		goto err;
 	}
 
-	aml_i2s_play();
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_i2s_dai, ARRAY_SIZE(aml_i2s_dai));
 	if (ret) {
-		pr_err("Can't register i2s dai: %d\n", ret);
+		dev_err(&pdev->dev, "Can't register i2s dai: %d\n", ret);
 		goto err_clk_dis;
 	}
 	return 0;
@@ -445,6 +663,16 @@ static int aml_i2s_dai_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void aml_i2s_dai_shutdown(struct platform_device *pdev)
+{
+	struct aml_i2s *i2s = dev_get_drvdata(&pdev->dev);
+
+	if (i2s && i2s->clk_mclk)
+		clk_disable_unprepare(i2s->clk_mclk);
+
+	return;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_dai_dt_match[] = {
 	{.compatible = "amlogic, aml-i2s-dai",},
@@ -463,6 +691,7 @@ static struct platform_driver aml_i2s_dai_driver = {
 
 	.probe = aml_i2s_dai_probe,
 	.remove = aml_i2s_dai_remove,
+	.shutdown = aml_i2s_dai_shutdown,
 };
 
 static int __init aml_i2s_dai_modinit(void)
diff --git a/sound/soc/aml/m8/aml_i2s_dai.h b/sound/soc/aml/m8/aml_i2s_dai.h
index eea60e6..72d305c 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.h
+++ b/sound/soc/aml/m8/aml_i2s_dai.h
@@ -23,6 +23,7 @@ struct aml_i2s {
 	struct clk *clk_mpl0;
 	struct clk *clk_mclk;
 	int old_samplerate;
+	bool disable_clk_suspend;
 };
 
 #endif
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index 2012bba..c834d34 100644
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_snd_card: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -46,8 +47,27 @@
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/of_gpio.h>
 #include <linux/io.h>
-#define DRV_NAME "aml_snd_card"
-/* extern struct device *spdif_dev; */
+#include <linux/amlogic/jtag.h>
+
+
+#define DRV_NAME "aml_snd_m8_card"
+
+static int i2sbuf[32 + 16];
+static void aml_i2s_play(void)
+{
+#if 0
+	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+	audio_set_i2s_mode(AIU_I2S_MODE_PCM16, 2);
+#else
+	audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
+#endif
+	memset(i2sbuf, 0, sizeof(i2sbuf));
+	audio_set_aiubuf((virt_to_phys(i2sbuf) + 63) & (~63), 128, 2);
+	audio_out_i2s_enable(1);
+
+#endif
+}
 
 static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio,
 				  unsigned long delay)
@@ -153,8 +173,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 		if (flag & 0x1) {
 			/* 1 :have mic ;  2 no mic */
 			switch_set_state(&p_aml_audio->sdev, 2);
-			pr_info(KERN_INFO
-			       "aml aduio hp pluged 3 jack_type: %d\n",
+			pr_info("aml aduio hp pluged 3 jack_type: %d\n",
 			       SND_JACK_HEADPHONE);
 			snd_soc_jack_report(&p_aml_audio->jack, status,
 					    SND_JACK_HEADPHONE);
@@ -164,8 +183,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 				if (flag & 0x8) {
 					switch_set_state(&p_aml_audio->mic_sdev,
 							 1);
-					pr_info(KERN_INFO
-					       "aml aduio mic pluged jack_type: %d\n",
+					pr_info("aml aduio mic pluged jack_type: %d\n",
 					       SND_JACK_MICROPHONE);
 					snd_soc_jack_report(&p_aml_audio->jack,
 						status, SND_JACK_HEADPHONE);
@@ -175,13 +193,12 @@ static void aml_asoc_work_func(struct work_struct *work)
 		} else if (flag & 0x2) {
 			/* 1 :have mic ;  2 no mic */
 			switch_set_state(&p_aml_audio->sdev, 1);
-			pr_info(KERN_INFO
-			       "aml aduio hp pluged 4 jack_type: %d\n",
+			pr_info("aml aduio hp pluged 4 jack_type: %d\n",
 			       SND_JACK_HEADSET);
 			snd_soc_jack_report(&p_aml_audio->jack, status,
 					    SND_JACK_HEADPHONE);
 		} else {
-			pr_info(KERN_INFO "aml audio hp unpluged\n");
+			pr_info("aml audio hp unpluged\n");
 			switch_set_state(&p_aml_audio->sdev, 0);
 			snd_soc_jack_report(&p_aml_audio->jack, 0,
 					    SND_JACK_HEADPHONE);
@@ -191,8 +208,7 @@ static void aml_asoc_work_func(struct work_struct *work)
 				if (flag & 0x8) {
 					switch_set_state(&p_aml_audio->mic_sdev,
 							 1);
-					pr_info(KERN_INFO
-					       "aml aduio mic pluged jack_type: %d\n",
+					pr_info("aml aduio mic pluged jack_type: %d\n",
 					       SND_JACK_MICROPHONE);
 					snd_soc_jack_report(&p_aml_audio->jack,
 						status, SND_JACK_HEADPHONE);
@@ -217,14 +233,14 @@ static void aml_asoc_timer_func(unsigned long data)
 	mod_timer(&p_aml_audio->timer, jiffies + delay);
 }
 
-struct aml_audio_private_data *p_audio;
+static struct aml_audio_private_data *p_audio;
 static int aml_m8_spk_enabled;
 
 static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
 			  struct snd_ctl_elem_value *ucontrol)
 {
 	aml_m8_spk_enabled = ucontrol->value.integer.value[0];
-	pr_info(KERN_INFO "aml_m8_set_spk: aml_m8_spk_enabled=%d\n",
+	pr_info("aml_m8_set_spk: aml_m8_spk_enabled=%d\n",
 	       aml_m8_spk_enabled);
 
 	msleep_interruptible(10);
@@ -239,8 +255,6 @@ static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
 static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
 			  struct snd_ctl_elem_value *ucontrol)
 {
-	/* pr_info("***aml_m8_get_spk****aml_m8_spk_enabled=%d**\n",
-		aml_m8_spk_enabled); */
 	ucontrol->value.integer.value[0] = aml_m8_spk_enabled;
 	return 0;
 }
@@ -248,8 +262,10 @@ static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
 static int aml_suspend_pre(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
+	struct pinctrl_state *state;
+	int val = 0;
 
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	if (!p_aml_audio->hp_disable) {
 		/* stop timer */
@@ -260,20 +276,36 @@ static int aml_suspend_pre(struct snd_soc_card *card)
 
 		mutex_unlock(&p_aml_audio->lock);
 	}
+
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to suspend\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_suspend");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl suspend state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
+	}
+
+	if (p_aml_audio->mute_desc) {
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	};
+
 	return 0;
 }
 
 static int aml_suspend_post(struct snd_soc_card *card)
 {
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	/* if(ext_codec) */
-	/* i2s_gpio_set(card); */
+	pr_info("enter %s\n", __func__);
 	return 0;
 }
 
 static int aml_resume_pre(struct snd_soc_card *card)
 {
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 
 	return 0;
 }
@@ -281,8 +313,10 @@ static int aml_resume_pre(struct snd_soc_card *card)
 static int aml_resume_post(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
+	struct pinctrl_state *state;
+	int val = 0;
 
-	pr_info(KERN_INFO "enter %s\n", __func__);
+	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	if (!p_aml_audio->hp_disable) {
 		mutex_lock(&p_aml_audio->lock);
@@ -294,22 +328,50 @@ static int aml_resume_post(struct snd_soc_card *card)
 		mutex_unlock(&p_aml_audio->lock);
 	}
 
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to resume\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_m8");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl working state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
+	}
+
+	if (p_aml_audio->mute_desc) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	}
 	return 0;
 }
 
 static int speaker_events(struct snd_soc_dapm_widget *w,
 			  struct snd_kcontrol *kcontrol, int event)
 {
+	int val = 0;
+
+	if (p_audio->mute_desc == NULL) {
+		pr_info("no mute_gpio setting");
+		return 0;
+	}
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
-		pr_info("speaker_events--mute =1\n");
+		pr_info("audio speaker on\n");
+		val = p_audio->mute_inv ?
+			GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
 		gpiod_direction_output(p_audio->mute_desc, 1);
 		aml_m8_spk_enabled = 1;
 		msleep(p_audio->sleep_time);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
-		pr_info("speaker_events--mute =0\n");
-		gpiod_direction_output(p_audio->mute_desc, 0);
+		pr_info("audio speaker off\n");
+		val = p_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_audio->mute_desc, val);
 		aml_m8_spk_enabled = 0;
 		break;
 	}
@@ -350,7 +412,6 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	int ret = 0;
 	int hp_paraments[5];
 
-	pr_info("enter %s\n", __func__);
 	p_aml_audio = snd_soc_card_get_drvdata(card);
 	ret = snd_soc_add_card_controls(codec->card, aml_m8_controls,
 					ARRAY_SIZE(aml_m8_controls));
@@ -363,7 +424,7 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	p_aml_audio->hp_disable =
 	    of_property_read_bool(card->dev->of_node, "hp_disable");
 
-	pr_info("p_aml_audio->hp_disable=%d\n", p_aml_audio->hp_disable);
+	pr_info("headphone detection disable=%d\n", p_aml_audio->hp_disable);
 
 	if (!p_aml_audio->hp_disable) {
 		/* for report headphone to android */
@@ -445,46 +506,43 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 	    of_property_read_u32(card->dev->of_node, "sleep_time",
 				 &p_aml_audio->sleep_time);
 	if (ret)
-		pr_info("falied to get spk event delay time\n");
-
-	pr_info("spk_event delay_time = %d\n",
-	       p_aml_audio->sleep_time);
+		pr_info("no spk event delay time set\n");
 
 	return 0;
 }
-static int ao_jtag_on;
+
 static void aml_m8_pinmux_init(struct snd_soc_card *card)
 {
 	struct aml_audio_private_data *p_aml_audio;
 	int val;
-	if (ao_jtag_on)
-		return;
+
 	p_aml_audio = snd_soc_card_get_drvdata(card);
+	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
+	p_aml_audio->mute_inv =
+	    of_property_read_bool(card->dev->of_node, "mute_inv");
+	if (p_aml_audio->mute_desc) {
+		if (p_aml_audio->sleep_time)
+			msleep(p_aml_audio->sleep_time);
+		val = p_aml_audio->mute_inv ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		gpiod_direction_output(p_aml_audio->mute_desc, val);
+	}
+
+	if (is_jtag_apao())
+		return;
 	val = aml_read_sec_reg(0xda004004);
 	pr_info("audio use jtag pinmux as i2s output, read val =%x\n",
 		aml_read_sec_reg(0xda004004));
 	val = val & (~((1<<8) | (1<<1)));
 	aml_write_sec_reg(0xda004004, val);
+
 	p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "aml_snd_m8");
 	if (IS_ERR(p_aml_audio->pin_ctl)) {
 		pr_info("%s,aml_m8_pinmux_init error!\n", __func__);
 		return;
 	}
-	/* p_audio = p_aml_audio; */
-
-	p_aml_audio->mute_desc = gpiod_get(card->dev, "mute_gpio");
-
-	p_aml_audio->mute_inv =
-	    of_property_read_bool(card->dev->of_node, "mute_inv");
-	gpiod_direction_output(p_aml_audio->mute_desc, GPIOF_OUT_INIT_LOW);
-
-}
-static int __init ao_jtag_func(char *buf)
-{
-	ao_jtag_on = 1;
-	return 0;
 }
-early_param("ao_jtag_on", ao_jtag_func);
+
 static int aml_card_dai_parse_of(struct device *dev,
 				 struct snd_soc_dai_link *dai_link,
 				 int (*init)(struct snd_soc_pcm_runtime *rtd),
@@ -660,6 +718,7 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	aml_i2s_play();
 	aml_m8_pinmux_init(card);
 	return 0;
  err:
@@ -667,6 +726,22 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static void aml_audio_shutdown(struct platform_device *pdev)
+{
+	struct pinctrl_state *state;
+
+	if (IS_ERR_OR_NULL(p_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to shutdown\n");
+		return;
+	}
+
+	state = pinctrl_lookup_state(p_audio->pin_ctl, "aml_snd_suspend");
+	if (!IS_ERR(state))
+		pinctrl_select_state(p_audio->pin_ctl, state);
+
+	return;
+}
+
 static const struct of_device_id amlogic_audio_of_match[] = {
 	{.compatible = "aml, aml_snd_m8",},
 	{},
@@ -682,6 +757,7 @@ static struct platform_driver aml_m8_audio_driver = {
 		   .pm = &snd_soc_pm_ops,
 		   },
 	.probe = aml_m8_audio_probe,
+	.shutdown = aml_audio_shutdown,
 };
 
 module_platform_driver(aml_m8_audio_driver);
diff --git a/sound/soc/aml/m8/aml_pcm.c b/sound/soc/aml/m8/aml_pcm.c
index ef71c8b..13d4064 100644
--- a/sound/soc/aml/m8/aml_pcm.c
+++ b/sound/soc/aml/m8/aml_pcm.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_pcm: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -41,18 +42,6 @@
 #include "aml_pcm.h"
 #include "aml_audio_hw_pcm2bt.h"
 
-#define USE_HRTIMER 0
-#define HRTIMER_PERIOD (1000000000UL/1000)
-#define DEBUG_ALSA_PLATFRORM
-
-/* #define PCM_DEBUG */
-
-#ifdef PCM_DEBUG
-#define pcm_debug(fmt, args...)  printk(fmt, ## args)
-#else
-#define pcm_debug(fmt, args...)
-#endif
-
 /*--------------------------------------------------------------------------*\
  * Hardware definition
 \*--------------------------------------------------------------------------*/
@@ -106,7 +95,7 @@ static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
 	else if (diff >= prtd->buffer_size)
 		diff = prtd->buffer_size;
 
-	pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __func__,
+	pr_debug("%s value: 0x%08x offset: 0x%08x\n", __func__,
 		  value, diff);
 	return (unsigned int)diff;
 }
@@ -123,7 +112,7 @@ static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
 	else if (diff >= prtd->buffer_size)
 		diff = prtd->buffer_size;
 
-	pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __func__,
+	pr_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __func__,
 		  value, diff);
 	return (unsigned int)diff;
 }
@@ -178,7 +167,7 @@ static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
 
 static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
 {
-	pcm_debug("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	spin_lock(&prtd->lock);
 	aml_pcm2bt_timer_rearm(prtd);
 	prtd->running = 1;
@@ -188,7 +177,7 @@ static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
 
 static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
 {
-	pcm_debug("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	spin_lock(&prtd->lock);
 	prtd->running = 0;
 	del_timer(&prtd->timer);
@@ -229,7 +218,7 @@ static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 
-	pcm_debug("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	init_timer(&prtd->timer);
 	prtd->timer_period = 1;
 	prtd->timer.data = (unsigned long)substream;
@@ -253,8 +242,6 @@ aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
 	else {
 		prtd->buffer_start = runtime->dma_addr;
 		prtd->buffer_size = runtime->dma_bytes;
-		pcm_debug("%s dma_addr: 0x%08x dma_bytes: 0x%x\n",
-			  __func__, runtime->dma_addr, runtime->dma_bytes);
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
@@ -271,7 +258,7 @@ aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
 
 static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
 {
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	snd_pcm_lib_free_pages(substream);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
@@ -295,7 +282,7 @@ static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	int ret = 0;
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -321,7 +308,7 @@ static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	snd_pcm_uframes_t frames;
 
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	frames = bytes_to_frames(runtime, (ssize_t) prtd->buffer_offset);
 
 	return frames;
@@ -332,7 +319,7 @@ static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd;
 	int ret;
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 
 	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
 
@@ -394,7 +381,7 @@ aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	unsigned int wrptr = 0;
 	int ret = 0;
 
-	pcm_debug("enter %s channel: %d pos: %ld count: %ld\n",
+	pr_debug("enter %s channel: %d pos: %ld count: %ld\n",
 		  __func__, channel, pos, count);
 
 	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
@@ -423,7 +410,7 @@ aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 	unsigned int rdptr = 0;
 	int ret = 0;
 
-	pcm_debug("enter %s channel: %d pos: %ld count: %ld\n",
+	pr_debug("enter %s channel: %d pos: %ld count: %ld\n",
 		  __func__, channel, pos, count);
 
 	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
@@ -468,7 +455,7 @@ static int aml_pcm2bt_silence(struct snd_pcm_substream *substream,
 	unsigned char *ppos = NULL;
 	ssize_t n;
 
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	n = frames_to_bytes(runtime, count);
 	ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
 	memset(ppos, 0, n);
@@ -501,15 +488,13 @@ static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
 
-	pr_info("enter %s stream: %d\n", __func__, stream);
-
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
 	buf->private_data = NULL;
 	buf->area = dma_alloc_coherent(pcm->card->dev, size,
 				       &buf->addr, GFP_KERNEL);
 	if (!buf->area) {
-		pr_info("%s dma_alloc_coherent failed!\n", __func__);
+		dev_err(pcm->dev, "aml_pcm alloc failed!\n");
 		return -ENOMEM;
 	}
 
@@ -520,13 +505,13 @@ static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 
 static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
 {
-	/* pcm_debug("enter %s\n", __FUNCTION__); */
+	/* pr_debug("enter %s\n", __FUNCTION__); */
 	int ret = 0;
 	struct snd_soc_card *card = rtd->card;
 	struct snd_pcm *pcm = rtd->pcm;
 	struct snd_soc_dai *dai;
 	dai = rtd->cpu_dai;
-	pcm_debug("enter %s dai->name: %s dai->id: %d\n", __func__,
+	pr_debug("enter %s dai->name: %s dai->id: %d\n", __func__,
 		  dai->name, dai->id);
 
 	if (!card->dev->dma_mask)
@@ -558,7 +543,7 @@ static void aml_pcm2bt_free(struct snd_pcm *pcm)
 	struct snd_dma_buffer *buf;
 	int stream;
 
-	pcm_debug("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
 		if (!substream)
@@ -585,7 +570,6 @@ EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
 
 static int aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
 {
-	pr_info("enter %s\n", __func__);
 	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
 }
 
@@ -618,13 +602,11 @@ static struct platform_driver aml_platform_pcm2bt_driver = {
 
 static int __init aml_alsa_bt_init(void)
 {
-	/* aml_pcm_init_debugfs(); */
 	return platform_driver_register(&aml_platform_pcm2bt_driver);
 }
 
 static void __exit aml_alsa_bt_exit(void)
 {
-	/* aml_pcm_cleanup_debugfs(); */
 	platform_driver_unregister(&aml_platform_pcm2bt_driver);
 }
 
diff --git a/sound/soc/aml/m8/aml_pcm_dai.c b/sound/soc/aml/m8/aml_pcm_dai.c
index da2a960..ed5e021 100644
--- a/sound/soc/aml/m8/aml_pcm_dai.c
+++ b/sound/soc/aml/m8/aml_pcm_dai.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_pcm_dai: " fmt
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -38,45 +39,26 @@
 
 #define DEV_NAME "aml-pcm-dai"
 
-/* static aml_dai_info_t dai_info[3] = {{0}}; */
-#define AML_DAI_DEBUG
-
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-pcm-dai]" fmt, ##args)
-#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-pcm-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-pcm-dai] enter func %s\n", __func__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
-
 static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
 static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 }
 
 static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
-/* #if 1 */
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		pr_info(
@@ -101,8 +83,6 @@ static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
 static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 			       struct snd_soc_dai *dai)
 {
-	ALSA_DEBUG();
-	/* struct snd_pcm_runtime *rtd = substream->runtime; */
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -137,17 +117,13 @@ static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *dai)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s:%s\n", __FILE__, __func__);
 	return 0;
 }
 
 static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 	if (fmt & SND_SOC_DAIFMT_CBS_CFS)
 		snd_soc_dai_get_drvdata(dai);
 	return 0;
@@ -156,9 +132,7 @@ static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
-#ifdef AML_DAI_DEBUG
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
-#endif
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
@@ -166,13 +140,13 @@ static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
 static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
 {
 
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
 static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
 {
-	pr_info("***Entered %s:%s\n", __FILE__, __func__);
+	pr_debug("***Entered %s\n", __func__);
 	return 0;
 }
 
@@ -223,7 +197,7 @@ static int aml_pcm_dai_probe(struct platform_device *pdev)
 {
 	struct pinctrl *pin_ctl;
 
-	pr_info("enter %s\n", __func__);
+	pr_debug("enter %s\n", __func__);
 
 	pin_ctl = devm_pinctrl_get_select(&pdev->dev, "aml_audio_btpcm");
 	if (IS_ERR(pin_ctl))
diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
index 5ef287b..ac76ef6 100644
--- a/sound/soc/aml/m8/aml_spdif_codec.c
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -30,8 +30,6 @@
 #define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
 	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
-static struct snd_soc_codec_driver soc_codec_spdif_dit;
-
 struct pinctrl *pin_spdif_ctl;
 struct device *spdif_dev;
 static struct snd_soc_dai_driver dit_stub_dai = {
@@ -60,20 +58,55 @@ void aml_spdif_pinmux_init(struct device *dev)
 		pin_spdif_ctl = devm_pinctrl_get_select(dev, "aml_audio_spdif");
 		if (IS_ERR(pin_spdif_ctl)) {
 			pin_spdif_ctl = NULL;
-			pr_info("aml_spdif_pinmux_init can't get pinctrl\n");
+			dev_err(dev, "aml_spdif_pinmux_init can't get pinctrl\n");
 		}
 	}
 }
 
 void aml_spdif_pinmux_deinit(struct device *dev)
 {
-	pr_info(KERN_INFO "aml_spdif_mute\n");
+	dev_dbg(dev, "aml_spdif_mute\n");
 	if (spdif_pinmux) {
 		spdif_pinmux = 0;
 		if (pin_spdif_ctl)
 			devm_pinctrl_put(pin_spdif_ctl);
 	}
 }
+bool aml_audio_spdif_mute_flag = 0;
+static int aml_audio_set_spdif_mute(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	aml_audio_spdif_mute_flag = ucontrol->value.integer.value[0];
+	pr_info("aml_audio_set_spdif_mute: flag=%d\n",
+		aml_audio_spdif_mute_flag);
+	if (aml_audio_spdif_mute_flag)
+		aml_spdif_pinmux_deinit(spdif_dev);
+	else
+		aml_spdif_pinmux_init(spdif_dev);
+	return 0;
+}
+
+static int aml_audio_get_spdif_mute(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = aml_audio_spdif_mute_flag;
+	return 0;
+}
+
+static const struct snd_kcontrol_new spdif_controls[] = {
+	SOC_SINGLE_BOOL_EXT("Audio spdif mute",
+			    0, aml_audio_get_spdif_mute,
+			    aml_audio_set_spdif_mute),
+};
+
+static int spdif_probe(struct snd_soc_codec *codec)
+{
+	return snd_soc_add_codec_controls(codec,
+			spdif_controls, ARRAY_SIZE(spdif_controls));
+}
+static struct snd_soc_codec_driver soc_codec_spdif_dit = {
+	.probe =	spdif_probe,
+};
 
 static ssize_t spdif_mute_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
@@ -94,7 +127,7 @@ static ssize_t spdif_mute_set(struct device *dev,
 	else if (strncmp(buf, "spdif_unmute", 12))
 		aml_spdif_pinmux_deinit(dev);
 	else
-		pr_info("spdif set the wrong value\n");
+		dev_err(dev, "spdif set the wrong value\n");
 
 	return count;
 }
@@ -104,12 +137,14 @@ static DEVICE_ATTR(spdif_mute, 0660, spdif_mute_show, spdif_mute_set);
 static int spdif_dit_probe(struct platform_device *pdev)
 {
 	int ret = device_create_file(&pdev->dev, &dev_attr_spdif_mute);
-	pr_info("enter spdif_dit_probe\n");
+
 	spdif_dev = &pdev->dev;
 
 	aml_spdif_pinmux_init(&pdev->dev);
 	if (ret < 0)
-		pr_info("spdif: failed to add spdif_mute sysfs: %d\n", ret);
+		dev_err(&pdev->dev,
+			"spdif: failed to add spdif_mute sysfs: %d\n", ret);
+
 	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
 				      &dit_stub_dai, 1);
 }
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index 7b42d2d..405d223 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -14,6 +14,7 @@
  * more details.
  *
 */
+#define pr_fmt(fmt) "aml_spdif_dai: " fmt
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -45,17 +46,8 @@
 #include "aml_i2s.h"
 #include <linux/amlogic/sound/aout_notify.h>
 #include <linux/amlogic/sound/aiu_regs.h>
+#include <linux/amlogic/cpu_version.h>
 
-/* #define DEBUG_ALSA_SPDIF_DAI */
-#define ALSA_PRINT(fmt, args...)	pr_info("[aml-spdif-dai]" fmt, ##args)
-#ifdef DEBUG_ALSA_SPDIF_DAI
-#define ALSA_DEBUG(fmt, args...)	pr_info("[aml-spdif-dai]" fmt, ##args)
-#define ALSA_TRACE()	pr_info("[aml-spdif-dai] enter func %s,line %d\n",\
-		__func__, __LINE__)
-#else
-#define ALSA_DEBUG(fmt, args...)
-#define ALSA_TRACE()
-#endif
 /*
  0 --  other formats except(DD,DD+,DTS)
  1 --  DTS
@@ -70,70 +62,72 @@ struct aml_spdif {
 	struct clk *clk_i958;
 	struct clk *clk_mclk;
 	struct clk *clk_spdif;
+	struct clk *clk_81;
 	int old_samplerate;
 };
 struct aml_spdif *spdif_p;
 unsigned int clk81 = 0;
 EXPORT_SYMBOL(clk81);
 
-static int iec958buf[32 + 16];
 static int old_samplerate = -1;
+static int flag_samesrc = -1;
 
-void aml_spdif_play(void)
+void aml_spdif_play(int samesrc)
 {
-#if 1
-	struct _aiu_958_raw_setting_t set;
-	struct _aiu_958_channel_status_t chstat;
-	struct snd_pcm_substream substream;
-	struct snd_pcm_runtime runtime;
-	substream.runtime = &runtime;
-	runtime.rate = 48000;
-	runtime.format = SNDRV_PCM_FORMAT_S16_LE;
-	runtime.channels = 2;
-	runtime.sample_bits = 16;
-	memset((void *)(&set), 0, sizeof(set));
-	memset((void *)(&chstat), 0, sizeof(chstat));
-	set.chan_stat = &chstat;
-	set.chan_stat->chstat0_l = 0x0100;
-	set.chan_stat->chstat0_r = 0x0100;
-	set.chan_stat->chstat1_l = 0X200;
-	set.chan_stat->chstat1_r = 0X200;
-	audio_hw_958_enable(0);
-	if (old_samplerate != AUDIO_CLK_FREQ_48) {
-		pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
-		__func__, old_samplerate, AUDIO_CLK_FREQ_48);
-		old_samplerate = AUDIO_CLK_FREQ_48;
-		aml_set_spdif_clk(48000 * 512, 0);
-	}
-	/* Todo, div can be changed, for most case, div = 2 */
-	/* audio_set_spdif_clk_div(); */
-	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
-	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
-		pr_info("set 4x audio clk for 958\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (0) {
-		pr_info("share the same clock\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
-	} else {
-		pr_info("set normal 512 fs /4 fs\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
+#if 0
+	if (is_meson_gxtvbb_cpu() == false) {
+		static int iec958buf[32 + 16];
+		struct _aiu_958_raw_setting_t set;
+		struct _aiu_958_channel_status_t chstat;
+		struct snd_pcm_substream substream;
+		struct snd_pcm_runtime runtime;
+		substream.runtime = &runtime;
+		runtime.rate = 48000;
+		runtime.format = SNDRV_PCM_FORMAT_S16_LE;
+		runtime.channels = 2;
+		runtime.sample_bits = 16;
+		memset((void *)(&set), 0, sizeof(set));
+		memset((void *)(&chstat), 0, sizeof(chstat));
+		set.chan_stat = &chstat;
+		set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+		audio_hw_958_enable(0);
+		if (old_samplerate != AUDIO_CLK_FREQ_48
+				|| samesrc != flag_samesrc) {
+			pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
+			__func__, old_samplerate, AUDIO_CLK_FREQ_48);
+			old_samplerate = AUDIO_CLK_FREQ_48;
+			flag_samesrc = samesrc;
+			aml_set_spdif_clk(48000 * 512, samesrc);
+		}
+		/* Todo, div can be changed, for most case, div = 2 */
+		/* audio_set_spdif_clk_div(); */
+		/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+		if (IEC958_mode_codec == 4	|| IEC958_mode_codec == 5 ||
+		IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+			pr_info("set 4x audio clk for 958\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+		} else if (samesrc) {
+			pr_info("share the same clock\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+		} else {
+			pr_info("set normal 512 fs /4 fs\n");
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
+		}
+		/* enable 958 divider */
+		aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
+		audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+		/*clear the same source function as new raw data output */
+		audio_i2s_958_same_source(0);
+		memset(iec958buf, 0, sizeof(iec958buf));
+		audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63),
+					128, 0);
+		audio_set_958_mode(AIU_958_MODE_PCM16, &set);
+		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
+		audio_hw_958_enable(1);
 	}
-	/* enable 958 divider */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
-	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-	memset(iec958buf, 0, sizeof(iec958buf));
-	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 0);
-	audio_set_958_mode(AIU_958_MODE_PCM16, &set);
-#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1
-	/* 512fs divide 4 == 128fs */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x3 << 4);
-#else
-	/* 256fs divide 2 == 128fs */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 4, 0x1 << 4);
-#endif
-	aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, &substream);
-	audio_hw_958_enable(1);
 #endif
 }
 
@@ -145,7 +139,6 @@ static void aml_spdif_play_stop(void)
 static int aml_dai_spdif_set_sysclk(struct snd_soc_dai *cpu_dai,
 				    int clk_id, unsigned int freq, int dir)
 {
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -155,18 +148,16 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 
 	struct snd_soc_pcm_runtime *rtd = NULL;
 
-	ALSA_TRACE();
-
 	rtd = (struct snd_soc_pcm_runtime *)substream->private_data;
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			ALSA_PRINT("aiu 958 playback enable\n");
+			pr_info("aiu 958 playback enable\n");
 			audio_hw_958_enable(1);
 		} else {
-			ALSA_PRINT("spdif in capture enable\n");
+			pr_info("spdif in capture enable\n");
 			audio_in_spdif_enable(1);
 		}
 		break;
@@ -174,10 +165,10 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			ALSA_PRINT("aiu 958 playback disable\n");
+			pr_info("aiu 958 playback disable\n");
 			audio_hw_958_enable(0);
 		} else {
-			ALSA_PRINT("spdif in capture disable\n");
+			pr_info("spdif in capture disable\n");
 			audio_in_spdif_enable(0);
 		}
 		break;
@@ -188,89 +179,77 @@ static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-void aml_hw_iec958_init(struct snd_pcm_substream *substream)
+void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 {
 	struct _aiu_958_raw_setting_t set;
 	struct _aiu_958_channel_status_t chstat;
-	unsigned i2s_mode, iec958_mode;
-	unsigned start, size;
-	int sample_rate;
+	unsigned iec958_mode;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (buf == NULL && runtime == NULL) {
+	if (buf == NULL || runtime == NULL) {
 		pr_info("buf/%p runtime/%p\n", buf, runtime);
 		return;
 	}
 
-	i2s_mode = AIU_I2S_MODE_PCM16;
-	sample_rate = AUDIO_CLK_FREQ_48;
+	iec958_mode = AIU_958_MODE_PCM16;
 	memset((void *)(&set), 0, sizeof(set));
 	memset((void *)(&chstat), 0, sizeof(chstat));
 	set.chan_stat = &chstat;
-	switch (runtime->rate) {
-	case 192000:
-		sample_rate = AUDIO_CLK_FREQ_192;
-		break;
-	case 176400:
-		sample_rate = AUDIO_CLK_FREQ_1764;
-		break;
-	case 96000:
-		sample_rate = AUDIO_CLK_FREQ_96;
-		break;
-	case 88200:
-		sample_rate = AUDIO_CLK_FREQ_882;
-		break;
-	case 48000:
-		sample_rate = AUDIO_CLK_FREQ_48;
-		break;
-	case 44100:
-		sample_rate = AUDIO_CLK_FREQ_441;
-		break;
-	case 32000:
-		sample_rate = AUDIO_CLK_FREQ_32;
-		break;
-	case 8000:
-		sample_rate = AUDIO_CLK_FREQ_8;
-		break;
-	case 11025:
-		sample_rate = AUDIO_CLK_FREQ_11;
-		break;
-	case 16000:
-		sample_rate = AUDIO_CLK_FREQ_16;
-		break;
-	case 22050:
-		sample_rate = AUDIO_CLK_FREQ_22;
-		break;
-	case 12000:
-		sample_rate = AUDIO_CLK_FREQ_12;
-		break;
-	case 24000:
-		sample_rate = AUDIO_CLK_FREQ_22;
-		break;
-	default:
-		sample_rate = AUDIO_CLK_FREQ_441;
-		break;
-	};
+
+	if (!samesrc) {
+		unsigned i2s_mode = AIU_I2S_MODE_PCM16;
+		switch (runtime->format) {
+		case SNDRV_PCM_FORMAT_S32:
+			i2s_mode = AIU_I2S_MODE_PCM32;
+			break;
+		case SNDRV_PCM_FORMAT_S24:
+			i2s_mode = AIU_I2S_MODE_PCM24;
+			break;
+		case SNDRV_PCM_FORMAT_S16:
+			i2s_mode = AIU_I2S_MODE_PCM16;
+			break;
+		}
+		audio_out_i2s_enable(0);
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#ifdef CONFIG_SND_AML_SPLIT_MODE
+		audio_set_i2s_mode(i2s_mode, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
+#else
+		audio_set_i2s_mode(i2s_mode);
+#endif
+		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
+	}
+
 	audio_hw_958_enable(0);
-	pr_info("----aml_hw_iec958_init,runtime->rate=%d,sample_rate=%d--\n",
-	       runtime->rate, sample_rate);
-	/* int srate; */
-	/* srate = params_rate(params); */
-	if (old_samplerate != sample_rate) {
-		old_samplerate = sample_rate;
-		aml_set_spdif_clk(runtime->rate * 512, 0);
+	pr_info("aml_hw_iec958_init,runtime->rate=%d, runtime->channels=%d, same source mode(%d)\n",
+	       runtime->rate, runtime->channels, samesrc);
+
+	if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		aml_set_spdif_clk((runtime->rate >> 2) * 512, samesrc); /* EAC3 */
+	} else {
+		aml_set_spdif_clk(runtime->rate * 512, samesrc);
 	}
+
 	/* Todo, div can be changed, for most case, div = 2 */
 	/* audio_set_spdif_clk_div(); */
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
-	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+	if (runtime->rate == 192000 && runtime->channels == 8 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
+		pr_info("set 4x audio clk for 958\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+	} else if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 4; /* EAC3 */
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (0) {
+	} else if (samesrc) {
+		IEC958_mode_codec = 0;
 		pr_info("share the same clock\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+	} else if (runtime->rate == 48000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 2; /* AC3/DTS */
+		pr_info("set normal 512 fs /4 fs\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	} else {
+		IEC958_mode_codec = 0;
 		pr_info("set normal 512 fs /4 fs\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	}
@@ -281,127 +260,62 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 	audio_i2s_958_same_source(0);
 
 	switch (runtime->format) {
-	case SNDRV_PCM_FORMAT_S32_LE:
-		i2s_mode = AIU_I2S_MODE_PCM32;
+	case SNDRV_PCM_FORMAT_S32:
+		iec958_mode = AIU_958_MODE_PCM32;
 		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		i2s_mode = AIU_I2S_MODE_PCM24;
+	case SNDRV_PCM_FORMAT_S24:
+		iec958_mode = AIU_958_MODE_PCM24;
 		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		i2s_mode = AIU_I2S_MODE_PCM16;
+	case SNDRV_PCM_FORMAT_S16:
+		iec958_mode = AIU_958_MODE_PCM16;
 		break;
 	}
+	if (IEC958_mode_codec > 0) {
+		iec958_mode = AIU_958_MODE_PCM_RAW;
+	}
 
-	/* audio_set_i2s_mode(i2s_mode); */
-	/* case 1,raw mode enabled */
-	if (IEC958_mode_codec) {
-		if (IEC958_mode_codec == 1) {
-			/* dts, use raw sync-word mode */
-			iec958_mode = AIU_958_MODE_RAW;
-			pr_info("iec958 mode RAW\n");
-		} else {
-			/* ac3,use the same pcm mode as i2s configuration */
-			iec958_mode = AIU_958_MODE_PCM_RAW;
-			pr_info("iec958 mode %s\n",
-				(i2s_mode == AIU_I2S_MODE_PCM32) ? "PCM32_RAW"
-				: ((I2S_MODE == AIU_I2S_MODE_PCM24) ?
-				"PCM24_RAW"	: "PCM16_RAW"));
-		}
+	/* AES1+0 */
+	if (iec958_mode == AIU_958_MODE_PCM_RAW) {
+		set.chan_stat->chstat0_l = 0x8206;
 	} else {
-		if (i2s_mode == AIU_I2S_MODE_PCM32)
-			iec958_mode = AIU_958_MODE_PCM32;
-		else if (i2s_mode == AIU_I2S_MODE_PCM24)
-			iec958_mode = AIU_958_MODE_PCM24;
-		else
-			iec958_mode = AIU_958_MODE_PCM16;
-		pr_info("iec958 mode %s\n",
-		       (i2s_mode ==
-			AIU_I2S_MODE_PCM32) ? "PCM32" : ((i2s_mode ==
-							  AIU_I2S_MODE_PCM24) ?
-							 "PCM24" : "PCM16"));
+		set.chan_stat->chstat0_l = 0x8204;
 	}
-	if (iec958_mode == AIU_958_MODE_PCM16
-	    || iec958_mode == AIU_958_MODE_PCM24
-	    || iec958_mode == AIU_958_MODE_PCM32) {
-		set.chan_stat->chstat0_l = 0x0100;
-		set.chan_stat->chstat0_r = 0x0100;
-		set.chan_stat->chstat1_l = 0x200;
-		set.chan_stat->chstat1_r = 0x200;
-		if (sample_rate == AUDIO_CLK_FREQ_882) {
-			pr_info("----sample_rate==AUDIO_CLK_FREQ_882---\n");
-			set.chan_stat->chstat1_l = 0x800;
-			set.chan_stat->chstat1_r = 0x800;
-		}
-
-		if (sample_rate == AUDIO_CLK_FREQ_96) {
-			pr_info("----sample_rate==AUDIO_CLK_FREQ_96---\n");
-			set.chan_stat->chstat1_l = 0xa00;
-			set.chan_stat->chstat1_r = 0xa00;
-		}
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size, 0);
-		/* audio_set_i2s_mode(AIU_I2S_MODE_PCM16); */
-		/* audio_set_aiubuf(start, size); */
+	set.chan_stat->chstat0_r = set.chan_stat->chstat0_l;
+
+	/* AES3+2 */
+	if (IEC958_mode_codec == 8) {
+		set.chan_stat->chstat1_l = 0x0900;
+	} else if (runtime->rate == 192000) {
+		set.chan_stat->chstat1_l = 0x0e00;
+	} else if (runtime->rate == 176400) {
+		set.chan_stat->chstat1_l = 0x0c00;
+	} else if (runtime->rate == 96000) {
+		set.chan_stat->chstat1_l = 0x0a00;
+	} else if (runtime->rate == 88200) {
+		set.chan_stat->chstat1_l = 0x0800;
+	} else if (runtime->rate == 48000) {
+		set.chan_stat->chstat1_l = 0x0200;
+	} else if (runtime->rate == 44100) {
+		set.chan_stat->chstat1_l = 0x0000;
+	} else if (runtime->rate == 32000) {
+		set.chan_stat->chstat1_l = 0x0300;
 	} else {
-
-		set.chan_stat->chstat0_l = 0x1902;
-		set.chan_stat->chstat0_r = 0x1902;
-		if (IEC958_mode_codec == 4 || IEC958_mode_codec == 5) {
-			/* DD+ */
-			if (runtime->rate == 32000) {
-				set.chan_stat->chstat1_l = 0x300;
-				set.chan_stat->chstat1_r = 0x300;
-			} else if (runtime->rate == 44100) {
-				set.chan_stat->chstat1_l = 0xc00;
-				set.chan_stat->chstat1_r = 0xc00;
-			} else {
-				set.chan_stat->chstat1_l = 0Xe00;
-				set.chan_stat->chstat1_r = 0Xe00;
-			}
-		} else {
-			/* DTS,DD */
-			if (runtime->rate == 32000) {
-				set.chan_stat->chstat1_l = 0x300;
-				set.chan_stat->chstat1_r = 0x300;
-			} else if (runtime->rate == 44100) {
-				set.chan_stat->chstat1_l = 0;
-				set.chan_stat->chstat1_r = 0;
-			} else {
-				set.chan_stat->chstat1_l = 0x200;
-				set.chan_stat->chstat1_r = 0x200;
-			}
-		}
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size,
-				    (iec958_mode == AIU_958_MODE_RAW) ? 1 : 0);
-		memset((void *)buf->area, 0, size);
+		set.chan_stat->chstat1_l = 0x0100;
 	}
-	ALSA_DEBUG("aiu 958 pcm buffer size %d\n", size);
+	set.chan_stat->chstat1_r = set.chan_stat->chstat1_l;
+
+	audio_set_958outbuf(buf->addr, snd_pcm_lib_buffer_bytes(substream), 0);
 	audio_set_958_mode(iec958_mode, &set);
 
-	if (IEC958_mode_codec == 2) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_AC_3, substream);
-	} else if (IEC958_mode_codec == 3) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS, substream);
-	} else if (IEC958_mode_codec == 4) {
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS,
-					 substream);
-	} else if (IEC958_mode_codec == 5) {
+	/* notify hdmi to set audio type */
+	if (IEC958_mode_codec == 8) {
+		/* TrueHD/DTS-HD MA */
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA, substream);
+	} else if (iec958_mode == AIU_958_MODE_PCM_RAW) {
+		/* AC3/DTS/EAC3 */
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD, substream);
-	} else if (IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
-		aml_write_cbus(AIU_958_CHSTAT_L0, 0x1902);
-		aml_write_cbus(AIU_958_CHSTAT_L1, 0x900);
-		aml_write_cbus(AIU_958_CHSTAT_R0, 0x1902);
-		aml_write_cbus(AIU_958_CHSTAT_R1, 0x900);
-		if (IEC958_mode_codec == 8)
-			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA,
-			substream);
-		else
-			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP,
-			substream);
 	} else {
+		/* PCM */
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
 }
@@ -418,7 +332,6 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 
 void aml_alsa_hw_reprepare(void)
 {
-	ALSA_TRACE();
 	/* M8 disable it */
 #if 0
 	/* diable 958 module before call initiation */
@@ -438,7 +351,6 @@ static int aml_dai_spdif_startup(struct snd_pcm_substream *substream,
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s;
 
-	ALSA_TRACE();
 	if (!prtd) {
 		prtd =
 		    (struct aml_runtime_data *)
@@ -471,17 +383,14 @@ static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
 
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	/* struct snd_dma_buffer *buf = &substream->dma_buffer; */
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		memset((void *)runtime->dma_area, 0,
 		       snd_pcm_lib_buffer_bytes(substream));
-		if (IEC958_mode_codec == 6) {
-			pr_info
-			    ("[%s %d]8chPCM output:disable aml_spdif_play()\n",
-			     __func__, __LINE__);
-		} else {
-			aml_spdif_play();
-		}
+		if (IEC958_mode_codec == 6)
+			pr_info("8chPCM output:disable aml_spdif_play\n");
+		else
+			;/*aml_spdif_play();*/
+
 		/* audio_spdifout_pg_enable(0); */
 	}
 
@@ -496,9 +405,8 @@ static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 	/* struct aml_runtime_data *prtd = runtime->private_data; */
 	/* audio_stream_t *s = &prtd->s; */
 
-	ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		aml_hw_iec958_init(substream);
+		aml_hw_iec958_init(substream, 0);
 	} else {
 		audio_in_spdif_set_buf(runtime->dma_addr,
 				       runtime->dma_bytes * 2);
@@ -519,7 +427,7 @@ static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 int aml_set_spdif_clk(unsigned long rate, bool src_i2s)
 {
 	int ret = 0;
-	pr_info("aml_set_spdif_clk rate\n");
+
 	if (src_i2s) {
 		ret = clk_set_parent(spdif_p->clk_spdif, spdif_p->clk_mclk);
 		if (ret) {
@@ -563,7 +471,6 @@ static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
 	srate = params_rate(params);
 	aml_set_spdif_clk(srate * 512, 0);
 #endif
-	ALSA_TRACE();
 	return 0;
 }
 
@@ -641,7 +548,6 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 	struct reset_control *spdif_reset;
 	struct aml_spdif *spdif_priv;
 
-	pr_info("aml_spdif_probe\n");
 	/* enable spdif power gate first */
 	for (i = 0; i < ARRAY_SIZE(gate_names); i++) {
 		spdif_reset = devm_reset_control_get(&pdev->dev, gate_names[i]);
@@ -708,7 +614,15 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	aml_spdif_play();
+	spdif_priv->clk_81 = devm_clk_get(&pdev->dev, "clk_81");
+	if (IS_ERR(spdif_priv->clk_81)) {
+		dev_err(&pdev->dev, "Can't get clk81\n");
+		ret = PTR_ERR(spdif_priv->clk_81);
+		goto err;
+	}
+	clk81 = clk_get_rate(spdif_priv->clk_81);
+
+	aml_spdif_play(0);
 	ret = snd_soc_register_component(&pdev->dev, &aml_component,
 					  aml_spdif_dai,
 					  ARRAY_SIZE(aml_spdif_dai));
@@ -733,6 +647,16 @@ static int aml_dai_spdif_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void aml_spdif_dai_shutdown(struct platform_device *pdev)
+{
+	struct aml_spdif *spdif_priv = dev_get_drvdata(&pdev->dev);
+
+	if (spdif_priv && spdif_priv->clk_spdif)
+		clk_disable_unprepare(spdif_priv->clk_spdif);
+
+	return;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_spdif_dai_dt_match[] = {
 	{.compatible = "amlogic, aml-spdif-dai",
@@ -746,6 +670,7 @@ static const struct of_device_id amlogic_spdif_dai_dt_match[] = {
 static struct platform_driver aml_spdif_dai_driver = {
 	.probe = aml_dai_spdif_probe,
 	.remove = aml_dai_spdif_remove,
+	.shutdown = aml_spdif_dai_shutdown,
 	.driver = {
 		   .name = "aml-spdif-dai",
 		   .owner = THIS_MODULE,
@@ -755,7 +680,6 @@ static struct platform_driver aml_spdif_dai_driver = {
 
 static int __init aml_dai_spdif_init(void)
 {
-	ALSA_PRINT("enter aml_dai_spdif_init\n");
 	return platform_driver_register(&aml_spdif_dai_driver);
 }
 
diff --git a/sound/soc/aml/m8/aml_spdif_dai.h b/sound/soc/aml/m8/aml_spdif_dai.h
index fd11637..a098171 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.h
+++ b/sound/soc/aml/m8/aml_spdif_dai.h
@@ -45,7 +45,7 @@ extern unsigned int IEC958_mode_codec;
 * 3)PCM  output for audios except ac3/dts,
 * when raw output mode is selected by user
 */
-void aml_hw_iec958_init(struct snd_pcm_substream *substream);
+void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc);
 int aml_set_spdif_clk(unsigned long rate, bool src_i2s);
-void aml_spdif_play(void);
+void aml_spdif_play(int samesrc);
 #endif  /* _AML_SPDIF_DAI_H */
diff --git a/sound/soc/aml/m8/odroid_dac.h b/sound/soc/aml/m8/odroid_dac.h
deleted file mode 100644
index 947c4a5..0000000
--- a/sound/soc/aml/m8/odroid_dac.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * sound/soc/aml/m8/aml_m8.h
- *
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
-*/
-
-#ifndef AML_M8_H
-#define AML_M8_H
-
-#include <sound/soc.h>
-#include <linux/gpio/consumer.h>
-struct odroid_audio_private_data {
-	struct pinctrl *pin_ctl;
-	void *data;
-};
-
-void aml_spdif_pinmux_init(struct device *pdev);
-void aml_spdif_pinmux_deinit(struct device *pdev);
-#endif
-
diff --git a/sound/soc/atmel/atmel_ssc_dai.c b/sound/soc/atmel/atmel_ssc_dai.c
index f20e703..1ead3c9 100644
--- a/sound/soc/atmel/atmel_ssc_dai.c
+++ b/sound/soc/atmel/atmel_ssc_dai.c
@@ -344,6 +344,7 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 	struct atmel_pcm_dma_params *dma_params;
 	int dir, channels, bits;
 	u32 tfmr, rfmr, tcmr, rcmr;
+	int start_event;
 	int ret;
 
 	/*
@@ -450,10 +451,19 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 		 * The SSC transmit clock is obtained from the BCLK signal on
 		 * on the TK line, and the SSC receive clock is
 		 * generated from the transmit clock.
+		 *
+		 *  For single channel data, one sample is transferred
+		 * on the falling edge of the LRC clock.
+		 * For two channel data, one sample is
+		 * transferred on both edges of the LRC clock.
 		 */
+		start_event = ((channels == 1)
+				? SSC_START_FALLING_RF
+				: SSC_START_EDGE_RF);
+
 		rcmr =	  SSC_BF(RCMR_PERIOD, 0)
 			| SSC_BF(RCMR_STTDLY, START_DELAY)
-			| SSC_BF(RCMR_START, SSC_START_FALLING_RF)
+			| SSC_BF(RCMR_START, start_event)
 			| SSC_BF(RCMR_CKI, SSC_CKI_RISING)
 			| SSC_BF(RCMR_CKO, SSC_CKO_NONE)
 			| SSC_BF(RCMR_CKS, SSC_CKS_CLOCK);
@@ -461,14 +471,14 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 		rfmr =	  SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)
 			| SSC_BF(RFMR_FSOS, SSC_FSOS_NONE)
 			| SSC_BF(RFMR_FSLEN, 0)
-			| SSC_BF(RFMR_DATNB, (channels - 1))
+			| SSC_BF(RFMR_DATNB, 0)
 			| SSC_BIT(RFMR_MSBF)
 			| SSC_BF(RFMR_LOOP, 0)
 			| SSC_BF(RFMR_DATLEN, (bits - 1));
 
 		tcmr =	  SSC_BF(TCMR_PERIOD, 0)
 			| SSC_BF(TCMR_STTDLY, START_DELAY)
-			| SSC_BF(TCMR_START, SSC_START_FALLING_RF)
+			| SSC_BF(TCMR_START, start_event)
 			| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)
 			| SSC_BF(TCMR_CKO, SSC_CKO_NONE)
 			| SSC_BF(TCMR_CKS, SSC_CKS_PIN);
@@ -477,7 +487,7 @@ static int atmel_ssc_hw_params(struct snd_pcm_substream *substream,
 			| SSC_BF(TFMR_FSDEN, 0)
 			| SSC_BF(TFMR_FSOS, SSC_FSOS_NONE)
 			| SSC_BF(TFMR_FSLEN, 0)
-			| SSC_BF(TFMR_DATNB, (channels - 1))
+			| SSC_BF(TFMR_DATNB, 0)
 			| SSC_BIT(TFMR_MSBF)
 			| SSC_BF(TFMR_DATDEF, 0)
 			| SSC_BF(TFMR_DATLEN, (bits - 1));
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 3216f9b..4e47e46 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -134,6 +134,10 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_WM9713 if SND_SOC_AC97_BUS
 	select SND_SOC_DUMMY_CODEC
 	select SND_SOC_PCM2BT
+	select SND_SOC_TAS5707 if I2C
+	select SND_SOC_TAS5717 if I2C
+	select SND_SOC_TAS5731 if I2C
+	select SND_SOC_AMLPMU4 if I2C
         help
           Normally ASoC codec drivers are only built if a machine driver which
           uses them is also built since they are only usable with a machine
@@ -557,8 +561,28 @@ config SND_SOC_ML26124
 config SND_SOC_TPA6130A2
 	tristate
 
+#Amlogic
+
 config SND_SOC_DUMMY_CODEC
 	tristate
 
+config SND_SOC_TAS5707
+	tristate
+
+config SND_SOC_TAS5717
+	tristate
+
+config SND_SOC_TAS5731
+	tristate
+
+config SND_SOC_AMLPMU4
+	tristate
+
 config SND_SOC_PCM2BT
 	tristate
+
+config SND_SOC_AMLT9015
+	tristate
+
+config SND_SOC_AMLT9015S
+	tristate
\ No newline at end of file
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index f86b42a..a938765 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -126,10 +126,16 @@ snd-soc-wm9713-objs := wm9713.o
 snd-soc-wm-hubs-objs := wm_hubs.o
 snd-soc-dummy_codec-objs := dummy_codec.o
 snd-soc-pcm2bt-objs  := pcm2bt.o
+snd-soc-amlpmu4-objs := aml_pmu4_codec.o
+snd-soc-aml_t9015-objs := aml_codec_t9015.o
+snd-soc-aml_t9015S-objs := aml_codec_t9015S.o
 
 # Amp
 snd-soc-max9877-objs := max9877.o
 snd-soc-tpa6130a2-objs := tpa6130a2.o
+snd-soc-tas5707-objs := tas5707.o
+snd-soc-tas5717-objs := tas5717.o
+snd-soc-tas5731-objs := tas5731.o
 
 obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
 obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
@@ -258,7 +264,13 @@ obj-$(CONFIG_SND_SOC_WM_ADSP)	+= snd-soc-wm-adsp.o
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 obj-$(CONFIG_SND_SOC_DUMMY_CODEC)	+= snd-soc-dummy_codec.o
 obj-$(CONFIG_SND_SOC_PCM2BT)	+= snd-soc-pcm2bt.o
+obj-$(CONFIG_SND_SOC_AMLPMU4)	+= snd-soc-amlpmu4.o
+obj-$(CONFIG_SND_SOC_AMLT9015)	+= snd-soc-aml_t9015.o
+obj-$(CONFIG_SND_SOC_AMLT9015S)	+= snd-soc-aml_t9015S.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
+obj-$(CONFIG_SND_SOC_TAS5707)   += snd-soc-tas5707.o
+obj-$(CONFIG_SND_SOC_TAS5717)   += snd-soc-tas5717.o
+obj-$(CONFIG_SND_SOC_TAS5731)   += snd-soc-tas5731.o
diff --git a/sound/soc/codecs/adav80x.c b/sound/soc/codecs/adav80x.c
index 23454e9..f78b27a 100644
--- a/sound/soc/codecs/adav80x.c
+++ b/sound/soc/codecs/adav80x.c
@@ -319,7 +319,7 @@ static int adav80x_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
-	unsigned int deemph = ucontrol->value.integer.value[0];
+	unsigned int deemph = ucontrol->value.enumerated.item[0];
 
 	if (deemph > 1)
 		return -EINVAL;
@@ -335,7 +335,7 @@ static int adav80x_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = adav80x->deemph;
+	ucontrol->value.enumerated.item[0] = adav80x->deemph;
 	return 0;
 };
 
diff --git a/sound/soc/codecs/ak4641.c b/sound/soc/codecs/ak4641.c
index d718472..94cbe50 100644
--- a/sound/soc/codecs/ak4641.c
+++ b/sound/soc/codecs/ak4641.c
@@ -76,7 +76,7 @@ static int ak4641_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.integer.value[0];
+	int deemph = ucontrol->value.enumerated.item[0];
 
 	if (deemph > 1)
 		return -EINVAL;
@@ -92,7 +92,7 @@ static int ak4641_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = ak4641->deemph;
+	ucontrol->value.enumerated.item[0] = ak4641->deemph;
 	return 0;
 };
 
diff --git a/sound/soc/codecs/aml_codec_t9015.c b/sound/soc/codecs/aml_codec_t9015.c
new file mode 100644
index 0000000..490f5c2
--- /dev/null
+++ b/sound/soc/codecs/aml_codec_t9015.c
@@ -0,0 +1,535 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/sound/aiu_regs.h>
+
+#include "aml_codec_t9015.h"
+
+static struct mutex acodec;
+static void acodec_reg_write(unsigned data, unsigned addr)
+{
+	void __iomem *vaddr;
+	mutex_lock(&acodec);
+	vaddr = ioremap((addr), 0x4);
+	writel(data, vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&acodec);
+}
+
+static unsigned acodec_reg_read(unsigned addr)
+{
+	unsigned tmp;
+	void __iomem *vaddr;
+	mutex_lock(&acodec);
+	vaddr = ioremap((addr), 0x4);
+	tmp = readl(vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&acodec);
+	return tmp;
+}
+
+struct aml_T9015_audio_priv {
+	struct snd_soc_codec *codec;
+	struct snd_pcm_hw_params *params;
+};
+
+struct T9015_audio_init_reg {
+	u32 reg;
+	u32 val;
+};
+
+static struct T9015_audio_init_reg init_list[] = {
+	{AUDIO_CONFIG_BLOCK_ENABLE, 0x0000B00F},
+	{ADC_VOL_CTR_PGA_IN_CONFIG, 0x00000000},
+	{DAC_VOL_CTR_DAC_SOFT_MUTE, 0xFBFB0000},
+	{LINE_OUT_CONFIG, 0x00001111},
+	{POWER_CONFIG, 0x00010000},
+};
+
+#define T9015_AUDIO_INIT_REG_LEN ARRAY_SIZE(init_list)
+
+static int aml_T9015_audio_reg_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for (i = 0; i < T9015_AUDIO_INIT_REG_LEN; i++)
+		snd_soc_write(codec, init_list[i].reg, init_list[i].val);
+
+	return 0;
+}
+
+static unsigned int aml_T9015_audio_read(struct snd_soc_codec *codec,
+				unsigned int reg)
+{
+	u32 val;
+	u32 int_reg = reg & (~0x3);
+	val = acodec_reg_read(ACODEC_BASE_ADD + int_reg);
+	return val;
+
+}
+
+static int aml_T9015_audio_write(struct snd_soc_codec *codec, unsigned int reg,
+				unsigned int val)
+{
+	u32 int_reg = reg & (~0x3);
+	acodec_reg_write(val, (ACODEC_BASE_ADD + int_reg));
+	return 0;
+}
+
+static int aml_DAC_Gain_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	u32 add = ACODEC_BASE_ADD + ADC_VOL_CTR_PGA_IN_CONFIG;
+	u32 val = acodec_reg_read(add);
+	u32 val1 = (val & (0x1 <<  DAC_GAIN_SEL_L)) >> DAC_GAIN_SEL_L;
+	u32 val2 = (val & (0x1 <<  DAC_GAIN_SEL_H)) >> (DAC_GAIN_SEL_H - 1);
+	val = val1 | val2;
+	ucontrol->value.enumerated.item[0] = val;
+	return 0;
+}
+
+static int aml_DAC_Gain_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	u32 add = ACODEC_BASE_ADD + ADC_VOL_CTR_PGA_IN_CONFIG;
+	u32 val = acodec_reg_read(add);
+
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		val &= ~(0x1 << DAC_GAIN_SEL_H);
+		val &= ~(0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		val &= ~(0x1 << DAC_GAIN_SEL_H);
+		val |= (0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	} else if (ucontrol->value.enumerated.item[0] == 2) {
+		val |= (0x1 << DAC_GAIN_SEL_H);
+		val &= ~(0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	} else if (ucontrol->value.enumerated.item[0] == 3) {
+		val |= (0x1 << DAC_GAIN_SEL_H);
+		val |= (0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	}
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -95250, 375, 1);
+
+static const char *const DAC_Gain_texts[] = { "0dB", "6dB", "12dB", "18dB" };
+
+static const struct soc_enum DAC_Gain_enum = SOC_ENUM_SINGLE(
+			SND_SOC_NOPM, 0, ARRAY_SIZE(DAC_Gain_texts),
+			DAC_Gain_texts);
+
+static const struct snd_kcontrol_new T9015_audio_snd_controls[] = {
+
+	/*DAC Digital Volume control */
+	SOC_DOUBLE_TLV("DAC Digital Playback Volume",
+			   DAC_VOL_CTR_DAC_SOFT_MUTE,
+			   DACL_VC, DACR_VC,
+			   0xff, 0, dac_vol_tlv),
+
+    /*DAC extra Digital Gain control */
+	SOC_ENUM_EXT("DAC Extra Digital Gain",
+			   DAC_Gain_enum,
+			   aml_DAC_Gain_get_enum,
+			   aml_DAC_Gain_set_enum),
+
+};
+
+/*line out Left Positive mux */
+static const char * const T9015_out_lp_txt[] = {
+	"None", "LOLP_SEL_DACL", "LOLP_SEL_DACL_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015_out_lp_enum, LINE_OUT_CONFIG,
+				  LOLP_SEL_DACL, T9015_out_lp_txt);
+
+static const struct snd_kcontrol_new line_out_lp_mux =
+SOC_DAPM_ENUM("ROUTE_LP_OUT", T9015_out_lp_enum);
+
+/*line out Left Negative mux */
+static const char * const T9015_out_ln_txt[] = {
+	"None", "LOLN_SEL_DACL_INV", "LOLN_SEL_DACL"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015_out_ln_enum, LINE_OUT_CONFIG,
+				  LOLN_SEL_DACL_INV, T9015_out_ln_txt);
+
+static const struct snd_kcontrol_new line_out_ln_mux =
+SOC_DAPM_ENUM("ROUTE_LN_OUT", T9015_out_ln_enum);
+
+/*line out Right Positive mux */
+static const char * const T9015_out_rp_txt[] = {
+	"None", "LORP_SEL_DACR", "LORP_SEL_DACR_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015_out_rp_enum, LINE_OUT_CONFIG,
+				  LORP_SEL_DACR, T9015_out_rp_txt);
+
+static const struct snd_kcontrol_new line_out_rp_mux =
+SOC_DAPM_ENUM("ROUTE_RP_OUT", T9015_out_rp_enum);
+
+/*line out Right Negative mux */
+static const char * const T9015_out_rn_txt[] = {
+	"None", "LORN_SEL_DACR_INV", "LORN_SEL_DACR"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015_out_rn_enum, LINE_OUT_CONFIG,
+				  LORN_SEL_DACR_INV, T9015_out_rn_txt);
+
+static const struct snd_kcontrol_new line_out_rn_mux =
+SOC_DAPM_ENUM("ROUTE_RN_OUT", T9015_out_rn_enum);
+
+static const struct snd_soc_dapm_widget T9015_audio_dapm_widgets[] = {
+
+	/*Output */
+	SND_SOC_DAPM_OUTPUT("Lineout left N"),
+	SND_SOC_DAPM_OUTPUT("Lineout left P"),
+	SND_SOC_DAPM_OUTPUT("Lineout right N"),
+	SND_SOC_DAPM_OUTPUT("Lineout right P"),
+
+	/*DAC playback stream */
+	SND_SOC_DAPM_DAC("Left DAC", "HIFI Playback",
+			 AUDIO_CONFIG_BLOCK_ENABLE,
+			 DACL_EN, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "HIFI Playback",
+			 AUDIO_CONFIG_BLOCK_ENABLE,
+			 DACR_EN, 0),
+
+	/*DRV output */
+	SND_SOC_DAPM_OUT_DRV("LOLP_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LOLN_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORP_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORN_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+
+	/*MUX output source select */
+	SND_SOC_DAPM_MUX("Lineout left P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_lp_mux),
+	SND_SOC_DAPM_MUX("Lineout left N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_ln_mux),
+	SND_SOC_DAPM_MUX("Lineout right P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rp_mux),
+	SND_SOC_DAPM_MUX("Lineout right N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rn_mux),
+};
+
+static const struct snd_soc_dapm_route T9015_audio_dapm_routes[] = {
+    /*Output path*/
+	{"Lineout left P switch", "LOLP_SEL_DACL", "Left DAC"},
+	{"Lineout left P switch", "LOLP_SEL_DACL_INV", "Left DAC"},
+
+	{"Lineout left N switch", "LOLN_SEL_DACL_INV", "Left DAC"},
+	{"Lineout left N switch", "LOLN_SEL_DACL", "Left DAC"},
+
+	{"Lineout right P switch", "LORP_SEL_DACR", "Right DAC"},
+	{"Lineout right P switch", "LORP_SEL_DACR_INV", "Right DAC"},
+
+	{"Lineout right N switch", "LORN_SEL_DACR_INV", "Right DAC"},
+	{"Lineout right N switch", "LORN_SEL_DACR", "Right DAC"},
+
+	{"LOLN_OUT_EN", NULL, "Lineout left N switch"},
+	{"LOLP_OUT_EN", NULL, "Lineout left P switch"},
+	{"LORN_OUT_EN", NULL, "Lineout right N switch"},
+	{"LORP_OUT_EN", NULL, "Lineout right P switch"},
+
+	{"Lineout left N", NULL, "LOLN_OUT_EN"},
+	{"Lineout left P", NULL, "LOLP_OUT_EN"},
+	{"Lineout right N", NULL, "LORN_OUT_EN"},
+	{"Lineout right P", NULL, "LORP_OUT_EN"},
+};
+
+static int aml_T9015_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		snd_soc_update_bits(codec, AUDIO_CONFIG_BLOCK_ENABLE,
+					I2S_MODE, 1);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		snd_soc_update_bits(codec, AUDIO_CONFIG_BLOCK_ENABLE,
+					I2S_MODE, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aml_T9015_set_dai_sysclk(struct snd_soc_dai *dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int aml_T9015_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct aml_T9015_audio_priv *T9015_audio =
+	    snd_soc_codec_get_drvdata(codec);
+
+	T9015_audio->params = params;
+
+	return 0;
+}
+
+static int aml_T9015_audio_set_bias_level(struct snd_soc_codec *codec,
+					 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (SND_SOC_BIAS_OFF == codec->dapm.bias_level) {
+			codec->cache_only = false;
+			codec->cache_sync = 1;
+			snd_soc_cache_sync(codec);
+		}
+		break;
+
+	case SND_SOC_BIAS_OFF:
+
+		break;
+
+	default:
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static int aml_T9015_prepare(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	/*struct snd_soc_codec *codec = dai->codec;*/
+	return 0;
+
+}
+
+static int aml_T9015_audio_reset(struct snd_soc_codec *codec)
+{
+	aml_cbus_update_bits(RESET1_REGISTER, (1 << ACODEC_RESET),
+					(1 << ACODEC_RESET));
+	udelay(1000);
+	return 0;
+}
+
+static int aml_T9015_audio_start_up(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xF000);
+	msleep(200);
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xB000);
+	return 0;
+}
+
+static int aml_T9015_codec_mute_stream(struct snd_soc_dai *dai, int mute,
+				      int stream)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u32 reg;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		reg = snd_soc_read(codec, DAC_VOL_CTR_DAC_SOFT_MUTE);
+		if (mute)
+			reg |= 0x1 << DAC_SOFT_MUTE;
+		else
+			reg &= ~(0x1 << DAC_SOFT_MUTE);
+
+		snd_soc_write(codec, DAC_VOL_CTR_DAC_SOFT_MUTE, reg);
+	}
+	return 0;
+}
+
+static int aml_T9015_audio_probe(struct snd_soc_codec *codec)
+{
+	struct aml_T9015_audio_priv *T9015_audio = NULL;
+
+	T9015_audio = kzalloc(sizeof(struct aml_T9015_audio_priv), GFP_KERNEL);
+	if (NULL == T9015_audio)
+		return -ENOMEM;
+	snd_soc_codec_set_drvdata(codec, T9015_audio);
+
+	/*reset audio codec register*/
+	aml_T9015_audio_reset(codec);
+	aml_T9015_audio_start_up(codec);
+	aml_T9015_audio_reg_init(codec);
+
+	aml_write_cbus(AIU_ACODEC_CTRL, (1 << 4)
+			   |(1 << 6)
+			   |(1 << 11)
+			   |(1 << 15)
+			   |(2 << 2)
+	);
+
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	T9015_audio->codec = codec;
+
+	return 0;
+}
+
+static int aml_T9015_audio_remove(struct snd_soc_codec *codec)
+{
+	aml_T9015_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int aml_T9015_audio_suspend(struct snd_soc_codec *codec)
+{
+	pr_info("aml_T9015_audio_suspend!\n");
+	aml_T9015_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0);
+	return 0;
+}
+
+static int aml_T9015_audio_resume(struct snd_soc_codec *codec)
+{
+	pr_info("aml_T9015_audio_resume!\n");
+	aml_T9015_audio_reset(codec);
+	aml_T9015_audio_start_up(codec);
+	aml_T9015_audio_reg_init(codec);
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	aml_T9015_audio_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+
+#define T9015_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_96000
+#define T9015_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
+			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
+			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
+
+struct snd_soc_dai_ops T9015_audio_aif_dai_ops = {
+	.hw_params = aml_T9015_hw_params,
+	.prepare = aml_T9015_prepare,
+	.set_fmt = aml_T9015_set_dai_fmt,
+	.set_sysclk = aml_T9015_set_dai_sysclk,
+	.mute_stream = aml_T9015_codec_mute_stream,
+};
+
+struct snd_soc_dai_driver aml_T9015_audio_dai[] = {
+	{
+	 .name = "T9015-audio-hifi",
+	 .id = 0,
+	 .playback = {
+		      .stream_name = "HIFI Playback",
+		      .channels_min = 2,
+		      .channels_max = 8,
+		      .rates = T9015_AUDIO_STEREO_RATES,
+		      .formats = T9015_AUDIO_FORMATS,
+		      },
+	 .ops = &T9015_audio_aif_dai_ops,
+	 },
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_aml_T9015_audio = {
+	.probe = aml_T9015_audio_probe,
+	.remove = aml_T9015_audio_remove,
+	.suspend = aml_T9015_audio_suspend,
+	.resume = aml_T9015_audio_resume,
+	.read = aml_T9015_audio_read,
+	.write = aml_T9015_audio_write,
+	.set_bias_level = aml_T9015_audio_set_bias_level,
+	.controls = T9015_audio_snd_controls,
+	.num_controls = ARRAY_SIZE(T9015_audio_snd_controls),
+	.dapm_widgets = T9015_audio_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(T9015_audio_dapm_widgets),
+	.dapm_routes = T9015_audio_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(T9015_audio_dapm_routes),
+	.reg_cache_size = 16,
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 2,
+};
+
+static int aml_T9015_audio_codec_probe(struct platform_device *pdev)
+{
+	int ret;
+	dev_info(&pdev->dev, "aml_T9015_audio_codec_probe\n");
+	mutex_init(&acodec);
+	ret = snd_soc_register_codec(&pdev->dev,
+				     &soc_codec_dev_aml_T9015_audio,
+				     &aml_T9015_audio_dai[0], 1);
+	return ret;
+}
+
+static int aml_T9015_audio_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id aml_T9015_codec_dt_match[] = {
+	{.compatible = "amlogic, aml_codec_T9015",},
+	{},
+};
+
+static struct platform_driver aml_T9015_codec_platform_driver = {
+	.driver = {
+		   .name = "aml_codec_T9015",
+		   .owner = THIS_MODULE,
+		   .of_match_table = aml_T9015_codec_dt_match,
+		   },
+	.probe = aml_T9015_audio_codec_probe,
+	.remove = aml_T9015_audio_codec_remove,
+};
+
+static int __init aml_T9015_audio_modinit(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&aml_T9015_codec_platform_driver);
+	if (ret != 0) {
+		pr_err(
+			"Failed to register AML T9015 codec platform driver: %d\n",
+			ret);
+	}
+
+	return ret;
+}
+
+module_init(aml_T9015_audio_modinit);
+
+static void __exit aml_T9015_audio_exit(void)
+{
+	platform_driver_unregister(&aml_T9015_codec_platform_driver);
+}
+
+module_exit(aml_T9015_audio_exit);
+
+MODULE_DESCRIPTION("ASoC AML T9015 audio codec driver");
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/aml_codec_t9015.h b/sound/soc/codecs/aml_codec_t9015.h
new file mode 100644
index 0000000..f24bdde
--- /dev/null
+++ b/sound/soc/codecs/aml_codec_t9015.h
@@ -0,0 +1,55 @@
+#ifndef AML_T9015_H_
+#define AML_T9015_H_
+
+#define ACODEC_BASE_ADD    0xc8832000
+#define ACODEC_TOP_ADDR(x) (x)
+
+#define AUDIO_CONFIG_BLOCK_ENABLE       ACODEC_TOP_ADDR(0x00)
+#define MCLK_FREQ                   0x1F
+#define I2S_MODE                    0x1E
+#define DAC_CLK_TO_GPIO_EN          0x18
+#define DACL_DATA_SOURCE            0x17
+#define DACR_DATA_SOURCE            0x16
+#define DACL_INV                    0x15
+#define DACR_INV                    0x14
+#define VMID_GEN_EN                 0x0F
+#define VMID_GEN_FAST               0x0E
+#define BIAS_CURRENT_EN             0x0D
+#define REFP_BUF_EN                 0x0C
+#define DACL_EN                     0x05
+#define DACR_EN                     0x04
+#define LOLP_EN                     0x03
+#define LOLN_EN                     0x02
+#define LORP_EN                     0x01
+#define LORN_EN                     0x00
+
+#define ADC_VOL_CTR_PGA_IN_CONFIG       ACODEC_TOP_ADDR(0x04)
+#define DAC_GAIN_SEL_H              0x1F
+#define DAC_GAIN_SEL_L              0x17
+
+
+#define DAC_VOL_CTR_DAC_SOFT_MUTE       ACODEC_TOP_ADDR(0x08)
+#define DACL_VC                     0x18
+#define DACR_VC                     0x10
+#define DAC_SOFT_MUTE               0x0F
+#define DAC_UNMUTE_MODE             0x0E
+#define DAC_MUTE_MODE               0x0D
+#define DAC_VC_RAMP_MODE            0x0C
+#define DAC_RAMP_RATE               0x0A
+#define DAC_MONO                    0x08
+
+#define LINE_OUT_CONFIG                 ACODEC_TOP_ADDR(0x0c)
+#define LOLP_SEL_DACL_INV           0x0D
+#define LOLP_SEL_DACL               0x0C
+#define LOLN_SEL_DACL               0x09
+#define LOLN_SEL_DACL_INV           0x08
+#define LORP_SEL_DACR_INV           0x05
+#define LORP_SEL_DACR               0x04
+#define LORN_SEL_DACR               0x01
+#define LORN_SEL_DACR_INV           0x00
+
+#define POWER_CONFIG                    ACODEC_TOP_ADDR(0x10)
+#define MUTE_DAC_PD_EN              0x1F
+#define IB_CON                      0x10
+
+#endif
diff --git a/sound/soc/codecs/aml_codec_t9015S.c b/sound/soc/codecs/aml_codec_t9015S.c
new file mode 100644
index 0000000..cd35dfb
--- /dev/null
+++ b/sound/soc/codecs/aml_codec_t9015S.c
@@ -0,0 +1,627 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/sound/aiu_regs.h>
+#include <linux/amlogic/sound/audin_regs.h>
+
+#include "aml_codec_t9015S.h"
+
+static struct mutex acodec;
+static void acodec_reg_write(unsigned data, unsigned addr)
+{
+	void __iomem *vaddr;
+	mutex_lock(&acodec);
+	vaddr = ioremap((addr), 0x4);
+	writel(data, vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&acodec);
+}
+
+static unsigned acodec_reg_read(unsigned addr)
+{
+	unsigned tmp;
+	void __iomem *vaddr;
+	mutex_lock(&acodec);
+	vaddr = ioremap((addr), 0x4);
+	tmp = readl(vaddr);
+	iounmap(vaddr);
+	mutex_unlock(&acodec);
+	return tmp;
+}
+
+struct aml_T9015S_audio_priv {
+	struct snd_soc_codec *codec;
+	struct snd_pcm_hw_params *params;
+};
+
+struct T9015S_audio_init_reg {
+	u32 reg;
+	u32 val;
+};
+
+static struct T9015S_audio_init_reg init_list[] = {
+	{AUDIO_CONFIG_BLOCK_ENABLE, 0x3400Bc0F},
+	{ADC_VOL_CTR_PGA_IN_CONFIG, 0x50502929},
+	{DAC_VOL_CTR_DAC_SOFT_MUTE, 0xFBFB0000},
+	{LINE_OUT_CONFIG, 0x00004444},
+	{POWER_CONFIG, 0x00010000},
+};
+
+#define T9015S_AUDIO_INIT_REG_LEN ARRAY_SIZE(init_list)
+
+static int aml_T9015S_audio_reg_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for (i = 0; i < T9015S_AUDIO_INIT_REG_LEN; i++)
+		snd_soc_write(codec, init_list[i].reg, init_list[i].val);
+
+	return 0;
+}
+
+static unsigned int aml_T9015S_audio_read(struct snd_soc_codec *codec,
+				unsigned int reg)
+{
+	u32 val;
+	u32 int_reg = reg & (~0x3);
+	val = acodec_reg_read(ACODEC_BASE_ADD + int_reg);
+	return val;
+
+}
+
+static int aml_T9015S_audio_write(struct snd_soc_codec *codec, unsigned int reg,
+				unsigned int val)
+{
+	u32 int_reg = reg & (~0x3);
+	acodec_reg_write(val, (ACODEC_BASE_ADD + int_reg));
+	return 0;
+}
+
+static int aml_DAC_Gain_get_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	u32 add = ACODEC_BASE_ADD + ADC_VOL_CTR_PGA_IN_CONFIG;
+	u32 val = acodec_reg_read(add);
+	u32 val1 = (val & (0x1 <<  DAC_GAIN_SEL_L)) >> DAC_GAIN_SEL_L;
+	u32 val2 = (val & (0x1 <<  DAC_GAIN_SEL_H)) >> (DAC_GAIN_SEL_H - 1);
+	val = val1 | val2;
+	ucontrol->value.enumerated.item[0] = val;
+	return 0;
+}
+
+static int aml_DAC_Gain_set_enum(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	u32 add = ACODEC_BASE_ADD + ADC_VOL_CTR_PGA_IN_CONFIG;
+	u32 val = acodec_reg_read(add);
+
+	if (ucontrol->value.enumerated.item[0] == 0) {
+		val &= ~(0x1 << DAC_GAIN_SEL_H);
+		val &= ~(0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+	} else if (ucontrol->value.enumerated.item[0] == 1) {
+		val &= ~(0x1 << DAC_GAIN_SEL_H);
+		val |= (0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	} else if (ucontrol->value.enumerated.item[0] == 2) {
+		val |= (0x1 << DAC_GAIN_SEL_H);
+		val &= ~(0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	} else if (ucontrol->value.enumerated.item[0] == 3) {
+		val |= (0x1 << DAC_GAIN_SEL_H);
+		val |= (0x1 << DAC_GAIN_SEL_L);
+		acodec_reg_write(val, add);
+		pr_info("It has risk of distortion!\n");
+	}
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(pga_in_tlv, -1200, 250, 1);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -29625, 375, 1);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -95250, 375, 1);
+
+static const char *const DAC_Gain_texts[] = { "0dB", "6dB", "12dB", "18dB" };
+
+static const struct soc_enum DAC_Gain_enum = SOC_ENUM_SINGLE(
+			SND_SOC_NOPM, 0, ARRAY_SIZE(DAC_Gain_texts),
+			DAC_Gain_texts);
+
+static const struct snd_kcontrol_new T9015S_audio_snd_controls[] = {
+	/*PGA_IN Gain */
+	SOC_DOUBLE_TLV("PGA IN Gain", ADC_VOL_CTR_PGA_IN_CONFIG,
+		       PGAL_IN_GAIN, PGAR_IN_GAIN,
+		       0x1f, 0, pga_in_tlv),
+
+	/*ADC Digital Volume control */
+	SOC_DOUBLE_TLV("ADC Digital Capture Volume", ADC_VOL_CTR_PGA_IN_CONFIG,
+		       ADCL_VC, ADCR_VC,
+		       0x7f, 0, adc_vol_tlv),
+
+	/*DAC Digital Volume control */
+	SOC_DOUBLE_TLV("DAC Digital Playback Volume",
+			   DAC_VOL_CTR_DAC_SOFT_MUTE,
+			   DACL_VC, DACR_VC,
+			   0xff, 0, dac_vol_tlv),
+
+    /*DAC extra Digital Gain control */
+	SOC_ENUM_EXT("DAC Extra Digital Gain",
+			   DAC_Gain_enum,
+			   aml_DAC_Gain_get_enum,
+			   aml_DAC_Gain_set_enum),
+
+};
+
+/*pgain Left Channel Input */
+static const char * const T9015S_pgain_left_txt[] = {
+	"None", "AIL1", "AIL2", "AIL3", "AIL4"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_pgain_left_enum,
+				  ADC_VOL_CTR_PGA_IN_CONFIG   ,
+				  PGAL_IN_SEL, T9015S_pgain_left_txt);
+
+static const struct snd_kcontrol_new pgain_ln_mux =
+SOC_DAPM_ENUM("ROUTE_L", T9015S_pgain_left_enum);
+
+/*pgain right Channel Input */
+static const char * const T9015S_pgain_right_txt[] = {
+	"None", "AIR1", "AIR2", "AIR3", "AIR4"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_pgain_right_enum,
+				  ADC_VOL_CTR_PGA_IN_CONFIG   ,
+				  PGAR_IN_SEL, T9015S_pgain_right_txt);
+
+static const struct snd_kcontrol_new pgain_rn_mux =
+SOC_DAPM_ENUM("ROUTE_R", T9015S_pgain_right_enum);
+
+/*line out Left Positive mux */
+static const char * const T9015S_out_lp_txt[] = {
+	"None", "LOLP_SEL_AIL_INV", "LOLP_SEL_AIL", "Reserved", "LOLP_SEL_DACL"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_lp_enum, LINE_OUT_CONFIG,
+				  LOLP_SEL_AIL_INV, T9015S_out_lp_txt);
+
+static const struct snd_kcontrol_new line_out_lp_mux =
+SOC_DAPM_ENUM("ROUTE_LP_OUT", T9015S_out_lp_enum);
+
+/*line out Left Negative mux */
+static const char * const T9015S_out_ln_txt[] = {
+	"None", "LOLN_SEL_AIL", "LOLN_SEL_DACL", "Reserved", "LOLN_SEL_DACL_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_ln_enum, LINE_OUT_CONFIG,
+				  LOLN_SEL_AIL, T9015S_out_ln_txt);
+
+static const struct snd_kcontrol_new line_out_ln_mux =
+SOC_DAPM_ENUM("ROUTE_LN_OUT", T9015S_out_ln_enum);
+
+/*line out Right Positive mux */
+static const char * const T9015S_out_rp_txt[] = {
+	"None", "LORP_SEL_AIR_INV", "LORP_SEL_AIR", "Reserved", "LORP_SEL_DACR"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_rp_enum, LINE_OUT_CONFIG,
+				  LORP_SEL_AIR_INV, T9015S_out_rp_txt);
+
+static const struct snd_kcontrol_new line_out_rp_mux =
+SOC_DAPM_ENUM("ROUTE_RP_OUT", T9015S_out_rp_enum);
+
+/*line out Right Negative mux */
+static const char * const T9015S_out_rn_txt[] = {
+	"None", "LORN_SEL_AIR", "LORN_SEL_DACR", "Reserved", "LORN_SEL_DACR_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(T9015S_out_rn_enum, LINE_OUT_CONFIG,
+				  LORN_SEL_AIR, T9015S_out_rn_txt);
+
+static const struct snd_kcontrol_new line_out_rn_mux =
+SOC_DAPM_ENUM("ROUTE_RN_OUT", T9015S_out_rn_enum);
+
+static const struct snd_soc_dapm_widget T9015S_audio_dapm_widgets[] = {
+
+	/* Input */
+	SND_SOC_DAPM_INPUT("Linein left 1"),
+	SND_SOC_DAPM_INPUT("Linein left 2"),
+	SND_SOC_DAPM_INPUT("Linein left 3"),
+	SND_SOC_DAPM_INPUT("Linein left 4"),
+
+	SND_SOC_DAPM_INPUT("Linein right 1"),
+	SND_SOC_DAPM_INPUT("Linein right 2"),
+	SND_SOC_DAPM_INPUT("Linein right 3"),
+	SND_SOC_DAPM_INPUT("Linein right 4"),
+
+	/*PGA input */
+	SND_SOC_DAPM_PGA("PGAL_IN_EN", AUDIO_CONFIG_BLOCK_ENABLE,
+			 PGAL_IN_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("PGAR_IN_EN", AUDIO_CONFIG_BLOCK_ENABLE,
+			 PGAL_IN_EN, 0, NULL, 0),
+
+	/*PGA input source select */
+	SND_SOC_DAPM_MUX("Linein left switch", SND_SOC_NOPM,
+			 0, 0, &pgain_ln_mux),
+	SND_SOC_DAPM_MUX("Linein right switch", SND_SOC_NOPM,
+			 0, 0, &pgain_rn_mux),
+
+	/*ADC capture stream */
+	SND_SOC_DAPM_ADC("Left ADC", "HIFI Capture", AUDIO_CONFIG_BLOCK_ENABLE,
+			 ADCL_EN, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "HIFI Capture", AUDIO_CONFIG_BLOCK_ENABLE,
+			 ADCR_EN, 0),
+
+	/*Output */
+	SND_SOC_DAPM_OUTPUT("Lineout left N"),
+	SND_SOC_DAPM_OUTPUT("Lineout left P"),
+	SND_SOC_DAPM_OUTPUT("Lineout right N"),
+	SND_SOC_DAPM_OUTPUT("Lineout right P"),
+
+	/*DAC playback stream */
+	SND_SOC_DAPM_DAC("Left DAC", "HIFI Playback",
+			 AUDIO_CONFIG_BLOCK_ENABLE,
+			 DACL_EN, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "HIFI Playback",
+			 AUDIO_CONFIG_BLOCK_ENABLE,
+			 DACR_EN, 0),
+
+	/*DRV output */
+	SND_SOC_DAPM_OUT_DRV("LOLP_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LOLN_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORP_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORN_OUT_EN", SND_SOC_NOPM,
+			     0, 0, NULL, 0),
+
+	/*MUX output source select */
+	SND_SOC_DAPM_MUX("Lineout left P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_lp_mux),
+	SND_SOC_DAPM_MUX("Lineout left N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_ln_mux),
+	SND_SOC_DAPM_MUX("Lineout right P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rp_mux),
+	SND_SOC_DAPM_MUX("Lineout right N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rn_mux),
+};
+
+static const struct snd_soc_dapm_route T9015S_audio_dapm_routes[] = {
+/* Input path */
+	{"Linein left switch", "AIL1", "Linein left 1"},
+	{"Linein left switch", "AIL2", "Linein left 2"},
+	{"Linein left switch", "AIL3", "Linein left 3"},
+	{"Linein left switch", "AIL4", "Linein left 4"},
+
+	{"Linein right switch", "AIR1", "Linein right 1"},
+	{"Linein right switch", "AIR2", "Linein right 2"},
+	{"Linein right switch", "AIR3", "Linein right 3"},
+	{"Linein right switch", "AIR4", "Linein right 4"},
+
+	{"PGAL_IN_EN", NULL, "Linein left switch"},
+	{"PGAR_IN_EN", NULL, "Linein right switch"},
+
+	{"Left ADC", NULL, "PGAL_IN_EN"},
+	{"Right ADC", NULL, "PGAR_IN_EN"},
+
+/*Output path*/
+	{"Lineout left P switch", "LOLP_SEL_DACL", "Left DAC"},
+	{"Lineout left P switch", "LOLP_SEL_AIL", "PGAL_IN_EN"},
+	{"Lineout left P switch", "LOLP_SEL_AIL_INV", "PGAL_IN_EN"},
+
+	{"Lineout left N switch", "LOLN_SEL_AIL", "PGAL_IN_EN"},
+	{"Lineout left N switch", "LOLN_SEL_DACL", "Left DAC"},
+	{"Lineout left N switch", "LOLN_SEL_DACL_INV", "Left DAC"},
+
+	{"Lineout right P switch", "LORP_SEL_DACR", "Right DAC"},
+	{"Lineout right P switch", "LORP_SEL_AIR", "PGAR_IN_EN"},
+	{"Lineout right P switch", "LORP_SEL_AIR_INV", "PGAR_IN_EN"},
+
+	{"Lineout right N switch", "LORN_SEL_AIR", "PGAR_IN_EN"},
+	{"Lineout right N switch", "LORN_SEL_DACR", "Right DAC"},
+	{"Lineout right N switch", "LORN_SEL_DACR_INV", "Right DAC"},
+
+	{"LOLN_OUT_EN", NULL, "Lineout left N switch"},
+	{"LOLP_OUT_EN", NULL, "Lineout left P switch"},
+	{"LORN_OUT_EN", NULL, "Lineout right N switch"},
+	{"LORP_OUT_EN", NULL, "Lineout right P switch"},
+
+	{"Lineout left N", NULL, "LOLN_OUT_EN"},
+	{"Lineout left P", NULL, "LOLP_OUT_EN"},
+	{"Lineout right N", NULL, "LORN_OUT_EN"},
+	{"Lineout right P", NULL, "LORP_OUT_EN"},
+};
+
+static int aml_T9015S_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		snd_soc_update_bits(codec, AUDIO_CONFIG_BLOCK_ENABLE,
+					I2S_MODE, 1);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		snd_soc_update_bits(codec, AUDIO_CONFIG_BLOCK_ENABLE,
+					I2S_MODE, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aml_T9015S_set_dai_sysclk(struct snd_soc_dai *dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int aml_T9015S_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct aml_T9015S_audio_priv *T9015S_audio =
+	    snd_soc_codec_get_drvdata(codec);
+
+	T9015S_audio->params = params;
+
+	return 0;
+}
+
+static int aml_T9015S_audio_set_bias_level(struct snd_soc_codec *codec,
+					 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (SND_SOC_BIAS_OFF == codec->dapm.bias_level) {
+			codec->cache_only = false;
+			codec->cache_sync = 1;
+			snd_soc_cache_sync(codec);
+		}
+		break;
+
+	case SND_SOC_BIAS_OFF:
+
+		break;
+
+	default:
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static int aml_T9015S_prepare(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	/*struct snd_soc_codec *codec = dai->codec;*/
+	return 0;
+
+}
+
+static int aml_T9015S_audio_reset(struct snd_soc_codec *codec)
+{
+	aml_cbus_update_bits(RESET1_REGISTER, (1 << ACODEC_RESET),
+					(1 << ACODEC_RESET));
+	udelay(1000);
+	return 0;
+}
+
+static int aml_T9015S_audio_start_up(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xF000);
+	msleep(200);
+	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xB000);
+	return 0;
+}
+
+static int aml_T9015S_codec_mute_stream(struct snd_soc_dai *dai, int mute,
+				      int stream)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u32 reg;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		reg = snd_soc_read(codec, DAC_VOL_CTR_DAC_SOFT_MUTE);
+		if (mute)
+			reg |= 0x1 << DAC_SOFT_MUTE;
+		else
+			reg &= ~(0x1 << DAC_SOFT_MUTE);
+
+		snd_soc_write(codec, DAC_VOL_CTR_DAC_SOFT_MUTE, reg);
+	}
+	return 0;
+}
+
+static int aml_T9015S_audio_probe(struct snd_soc_codec *codec)
+{
+	struct aml_T9015S_audio_priv *T9015S_audio = NULL;
+
+	T9015S_audio = kzalloc(sizeof(struct aml_T9015S_audio_priv),
+		GFP_KERNEL);
+	if (NULL == T9015S_audio)
+		return -ENOMEM;
+	snd_soc_codec_set_drvdata(codec, T9015S_audio);
+
+	/*reset audio codec register*/
+	aml_T9015S_audio_reset(codec);
+	aml_T9015S_audio_start_up(codec);
+	aml_T9015S_audio_reg_init(codec);
+
+	aml_write_cbus(AIU_ACODEC_CTRL, (1 << 4)
+			   |(1 << 6)
+			   |(1 << 11)
+			   |(1 << 15)
+			   |(2 << 2)
+	);
+
+	aml_write_cbus(AUDIN_SOURCE_SEL, 3);
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	T9015S_audio->codec = codec;
+
+	return 0;
+}
+
+static int aml_T9015S_audio_remove(struct snd_soc_codec *codec)
+{
+	aml_T9015S_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int aml_T9015S_audio_suspend(struct snd_soc_codec *codec)
+{
+	aml_T9015S_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int aml_T9015S_audio_resume(struct snd_soc_codec *codec)
+{
+	aml_T9015S_audio_reset(codec);
+	aml_T9015S_audio_start_up(codec);
+	aml_T9015S_audio_reg_init(codec);
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	aml_T9015S_audio_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+
+#define T9015S_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_96000
+#define T9015S_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
+			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
+			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
+
+struct snd_soc_dai_ops T9015S_audio_aif_dai_ops = {
+	.hw_params = aml_T9015S_hw_params,
+	.prepare = aml_T9015S_prepare,
+	.set_fmt = aml_T9015S_set_dai_fmt,
+	.set_sysclk = aml_T9015S_set_dai_sysclk,
+	.mute_stream = aml_T9015S_codec_mute_stream,
+};
+
+struct snd_soc_dai_driver aml_T9015S_audio_dai[] = {
+	{
+	 .name = "T9015S-audio-hifi",
+	 .id = 0,
+	 .playback = {
+		      .stream_name = "HIFI Playback",
+		      .channels_min = 2,
+		      .channels_max = 8,
+		      .rates = T9015S_AUDIO_STEREO_RATES,
+		      .formats = T9015S_AUDIO_FORMATS,
+		      },
+	 .capture = {
+		     .stream_name = "HIFI Capture",
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = T9015S_AUDIO_STEREO_RATES,
+		     .formats = T9015S_AUDIO_FORMATS,
+		     },
+	 .ops = &T9015S_audio_aif_dai_ops,
+	 },
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_aml_T9015S_audio = {
+	.probe = aml_T9015S_audio_probe,
+	.remove = aml_T9015S_audio_remove,
+	.suspend = aml_T9015S_audio_suspend,
+	.resume = aml_T9015S_audio_resume,
+	.read = aml_T9015S_audio_read,
+	.write = aml_T9015S_audio_write,
+	.set_bias_level = aml_T9015S_audio_set_bias_level,
+	.controls = T9015S_audio_snd_controls,
+	.num_controls = ARRAY_SIZE(T9015S_audio_snd_controls),
+	.dapm_widgets = T9015S_audio_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(T9015S_audio_dapm_widgets),
+	.dapm_routes = T9015S_audio_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(T9015S_audio_dapm_routes),
+	.reg_cache_size = 16,
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 2,
+};
+
+static int aml_T9015S_audio_codec_probe(struct platform_device *pdev)
+{
+	int ret;
+	dev_info(&pdev->dev, "aml_T9015S_audio_codec_probe\n");
+	mutex_init(&acodec);
+	ret = snd_soc_register_codec(&pdev->dev,
+				     &soc_codec_dev_aml_T9015S_audio,
+				     &aml_T9015S_audio_dai[0], 1);
+	return ret;
+}
+
+static int aml_T9015S_audio_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id aml_T9015S_codec_dt_match[] = {
+	{.compatible = "amlogic, aml_codec_T9015S",},
+	{},
+};
+
+static struct platform_driver aml_T9015S_codec_platform_driver = {
+	.driver = {
+		   .name = "aml_codec_T9015S",
+		   .owner = THIS_MODULE,
+		   .of_match_table = aml_T9015S_codec_dt_match,
+		   },
+	.probe = aml_T9015S_audio_codec_probe,
+	.remove = aml_T9015S_audio_codec_remove,
+};
+
+static int __init aml_T9015S_audio_modinit(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&aml_T9015S_codec_platform_driver);
+	if (ret != 0) {
+		pr_err(
+			"Failed to register AML T9015S codec platform driver: %d\n",
+			ret);
+	}
+
+	return ret;
+}
+
+module_init(aml_T9015S_audio_modinit);
+
+static void __exit aml_T9015S_audio_exit(void)
+{
+	platform_driver_unregister(&aml_T9015S_codec_platform_driver);
+}
+
+module_exit(aml_T9015S_audio_exit);
+
+MODULE_DESCRIPTION("ASoC AML T9015S audio codec driver");
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/aml_codec_t9015S.h b/sound/soc/codecs/aml_codec_t9015S.h
new file mode 100644
index 0000000..1659b48
--- /dev/null
+++ b/sound/soc/codecs/aml_codec_t9015S.h
@@ -0,0 +1,79 @@
+#ifndef AML_T9015S_H_
+#define AML_T9015S_H_
+
+#define ACODEC_BASE_ADD    0xc8832000
+#define ACODEC_TOP_ADDR(x) (x)
+
+#define AUDIO_CONFIG_BLOCK_ENABLE       ACODEC_TOP_ADDR(0x00)
+#define MCLK_FREQ                   0x1F
+#define I2S_MODE                    0x1E
+#define ADC_HPF_EN                  0x1D
+#define ADC_HPF_MODE                0x1C
+#define ADC_OVERLOAD_DET_EN         0x1B
+#define ADC_DEM_EN                  0x1A
+#define ADC_CLK_TO_GPIO_EN          0x19
+#define DAC_CLK_TO_GPIO_EN          0x18
+#define DACL_DATA_SOURCE            0x17
+#define DACR_DATA_SOURCE            0x16
+#define DACL_INV                    0x15
+#define DACR_INV                    0x14
+#define ADCDATL_SOURCE              0x13
+#define ADCDATR_SOURCE              0x12
+#define ADCL_INV                    0x11
+#define ADCR_INV                    0x10
+#define VMID_GEN_EN                 0x0F
+#define VMID_GEN_FAST               0x0E
+#define BIAS_CURRENT_EN             0x0D
+#define REFP_BUF_EN                 0x0C
+#define PGAL_IN_EN                  0x0B
+#define PGAR_IN_EN                  0x0A
+#define PGAL_IN_ZC_EN               0x09
+#define PGAR_IN_ZC_EN               0x08
+#define ADCL_EN                     0x07
+#define ADCR_EN                     0x06
+#define DACL_EN                     0x05
+#define DACR_EN                     0x04
+#define LOLP_EN                     0x03
+#define LOLN_EN                     0x02
+#define LORP_EN                     0x01
+#define LORN_EN                     0x00
+
+#define ADC_VOL_CTR_PGA_IN_CONFIG       ACODEC_TOP_ADDR(0x04)
+#define DAC_GAIN_SEL_H              0x1F
+#define ADCL_VC                     0x18
+#define DAC_GAIN_SEL_L              0x17
+#define ADCR_VC                     0x10
+#define PGAL_IN_SEL                 0x0D
+#define PGAL_IN_GAIN                0x08
+#define PGAR_IN_SEL                 0x05
+#define PGAR_IN_GAIN                0x00
+
+#define DAC_VOL_CTR_DAC_SOFT_MUTE       ACODEC_TOP_ADDR(0x08)
+#define DACL_VC                     0x18
+#define DACR_VC                     0x10
+#define DAC_SOFT_MUTE               0x0F
+#define DAC_UNMUTE_MODE             0x0E
+#define DAC_MUTE_MODE               0x0D
+#define DAC_VC_RAMP_MODE            0x0C
+#define DAC_RAMP_RATE               0x0A
+#define DAC_MONO                    0x08
+
+#define LINE_OUT_CONFIG                 ACODEC_TOP_ADDR(0x0c)
+#define LOLP_SEL_DACL               0x0E
+#define LOLP_SEL_AIL                0x0D
+#define LOLP_SEL_AIL_INV            0x0C
+#define LOLN_SEL_DACL_INV           0x0A
+#define LOLN_SEL_DACL               0x09
+#define LOLN_SEL_AIL                0x08
+#define LORP_SEL_DACR               0x06
+#define LORP_SEL_AIR                0x05
+#define LORP_SEL_AIR_INV            0x04
+#define LORN_SEL_DACR_INV           0x02
+#define LORN_SEL_DACR               0x01
+#define LORN_SEL_AIR                0x00
+
+#define POWER_CONFIG                    ACODEC_TOP_ADDR(0x10)
+#define MUTE_DAC_PD_EN              0x1F
+#define IB_CON                      0x10
+
+#endif
diff --git a/sound/soc/codecs/aml_pmu4_codec.c b/sound/soc/codecs/aml_pmu4_codec.c
new file mode 100644
index 0000000..69de6cf
--- /dev/null
+++ b/sound/soc/codecs/aml_pmu4_codec.c
@@ -0,0 +1,566 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/amlogic/aml_pmu4.h>
+#include "aml_pmu4_codec.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+struct aml_pmu4_audio_priv {
+	struct snd_soc_codec *codec;
+	struct snd_pcm_hw_params *params;
+};
+
+struct pmu4_audio_init_reg {
+	u8 reg;
+	u16 val;
+};
+
+#define AML1220_PMU_CTR_04 0x05
+
+static struct pmu4_audio_init_reg init_list[] = {
+	{PMU4_BLOCK_ENABLE, 0xBCF6},
+	{PMU4_AUDIO_CONFIG, 0x3400},
+	{PMU4_PGA_IN_CONFIG, 0x2929},
+	{PMU4_ADC_VOL_CTR, 0x5050},
+	{PMU4_DAC_SOFT_MUTE, 0x0000},
+	{PMU4_DAC_VOL_CTR, 0xFFFF},
+	{PMU4_LINE_OUT_CONFIG, 0x4242},
+
+};
+
+#define PMU4_AUDIO_INIT_REG_LEN ARRAY_SIZE(init_list)
+
+static int aml_pmu4_audio_reg_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for (i = 0; i < PMU4_AUDIO_INIT_REG_LEN; i++)
+		snd_soc_write(codec, init_list[i].reg, init_list[i].val);
+
+	return 0;
+}
+
+static unsigned int aml_pmu4_audio_read(struct snd_soc_codec *codec,
+					unsigned int reg)
+{
+	u16 pmu4_audio_reg;
+	u16 val;
+
+	pmu4_audio_reg = PMU4_AUDIO_BASE + reg;
+	aml_pmu4_read16(pmu4_audio_reg, &val);
+
+	return val;
+
+}
+
+static int aml_pmu4_audio_write(struct snd_soc_codec *codec, unsigned int reg,
+				unsigned int val)
+{
+	u16 pmu4_audio_reg;
+
+	pmu4_audio_reg = PMU4_AUDIO_BASE + reg;
+	aml_pmu4_write16(pmu4_audio_reg, val);
+
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(pga_in_tlv, -1200, 250, 1);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -29625, 375, 1);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -95250, 375, 1);
+
+static const struct snd_kcontrol_new pmu4_audio_snd_controls[] = {
+	/*PGA_IN Gain */
+	SOC_DOUBLE_TLV("PGA IN Gain", PMU4_PGA_IN_CONFIG,
+		       PMU4_PGAL_IN_GAIN, PMU4_PGAR_IN_GAIN,
+		       0x1f, 0, pga_in_tlv),
+
+	/*ADC Digital Volume control */
+	SOC_DOUBLE_TLV("ADC Digital Capture Volume", PMU4_ADC_VOL_CTR,
+		       PMU4_ADCL_VOL_CTR, PMU4_ADCR_VOL_CTR,
+		       0x7f, 0, adc_vol_tlv),
+
+	/*DAC Digital Volume control */
+	SOC_DOUBLE_TLV("DAC Digital Playback Volume", PMU4_DAC_VOL_CTR,
+		       PMU4_DACL_VOL_CTR, PMU4_DACR_VOL_CTR,
+		       0xff, 0, dac_vol_tlv),
+
+};
+
+/*pgain Left Channel Input */
+static const char * const pmu4_pgain_left_txt[] = {
+	"None", "AIL1", "AIL2", "AIL3", "AIL4"
+};
+
+static const SOC_ENUM_SINGLE_DECL(pmu4_pgain_left_enum, PMU4_PGA_IN_CONFIG,
+				  PMU4_PGAL_IN_SEL, pmu4_pgain_left_txt);
+
+static const struct snd_kcontrol_new pgain_ln_mux =
+SOC_DAPM_ENUM("ROUTE_L", pmu4_pgain_left_enum);
+
+/*pgain right Channel Input */
+static const char * const pmu4_pgain_right_txt[] = {
+	"None", "AIR1", "AIR2", "AIR3", "AIR4"
+};
+
+static const SOC_ENUM_SINGLE_DECL(pmu4_pgain_right_enum, PMU4_PGA_IN_CONFIG,
+				  PMU4_PGAR_IN_SEL, pmu4_pgain_right_txt);
+
+static const struct snd_kcontrol_new pgain_rn_mux =
+SOC_DAPM_ENUM("ROUTE_R", pmu4_pgain_right_enum);
+
+/*line out Left Positive mux */
+static const char * const pmu4_out_lp_txt[] = {
+	"None", "LOLP_SEL_AIL_INV", "LOLP_SEL_AIL", "Reserved", "LOLP_SEL_DACL"
+};
+
+static const SOC_ENUM_SINGLE_DECL(pmu4_out_lp_enum, PMU4_LINE_OUT_CONFIG,
+				  PMU4_LOLP_SEL_SHIFT, pmu4_out_lp_txt);
+
+static const struct snd_kcontrol_new line_out_lp_mux =
+SOC_DAPM_ENUM("ROUTE_LP_OUT", pmu4_out_lp_enum);
+
+/*line out Left Negative mux */
+static const char * const pmu4_out_ln_txt[] = {
+	"None", "LOLN_SEL_AIL", "LOLN_SEL_DACL", "Reserved", "LOLN_SEL_DACL_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(pmu4_out_ln_enum, PMU4_LINE_OUT_CONFIG,
+				  PMU4_LOLN_SEL_SHIFT, pmu4_out_ln_txt);
+
+static const struct snd_kcontrol_new line_out_ln_mux =
+SOC_DAPM_ENUM("ROUTE_LN_OUT", pmu4_out_ln_enum);
+
+/*line out Right Positive mux */
+static const char * const pmu4_out_rp_txt[] = {
+	"None", "LORP_SEL_AIR_INV", "LORP_SEL_AIR", "Reserved", "LORP_SEL_DACR"
+};
+
+static const SOC_ENUM_SINGLE_DECL(pmu4_out_rp_enum, PMU4_LINE_OUT_CONFIG,
+				  PMU4_LORP_SEL_SHIFT, pmu4_out_rp_txt);
+
+static const struct snd_kcontrol_new line_out_rp_mux =
+SOC_DAPM_ENUM("ROUTE_RP_OUT", pmu4_out_rp_enum);
+
+/*line out Right Negative mux */
+static const char * const pmu4_out_rn_txt[] = {
+	"None", "LORN_SEL_AIR", "LORN_SEL_DACR", "Reserved", "LORN_SEL_DACR_INV"
+};
+
+static const SOC_ENUM_SINGLE_DECL(pmu4_out_rn_enum, PMU4_LINE_OUT_CONFIG,
+				  PMU4_LORN_SEL_SHIFT, pmu4_out_rn_txt);
+
+static const struct snd_kcontrol_new line_out_rn_mux =
+SOC_DAPM_ENUM("ROUTE_RN_OUT", pmu4_out_rn_enum);
+
+static const struct snd_soc_dapm_widget pmu4_audio_dapm_widgets[] = {
+
+	/* Input */
+	SND_SOC_DAPM_INPUT("Linein left 1"),
+	SND_SOC_DAPM_INPUT("Linein left 2"),
+	SND_SOC_DAPM_INPUT("Linein left 3"),
+	SND_SOC_DAPM_INPUT("Linein left 4"),
+
+	SND_SOC_DAPM_INPUT("Linein right 1"),
+	SND_SOC_DAPM_INPUT("Linein right 2"),
+	SND_SOC_DAPM_INPUT("Linein right 3"),
+	SND_SOC_DAPM_INPUT("Linein right 4"),
+
+	/*PGA input */
+	SND_SOC_DAPM_PGA("PGAL_IN_EN", PMU4_BLOCK_ENABLE,
+			 PMU4_PGAL_IN_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("PGAR_IN_EN", PMU4_BLOCK_ENABLE,
+			 PMU4_PGAR_IN_EN, 0, NULL, 0),
+
+	/*PGA input source select */
+	SND_SOC_DAPM_MUX("Linein left switch", SND_SOC_NOPM,
+			 0, 0, &pgain_ln_mux),
+	SND_SOC_DAPM_MUX("Linein right switch", SND_SOC_NOPM,
+			 0, 0, &pgain_rn_mux),
+
+	/*ADC capture stream */
+	SND_SOC_DAPM_ADC("Left ADC", "HIFI Capture", PMU4_BLOCK_ENABLE,
+			 PMU4_ADCL_EN, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "HIFI Capture", PMU4_BLOCK_ENABLE,
+			 PMU4_ADCR_EN, 0),
+
+	/*Output */
+	SND_SOC_DAPM_OUTPUT("Lineout left N"),
+	SND_SOC_DAPM_OUTPUT("Lineout left P"),
+	SND_SOC_DAPM_OUTPUT("Lineout right N"),
+	SND_SOC_DAPM_OUTPUT("Lineout right P"),
+
+	/*DAC playback stream */
+	SND_SOC_DAPM_DAC("Left DAC", "HIFI Playback", PMU4_BLOCK_ENABLE,
+			 PMU4_DACL_EN, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "HIFI Playback", PMU4_BLOCK_ENABLE,
+			 PMU4_DACR_EN, 0),
+
+	/*DRV output */
+	SND_SOC_DAPM_OUT_DRV("LOLP_OUT_EN", PMU4_BLOCK_ENABLE,
+			     PMU4_LOLP_EN, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LOLN_OUT_EN", PMU4_BLOCK_ENABLE,
+			     PMU4_LOLN_EN, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORP_OUT_EN", PMU4_BLOCK_ENABLE,
+			     PMU4_LORP_EN, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("LORN_OUT_EN", PMU4_BLOCK_ENABLE,
+			     PMU4_LORN_EN, 0, NULL, 0),
+
+	/*MUX output source select */
+	SND_SOC_DAPM_MUX("Lineout left P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_lp_mux),
+	SND_SOC_DAPM_MUX("Lineout left N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_ln_mux),
+	SND_SOC_DAPM_MUX("Lineout right P switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rp_mux),
+	SND_SOC_DAPM_MUX("Lineout right N switch", SND_SOC_NOPM,
+			 0, 0, &line_out_rn_mux),
+};
+
+static const struct snd_soc_dapm_route pmu4_audio_dapm_routes[] = {
+/* Input path */
+	{"Linein left switch", "AIL1", "Linein left 1"},
+	{"Linein left switch", "AIL2", "Linein left 2"},
+	{"Linein left switch", "AIL3", "Linein left 3"},
+	{"Linein left switch", "AIL4", "Linein left 4"},
+
+	{"Linein right switch", "AIR1", "Linein right 1"},
+	{"Linein right switch", "AIR2", "Linein right 2"},
+	{"Linein right switch", "AIR3", "Linein right 3"},
+	{"Linein right switch", "AIR4", "Linein right 4"},
+
+	{"PGAL_IN_EN", NULL, "Linein left switch"},
+	{"PGAR_IN_EN", NULL, "Linein right switch"},
+
+	{"Left ADC", NULL, "PGAL_IN_EN"},
+	{"Right ADC", NULL, "PGAR_IN_EN"},
+
+/*Output path*/
+	{"Lineout left P switch", "LOLP_SEL_DACL", "Left DAC"},
+	{"Lineout left P switch", "LOLP_SEL_AIL", "PGAL_IN_EN"},
+	{"Lineout left P switch", "LOLP_SEL_AIL_INV", "PGAL_IN_EN"},
+
+	{"Lineout left N switch", "LOLN_SEL_AIL", "PGAL_IN_EN"},
+	{"Lineout left N switch", "LOLN_SEL_DACL", "Left DAC"},
+	{"Lineout left N switch", "LOLN_SEL_DACL_INV", "Left DAC"},
+
+	{"Lineout right P switch", "LORP_SEL_DACR", "Right DAC"},
+	{"Lineout right P switch", "LORP_SEL_AIR", "PGAR_IN_EN"},
+	{"Lineout right P switch", "LORP_SEL_AIR_INV", "PGAR_IN_EN"},
+
+	{"Lineout right N switch", "LORN_SEL_AIR", "PGAR_IN_EN"},
+	{"Lineout right N switch", "LORN_SEL_DACR", "Right DAC"},
+	{"Lineout right N switch", "LORN_SEL_DACR_INV", "Right DAC"},
+
+	{"LOLN_OUT_EN", NULL, "Lineout left N switch"},
+	{"LOLP_OUT_EN", NULL, "Lineout left P switch"},
+	{"LORN_OUT_EN", NULL, "Lineout right N switch"},
+	{"LORP_OUT_EN", NULL, "Lineout right P switch"},
+
+	{"Lineout left N", NULL, "LOLN_OUT_EN"},
+	{"Lineout left P", NULL, "LOLP_OUT_EN"},
+	{"Lineout right N", NULL, "LORN_OUT_EN"},
+	{"Lineout right P", NULL, "LORP_OUT_EN"},
+};
+
+static int aml_pmu4_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		snd_soc_update_bits(codec, PMU4_AUDIO_CONFIG,
+				    PMU4_I2S_MODE, PMU4_I2S_MODE);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		snd_soc_update_bits(codec, PMU4_AUDIO_CONFIG, PMU4_I2S_MODE, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aml_pmu4_set_dai_sysclk(struct snd_soc_dai *dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int aml_pmu4_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct aml_pmu4_audio_priv *pmu4_audio =
+	    snd_soc_codec_get_drvdata(codec);
+
+	pmu4_audio->params = params;
+
+	return 0;
+}
+
+static int aml_pmu4_audio_set_bias_level(struct snd_soc_codec *codec,
+					 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (SND_SOC_BIAS_OFF == codec->dapm.bias_level) {
+
+			codec->cache_only = false;
+			codec->cache_sync = 1;
+			snd_soc_cache_sync(codec);
+		}
+		break;
+
+	case SND_SOC_BIAS_OFF:
+
+		break;
+
+	default:
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static int aml_pmu4_prepare(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	/*struct snd_soc_codec *codec = dai->codec;*/
+	return 0;
+
+}
+
+static int aml_pmu4_audio_reset(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, PMU4_SOFT_RESET, 0xF);
+	snd_soc_write(codec, PMU4_SOFT_RESET, 0x0);
+	udelay(10*1000);
+	return 0;
+}
+
+static int aml_pmu4_audio_start_up(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, PMU4_BLOCK_ENABLE, 0xF000);
+	msleep(200);
+	snd_soc_write(codec, PMU4_BLOCK_ENABLE, 0xB000);
+	return 0;
+}
+
+static int aml_pmu4_audio_power_init(void)
+{
+	uint8_t val = 0;
+
+	/*set audio ldo supply en in,reg:0x05,bit 0*/
+	aml_pmu4_read(AML1220_PMU_CTR_04, &val);
+	aml_pmu4_write(AML1220_PMU_CTR_04, val | 0x01);
+	return 0;
+
+}
+
+static int aml_pmu4_codec_mute_stream(struct snd_soc_dai *dai, int mute,
+				      int stream)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 reg;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		reg = snd_soc_read(codec, PMU4_DAC_SOFT_MUTE);
+		if (mute)
+			reg |= 0x8000;
+		else
+			reg &= ~0x8000;
+
+		snd_soc_write(codec, PMU4_DAC_SOFT_MUTE, reg);
+	}
+	return 0;
+}
+
+static int aml_pmu4_audio_probe(struct snd_soc_codec *codec)
+{
+	struct aml_pmu4_audio_priv *pmu4_audio = NULL;
+
+	/*pr_info("enter %s\n", __func__);*/
+	pmu4_audio = kzalloc(sizeof(struct aml_pmu4_audio_priv), GFP_KERNEL);
+	if (NULL == pmu4_audio)
+		return -ENOMEM;
+	snd_soc_codec_set_drvdata(codec, pmu4_audio);
+
+	/*enable LDO1V8 for audio*/
+	aml_pmu4_audio_power_init();
+
+	/*reset audio codec register*/
+	aml_pmu4_audio_reset(codec);
+	aml_pmu4_audio_start_up(codec);
+	aml_pmu4_audio_reg_init(codec);
+
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	pmu4_audio->codec = codec;
+
+	return 0;
+}
+
+static int aml_pmu4_audio_remove(struct snd_soc_codec *codec)
+{
+	aml_pmu4_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int aml_pmu4_audio_suspend(struct snd_soc_codec *codec)
+{
+	aml_pmu4_audio_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int aml_pmu4_audio_resume(struct snd_soc_codec *codec)
+{
+	pr_info("enter %s\n", __func__);
+	aml_pmu4_audio_power_init();
+	aml_pmu4_audio_reset(codec);
+	aml_pmu4_audio_start_up(codec);
+	aml_pmu4_audio_reg_init(codec);
+	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+	aml_pmu4_audio_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+
+#define PMU4_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_96000
+#define PMU4_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
+			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
+			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
+
+struct snd_soc_dai_ops pmu4_audio_aif_dai_ops = {
+	.hw_params = aml_pmu4_hw_params,
+	.prepare = aml_pmu4_prepare,
+	.set_fmt = aml_pmu4_set_dai_fmt,
+	.set_sysclk = aml_pmu4_set_dai_sysclk,
+	.mute_stream = aml_pmu4_codec_mute_stream,
+};
+
+struct snd_soc_dai_driver aml_pmu4_audio_dai[] = {
+	{
+	 .name = "pmu4-audio-hifi",
+	 .id = 0,
+	 .playback = {
+		      .stream_name = "HIFI Playback",
+		      .channels_min = 2,
+		      .channels_max = 8,
+		      .rates = PMU4_AUDIO_STEREO_RATES,
+		      .formats = PMU4_AUDIO_FORMATS,
+		      },
+	 .capture = {
+		     .stream_name = "HIFI Capture",
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = PMU4_AUDIO_STEREO_RATES,
+		     .formats = PMU4_AUDIO_FORMATS,
+		     },
+	 .ops = &pmu4_audio_aif_dai_ops,
+	 },
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_aml_pmu4_audio = {
+	.probe = aml_pmu4_audio_probe,
+	.remove = aml_pmu4_audio_remove,
+	.suspend = aml_pmu4_audio_suspend,
+	.resume = aml_pmu4_audio_resume,
+	.read = aml_pmu4_audio_read,
+	.write = aml_pmu4_audio_write,
+	.set_bias_level = aml_pmu4_audio_set_bias_level,
+	.controls = pmu4_audio_snd_controls,
+	.num_controls = ARRAY_SIZE(pmu4_audio_snd_controls),
+	.dapm_widgets = pmu4_audio_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pmu4_audio_dapm_widgets),
+	.dapm_routes = pmu4_audio_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(pmu4_audio_dapm_routes),
+	.reg_cache_size = 16,
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 2,
+};
+
+static int aml_pmu4_audio_codec_probe(struct platform_device *pdev)
+{
+	int ret;
+	dev_info(&pdev->dev, "aml_pmu4_audio_codec_probe\n");
+	ret = snd_soc_register_codec(&pdev->dev,
+				     &soc_codec_dev_aml_pmu4_audio,
+				     &aml_pmu4_audio_dai[0], 1);
+	return ret;
+}
+
+static int aml_pmu4_audio_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id aml_pmu4_codec_dt_match[] = {
+	{.compatible = "amlogic, aml_pmu4_codec",},
+	{},
+};
+
+static struct platform_driver aml_pmu4_codec_platform_driver = {
+	.driver = {
+		   .name = "aml_pmu4_codec",
+		   .owner = THIS_MODULE,
+		   .of_match_table = aml_pmu4_codec_dt_match,
+		   },
+	.probe = aml_pmu4_audio_codec_probe,
+	.remove = aml_pmu4_audio_codec_remove,
+};
+
+static int __init aml_pmu4_audio_modinit(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&aml_pmu4_codec_platform_driver);
+	if (ret != 0) {
+		pr_info(KERN_ERR
+			"Failed to register AML PMU4 codec platform driver: %d\n",
+			ret);
+	}
+
+	return ret;
+}
+
+module_init(aml_pmu4_audio_modinit);
+
+static void __exit aml_pmu4_audio_exit(void)
+{
+	platform_driver_unregister(&aml_pmu4_codec_platform_driver);
+}
+
+module_exit(aml_pmu4_audio_exit);
+
+MODULE_DESCRIPTION("ASoC AML pmu4 audio codec driver");
+MODULE_AUTHOR("Chengshun Wang <chengshun.wang@amlogic.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/aml_pmu4_codec.h b/sound/soc/codecs/aml_pmu4_codec.h
new file mode 100644
index 0000000..c0e5963
--- /dev/null
+++ b/sound/soc/codecs/aml_pmu4_codec.h
@@ -0,0 +1,83 @@
+#ifndef AML_PMU4_H_
+#define AML_PMU4_H_
+
+#define PMU4_AUDIO_BASE    0x40
+/*Info*/
+#define PMU4_SOFT_RESET                0x00
+#define PMU4_BLOCK_ENABLE              0x02
+#define PMU4_AUDIO_CONFIG              0x04
+#define PMU4_PGA_IN_CONFIG             0x06
+#define PMU4_ADC_VOL_CTR               0x08
+#define PMU4_DAC_SOFT_MUTE             0x0A
+#define PMU4_DAC_VOL_CTR               0x0C
+#define PMU4_LINE_OUT_CONFIG           0x0E
+
+/*Block Enable , Reg 0x02h*/
+#define PMU4_BIAS_CURRENT_EN    0xD
+#define PMU4_PGAL_IN_EN         0xB
+#define PMU4_PGAR_IN_EN         0xA
+#define PMU4_PGAL_IN_ZC_EN      0x9
+#define PMU4_PGAR_IN_ZC_EN      0x8
+#define PMU4_ADCL_EN            0x7
+#define PMU4_ADCR_EN            0x6
+#define PMU4_DACL_EN            0x5
+#define PMU4_DACR_EN            0x4
+#define PMU4_LOLP_EN            0x3
+#define PMU4_LOLN_EN            0x2
+#define PMU4_LORP_EN            0x1
+#define PMU4_LORN_EN            0x0
+
+/*Audio Config,Reg 0x04h*/
+#define PMU4_MCLK_FREQ          0xF
+#define PMU4_I2S_MODE           0xE
+#define PMU4_ADC_HPF_MODE       0xC
+#define PMU4_ADC_DEM_EN         0xA
+#define PMU4_ADC_CLK_TO_GPIO_EN 0x9
+#define PMU4_DAC_CLK_TO_GPIO_EN 0x8
+#define PMU4_DACL_DATA_SOURCE   0x7
+#define PMU4_DACR_DATA_SOURCE   0x6
+#define PMU4_DACL_INV           0x5
+#define PMU4_DACR_INV           0x4
+#define PMU4_ADCDATL_SOURCE     0x3
+#define PMU4_ADCDATR_SOURCE     0x2
+#define PMU4_ADCL_INV           0x1
+#define PMU4_ADCR_INV           0x0
+
+/*PGA_IN Config,  Reg 0x06h*/
+#define PMU4_PGAL_IN_SEL        0xD
+#define PMU4_PGAL_IN_GAIN       0x8
+#define PMU4_PGAR_IN_SEL        0x5
+#define PMU4_PGAR_IN_GAIN       0x0
+
+/*ADC_Volume_Control , Reg 0x08h*/
+#define PMU4_ADCL_VOL_CTR            0x8
+#define PMU4_ADCR_VOL_CTR            0x0
+
+/*DAC Soft Mute, Reg 0xA*/
+#define PMU4_DAC_SOFT_MUTE_BIT  0xF
+#define PMU4_DAC_UNMUTE_MODE    0xE
+#define PMU4_DAC_MUTE_MODE      0xD
+#define PMU4_DAC_VC_RAMP_MODE   0xC
+#define PMU4_DAC_RAMP_RATE      0xA
+#define PMU4_DAC_MONO           0x8
+#define PMU4_MUTE_DAC_PD_EN     0x7
+
+/*DAC_Volume_Control, Reg 0xC*/
+#define PMU4_DACL_VOL_CTR            0x8
+#define PMU4_DACR_VOL_CTR            0x0
+
+/*Line-Out Config, Reg 0xE*/
+#define PMU4_LOLP_SEL_DACL      0xE
+#define PMU4_LOLP_SEL_AIL       0xD
+#define PMU4_LOLP_SEL_SHIFT     0xC
+#define PMU4_LOLN_SEL_DACL_INV  0xA
+#define PMU4_LOLN_SEL_DACL      0x9
+#define PMU4_LOLN_SEL_SHIFT     0x8
+#define PMU4_LORP_SEL_DACR      0x6
+#define PMU4_LORP_SEL_AIR       0x5
+#define PMU4_LORP_SEL_SHIFT     0x4
+#define PMU4_LORN_SEL_DACR_INV  0x2
+#define PMU4_LORN_SEL_DACR      0x1
+#define PMU4_LORN_SEL_SHIFT     0x0
+
+#endif
diff --git a/sound/soc/codecs/arizona.c b/sound/soc/codecs/arizona.c
index 20aa991..e4295fe 100644
--- a/sound/soc/codecs/arizona.c
+++ b/sound/soc/codecs/arizona.c
@@ -1171,7 +1171,7 @@ static int arizona_hw_params(struct snd_pcm_substream *substream,
 	int chan_limit = arizona->pdata.max_channels_clocked[dai->id - 1];
 	int bclk, lrclk, wl, frame, bclk_target;
 
-	if (params_rate(params) % 4000)
+	if (params_rate(params) % 8000)
 		rates = &arizona_44k1_bclk_rates[0];
 	else
 		rates = &arizona_48k_bclk_rates[0];
diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c
index a0ad41a..ce05fd9 100644
--- a/sound/soc/codecs/cs4271.c
+++ b/sound/soc/codecs/cs4271.c
@@ -288,7 +288,7 @@ static int cs4271_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = cs4271->deemph;
+	ucontrol->value.enumerated.item[0] = cs4271->deemph;
 	return 0;
 }
 
@@ -298,7 +298,7 @@ static int cs4271_put_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
-	cs4271->deemph = ucontrol->value.integer.value[0];
+	cs4271->deemph = ucontrol->value.enumerated.item[0];
 	return cs4271_set_deemph(codec);
 }
 
diff --git a/sound/soc/codecs/dummy_codec.c b/sound/soc/codecs/dummy_codec.c
index b59621f..0696213 100644
--- a/sound/soc/codecs/dummy_codec.c
+++ b/sound/soc/codecs/dummy_codec.c
@@ -118,7 +118,6 @@ static int dummy_codec_platform_probe(struct platform_device *pdev)
 	struct dummy_codec_private *dummy_codec;
 	int ret;
 
-	pr_info("dummy_codec_platform_probe\n");
 	dummy_codec = kzalloc(sizeof(struct dummy_codec_private), GFP_KERNEL);
 	if (dummy_codec == NULL)
 		return -ENOMEM;
diff --git a/sound/soc/codecs/mc13783.c b/sound/soc/codecs/mc13783.c
index b852293..582c2bb 100644
--- a/sound/soc/codecs/mc13783.c
+++ b/sound/soc/codecs/mc13783.c
@@ -634,14 +634,14 @@ static int mc13783_probe(struct snd_soc_codec *codec)
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_CODEC,
-				AUDIO_SSI_SEL, AUDIO_SSI_SEL);
+				0, AUDIO_SSI_SEL);
 
 	if (priv->dac_ssi_port == MC13783_SSI1_PORT)
 		mc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,
-				AUDIO_SSI_SEL, AUDIO_SSI_SEL);
+				0, AUDIO_SSI_SEL);
 
 	return 0;
 }
diff --git a/sound/soc/codecs/pcm1681.c b/sound/soc/codecs/pcm1681.c
index dfa9755..73f9c36 100644
--- a/sound/soc/codecs/pcm1681.c
+++ b/sound/soc/codecs/pcm1681.c
@@ -102,7 +102,7 @@ static int pcm1681_set_deemph(struct snd_soc_codec *codec)
 
 	if (val != -1) {
 		regmap_update_bits(priv->regmap, PCM1681_DEEMPH_CONTROL,
-				   PCM1681_DEEMPH_RATE_MASK, val << 3);
+					PCM1681_DEEMPH_RATE_MASK, val);
 		enable = 1;
 	} else
 		enable = 0;
@@ -118,7 +118,7 @@ static int pcm1681_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = priv->deemph;
+	ucontrol->value.enumerated.item[0] = priv->deemph;
 
 	return 0;
 }
@@ -129,7 +129,7 @@ static int pcm1681_put_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);
 
-	priv->deemph = ucontrol->value.integer.value[0];
+	priv->deemph = ucontrol->value.enumerated.item[0];
 
 	return pcm1681_set_deemph(codec);
 }
diff --git a/sound/soc/codecs/pcm2bt.c b/sound/soc/codecs/pcm2bt.c
index 0bc4789..0158367 100644
--- a/sound/soc/codecs/pcm2bt.c
+++ b/sound/soc/codecs/pcm2bt.c
@@ -105,12 +105,13 @@ static struct snd_soc_codec_driver soc_codec_dev_pcm2bt = {
 	.resume = pcm2bt_resume,
 	.set_bias_level = pcm2bt_set_bias_level,
 };
+
 EXPORT_SYMBOL_GPL(soc_codec_dev_pcm2bt);
 
 static int pcm2bt_platform_probe(struct platform_device *pdev)
 {
 	int ret;
-	pr_info("*****enter pcm2bt_codec_probe\n");
+
 	ret = snd_soc_register_codec(&pdev->dev,
 				     &soc_codec_dev_pcm2bt, pcm2bt_dai,
 				     ARRAY_SIZE(pcm2bt_dai));
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index e93c36f..12528e9 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -1198,7 +1198,13 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 		/* Enable VDDC charge pump */
 		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
 	} else if (vddio >= 3100 && vdda >= 3100) {
-		ana_pwr &= ~SGTL5000_VDDC_CHRGPMP_POWERUP;
+		/*
+		 * if vddio and vddd > 3.1v,
+		 * charge pump should be clean before set ana_pwr
+		 */
+		snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
+				SGTL5000_VDDC_CHRGPMP_POWERUP, 0);
+
 		/* VDDC use VDDIO rail */
 		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
 		lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
@@ -1515,9 +1521,6 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 	if (ret)
 		return ret;
 
-	/* Need 8 clocks before I2C accesses */
-	udelay(1);
-
 	/* read chip information */
 	ret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);
 	if (ret)
diff --git a/sound/soc/codecs/tas5086.c b/sound/soc/codecs/tas5086.c
index c6c6500..a895a5e 100644
--- a/sound/soc/codecs/tas5086.c
+++ b/sound/soc/codecs/tas5086.c
@@ -275,7 +275,7 @@ static int tas5086_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = priv->deemph;
+	ucontrol->value.enumerated.item[0] = priv->deemph;
 
 	return 0;
 }
@@ -286,7 +286,7 @@ static int tas5086_put_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);
 
-	priv->deemph = ucontrol->value.integer.value[0];
+	priv->deemph = ucontrol->value.enumerated.item[0];
 
 	return tas5086_set_deemph(codec);
 }
diff --git a/sound/soc/codecs/tas5707.c b/sound/soc/codecs/tas5707.c
new file mode 100644
index 0000000..5b61999
--- /dev/null
+++ b/sound/soc/codecs/tas5707.c
@@ -0,0 +1,705 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/tas57xx.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include "tas5707.h"
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend early_suspend;
+static void tas5707_early_suspend(struct early_suspend *h);
+static void tas5707_late_resume(struct early_suspend *h);
+#endif
+
+#define tas5707_RATES (SNDRV_PCM_RATE_8000 | \
+		       SNDRV_PCM_RATE_11025 | \
+		       SNDRV_PCM_RATE_16000 | \
+		       SNDRV_PCM_RATE_22050 | \
+		       SNDRV_PCM_RATE_32000 | \
+		       SNDRV_PCM_RATE_44100 | \
+		       SNDRV_PCM_RATE_48000)
+
+#define tas5707_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE | \
+	 SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE | \
+	 SNDRV_PCM_FMTBIT_S32_LE)
+
+/* Power-up register defaults */
+static const u8 tas5707_regs[DDX_NUM_BYTE_REG] = {
+	0x6c, 0x70, 0x00, 0xA0, 0x05, 0x40, 0x00, 0xFF,
+	0x30, 0x30, 0xFF, 0x00, 0x00, 0x00, 0x91, 0x00,
+	0x02, 0xAC, 0x54, 0xAC, 0x54, 0x00, 0x00, 0x00,
+	0x00, 0x30, 0x0F, 0x82, 0x02,
+};
+
+static u8 TAS5707_drc1_table[3][8] = {
+	/* 0x3A drc1_ae */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3B drc1_aa */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3C drc1_ad */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+};
+
+static u8 tas5707_drc1_tko_table[3][4] = {
+	/* 0x40 drc1_t */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x41 drc1_k */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x42 drc1_o */
+	{ 0x00, 0x00, 0x00, 0x00 }
+};
+
+/* codec private data */
+struct tas5707_priv {
+	struct snd_soc_codec *codec;
+	struct tas57xx_platform_data *pdata;
+
+	enum snd_soc_control_type control_type;
+	void *control_data;
+
+	/*Platform provided EQ configuration */
+	int num_eq_conf_texts;
+	const char **eq_conf_texts;
+	int eq_cfg;
+	struct soc_enum eq_conf_enum;
+	unsigned char Ch1_vol;
+	unsigned char Ch2_vol;
+	unsigned mclk;
+};
+
+static const DECLARE_TLV_DB_SCALE(mvol_tlv, -12700, 50, 1);
+static const DECLARE_TLV_DB_SCALE(chvol_tlv, -10300, 50, 1);
+
+static const struct snd_kcontrol_new tas5707_snd_controls[] = {
+	SOC_SINGLE_TLV("Master Volume", DDX_MASTER_VOLUME, 0,
+		       0xff, 1, mvol_tlv),
+	SOC_SINGLE_TLV("Ch1 Volume", DDX_CHANNEL1_VOL, 0,
+		       0xff, 1, chvol_tlv),
+	SOC_SINGLE_TLV("Ch2 Volume", DDX_CHANNEL2_VOL, 0,
+		       0xff, 1, chvol_tlv),
+	SOC_SINGLE("Ch1 Switch", DDX_SOFT_MUTE, 0, 1, 1),
+	SOC_SINGLE("Ch2 Switch", DDX_SOFT_MUTE, 1, 1, 1),
+	SOC_SINGLE_RANGE("Fine Master Volume", DDX_CHANNEL3_VOL, 0,
+			   0x80, 0x83, 0),
+};
+
+static int tas5707_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+
+	tas5707->mclk = freq;
+	/* 0x74 = 512fs; 0x6c = 256fs */
+	if (freq == 512 * 48000)
+		snd_soc_write(codec, DDX_CLOCK_CTL, 0x74);
+	else
+		snd_soc_write(codec, DDX_CLOCK_CTL, 0x6c);
+	return 0;
+}
+
+static int tas5707_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int tas5707_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	unsigned int rate;
+
+	rate = params_rate(params);
+	pr_debug("rate: %u\n", rate);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S24_BE:
+		pr_debug("24bit\n");
+	/* fall through */
+	case SNDRV_PCM_FORMAT_S32_LE:
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S20_3BE:
+		pr_debug("20bit\n");
+
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S16_BE:
+		pr_debug("16bit\n");
+
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int tas5707_set_bias_level(struct snd_soc_codec *codec,
+				  enum snd_soc_bias_level level)
+{
+	pr_debug("level = %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* Full power on */
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/* The chip runs through the power down sequence for us. */
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static const struct snd_soc_dai_ops tas5707_dai_ops = {
+	.hw_params = tas5707_hw_params,
+	.set_sysclk = tas5707_set_dai_sysclk,
+	.set_fmt = tas5707_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver tas5707_dai = {
+	.name = "tas5707",
+	.playback = {
+		.stream_name = "HIFI Playback",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = tas5707_RATES,
+		.formats = tas5707_FORMATS,
+	},
+	.ops = &tas5707_dai_ops,
+};
+
+static int tas5707_set_master_vol(struct snd_soc_codec *codec)
+{
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	/* using user BSP defined master vol config; */
+	if (pdata && pdata->custom_master_vol) {
+		pr_debug("tas5707_set_master_vol::%d\n",
+			pdata->custom_master_vol);
+		snd_soc_write(codec, DDX_MASTER_VOLUME,
+			      (0xff - pdata->custom_master_vol));
+	} else {
+		pr_debug
+			("get dtd master_vol failed:using default setting\n");
+		snd_soc_write(codec, DDX_MASTER_VOLUME, 0x30);
+	}
+
+	return 0;
+}
+
+/* tas5707 DRC for channel L/R */
+static int tas5707_set_drc1(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0;
+	u8 *p = NULL;
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->custom_drc1_table
+	    && pdata->custom_drc1_table_len == 24) {
+		p = pdata->custom_drc1_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 8; j++)
+				TAS5707_drc1_table[i][j] = p[i * 8 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC1_AE + i,
+					 TAS5707_drc1_table[i], 8);
+			/*for (j = 0; j < 8; j++)
+				pr_info("TAS5707_drc1_table[%d][%d]: %x\n",
+					 i, j, TAS5707_drc1_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	if (pdata && pdata->custom_drc1_tko_table
+	    && pdata->custom_drc1_tko_table_len == 12) {
+		p = pdata->custom_drc1_tko_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 4; j++)
+				tas5707_drc1_tko_table[i][j] = p[i * 4 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC1_T + i,
+					 tas5707_drc1_tko_table[i], 4);
+			/*for (j = 0; j < 4; j++)
+				pr_info("tas5707_drc1_tko_table[%d][%d]: %x\n",
+					 i, j, tas5707_drc1_tko_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int tas5707_set_drc(struct snd_soc_codec *codec)
+{
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+	char drc_mask = 0;
+	u8 tas5707_drc_ctl_table[] = { 0x00, 0x00, 0x00, 0x00 };
+
+	if (pdata && pdata->enable_ch1_drc && pdata->drc_enable) {
+		drc_mask |= 0x01;
+		tas5707_drc_ctl_table[3] = drc_mask;
+		tas5707_set_drc1(codec);
+	    regmap_raw_write(codec->control_data, DDX_DRC_CTL,
+			 tas5707_drc_ctl_table, 4);
+	    return 0;
+	}
+	return -1;
+}
+
+static int tas5707_set_eq_biquad(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0, k = 0;
+	u8 *p = NULL;
+	u8 addr;
+	u8 tas5707_bq_table[20];
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5707->pdata;
+	struct tas57xx_eq_cfg *cfg;
+
+	if (!pdata)
+		return 0;
+
+	cfg = pdata->eq_cfgs;
+	if (!(cfg))
+		return 0;
+
+	p = cfg[tas5707->eq_cfg].regs;
+
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 7; j++) {
+			addr = (DDX_CH1_BQ_0 + i * 7 + j);
+			for (k = 0; k < 20; k++)
+				tas5707_bq_table[k] =
+					p[i * 7 * 20 + j * 20 + k];
+			regmap_raw_write(codec->control_data, addr,
+					tas5707_bq_table, 20);
+			/*for (k = 0; k < 20; k++)
+				pr_info("tas5707_bq_table[%d]: %x\n",
+					k, tas5707_bq_table[k]);*/
+		}
+	}
+	return 0;
+}
+
+static int tas5707_put_eq_enum(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5707->pdata;
+	int value = ucontrol->value.integer.value[0];
+
+	if (value >= pdata->num_eq_cfgs)
+		return -EINVAL;
+
+	tas5707->eq_cfg = value;
+	tas5707_set_eq_biquad(codec);
+
+	return 0;
+}
+
+static int tas5707_get_eq_enum(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+
+	ucontrol->value.enumerated.item[0] = tas5707->eq_cfg;
+
+	return 0;
+}
+
+static int tas5707_set_eq(struct snd_soc_codec *codec)
+{
+	int i = 0, ret = 0;
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5707->pdata;
+	u8 tas5707_eq_ctl_table[] = { 0x00, 0x00, 0x00, 0x80 };
+	struct tas57xx_eq_cfg *cfg = pdata->eq_cfgs;
+
+	if (!pdata || !pdata->eq_enable)
+		return -ENOENT;
+
+	if (pdata->num_eq_cfgs && (tas5707->eq_conf_texts == NULL)) {
+		struct snd_kcontrol_new control =
+			SOC_ENUM_EXT("EQ Mode", tas5707->eq_conf_enum,
+				     tas5707_get_eq_enum, tas5707_put_eq_enum);
+
+		tas5707->eq_conf_texts =
+			kzalloc(sizeof(char *) * pdata->num_eq_cfgs,
+				GFP_KERNEL);
+		if (!tas5707->eq_conf_texts) {
+			dev_err(codec->dev,
+				"Fail to allocate %d EQ config tests\n",
+				pdata->num_eq_cfgs);
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < pdata->num_eq_cfgs; i++)
+			tas5707->eq_conf_texts[i] = cfg[i].name;
+
+		tas5707->eq_conf_enum.max = pdata->num_eq_cfgs;
+		tas5707->eq_conf_enum.texts = tas5707->eq_conf_texts;
+
+		ret = snd_soc_add_codec_controls(codec, &control, 1);
+		if (ret != 0)
+			dev_err(codec->dev, "Fail to add EQ mode control: %d\n",
+				ret);
+	}
+
+	tas5707_set_eq_biquad(codec);
+
+	tas5707_eq_ctl_table[3] &= 0x7F;
+	regmap_raw_write(codec->control_data, DDX_BANKSWITCH_AND_EQCTL,
+			 tas5707_eq_ctl_table, 4);
+	return 0;
+}
+
+static int tas5707_customer_init(struct snd_soc_codec *codec)
+{
+	int i = 0;
+	u8 data[4] = {0x00, 0x00, 0x00, 0x00};
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->init_regs) {
+		if (pdata->num_init_regs != 4) {
+			dev_err(codec->dev, "num_init_regs = %d\n",
+				pdata->num_init_regs);
+			return -1;
+		}
+		for (i = 0; i < pdata->num_init_regs; i++)
+			data[i] = pdata->init_regs[i];
+		/*pr_info("init_regs[]: [%x][%x][%x][%x]\n",
+			data[0], data[1], data[2], data[3]);*/
+	} else {
+		return -1;
+	}
+
+	regmap_raw_write(codec->control_data, DDX_INPUT_MUX, data, 4);
+	return 0;
+}
+
+static int reset_tas5707_GPIO(struct snd_soc_codec *codec)
+{
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5707->pdata;
+
+	gpio_direction_output(pdata->reset_pin, GPIOF_OUT_INIT_LOW);
+	udelay(1000);
+	gpio_direction_output(pdata->reset_pin, GPIOF_OUT_INIT_HIGH);
+	mdelay(15);
+	return 0;
+}
+
+static int tas5707_init(struct snd_soc_codec *codec)
+{
+	unsigned char burst_data[][4] = {
+		{ 0x00, 0x01, 0x77, 0x72 },
+		{ 0x00, 0x00, 0x42, 0x03 },
+		{ 0x01, 0x02, 0x13, 0x45 },
+	};
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+
+	reset_tas5707_GPIO(codec);
+
+	dev_info(codec->dev, "tas5707_init!\n");
+	snd_soc_write(codec, DDX_OSC_TRIM, 0x00);
+	msleep(50);
+	snd_soc_write(codec, DDX_CLOCK_CTL, 0x6c);
+	snd_soc_write(codec, DDX_SYS_CTL_1, 0xa0);
+	snd_soc_write(codec, DDX_SERIAL_DATA_INTERFACE, 0x05);
+	snd_soc_write(codec, DDX_BKND_ERR, 0x02);
+
+	regmap_raw_write(codec->control_data, DDX_INPUT_MUX, burst_data[0], 4);
+	regmap_raw_write(codec->control_data, DDX_CH4_SOURCE_SELECT,
+			 burst_data[1], 4);
+	regmap_raw_write(codec->control_data, DDX_PWM_MUX, burst_data[2], 4);
+
+	/*drc */
+	if ((tas5707_set_drc(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5707 drc!\n");
+	/*eq */
+	if ((tas5707_set_eq(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5707 eq!\n");
+	/*init */
+	if ((tas5707_customer_init(codec)) < 0)
+		dev_err(codec->dev, " fail to set tas5707 customer init!\n");
+
+	snd_soc_write(codec, DDX_VOLUME_CONFIG, 0xD1);
+	snd_soc_write(codec, DDX_SYS_CTL_2, 0x84);
+	snd_soc_write(codec, DDX_START_STOP_PERIOD, 0x95);
+	snd_soc_write(codec, DDX_PWM_SHUTDOWN_GROUP, 0x30);
+	snd_soc_write(codec, DDX_MODULATION_LIMIT, 0x02);
+	/*normal operation */
+	if ((tas5707_set_master_vol(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5707 master vol!\n");
+
+	snd_soc_write(codec, DDX_CHANNEL1_VOL, tas5707->Ch1_vol);
+	snd_soc_write(codec, DDX_CHANNEL2_VOL, tas5707->Ch2_vol);
+	snd_soc_write(codec, DDX_SOFT_MUTE, 0x00);
+	snd_soc_write(codec, DDX_CHANNEL3_VOL, 0x80);
+
+	return 0;
+}
+
+static int tas5707_probe(struct snd_soc_codec *codec)
+{
+	int ret = 0;
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	early_suspend.suspend = tas5707_early_suspend;
+	early_suspend.resume = tas5707_late_resume;
+	early_suspend.param = codec;
+	register_early_suspend(&early_suspend);
+#endif
+
+	tas5707->pdata = pdata;
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, tas5707->control_type);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+	tas5707_init(codec);
+
+	return 0;
+}
+
+static int tas5707_remove(struct snd_soc_codec *codec)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&early_suspend);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tas5707_suspend(struct snd_soc_codec *codec)
+{
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5707_suspend!\n");
+
+	if (pdata && pdata->suspend_func)
+		pdata->suspend_func();
+
+	/*save volume */
+	tas5707->Ch1_vol = snd_soc_read(codec, DDX_CHANNEL1_VOL);
+	tas5707->Ch2_vol = snd_soc_read(codec, DDX_CHANNEL2_VOL);
+	tas5707_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int tas5707_resume(struct snd_soc_codec *codec)
+{
+	struct tas5707_priv *tas5707 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5707_resume!\n");
+
+	if (pdata && pdata->resume_func)
+		pdata->resume_func();
+
+	tas5707_init(codec);
+	snd_soc_write(codec, DDX_CHANNEL1_VOL, tas5707->Ch1_vol);
+	snd_soc_write(codec, DDX_CHANNEL2_VOL, tas5707->Ch2_vol);
+	tas5707_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+#else
+#define tas5707_suspend NULL
+#define tas5707_resume NULL
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void tas5707_early_suspend(struct early_suspend *h)
+{
+	return;
+	/*struct snd_soc_codec *codec = NULL;
+	struct tas57xx_platform_data *pdata = NULL;
+
+	codec = (struct snd_soc_codec *)(h->param);
+	pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5707_early_suspend!\n");
+	if (pdata && pdata->early_suspend_func)
+		pdata->early_suspend_func();
+
+	snd_soc_write(codec, DDX_MASTER_VOLUME, 0xFF);*/
+}
+
+static void tas5707_late_resume(struct early_suspend *h)
+{
+	return;
+	/*struct snd_soc_codec *codec = NULL;
+	struct tas57xx_platform_data *pdata = NULL;
+
+	codec = (struct snd_soc_codec *)(h->param);
+	pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5707_late_resume!\n");
+	if (pdata && pdata->late_resume_func)
+		pdata->late_resume_func();
+
+	tas5707_set_master_vol(codec);*/
+}
+#endif
+
+static const struct snd_soc_dapm_widget tas5707_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC", "HIFI Playback", SND_SOC_NOPM, 0, 0),
+};
+
+static const struct snd_soc_codec_driver tas5707_codec = {
+	.probe = tas5707_probe,
+	.remove = tas5707_remove,
+	.suspend = tas5707_suspend,
+	.resume = tas5707_resume,
+	.reg_cache_size = DDX_NUM_BYTE_REG,
+	.reg_word_size = sizeof(u8),
+	.reg_cache_default = tas5707_regs,
+	.set_bias_level = tas5707_set_bias_level,
+	.controls = tas5707_snd_controls,
+	.num_controls = ARRAY_SIZE(tas5707_snd_controls),
+	.dapm_widgets = tas5707_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(tas5707_dapm_widgets),
+};
+
+static int tas5707_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct tas5707_priv *tas5707;
+	int ret;
+
+	tas5707 = devm_kzalloc(&i2c->dev, sizeof(struct tas5707_priv),
+			       GFP_KERNEL);
+	if (!tas5707)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, tas5707);
+	tas5707->control_type = SND_SOC_I2C;
+
+	ret = snd_soc_register_codec(&i2c->dev, &tas5707_codec,
+				     &tas5707_dai, 1);
+	if (ret != 0)
+		dev_err(&i2c->dev, "Failed to register codec (%d)\n", ret);
+
+	return ret;
+}
+
+static int tas5707_i2c_remove(struct i2c_client *client)
+{
+	devm_kfree(&client->dev, i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id tas5707_i2c_id[] = {
+	{ "tas5707", 0 },
+	{}
+};
+
+static struct i2c_driver tas5707_i2c_driver = {
+	.driver = {
+		.name = "tas5707",
+		.owner = THIS_MODULE,
+	},
+	.probe = tas5707_i2c_probe,
+	.remove = tas5707_i2c_remove,
+	.id_table = tas5707_i2c_id,
+};
+
+static int aml_tas5707_codec_probe(struct platform_device *pdev)
+{
+	return 0;
+}
+static int aml_tas5707_codec_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+static const struct of_device_id amlogic_tas5707_codec_dt_match[] = {
+	{ .compatible = "amlogic, aml_tas5707_codec", },
+	{},
+};
+
+static struct platform_driver aml_tas5707_codec_platform_driver = {
+	.driver = {
+		.name = "tas5707",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_tas5707_codec_dt_match,
+	},
+	.probe = aml_tas5707_codec_probe,
+	.remove = aml_tas5707_codec_remove,
+};
+
+static int __init aml_tas5707_modinit(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&aml_tas5707_codec_platform_driver);
+	if (ret != 0)
+		pr_err("Failed to register codec tas5707 platform driver\n");
+	i2c_add_driver(&tas5707_i2c_driver);
+	return ret;
+}
+static void __exit aml_tas5707_exit(void)
+{
+	platform_driver_unregister(&aml_tas5707_codec_platform_driver);
+	i2c_del_driver(&tas5707_i2c_driver);
+}
+
+module_init(aml_tas5707_modinit);
+module_exit(aml_tas5707_exit);
+
+MODULE_DESCRIPTION("ASoC Tas5707 driver");
+MODULE_AUTHOR("AML MM team");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/codecs/tas5707.h b/sound/soc/codecs/tas5707.h
new file mode 100644
index 0000000..4e7e239
--- /dev/null
+++ b/sound/soc/codecs/tas5707.h
@@ -0,0 +1,91 @@
+#ifndef _TAS5707_H
+#define _TAS5707_H
+
+#define DDX_I2C_ADDR                                0x36
+
+#define DDX_CLOCK_CTL                               0x00
+#define DDX_DEVICE_ID                               0x01
+#define DDX_ERROR_STATUS                            0x02
+#define DDX_SYS_CTL_1                               0x03
+#define DDX_SERIAL_DATA_INTERFACE                   0x04
+#define DDX_SYS_CTL_2                               0x05
+#define DDX_SOFT_MUTE                               0x06
+#define DDX_MASTER_VOLUME                           0x07
+#define DDX_CHANNEL1_VOL                            0x08
+#define DDX_CHANNEL2_VOL                            0x09
+#define DDX_CHANNEL3_VOL                            0x0A
+#define DDX_VOLUME_CONFIG                           0x0E
+
+#define DDX_MODULATION_LIMIT                        0x10
+#define DDX_IC_DELAY_CHANNEL_1                      0x11
+#define DDX_IC_DELAY_CHANNEL_2                      0x12
+#define DDX_IC_DELAY_CHANNEL_3                      0x13
+#define DDX_IC_DELAY_CHANNEL_4                      0x14
+#define DDX_PWM_SHUTDOWN_GROUP                      0x19
+#define DDX_START_STOP_PERIOD                       0x1A
+#define DDX_OSC_TRIM                                0x1B
+#define DDX_BKND_ERR                                0x1C
+#define DDX_NUM_BYTE_REG                            0x1D
+
+#define DDX_INPUT_MUX                               0x20
+#define DDX_CH4_SOURCE_SELECT                       0x21
+
+#define DDX_PWM_MUX                                 0x25
+
+#define DDX_CH1_BQ_0                                0x29
+#define DDX_CH1_BQ_1                                0x2A
+#define DDX_CH1_BQ_2                                0x2B
+#define DDX_CH1_BQ_3                                0x2C
+#define DDX_CH1_BQ_4                                0x2D
+#define DDX_CH1_BQ_5                                0x2E
+#define DDX_CH1_BQ_6                                0x2F
+
+#define DDX_CH2_BQ_0                                0x30
+#define DDX_CH2_BQ_1                                0x31
+#define DDX_CH2_BQ_2                                0x32
+#define DDX_CH2_BQ_3                                0x33
+#define DDX_CH2_BQ_4                                0x34
+#define DDX_CH2_BQ_5                                0x35
+#define DDX_CH2_BQ_6                                0x36
+
+#define DDX_DRC1_AE                                 0x3A
+#define DDX_DRC1_AA                                 0x3B
+#define DDX_DRC1_AD                                 0x3C
+#define DDX_DRC2_AE                                 0x3D
+#define DDX_DRC2_AA                                 0x3E
+#define DDX_DRC2_AD                                 0x3F
+#define DDX_DRC1_T                                  0x40
+#define DDX_DRC1_K                                  0x41
+#define DDX_DRC1_O                                  0x42
+#define DDX_DRC2_T                                  0x43
+#define DDX_DRC2_K                                  0x44
+#define DDX_DRC2_O                                  0x45
+#define DDX_DRC_CTL                                 0x46
+
+#define DDX_BANKSWITCH_AND_EQCTL                    0x50
+#define DDX_CH_1_OUTPUT_MIXER                       0x51
+#define DDX_CH_2_OUTPUT_MIXER                       0x52
+#define DDX_CH_1_INPUT_MIXER                        0x53
+#define DDX_CH_2_INPUT_MIXER                        0x54
+#define DDX_CH_3_INPUT_MIXER                        0x55
+#define DDX_OUTPUT_POST_SCALE                       0x56
+#define DDX_OUTPUT_PRE_SCALE                        0x57
+
+#define DDX_CH1_BQ_7                                0x58
+#define DDX_CH1_BQ_8                                0x59
+#define DDX_SUBCHANNEL_BQ_0                         0x5A
+#define DDX_SUBCHANNEL_BQ_1                         0x5B
+#define DDX_CH2_BQ_7                                0x5C
+#define DDX_CH2_BQ_8                                0x5D
+#define DDX_PSEUDO_CH2_BQ_0                         0x5E
+
+#define DDX_CH_4_OUTPUT_MIXER                       0x60
+#define DDX_CH_4_INPUT_MIXER                        0x61
+#define DDX_CH_IDF_POST_SCALE                       0x62
+#define DDX_CH_DEV_ADDR_ENABLE                      0xF8
+#define DDX_CH_DEV_ADDR_UPDATE                      0xF9
+
+#define DDX_DRC_BYTES                               (8)
+#define DDX_BQ_BYTES                                (20)
+
+#endif
diff --git a/sound/soc/codecs/tas5717.c b/sound/soc/codecs/tas5717.c
new file mode 100644
index 0000000..d51c0c3
--- /dev/null
+++ b/sound/soc/codecs/tas5717.c
@@ -0,0 +1,921 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/tas57xx.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+
+#include "tas5717.h"
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend early_suspend;
+struct task_struct *phone_task;
+static void tas5717_early_suspend(struct early_suspend *h);
+static void tas5717_late_resume(struct early_suspend *h);
+#endif
+
+#define tas5717_RATES (SNDRV_PCM_RATE_8000 | \
+		       SNDRV_PCM_RATE_11025 | \
+		       SNDRV_PCM_RATE_16000 | \
+		       SNDRV_PCM_RATE_22050 | \
+		       SNDRV_PCM_RATE_32000 | \
+		       SNDRV_PCM_RATE_44100 | \
+		       SNDRV_PCM_RATE_48000)
+
+#define tas5717_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE | \
+	 SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE | \
+	 SNDRV_PCM_FMTBIT_S32_LE)
+
+/* Power-up register defaults */
+static const u8 tas5717_regs[DDX_NUM_BYTE_REG] = {
+	0x6c, 0x70, 0x00, 0xA0, 0x05, 0x40, 0x00, 0xFF,
+	0x30, 0x30, 0xFF, 0x00, 0x00, 0x00, 0x91, 0x00,
+	0x02, 0xAC, 0x54, 0xAC, 0x54, 0x00, 0x00, 0x00,
+	0x00, 0x30, 0x0F, 0x82, 0x02,
+};
+
+static u8 TAS5717_drc1_table[3][8] = {
+	/* 0x3A drc1_ae */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3B drc1_aa */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3C drc1_ad */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+};
+
+static u8 TAS5717_drc2_table[3][8] = {
+	/* 0x3D drc2_ae */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3E drc2_aa */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3F drc2_ad */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+};
+
+static u8 tas5717_drc1_tko_table[3][4] = {
+	/* 0x40 drc1_t */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x41 drc1_k */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x42 drc1_o */
+	{ 0x00, 0x00, 0x00, 0x00 }
+};
+
+static u8 tas5717_drc2_tko_table[3][4] = {
+	/* 0x43 drc2_t */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x44 drc2_k */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x45 drc2_o */
+	{ 0x00, 0x00, 0x00, 0x00 }
+};
+
+/* codec private data */
+struct tas5717_priv {
+	struct snd_soc_codec *codec;
+	struct tas57xx_platform_data *pdata;
+
+	enum snd_soc_control_type control_type;
+	void *control_data;
+
+	/*Platform provided EQ configuration */
+	int num_eq_conf_texts;
+	const char **eq_conf_texts;
+	int eq_cfg;
+	struct soc_enum eq_conf_enum;
+	unsigned char Ch1_vol;
+	unsigned char Ch2_vol;
+	unsigned mclk;
+};
+/*Master Volume*/
+static int tad5717_mv_16bit_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int ret;
+	unsigned int value = 0;
+	unsigned char data_tmp = 0;
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int max = mc->max;
+	unsigned int invert = mc->invert;
+	unsigned int mask = (1 << fls(max)) - 1;
+	ret = regmap_raw_read(codec->control_data, mc->reg,
+				      ucontrol->value.bytes.data,
+				      2);
+	data_tmp = ucontrol->value.bytes.data[0];
+	ucontrol->value.bytes.data[0] = ucontrol->value.bytes.data[1];
+	ucontrol->value.bytes.data[1] = data_tmp;
+	/*dev_info(codec->dev, " ucontrol->value.bytes.data=[%x][%x]!\n",
+	ucontrol->value.bytes.data[0],ucontrol->value.bytes.data[1]);*/
+	value = (((u16 *)(&ucontrol->value.bytes.data))[0]>>2) & mask;
+	if (invert)
+		value = max - value;
+	((u16 *)(&ucontrol->value.bytes.data))[0] = value;
+	/*dev_info(codec->dev, "tad5717_mv_16bit_get %x[%d]=%d!\n",
+	mc->reg,codec->val_bytes,value);*/
+	return ret;
+}
+
+static int tad5717_mv_16bit_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int ret;
+	unsigned int value = 0;
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int max = mc->max;
+	unsigned int invert = mc->invert;
+	unsigned int mask = (1 << fls(max)) - 1;
+	value = ((u16 *)(&ucontrol->value.integer.value))[0] & mask;
+	if (invert)
+		value = max - value;
+	/*dev_info(codec->dev, "set1!mc =%d mask%d\n",value, mask);*/
+	value <<= 2;
+	value = ((value >> 8) & 0xff) | ((value << 8) & 0xff00);
+	/*dev_info(codec->dev, "set2!mc =%d mask%d\n",value, mask);*/
+	ret = regmap_raw_write(codec->control_data, mc->reg, &value, 2);
+	return ret;
+}
+
+static const DECLARE_TLV_DB_SCALE(mvol_tlv, -12700, 50, 1);
+static const DECLARE_TLV_DB_SCALE(chvol_tlv, -10300, 50, 1);
+
+static const struct snd_kcontrol_new tas5717_snd_controls[] = {
+	SOC_SINGLE_EXT_TLV("Master Volume",
+		DDX_MASTER_VOLUME, 0, 0xff, 1,
+		tad5717_mv_16bit_get, tad5717_mv_16bit_put, mvol_tlv),
+	SOC_SINGLE_EXT_TLV("Headphone Volume",
+	DDX_HEADPHONE_VOL, 0, 0xff, 1,
+	tad5717_mv_16bit_get, tad5717_mv_16bit_put, mvol_tlv),
+	SOC_SINGLE_EXT_TLV("Ch1 Volume",
+	DDX_CHANNEL1_VOL, 0, 0xff, 1,
+	tad5717_mv_16bit_get, tad5717_mv_16bit_put, chvol_tlv),
+	SOC_SINGLE_EXT_TLV("Ch2 Volume",
+	DDX_CHANNEL2_VOL, 0, 0xff, 1,
+	tad5717_mv_16bit_get, tad5717_mv_16bit_put, chvol_tlv),
+	SOC_SINGLE("Ch1 Switch", DDX_SOFT_MUTE, 0, 1, 1),
+	SOC_SINGLE("Ch2 Switch", DDX_SOFT_MUTE, 1, 1, 1),
+	SOC_SINGLE_RANGE("Fine Master Volume", DDX_CHANNEL3_VOL, 0,
+			0x80, 0x83, 0),
+};
+
+static int tas5717_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+
+	tas5717->mclk = freq;
+	/* 0x74 = 512fs; 0x6c = 256fs */
+	if (freq == 512 * 48000)
+		snd_soc_write(codec, DDX_CLOCK_CTL, 0x74);
+	else
+		snd_soc_write(codec, DDX_CLOCK_CTL, 0x6c);
+	return 0;
+}
+
+static int tas5717_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int tas5717_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	unsigned int rate;
+
+	rate = params_rate(params);
+	pr_debug("rate: %u\n", rate);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S24_BE:
+		pr_debug("24bit\n");
+	/* fall through */
+	case SNDRV_PCM_FORMAT_S32_LE:
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S20_3BE:
+		pr_debug("20bit\n");
+
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S16_BE:
+		pr_debug("16bit\n");
+
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int tas5717_set_bias_level(struct snd_soc_codec *codec,
+				  enum snd_soc_bias_level level)
+{
+	pr_debug("level = %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* Full power on */
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/* The chip runs through the power down sequence for us. */
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static const struct snd_soc_dai_ops tas5717_dai_ops = {
+	.hw_params = tas5717_hw_params,
+	.set_sysclk = tas5717_set_dai_sysclk,
+	.set_fmt = tas5717_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver tas5717_dai = {
+	.name = "tas5717",
+	.playback = {
+		.stream_name = "HIFI Playback",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = tas5717_RATES,
+		.formats = tas5717_FORMATS,
+	},
+	.ops = &tas5717_dai_ops,
+};
+
+static int tas5717_set_master_vol(struct snd_soc_codec *codec)
+{
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+	unsigned char vol_data[2] = {0x01, 0x00};
+
+	/* using user BSP defined master vol config; */
+	if (pdata && pdata->custom_master_vol) {
+		pr_info("tas5717_set_master_vol::%d\n",
+			pdata->custom_master_vol);
+		vol_data[0] = (pdata->custom_master_vol * 4 + 3) >> 8;
+		vol_data[1] = pdata->custom_master_vol * 4 + 3;
+		regmap_raw_write(codec->control_data, DDX_MASTER_VOLUME,
+			      vol_data, 2);
+	} else {
+		pr_info
+			("get dtd master_vol failed:using default setting\n");
+		regmap_raw_write(codec->control_data, DDX_MASTER_VOLUME,
+						  vol_data, 2);
+	}
+	pr_info("vol_data::0x%x,%x\n", vol_data[0], vol_data[1]);
+
+	return 0;
+}
+
+/* tas5717 DRC for channel L/R */
+static int tas5717_set_drc1(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0;
+	u8 *p = NULL;
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->custom_drc1_table
+	    && pdata->custom_drc1_table_len == 24) {
+		p = pdata->custom_drc1_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 8; j++)
+				TAS5717_drc1_table[i][j] = p[i * 8 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC1_AE + i,
+					 TAS5717_drc1_table[i], 8);
+			/*for (j = 0; j < 8; j++)
+				pr_info("TAS5717_drc1_table[%d][%d]: %x\n",
+					 i, j, TAS5717_drc1_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	if (pdata && pdata->custom_drc1_tko_table
+	    && pdata->custom_drc1_tko_table_len == 12) {
+		p = pdata->custom_drc1_tko_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 4; j++)
+				tas5717_drc1_tko_table[i][j] = p[i * 4 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC1_T + i,
+					 tas5717_drc1_tko_table[i], 4);
+			/*for (j = 0; j < 4; j++)
+				pr_info("tas5717_drc1_tko_table[%d][%d]: %x\n",
+					 i, j, tas5717_drc1_tko_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int tas5717_set_drc2(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0;
+	u8 *p = NULL;
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->custom_drc2_table
+	    && pdata->custom_drc2_table_len == 24) {
+		p = pdata->custom_drc2_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 8; j++)
+				TAS5717_drc2_table[i][j] = p[i * 8 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC2_AE + i,
+					 TAS5717_drc2_table[i], 8);
+			/*for (j = 0; j < 8; j++)
+				pr_info("TAS5717_drc2_table[%d][%d]: %x\n",
+					 i, j, TAS5717_drc2_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	if (pdata && pdata->custom_drc2_tko_table
+	    && pdata->custom_drc2_tko_table_len == 12) {
+		p = pdata->custom_drc2_tko_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 4; j++)
+				tas5717_drc2_tko_table[i][j] = p[i * 4 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC2_T + i,
+					 tas5717_drc2_tko_table[i], 4);
+			/*for (j = 0; j < 4; j++)
+				pr_info("tas5717_drc2_tko_table[%d][%d]: %x\n",
+					 i, j, tas5717_drc2_tko_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int tas5717_set_drc(struct snd_soc_codec *codec)
+{
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+	char drc_mask = 0;
+	u8 tas5717_drc_ctl_table[] = { 0x00, 0x00, 0x00, 0x00 };
+
+	if (pdata && pdata->enable_ch1_drc
+		&& pdata->enable_ch2_drc && pdata->drc_enable) {
+		drc_mask |= 0x03;
+		tas5717_drc_ctl_table[3] = drc_mask;
+		tas5717_set_drc1(codec);
+		tas5717_set_drc2(codec);
+	    regmap_raw_write(codec->control_data, DDX_DRC_CTL,
+			 tas5717_drc_ctl_table, 4);
+	    return 0;
+	}
+	return -1;
+}
+
+
+static int tas5717_set_eq_biquad(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0, k = 0;
+	u8 *p = NULL;
+	u8 addr;
+	u8 tas5717_bq_table[20];
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5717->pdata;
+	struct tas57xx_eq_cfg *cfg;
+
+	if (!pdata)
+		return 0;
+
+	cfg = pdata->eq_cfgs;
+	if (!(cfg))
+		return 0;
+
+	p = cfg[tas5717->eq_cfg].regs;
+
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 7; j++) {
+			addr = (DDX_CH1_BQ_0 + i * 7 + j);
+			for (k = 0; k < 20; k++)
+				tas5717_bq_table[k] =
+					p[i * 7 * 20 + j * 20 + k];
+			regmap_raw_write(codec->control_data, addr,
+					tas5717_bq_table, 20);
+			/*for (k = 0; k < 20; k++)
+				pr_info("tas5717_bq_table[%d]: %x\n",
+					k, tas5717_bq_table[k]);*/
+		}
+	}
+	return 0;
+}
+
+static int tas5717_put_eq_enum(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5717->pdata;
+	int value = ucontrol->value.integer.value[0];
+
+	if (value >= pdata->num_eq_cfgs)
+		return -EINVAL;
+
+	tas5717->eq_cfg = value;
+	tas5717_set_eq_biquad(codec);
+
+	return 0;
+}
+
+static int tas5717_get_eq_enum(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+
+	ucontrol->value.enumerated.item[0] = tas5717->eq_cfg;
+
+	return 0;
+}
+
+static int tas5717_set_eq(struct snd_soc_codec *codec)
+{
+	int i = 0, ret = 0;
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5717->pdata;
+	u8 tas5717_eq_ctl_table[] = { 0x00, 0x00, 0x00, 0x80 };
+	struct tas57xx_eq_cfg *cfg = pdata->eq_cfgs;
+
+	if (!pdata || !pdata->eq_enable)
+		return -ENOENT;
+
+	if (pdata->num_eq_cfgs && (tas5717->eq_conf_texts == NULL)) {
+		struct snd_kcontrol_new control =
+			SOC_ENUM_EXT("EQ Mode", tas5717->eq_conf_enum,
+				     tas5717_get_eq_enum, tas5717_put_eq_enum);
+
+		tas5717->eq_conf_texts =
+			kzalloc(sizeof(char *) * pdata->num_eq_cfgs,
+				GFP_KERNEL);
+		if (!tas5717->eq_conf_texts) {
+			dev_err(codec->dev,
+				"Fail to allocate %d EQ config tests\n",
+				pdata->num_eq_cfgs);
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < pdata->num_eq_cfgs; i++)
+			tas5717->eq_conf_texts[i] = cfg[i].name;
+
+		tas5717->eq_conf_enum.max = pdata->num_eq_cfgs;
+		tas5717->eq_conf_enum.texts = tas5717->eq_conf_texts;
+
+		ret = snd_soc_add_codec_controls(codec, &control, 1);
+		if (ret != 0)
+			dev_err(codec->dev, "Fail to add EQ mode control: %d\n",
+				ret);
+	}
+
+	tas5717_set_eq_biquad(codec);
+
+	tas5717_eq_ctl_table[3] &= 0x7F;
+	regmap_raw_write(codec->control_data, DDX_BANKSWITCH_AND_EQCTL,
+			 tas5717_eq_ctl_table, 4);
+	return 0;
+}
+
+static int tas5717_customer_init(struct snd_soc_codec *codec)
+{
+	int i = 0;
+	u8 data[4] = {0x00, 0x00, 0x00, 0x00};
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->init_regs) {
+		if (pdata->num_init_regs != 4) {
+			dev_err(codec->dev, "num_init_regs = %d\n",
+				pdata->num_init_regs);
+			return -1;
+		}
+		for (i = 0; i < pdata->num_init_regs; i++)
+			data[i] = pdata->init_regs[i];
+		/*pr_info("init_regs[]: [%x][%x][%x][%x]\n",
+			data[0], data[1], data[2], data[3]);*/
+	} else {
+		return -1;
+	}
+
+	regmap_raw_write(codec->control_data, DDX_INPUT_MUX, data, 4);
+	return 0;
+}
+
+static int reset_tas5717_GPIO(struct snd_soc_codec *codec)
+{
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5717->pdata;
+
+	gpio_direction_output(pdata->reset_pin, GPIOF_OUT_INIT_LOW);
+	udelay(1000);
+	gpio_direction_output(pdata->reset_pin, GPIOF_OUT_INIT_HIGH);
+	mdelay(15);
+
+	/*open phone*/
+	gpio_direction_output(pdata->phone_pin, GPIOF_OUT_INIT_HIGH);
+	return 0;
+}
+static int phone_thread(void *codec)
+{
+	struct tas5717_priv *tas5717 =
+		snd_soc_codec_get_drvdata((struct snd_soc_codec *)codec);
+	struct tas57xx_platform_data *pdata = tas5717->pdata;
+	int scan_value = 0;
+	int times_num = 0;
+	pr_info("phone_thread scan_pin=%d\n", pdata->scan_pin);
+	while (1) {
+		scan_value = gpio_get_value(pdata->scan_pin);
+		/*insert earphones*/
+		if (GPIO_LOW_LEVEL == scan_value) {
+			do {
+				gpio_set_value(pdata->phone_pin,
+					GPIO_HIGH_LEVEL);
+				snd_soc_write(codec, DDX_SYS_CTL_2, 0x13);
+			} while (
+			(GPIO_HIGH_LEVEL != gpio_get_value(pdata->phone_pin))
+				&& (times_num++ < 5));
+			times_num = 0;
+		} /*Pull_out earphones*/
+		else if (GPIO_HIGH_LEVEL == scan_value) {
+			do {
+				snd_soc_write(codec, DDX_SYS_CTL_2, 0x00);
+				gpio_set_value(pdata->phone_pin,
+					GPIO_LOW_LEVEL);
+			} while (
+			(GPIO_HIGH_LEVEL != gpio_get_value(pdata->phone_pin))
+				&& (times_num++ < 5));
+			times_num = 0;
+
+		}
+		/*pr_info("phone_thread scan_pin=%d\n",
+			gpio_get_value(pdata->scan_pin));*/
+		msleep(1000);
+	}
+	return 0;
+}
+static int tas5717_init(struct snd_soc_codec *codec)
+{
+	int err;
+	unsigned char burst_data[][4] = {
+		{ 0x00, 0x01, 0x77, 0x72 },
+		{ 0x00, 0x00, 0x43, 0x03 },
+		{ 0x01, 0x02, 0x13, 0x45 },
+	};
+	unsigned char channel_vol[][2] = {
+		{ 0x00, 0xC0 },
+		{ 0x00, 0xC0 },
+		{ 0x00, 0xC0 },
+	};
+	unsigned char test_data[2] = {0x01, 0x00};
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+
+	reset_tas5717_GPIO(codec);
+
+	dev_info(codec->dev, "tas5717_init!\n");
+	if (1) {
+		snd_soc_write(codec, DDX_OSC_TRIM, 0x80);
+	msleep(50);
+	snd_soc_write(codec, DDX_CLOCK_CTL, 0x6c);
+	snd_soc_write(codec, DDX_SYS_CTL_1, 0xa0);
+	snd_soc_write(codec, DDX_SERIAL_DATA_INTERFACE, 0x05);
+	snd_soc_write(codec, DDX_BKND_ERR, 0x57);
+
+	regmap_raw_write(codec->control_data, DDX_INPUT_MUX, burst_data[0], 4);
+	regmap_raw_write(codec->control_data, DDX_CH4_SOURCE_SELECT,
+			 burst_data[1], 4);
+	regmap_raw_write(codec->control_data, DDX_PWM_MUX, burst_data[2], 4);
+
+	/*drc */
+	if ((tas5717_set_drc(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5717 drc!\n");
+	/*eq */
+	if ((tas5717_set_eq(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5717 eq!\n");
+	/*init */
+	if ((tas5717_customer_init(codec)) < 0)
+		dev_err(codec->dev, " fail to set tas5717 customer init!\n");
+
+	snd_soc_write(codec, DDX_VOLUME_CONFIG, 0xF0);
+	snd_soc_write(codec, DDX_SYS_CTL_2, 0x00);
+	snd_soc_write(codec, DDX_START_STOP_PERIOD, 0x68);
+	snd_soc_write(codec, DDX_PWM_SHUTDOWN_GROUP, 0x30);
+	snd_soc_write(codec, DDX_MODULATION_LIMIT, 0x02);
+	/*normal operation */
+	if ((tas5717_set_master_vol(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5717 master vol!\n");
+	channel_vol[0][0] = ((tas5717->Ch1_vol * 4 + 3) & 0xFF00) >> 8;
+	channel_vol[0][1] = (tas5717->Ch1_vol * 4 + 3) & 0x00FF;
+	channel_vol[1][0] = ((tas5717->Ch2_vol * 4 + 3) & 0xFF00) >> 8;
+	channel_vol[1][1] = (tas5717->Ch2_vol * 4 + 3) & 0x00FF;
+	pr_info("channel_vol[0]::0x%x,%x\n",
+		channel_vol[0][0], channel_vol[0][1]);
+	pr_info("channel_vol[1]::0x%x,%x\n",
+		channel_vol[1][0], channel_vol[1][1]);
+	pr_info("channel_vol[2]::0x%x,%x\n",
+		channel_vol[2][0], channel_vol[2][1]);
+	regmap_raw_write(codec->control_data, DDX_CHANNEL1_VOL,
+		channel_vol[0], 2);
+	regmap_raw_write(codec->control_data, DDX_CHANNEL2_VOL,
+		channel_vol[1], 2);
+	snd_soc_write(codec, DDX_SOFT_MUTE, 0x00);
+	regmap_raw_write(codec->control_data, DDX_CHANNEL3_VOL,
+		channel_vol[2], 2);
+	} else {
+		pr_info("GST 5705 test_init\n");
+		snd_soc_write(codec, DDX_SYS_CTL_2, 0x00);
+		snd_soc_write(codec, DDX_OSC_TRIM, 0x80);
+		regmap_raw_write(codec->control_data, DDX_MASTER_VOLUME,
+			test_data, 2);
+	}
+	/*kthread for phone*/
+	if (tas5717->pdata->scan_pin > 0) {
+		phone_task =
+			kthread_create(phone_thread, codec, "phone_thread");
+		if (IS_ERR(phone_task)) {
+			dev_err(codec->dev, "Unable to start kernel thread./n");
+			err = PTR_ERR(phone_task);
+			phone_task = NULL;
+			return err;
+		}
+		wake_up_process(phone_task);
+	}
+	return 0;
+}
+
+static int tas5717_probe(struct snd_soc_codec *codec)
+{
+	int ret = 0;
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	early_suspend.suspend = tas5717_early_suspend;
+	early_suspend.resume = tas5717_late_resume;
+	early_suspend.param = codec;
+	register_early_suspend(&early_suspend);
+#endif
+
+	tas5717->pdata = pdata;
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, tas5717->control_type);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+	tas5717_init(codec);
+
+	return 0;
+}
+
+static int tas5717_remove(struct snd_soc_codec *codec)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&early_suspend);
+#endif
+	if (phone_task) {
+		kthread_stop(phone_task);
+		phone_task = NULL;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tas5717_suspend(struct snd_soc_codec *codec)
+{
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5717_suspend!\n");
+
+	if (pdata && pdata->suspend_func)
+		pdata->suspend_func();
+
+	/*save volume */
+	tas5717->Ch1_vol = snd_soc_read(codec, DDX_CHANNEL1_VOL);
+	tas5717->Ch2_vol = snd_soc_read(codec, DDX_CHANNEL2_VOL);
+	tas5717_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int tas5717_resume(struct snd_soc_codec *codec)
+{
+	struct tas5717_priv *tas5717 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5717_resume!\n");
+
+	if (pdata && pdata->resume_func)
+		pdata->resume_func();
+
+	tas5717_init(codec);
+	snd_soc_write(codec, DDX_CHANNEL1_VOL, tas5717->Ch1_vol);
+	snd_soc_write(codec, DDX_CHANNEL2_VOL, tas5717->Ch2_vol);
+	tas5717_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+#else
+#define tas5717_suspend NULL
+#define tas5717_resume NULL
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void tas5717_early_suspend(struct early_suspend *h)
+{
+	return;
+	/*struct snd_soc_codec *codec = NULL;
+	struct tas57xx_platform_data *pdata = NULL;
+
+	codec = (struct snd_soc_codec *)(h->param);
+	pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5717_early_suspend!\n");
+	if (pdata && pdata->early_suspend_func)
+		pdata->early_suspend_func();
+
+	snd_soc_write(codec, DDX_MASTER_VOLUME, 0xFF);*/
+}
+
+static void tas5717_late_resume(struct early_suspend *h)
+{
+	return;
+	/*struct snd_soc_codec *codec = NULL;
+	struct tas57xx_platform_data *pdata = NULL;
+
+	codec = (struct snd_soc_codec *)(h->param);
+	pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5717_late_resume!\n");
+	if (pdata && pdata->late_resume_func)
+		pdata->late_resume_func();
+
+	tas5717_set_master_vol(codec);*/
+}
+#endif
+
+static const struct snd_soc_dapm_widget tas5717_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC", "HIFI Playback", SND_SOC_NOPM, 0, 0),
+};
+
+static const struct snd_soc_dapm_route tas5717_dapm_routes[] = {
+	{ "LEFT", NULL, "DAC" },
+	{ "RIGHT", NULL, "DAC" },
+};
+
+static const struct snd_soc_codec_driver tas5717_codec = {
+	.probe = tas5717_probe,
+	.remove = tas5717_remove,
+	.suspend = tas5717_suspend,
+	.resume = tas5717_resume,
+	.reg_cache_size = DDX_NUM_BYTE_REG,
+	.reg_word_size = sizeof(u8),
+	.reg_cache_default = tas5717_regs,
+	.set_bias_level = tas5717_set_bias_level,
+	.controls = tas5717_snd_controls,
+	.num_controls = ARRAY_SIZE(tas5717_snd_controls),
+	.dapm_widgets = tas5717_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(tas5717_dapm_widgets),
+	.dapm_routes = tas5717_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(tas5717_dapm_routes),
+};
+
+static int tas5717_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct tas5717_priv *tas5717;
+	int ret;
+
+	tas5717 = devm_kzalloc(&i2c->dev, sizeof(struct tas5717_priv),
+			       GFP_KERNEL);
+	if (!tas5717)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, tas5717);
+	tas5717->control_type = SND_SOC_I2C;
+	ret = snd_soc_register_codec(&i2c->dev, &tas5717_codec,
+				     &tas5717_dai, 1);
+	if (ret != 0)
+		dev_err(&i2c->dev, "Failed to register codec (%d)\n", ret);
+
+	return ret;
+}
+
+static int tas5717_i2c_remove(struct i2c_client *client)
+{
+	devm_kfree(&client->dev, i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id tas5717_i2c_id[] = {
+	{ "tas5717", 0 },
+	{}
+};
+
+static struct i2c_driver tas5717_i2c_driver = {
+	.driver = {
+		.name = "tas5717",
+		.owner = THIS_MODULE,
+	},
+	.probe = tas5717_i2c_probe,
+	.remove = tas5717_i2c_remove,
+	.id_table = tas5717_i2c_id,
+};
+
+static int aml_tas5717_codec_probe(struct platform_device *pdev)
+{
+	return 0;
+}
+static int aml_tas5717_codec_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+static const struct of_device_id amlogic_tas5717_codec_dt_match[] = {
+	{ .compatible = "amlogic, aml_tas5717_codec", },
+	{},
+};
+
+static struct platform_driver aml_tas5717_codec_platform_driver = {
+	.driver = {
+		.name = "tas5717",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_tas5717_codec_dt_match,
+	},
+	.probe = aml_tas5717_codec_probe,
+	.remove = aml_tas5717_codec_remove,
+};
+
+static int __init aml_tas5717_modinit(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&aml_tas5717_codec_platform_driver);
+	if (ret != 0)
+		pr_err("Failed to register codec tas5717 platform driver\n");
+	i2c_add_driver(&tas5717_i2c_driver);
+	return ret;
+}
+static void __exit aml_tas5717_exit(void)
+{
+	platform_driver_unregister(&aml_tas5717_codec_platform_driver);
+	i2c_del_driver(&tas5717_i2c_driver);
+}
+
+module_init(aml_tas5717_modinit);
+module_exit(aml_tas5717_exit);
+
+MODULE_DESCRIPTION("ASoC Tas5717 driver");
+MODULE_AUTHOR("AML MM team");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/codecs/tas5717.h b/sound/soc/codecs/tas5717.h
new file mode 100644
index 0000000..01b2bf4
--- /dev/null
+++ b/sound/soc/codecs/tas5717.h
@@ -0,0 +1,95 @@
+#ifndef _TAS5717_H
+#define _TAS5717_H
+
+#define DDX_I2C_ADDR                                0x36
+
+#define DDX_CLOCK_CTL                               0x00
+#define DDX_DEVICE_ID                               0x01
+#define DDX_ERROR_STATUS                            0x02
+#define DDX_SYS_CTL_1                               0x03
+#define DDX_SERIAL_DATA_INTERFACE                   0x04
+#define DDX_SYS_CTL_2                               0x05
+#define DDX_SOFT_MUTE                               0x06
+#define DDX_MASTER_VOLUME                           0x07
+#define DDX_CHANNEL1_VOL                            0x08
+#define DDX_CHANNEL2_VOL                            0x09
+#define DDX_CHANNEL3_VOL                            0x0A
+#define DDX_HEADPHONE_VOL                           0x0C
+#define DDX_VOLUME_CONFIG                           0x0E
+
+#define DDX_MODULATION_LIMIT                        0x10
+#define DDX_IC_DELAY_CHANNEL_1                      0x11
+#define DDX_IC_DELAY_CHANNEL_2                      0x12
+#define DDX_IC_DELAY_CHANNEL_3                      0x13
+#define DDX_IC_DELAY_CHANNEL_4                      0x14
+#define DDX_PWM_SHUTDOWN_GROUP                      0x19
+#define DDX_START_STOP_PERIOD                       0x1A
+#define DDX_OSC_TRIM                                0x1B
+#define DDX_BKND_ERR                                0x1C
+#define DDX_NUM_BYTE_REG                            0x1D
+
+#define DDX_INPUT_MUX                               0x20
+#define DDX_CH4_SOURCE_SELECT                       0x21
+
+#define DDX_PWM_MUX                                 0x25
+
+#define DDX_CH1_BQ_0                                0x29
+#define DDX_CH1_BQ_1                                0x2A
+#define DDX_CH1_BQ_2                                0x2B
+#define DDX_CH1_BQ_3                                0x2C
+#define DDX_CH1_BQ_4                                0x2D
+#define DDX_CH1_BQ_5                                0x2E
+#define DDX_CH1_BQ_6                                0x2F
+
+#define DDX_CH2_BQ_0                                0x30
+#define DDX_CH2_BQ_1                                0x31
+#define DDX_CH2_BQ_2                                0x32
+#define DDX_CH2_BQ_3                                0x33
+#define DDX_CH2_BQ_4                                0x34
+#define DDX_CH2_BQ_5                                0x35
+#define DDX_CH2_BQ_6                                0x36
+
+#define DDX_DRC1_AE                                 0x3A
+#define DDX_DRC1_AA                                 0x3B
+#define DDX_DRC1_AD                                 0x3C
+#define DDX_DRC2_AE                                 0x3D
+#define DDX_DRC2_AA                                 0x3E
+#define DDX_DRC2_AD                                 0x3F
+#define DDX_DRC1_T                                  0x40
+#define DDX_DRC1_K                                  0x41
+#define DDX_DRC1_O                                  0x42
+#define DDX_DRC2_T                                  0x43
+#define DDX_DRC2_K                                  0x44
+#define DDX_DRC2_O                                  0x45
+#define DDX_DRC_CTL                                 0x46
+
+#define DDX_BANKSWITCH_AND_EQCTL                    0x50
+#define DDX_CH_1_OUTPUT_MIXER                       0x51
+#define DDX_CH_2_OUTPUT_MIXER                       0x52
+#define DDX_CH_1_INPUT_MIXER                        0x53
+#define DDX_CH_2_INPUT_MIXER                        0x54
+#define DDX_CH_3_INPUT_MIXER                        0x55
+#define DDX_OUTPUT_POST_SCALE                       0x56
+#define DDX_OUTPUT_PRE_SCALE                        0x57
+
+#define DDX_CH1_BQ_7                                0x58
+#define DDX_CH1_BQ_8                                0x59
+#define DDX_SUBCHANNEL_BQ_0                         0x5A
+#define DDX_SUBCHANNEL_BQ_1                         0x5B
+#define DDX_CH2_BQ_7                                0x5C
+#define DDX_CH2_BQ_8                                0x5D
+#define DDX_PSEUDO_CH2_BQ_0                         0x5E
+
+#define DDX_CH_4_OUTPUT_MIXER                       0x60
+#define DDX_CH_4_INPUT_MIXER                        0x61
+#define DDX_CH_IDF_POST_SCALE                       0x62
+#define DDX_CH_DEV_ADDR_ENABLE                      0xF8
+#define DDX_CH_DEV_ADDR_UPDATE                      0xF9
+
+#define DDX_DRC_BYTES                               (8)
+#define DDX_BQ_BYTES                                (20)
+
+#define GPIO_HIGH_LEVEL	(1)
+#define GPIO_LOW_LEVEL    (0)
+
+#endif
diff --git a/sound/soc/codecs/tas5731.c b/sound/soc/codecs/tas5731.c
new file mode 100644
index 0000000..e5516af
--- /dev/null
+++ b/sound/soc/codecs/tas5731.c
@@ -0,0 +1,770 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/tas57xx.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include "tas5731.h"
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend early_suspend;
+static void tas5731_early_suspend(struct early_suspend *h);
+static void tas5731_late_resume(struct early_suspend *h);
+#endif
+
+#define tas5731_RATES (SNDRV_PCM_RATE_8000 | \
+		       SNDRV_PCM_RATE_11025 | \
+		       SNDRV_PCM_RATE_16000 | \
+		       SNDRV_PCM_RATE_22050 | \
+		       SNDRV_PCM_RATE_32000 | \
+		       SNDRV_PCM_RATE_44100 | \
+		       SNDRV_PCM_RATE_48000)
+
+#define tas5731_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE | \
+	 SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+	 SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE | \
+	 SNDRV_PCM_FMTBIT_S32_LE)
+
+/* Power-up register defaults */
+static const u8 tas5731_regs[DDX_NUM_BYTE_REG] = {
+	0x6c, 0x70, 0x00, 0xA0, 0x05, 0x40, 0x00, 0xFF,
+	0x30, 0x30, 0xFF, 0x00, 0x00, 0x00, 0x91, 0x00,
+	0x02, 0xAC, 0x54, 0xAC, 0x54, 0x00, 0x00, 0x00,
+	0x00, 0x30, 0x0F, 0x82, 0x02,
+};
+
+static u8 TAS5731_drc1_table[3][8] = {
+	/* 0x3A drc1_ae */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3B drc1_aa */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3C drc1_ad */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+};
+
+static u8 TAS5731_drc2_table[3][8] = {
+	/* 0x3D drc2_ae */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3E drc2_aa */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 0x3F drc2_ad */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+};
+
+static u8 tas5731_drc1_tko_table[3][4] = {
+	/* 0x40 drc1_t */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x41 drc1_k */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x42 drc1_o */
+	{ 0x00, 0x00, 0x00, 0x00 }
+};
+
+static u8 tas5731_drc2_tko_table[3][4] = {
+	/* 0x43 drc2_t */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x44 drc2_k */
+	{ 0x00, 0x00, 0x00, 0x00 },
+	/* 0x45 drc2_o */
+	{ 0x00, 0x00, 0x00, 0x00 }
+};
+
+
+/* codec private data */
+struct tas5731_priv {
+	struct snd_soc_codec *codec;
+	struct tas57xx_platform_data *pdata;
+
+	enum snd_soc_control_type control_type;
+	void *control_data;
+
+	/*Platform provided EQ configuration */
+	int num_eq_conf_texts;
+	const char **eq_conf_texts;
+	int eq_cfg;
+	struct soc_enum eq_conf_enum;
+	unsigned char Ch1_vol;
+	unsigned char Ch2_vol;
+	unsigned mclk;
+};
+
+static const DECLARE_TLV_DB_SCALE(mvol_tlv, -12700, 50, 1);
+static const DECLARE_TLV_DB_SCALE(chvol_tlv, -10300, 50, 1);
+
+static const struct snd_kcontrol_new tas5731_snd_controls[] = {
+	SOC_SINGLE_TLV("Master Volume", DDX_MASTER_VOLUME, 0,
+		       0xff, 1, mvol_tlv),
+	SOC_SINGLE_TLV("Ch1 Volume", DDX_CHANNEL1_VOL, 0,
+		       0xff, 1, chvol_tlv),
+	SOC_SINGLE_TLV("Ch2 Volume", DDX_CHANNEL2_VOL, 0,
+		       0xff, 1, chvol_tlv),
+	SOC_SINGLE("Ch1 Switch", DDX_SOFT_MUTE, 0, 1, 1),
+	SOC_SINGLE("Ch2 Switch", DDX_SOFT_MUTE, 1, 1, 1),
+	SOC_SINGLE_RANGE("Fine Master Volume", DDX_CHANNEL3_VOL, 0,
+			   0x80, 0x83, 0),
+};
+
+static int tas5731_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+
+	tas5731->mclk = freq;
+	/* 0x74 = 512fs; 0x6c = 256fs */
+	if (freq == 512 * 48000)
+		snd_soc_write(codec, DDX_CLOCK_CTL, 0x74);
+	else
+		snd_soc_write(codec, DDX_CLOCK_CTL, 0x6c);
+	return 0;
+}
+
+static int tas5731_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int tas5731_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	unsigned int rate;
+
+	rate = params_rate(params);
+	pr_debug("rate: %u\n", rate);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S24_BE:
+		pr_debug("24bit\n");
+	/* fall through */
+	case SNDRV_PCM_FORMAT_S32_LE:
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S20_3BE:
+		pr_debug("20bit\n");
+
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S16_BE:
+		pr_debug("16bit\n");
+
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int tas5731_set_bias_level(struct snd_soc_codec *codec,
+				  enum snd_soc_bias_level level)
+{
+	pr_debug("level = %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* Full power on */
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/* The chip runs through the power down sequence for us. */
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static const struct snd_soc_dai_ops tas5731_dai_ops = {
+	.hw_params = tas5731_hw_params,
+	.set_sysclk = tas5731_set_dai_sysclk,
+	.set_fmt = tas5731_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver tas5731_dai = {
+	.name = "tas5731",
+	.playback = {
+		.stream_name = "HIFI Playback",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = tas5731_RATES,
+		.formats = tas5731_FORMATS,
+	},
+	.ops = &tas5731_dai_ops,
+};
+
+static int tas5731_set_master_vol(struct snd_soc_codec *codec)
+{
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	/* using user BSP defined master vol config; */
+	if (pdata && pdata->custom_master_vol) {
+		pr_debug("tas5731_set_master_vol::%d\n",
+			pdata->custom_master_vol);
+		snd_soc_write(codec, DDX_MASTER_VOLUME,
+			      (0xff - pdata->custom_master_vol));
+	} else {
+		pr_debug
+			("get dtd master_vol failed:using default setting\n");
+		snd_soc_write(codec, DDX_MASTER_VOLUME, 0x30);
+	}
+
+	return 0;
+}
+
+/* tas5731 DRC for channel L/R */
+static int tas5731_set_drc1(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0;
+	u8 *p = NULL;
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->custom_drc1_table
+	    && pdata->custom_drc1_table_len == 24) {
+		p = pdata->custom_drc1_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 8; j++)
+				TAS5731_drc1_table[i][j] = p[i * 8 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC1_AE + i,
+					 TAS5731_drc1_table[i], 8);
+			/*for (j = 0; j < 8; j++)
+				pr_info("TAS5731_drc1_table[%d][%d]: %x\n",
+					 i, j, TAS5731_drc1_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	if (pdata && pdata->custom_drc1_tko_table
+	    && pdata->custom_drc1_tko_table_len == 12) {
+		p = pdata->custom_drc1_tko_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 4; j++)
+				tas5731_drc1_tko_table[i][j] = p[i * 4 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC1_T + i,
+					 tas5731_drc1_tko_table[i], 4);
+			/*for (j = 0; j < 4; j++)
+				pr_info("tas5731_drc1_tko_table[%d][%d]: %x\n",
+					 i, j, tas5731_drc1_tko_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int tas5731_set_drc2(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0;
+	u8 *p = NULL;
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->custom_drc2_table
+	    && pdata->custom_drc2_table_len == 24) {
+		p = pdata->custom_drc2_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 8; j++)
+				TAS5731_drc2_table[i][j] = p[i * 8 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC2_AE + i,
+					 TAS5731_drc2_table[i], 8);
+			/*for (j = 0; j < 8; j++)
+				pr_info("TAS5731_drc2_table[%d][%d]: %x\n",
+					 i, j, TAS5731_drc2_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	if (pdata && pdata->custom_drc2_tko_table
+	    && pdata->custom_drc2_tko_table_len == 12) {
+		p = pdata->custom_drc2_tko_table;
+		for (i = 0; i < 3; i++) {
+			for (j = 0; j < 4; j++)
+				tas5731_drc2_tko_table[i][j] = p[i * 4 + j];
+
+			regmap_raw_write(codec->control_data, DDX_DRC2_T + i,
+					 tas5731_drc2_tko_table[i], 4);
+			/*for (j = 0; j < 4; j++)
+				pr_info("tas5731_drc2_tko_table[%d][%d]: %x\n",
+					 i, j, tas5731_drc2_tko_table[i][j]);*/
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static int tas5731_set_drc(struct snd_soc_codec *codec)
+{
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+	char drc_mask = 0;
+	u8 tas5731_drc_ctl_table[] = { 0x00, 0x00, 0x00, 0x00 };
+
+	if (pdata && pdata->enable_ch1_drc
+		&& pdata->enable_ch2_drc && pdata->drc_enable) {
+		drc_mask |= 0x03;
+		tas5731_drc_ctl_table[3] = drc_mask;
+		tas5731_set_drc1(codec);
+		tas5731_set_drc2(codec);
+	    regmap_raw_write(codec->control_data, DDX_DRC_CTL,
+			 tas5731_drc_ctl_table, 4);
+	    return 0;
+	}
+	return -1;
+}
+
+static int tas5731_set_eq_biquad(struct snd_soc_codec *codec)
+{
+	int i = 0, j = 0, k = 0;
+	u8 *p = NULL;
+	u8 addr;
+	u8 tas5731_bq_table[20];
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5731->pdata;
+	struct tas57xx_eq_cfg *cfg;
+
+	if (!pdata)
+		return 0;
+
+	cfg = pdata->eq_cfgs;
+	if (!(cfg))
+		return 0;
+
+	p = cfg[tas5731->eq_cfg].regs;
+
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 7; j++) {
+			addr = (DDX_CH1_BQ_0 + i * 7 + j);
+			for (k = 0; k < 20; k++)
+				tas5731_bq_table[k] =
+					p[i * 7 * 20 + j * 20 + k];
+			regmap_raw_write(codec->control_data, addr,
+					tas5731_bq_table, 20);
+			/*for (k = 0; k < 20; k++)
+				pr_info("tas5731_bq_table[%d]: %x\n",
+					k, tas5731_bq_table[k]);*/
+		}
+	}
+	return 0;
+}
+
+static int tas5731_put_eq_enum(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5731->pdata;
+	int value = ucontrol->value.integer.value[0];
+
+	if (value >= pdata->num_eq_cfgs)
+		return -EINVAL;
+
+	tas5731->eq_cfg = value;
+	tas5731_set_eq_biquad(codec);
+
+	return 0;
+}
+
+static int tas5731_get_eq_enum(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+
+	ucontrol->value.enumerated.item[0] = tas5731->eq_cfg;
+
+	return 0;
+}
+
+static int tas5731_set_eq(struct snd_soc_codec *codec)
+{
+	int i = 0, ret = 0;
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5731->pdata;
+	u8 tas5731_eq_ctl_table[] = { 0x00, 0x00, 0x00, 0x80 };
+	struct tas57xx_eq_cfg *cfg = pdata->eq_cfgs;
+
+	if (!pdata || !pdata->eq_enable)
+		return -ENOENT;
+
+	if (pdata->num_eq_cfgs && (tas5731->eq_conf_texts == NULL)) {
+		struct snd_kcontrol_new control =
+			SOC_ENUM_EXT("EQ Mode", tas5731->eq_conf_enum,
+				     tas5731_get_eq_enum, tas5731_put_eq_enum);
+
+		tas5731->eq_conf_texts =
+			kzalloc(sizeof(char *) * pdata->num_eq_cfgs,
+				GFP_KERNEL);
+		if (!tas5731->eq_conf_texts) {
+			dev_err(codec->dev,
+				"Fail to allocate %d EQ config tests\n",
+				pdata->num_eq_cfgs);
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < pdata->num_eq_cfgs; i++)
+			tas5731->eq_conf_texts[i] = cfg[i].name;
+
+		tas5731->eq_conf_enum.max = pdata->num_eq_cfgs;
+		tas5731->eq_conf_enum.texts = tas5731->eq_conf_texts;
+
+		ret = snd_soc_add_codec_controls(codec, &control, 1);
+		if (ret != 0)
+			dev_err(codec->dev, "Fail to add EQ mode control: %d\n",
+				ret);
+	}
+
+	tas5731_set_eq_biquad(codec);
+
+	tas5731_eq_ctl_table[3] &= 0x7F;
+	regmap_raw_write(codec->control_data, DDX_BANKSWITCH_AND_EQCTL,
+			 tas5731_eq_ctl_table, 4);
+	return 0;
+}
+
+static int tas5731_customer_init(struct snd_soc_codec *codec)
+{
+	int i = 0;
+	u8 data[4] = {0x00, 0x00, 0x00, 0x00};
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->init_regs) {
+		if (pdata->num_init_regs != 4) {
+			dev_err(codec->dev, "num_init_regs = %d\n",
+				pdata->num_init_regs);
+			return -1;
+		}
+		for (i = 0; i < pdata->num_init_regs; i++)
+			data[i] = pdata->init_regs[i];
+		/*pr_info("init_regs[]: [%x][%x][%x][%x]\n",
+			data[0], data[1], data[2], data[3]);*/
+	} else {
+		return -1;
+	}
+
+	regmap_raw_write(codec->control_data, DDX_INPUT_MUX, data, 4);
+	return 0;
+}
+
+static int reset_tas5731_GPIO(struct snd_soc_codec *codec)
+{
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = tas5731->pdata;
+
+	gpio_direction_output(pdata->reset_pin, GPIOF_OUT_INIT_LOW);
+	udelay(1000);
+	gpio_direction_output(pdata->reset_pin, GPIOF_OUT_INIT_HIGH);
+	mdelay(15);
+	return 0;
+}
+
+static int tas5731_init(struct snd_soc_codec *codec)
+{
+	unsigned char burst_data[][4] = {
+		{ 0x00, 0x01, 0x77, 0x72 },
+		{ 0x00, 0x00, 0x43, 0x03 },
+		{ 0x01, 0x02, 0x13, 0x45 },
+	};
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+
+	reset_tas5731_GPIO(codec);
+
+	dev_info(codec->dev, "tas5731_init!\n");
+	snd_soc_write(codec, DDX_OSC_TRIM, 0x00);
+	msleep(50);
+	snd_soc_write(codec, DDX_CLOCK_CTL, 0x6c);
+	snd_soc_write(codec, DDX_SYS_CTL_1, 0xa0);
+	snd_soc_write(codec, DDX_SERIAL_DATA_INTERFACE, 0x05);
+	snd_soc_write(codec, DDX_BKND_ERR, 0x02);
+
+	regmap_raw_write(codec->control_data, DDX_INPUT_MUX, burst_data[0], 4);
+	regmap_raw_write(codec->control_data, DDX_CH4_SOURCE_SELECT,
+			 burst_data[1], 4);
+	regmap_raw_write(codec->control_data, DDX_PWM_MUX, burst_data[2], 4);
+
+	/*drc */
+	if ((tas5731_set_drc(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5731 drc!\n");
+	/*eq */
+	if ((tas5731_set_eq(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5731 eq!\n");
+	/*init */
+	if ((tas5731_customer_init(codec)) < 0)
+		dev_err(codec->dev, " fail to set tas5731 customer init!\n");
+
+	snd_soc_write(codec, DDX_VOLUME_CONFIG, 0xD1);
+	snd_soc_write(codec, DDX_SYS_CTL_2, 0x00);
+	snd_soc_write(codec, DDX_START_STOP_PERIOD, 0x0F);
+	snd_soc_write(codec, DDX_PWM_SHUTDOWN_GROUP, 0x30);
+	snd_soc_write(codec, DDX_MODULATION_LIMIT, 0x02);
+	/*normal operation */
+	if ((tas5731_set_master_vol(codec)) < 0)
+		dev_err(codec->dev, "fail to set tas5731 master vol!\n");
+
+	snd_soc_write(codec, DDX_CHANNEL1_VOL, tas5731->Ch1_vol);
+	snd_soc_write(codec, DDX_CHANNEL2_VOL, tas5731->Ch2_vol);
+	snd_soc_write(codec, DDX_SOFT_MUTE, 0x00);
+	snd_soc_write(codec, DDX_CHANNEL3_VOL, 0x80);
+
+	return 0;
+}
+
+static int tas5731_probe(struct snd_soc_codec *codec)
+{
+	int ret = 0;
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	early_suspend.suspend = tas5731_early_suspend;
+	early_suspend.resume = tas5731_late_resume;
+	early_suspend.param = codec;
+	register_early_suspend(&early_suspend);
+#endif
+
+	tas5731->pdata = pdata;
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, tas5731->control_type);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+	tas5731_init(codec);
+
+	return 0;
+}
+
+static int tas5731_remove(struct snd_soc_codec *codec)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&early_suspend);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tas5731_suspend(struct snd_soc_codec *codec)
+{
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5731_suspend!\n");
+
+	if (pdata && pdata->suspend_func)
+		pdata->suspend_func();
+
+	/*save volume */
+	tas5731->Ch1_vol = snd_soc_read(codec, DDX_CHANNEL1_VOL);
+	tas5731->Ch2_vol = snd_soc_read(codec, DDX_CHANNEL2_VOL);
+	tas5731_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int tas5731_resume(struct snd_soc_codec *codec)
+{
+	struct tas5731_priv *tas5731 = snd_soc_codec_get_drvdata(codec);
+	struct tas57xx_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5731_resume!\n");
+
+	if (pdata && pdata->resume_func)
+		pdata->resume_func();
+
+	tas5731_init(codec);
+	snd_soc_write(codec, DDX_CHANNEL1_VOL, tas5731->Ch1_vol);
+	snd_soc_write(codec, DDX_CHANNEL2_VOL, tas5731->Ch2_vol);
+	tas5731_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+#else
+#define tas5731_suspend NULL
+#define tas5731_resume NULL
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void tas5731_early_suspend(struct early_suspend *h)
+{
+	return;
+	/*struct snd_soc_codec *codec = NULL;
+	struct tas57xx_platform_data *pdata = NULL;
+
+	codec = (struct snd_soc_codec *)(h->param);
+	pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5731_early_suspend!\n");
+	if (pdata && pdata->early_suspend_func)
+		pdata->early_suspend_func();
+
+	snd_soc_write(codec, DDX_MASTER_VOLUME, 0xFF);*/
+}
+
+static void tas5731_late_resume(struct early_suspend *h)
+{
+	return;
+	/*struct snd_soc_codec *codec = NULL;
+	struct tas57xx_platform_data *pdata = NULL;
+
+	codec = (struct snd_soc_codec *)(h->param);
+	pdata = dev_get_platdata(codec->dev);
+
+	dev_info(codec->dev, "tas5731_late_resume!\n");
+	if (pdata && pdata->late_resume_func)
+		pdata->late_resume_func();
+
+	tas5731_set_master_vol(codec);*/
+}
+#endif
+
+static const struct snd_soc_dapm_widget tas5731_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC", "HIFI Playback", SND_SOC_NOPM, 0, 0),
+};
+
+static const struct snd_soc_codec_driver tas5731_codec = {
+	.probe = tas5731_probe,
+	.remove = tas5731_remove,
+	.suspend = tas5731_suspend,
+	.resume = tas5731_resume,
+	.reg_cache_size = DDX_NUM_BYTE_REG,
+	.reg_word_size = sizeof(u8),
+	.reg_cache_default = tas5731_regs,
+	.set_bias_level = tas5731_set_bias_level,
+	.controls = tas5731_snd_controls,
+	.num_controls = ARRAY_SIZE(tas5731_snd_controls),
+	.dapm_widgets = tas5731_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(tas5731_dapm_widgets),
+};
+
+static int tas5731_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct tas5731_priv *tas5731;
+	int ret;
+
+	tas5731 = devm_kzalloc(&i2c->dev, sizeof(struct tas5731_priv),
+			       GFP_KERNEL);
+	if (!tas5731)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, tas5731);
+	tas5731->control_type = SND_SOC_I2C;
+
+	ret = snd_soc_register_codec(&i2c->dev, &tas5731_codec,
+				     &tas5731_dai, 1);
+	if (ret != 0)
+		dev_err(&i2c->dev, "Failed to register codec (%d)\n", ret);
+
+	return ret;
+}
+
+static int tas5731_i2c_remove(struct i2c_client *client)
+{
+	devm_kfree(&client->dev, i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id tas5731_i2c_id[] = {
+	{ "tas5731", 0 },
+	{}
+};
+
+static struct i2c_driver tas5731_i2c_driver = {
+	.driver = {
+		.name = "tas5731",
+		.owner = THIS_MODULE,
+	},
+	.probe = tas5731_i2c_probe,
+	.remove = tas5731_i2c_remove,
+	.id_table = tas5731_i2c_id,
+};
+
+static int aml_tas5731_codec_probe(struct platform_device *pdev)
+{
+	return 0;
+}
+static int aml_tas5731_codec_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+static const struct of_device_id amlogic_tas5731_codec_dt_match[] = {
+	{ .compatible = "amlogic, aml_tas5731_codec", },
+	{},
+};
+
+static struct platform_driver aml_tas5731_codec_platform_driver = {
+	.driver = {
+		.name = "tas5731",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_tas5731_codec_dt_match,
+	},
+	.probe = aml_tas5731_codec_probe,
+	.remove = aml_tas5731_codec_remove,
+};
+
+static int __init aml_tas5731_modinit(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&aml_tas5731_codec_platform_driver);
+	if (ret != 0)
+		pr_err("Failed to register codec tas5731 platform driver\n");
+	i2c_add_driver(&tas5731_i2c_driver);
+	return ret;
+}
+static void __exit aml_tas5731_exit(void)
+{
+	platform_driver_unregister(&aml_tas5731_codec_platform_driver);
+	i2c_del_driver(&tas5731_i2c_driver);
+}
+
+module_init(aml_tas5731_modinit);
+module_exit(aml_tas5731_exit);
+
+MODULE_DESCRIPTION("ASoC Tas5731 driver");
+MODULE_AUTHOR("AML MM team");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/codecs/tas5731.h b/sound/soc/codecs/tas5731.h
new file mode 100644
index 0000000..3460b54
--- /dev/null
+++ b/sound/soc/codecs/tas5731.h
@@ -0,0 +1,91 @@
+#ifndef _TAS5731_H
+#define _TAS5731_H
+
+#define DDX_I2C_ADDR                                0x36
+
+#define DDX_CLOCK_CTL                               0x00
+#define DDX_DEVICE_ID                               0x01
+#define DDX_ERROR_STATUS                            0x02
+#define DDX_SYS_CTL_1                               0x03
+#define DDX_SERIAL_DATA_INTERFACE                   0x04
+#define DDX_SYS_CTL_2                               0x05
+#define DDX_SOFT_MUTE                               0x06
+#define DDX_MASTER_VOLUME                           0x07
+#define DDX_CHANNEL1_VOL                            0x08
+#define DDX_CHANNEL2_VOL                            0x09
+#define DDX_CHANNEL3_VOL                            0x0A
+#define DDX_VOLUME_CONFIG                           0x0E
+
+#define DDX_MODULATION_LIMIT                        0x10
+#define DDX_IC_DELAY_CHANNEL_1                      0x11
+#define DDX_IC_DELAY_CHANNEL_2                      0x12
+#define DDX_IC_DELAY_CHANNEL_3                      0x13
+#define DDX_IC_DELAY_CHANNEL_4                      0x14
+#define DDX_PWM_SHUTDOWN_GROUP                      0x19
+#define DDX_START_STOP_PERIOD                       0x1A
+#define DDX_OSC_TRIM                                0x1B
+#define DDX_BKND_ERR                                0x1C
+#define DDX_NUM_BYTE_REG                            0x1D
+
+#define DDX_INPUT_MUX                               0x20
+#define DDX_CH4_SOURCE_SELECT                       0x21
+
+#define DDX_PWM_MUX                                 0x25
+
+#define DDX_CH1_BQ_0                                0x29
+#define DDX_CH1_BQ_1                                0x2A
+#define DDX_CH1_BQ_2                                0x2B
+#define DDX_CH1_BQ_3                                0x2C
+#define DDX_CH1_BQ_4                                0x2D
+#define DDX_CH1_BQ_5                                0x2E
+#define DDX_CH1_BQ_6                                0x2F
+
+#define DDX_CH2_BQ_0                                0x30
+#define DDX_CH2_BQ_1                                0x31
+#define DDX_CH2_BQ_2                                0x32
+#define DDX_CH2_BQ_3                                0x33
+#define DDX_CH2_BQ_4                                0x34
+#define DDX_CH2_BQ_5                                0x35
+#define DDX_CH2_BQ_6                                0x36
+
+#define DDX_DRC1_AE                                 0x3A
+#define DDX_DRC1_AA                                 0x3B
+#define DDX_DRC1_AD                                 0x3C
+#define DDX_DRC2_AE                                 0x3D
+#define DDX_DRC2_AA                                 0x3E
+#define DDX_DRC2_AD                                 0x3F
+#define DDX_DRC1_T                                  0x40
+#define DDX_DRC1_K                                  0x41
+#define DDX_DRC1_O                                  0x42
+#define DDX_DRC2_T                                  0x43
+#define DDX_DRC2_K                                  0x44
+#define DDX_DRC2_O                                  0x45
+#define DDX_DRC_CTL                                 0x46
+
+#define DDX_BANKSWITCH_AND_EQCTL                    0x50
+#define DDX_CH_1_OUTPUT_MIXER                       0x51
+#define DDX_CH_2_OUTPUT_MIXER                       0x52
+#define DDX_CH_1_INPUT_MIXER                        0x53
+#define DDX_CH_2_INPUT_MIXER                        0x54
+#define DDX_CH_3_INPUT_MIXER                        0x55
+#define DDX_OUTPUT_POST_SCALE                       0x56
+#define DDX_OUTPUT_PRE_SCALE                        0x57
+
+#define DDX_CH1_BQ_7                                0x58
+#define DDX_CH1_BQ_8                                0x59
+#define DDX_SUBCHANNEL_BQ_0                         0x5A
+#define DDX_SUBCHANNEL_BQ_1                         0x5B
+#define DDX_CH2_BQ_7                                0x5C
+#define DDX_CH2_BQ_8                                0x5D
+#define DDX_PSEUDO_CH2_BQ_0                         0x5E
+
+#define DDX_CH_4_OUTPUT_MIXER                       0x60
+#define DDX_CH_4_INPUT_MIXER                        0x61
+#define DDX_CH_IDF_POST_SCALE                       0x62
+#define DDX_CH_DEV_ADDR_ENABLE                      0xF8
+#define DDX_CH_DEV_ADDR_UPDATE                      0xF9
+
+#define DDX_DRC_BYTES                               (8)
+#define DDX_BQ_BYTES                                (20)
+
+#endif
diff --git a/sound/soc/codecs/wm2000.c b/sound/soc/codecs/wm2000.c
index 1a9f457..8ae5027 100644
--- a/sound/soc/codecs/wm2000.c
+++ b/sound/soc/codecs/wm2000.c
@@ -610,7 +610,7 @@ static int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
 
-	ucontrol->value.integer.value[0] = wm2000->anc_active;
+	ucontrol->value.enumerated.item[0] = wm2000->anc_active;
 
 	return 0;
 }
@@ -620,7 +620,7 @@ static int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
-	int anc_active = ucontrol->value.integer.value[0];
+	int anc_active = ucontrol->value.enumerated.item[0];
 	int ret;
 
 	if (anc_active > 1)
@@ -643,7 +643,7 @@ static int wm2000_speaker_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
 
-	ucontrol->value.integer.value[0] = wm2000->spk_ena;
+	ucontrol->value.enumerated.item[0] = wm2000->spk_ena;
 
 	return 0;
 }
@@ -653,7 +653,7 @@ static int wm2000_speaker_put(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
-	int val = ucontrol->value.integer.value[0];
+	int val = ucontrol->value.enumerated.item[0];
 	int ret;
 
 	if (val > 1)
diff --git a/sound/soc/codecs/wm5102.c b/sound/soc/codecs/wm5102.c
index fbee45c..ce9c8e1 100644
--- a/sound/soc/codecs/wm5102.c
+++ b/sound/soc/codecs/wm5102.c
@@ -41,7 +41,7 @@ struct wm5102_priv {
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
-static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);
+static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct wm_adsp_region wm5102_dsp1_regions[] = {
diff --git a/sound/soc/codecs/wm5110.c b/sound/soc/codecs/wm5110.c
index 0fce853..2c3c962 100644
--- a/sound/soc/codecs/wm5110.c
+++ b/sound/soc/codecs/wm5110.c
@@ -167,7 +167,7 @@ static int wm5110_sysclk_ev(struct snd_soc_dapm_widget *w,
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
-static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);
+static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 #define WM5110_NG_SRC(name, base) \
diff --git a/sound/soc/codecs/wm8731.c b/sound/soc/codecs/wm8731.c
index e593722..0297203 100644
--- a/sound/soc/codecs/wm8731.c
+++ b/sound/soc/codecs/wm8731.c
@@ -122,7 +122,7 @@ static int wm8731_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = wm8731->deemph;
+	ucontrol->value.enumerated.item[0] = wm8731->deemph;
 
 	return 0;
 }
@@ -132,7 +132,7 @@ static int wm8731_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.integer.value[0];
+	int deemph = ucontrol->value.enumerated.item[0];
 	int ret = 0;
 
 	if (deemph > 1)
diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c
index 62bacb8..2f167a8 100644
--- a/sound/soc/codecs/wm8737.c
+++ b/sound/soc/codecs/wm8737.c
@@ -494,8 +494,7 @@ static int wm8737_set_bias_level(struct snd_soc_codec *codec,
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
-					    WM8737_VMIDSEL_MASK,
-					    2 << WM8737_VMIDSEL_SHIFT);
+					    WM8737_VMIDSEL_MASK, 0x4);
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
@@ -509,8 +508,7 @@ static int wm8737_set_bias_level(struct snd_soc_codec *codec,
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
-				    WM8737_VMIDSEL_MASK,
-				    1 << WM8737_VMIDSEL_SHIFT);
+				    WM8737_VMIDSEL_MASK, 2);
 
 		break;
 
diff --git a/sound/soc/codecs/wm8903.c b/sound/soc/codecs/wm8903.c
index ae7d76e..eebcb1d 100644
--- a/sound/soc/codecs/wm8903.c
+++ b/sound/soc/codecs/wm8903.c
@@ -442,7 +442,7 @@ static int wm8903_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = wm8903->deemph;
+	ucontrol->value.enumerated.item[0] = wm8903->deemph;
 
 	return 0;
 }
@@ -452,7 +452,7 @@ static int wm8903_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.integer.value[0];
+	int deemph = ucontrol->value.enumerated.item[0];
 	int ret = 0;
 
 	if (deemph > 1)
diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h
index 0bb4a64..db94931 100644
--- a/sound/soc/codecs/wm8903.h
+++ b/sound/soc/codecs/wm8903.h
@@ -172,7 +172,7 @@ extern int wm8903_mic_detect(struct snd_soc_codec *codec,
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
-#define WM8903_VMID_RES_250K                         4
+#define WM8903_VMID_RES_250K                         3
 #define WM8903_VMID_RES_5K                           6
 
 /*
diff --git a/sound/soc/codecs/wm8904.c b/sound/soc/codecs/wm8904.c
index 66cb9e9..53bbfac 100644
--- a/sound/soc/codecs/wm8904.c
+++ b/sound/soc/codecs/wm8904.c
@@ -523,7 +523,7 @@ static int wm8904_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = wm8904->deemph;
+	ucontrol->value.enumerated.item[0] = wm8904->deemph;
 	return 0;
 }
 
@@ -532,7 +532,7 @@ static int wm8904_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.integer.value[0];
+	int deemph = ucontrol->value.enumerated.item[0];
 
 	if (deemph > 1)
 		return -EINVAL;
diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c
index 475fc24..82c8ba9 100644
--- a/sound/soc/codecs/wm8955.c
+++ b/sound/soc/codecs/wm8955.c
@@ -298,7 +298,7 @@ static int wm8955_configure_clocking(struct snd_soc_codec *codec)
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k >> 9) & WM8955_K_17_9_MASK);
-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,
+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_8_0_MASK,
 				    pll.k & WM8955_K_8_0_MASK);
 		if (pll.k)
@@ -393,7 +393,7 @@ static int wm8955_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = wm8955->deemph;
+	ucontrol->value.enumerated.item[0] = wm8955->deemph;
 	return 0;
 }
 
@@ -402,7 +402,7 @@ static int wm8955_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.integer.value[0];
+	int deemph = ucontrol->value.enumerated.item[0];
 
 	if (deemph > 1)
 		return -EINVAL;
diff --git a/sound/soc/codecs/wm8958-dsp2.c b/sound/soc/codecs/wm8958-dsp2.c
index 4f73619..d4248e0 100644
--- a/sound/soc/codecs/wm8958-dsp2.c
+++ b/sound/soc/codecs/wm8958-dsp2.c
@@ -459,7 +459,7 @@ static int wm8958_put_mbc_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.enumerated.item[0];
+	int value = ucontrol->value.integer.value[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
@@ -549,7 +549,7 @@ static int wm8958_put_vss_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.enumerated.item[0];
+	int value = ucontrol->value.integer.value[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
@@ -582,7 +582,7 @@ static int wm8958_put_vss_hpf_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.enumerated.item[0];
+	int value = ucontrol->value.integer.value[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
@@ -749,7 +749,7 @@ static int wm8958_put_enh_eq_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.enumerated.item[0];
+	int value = ucontrol->value.integer.value[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c
index e04dbaa..f156010 100644
--- a/sound/soc/codecs/wm8960.c
+++ b/sound/soc/codecs/wm8960.c
@@ -181,7 +181,7 @@ static int wm8960_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.integer.value[0] = wm8960->deemph;
+	ucontrol->value.enumerated.item[0] = wm8960->deemph;
 	return 0;
 }
 
@@ -190,7 +190,7 @@ static int wm8960_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.integer.value[0];
+	int deemph = ucontrol->value.enumerated.item[0];
 
 	if (deemph > 1)
 		return -EINVAL;
@@ -242,7 +242,7 @@ SOC_SINGLE("PCM Playback -6dB Switch", WM8960_DACCTL1, 7, 1, 0),
 SOC_ENUM("ADC Polarity", wm8960_enum[0]),
 SOC_SINGLE("ADC High Pass Filter Switch", WM8960_DACCTL1, 0, 1, 0),
 
-SOC_ENUM("DAC Polarity", wm8960_enum[1]),
+SOC_ENUM("DAC Polarity", wm8960_enum[2]),
 SOC_SINGLE_BOOL_EXT("DAC Deemphasis Switch", 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
@@ -392,7 +392,7 @@ static const struct snd_soc_dapm_route audio_paths[] = {
 	{ "Right Input Mixer", "Boost Switch", "Right Boost Mixer", },
 	{ "Right Input Mixer", NULL, "RINPUT1", },  /* Really Boost Switch */
 	{ "Right Input Mixer", NULL, "RINPUT2" },
-	{ "Right Input Mixer", NULL, "RINPUT3" },
+	{ "Right Input Mixer", NULL, "LINPUT3" },
 
 	{ "Left ADC", NULL, "Left Input Mixer" },
 	{ "Right ADC", NULL, "Right Input Mixer" },
@@ -555,7 +555,7 @@ static struct {
 	{ 22050, 2 },
 	{ 24000, 2 },
 	{ 16000, 3 },
-	{ 11025, 4 },
+	{ 11250, 4 },
 	{ 12000, 4 },
 	{  8000, 5 },
 };
diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c
index c8c8f6d..799348e 100644
--- a/sound/soc/codecs/wm8962.c
+++ b/sound/soc/codecs/wm8962.c
@@ -364,8 +364,8 @@ static struct reg_default wm8962_reg[] = {
 	{ 16924, 0x0059 },   /* R16924 - HDBASS_PG_1 */
 	{ 16925, 0x999A },   /* R16925 - HDBASS_PG_0 */
 
-	{ 17408, 0x0083 },   /* R17408 - HPF_C_1 */
-	{ 17409, 0x98AD },   /* R17409 - HPF_C_0 */
+	{ 17048, 0x0083 },   /* R17408 - HPF_C_1 */
+	{ 17049, 0x98AD },   /* R17409 - HPF_C_0 */
 
 	{ 17920, 0x007F },   /* R17920 - ADCL_RETUNE_C1_1 */
 	{ 17921, 0xFFFF },   /* R17921 - ADCL_RETUNE_C1_0 */
diff --git a/sound/soc/codecs/wm8974.c b/sound/soc/codecs/wm8974.c
index 31bd730..15f45c7 100644
--- a/sound/soc/codecs/wm8974.c
+++ b/sound/soc/codecs/wm8974.c
@@ -587,7 +587,6 @@ static const struct regmap_config wm8974_regmap = {
 	.max_register = WM8974_MONOMIX,
 	.reg_defaults = wm8974_reg_defaults,
 	.num_reg_defaults = ARRAY_SIZE(wm8974_reg_defaults),
-	.cache_type = REGCACHE_FLAT,
 };
 
 static int wm8974_probe(struct snd_soc_codec *codec)
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index 355b07e..d98e52f 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -360,7 +360,7 @@ static int wm8994_put_drc_enum(struct snd_kcontrol *kcontrol,
 	struct wm8994 *control = wm8994->wm8994;
 	struct wm8994_pdata *pdata = &control->pdata;
 	int drc = wm8994_get_drc(kcontrol->id.name);
-	int value = ucontrol->value.enumerated.item[0];
+	int value = ucontrol->value.integer.value[0];
 
 	if (drc < 0)
 		return drc;
@@ -467,7 +467,7 @@ static int wm8994_put_retune_mobile_enum(struct snd_kcontrol *kcontrol,
 	struct wm8994 *control = wm8994->wm8994;
 	struct wm8994_pdata *pdata = &control->pdata;
 	int block = wm8994_get_retune_mobile_block(kcontrol->id.name);
-	int value = ucontrol->value.enumerated.item[0];
+	int value = ucontrol->value.integer.value[0];
 
 	if (block < 0)
 		return block;
@@ -2745,7 +2745,7 @@ static struct {
 };
 
 static int fs_ratios[] = {
-	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536
+	64, 128, 192, 256, 348, 512, 768, 1024, 1408, 1536
 };
 
 static int bclk_divs[] = {
diff --git a/sound/soc/codecs/wm8997.c b/sound/soc/codecs/wm8997.c
index 1461ae6..555115e 100644
--- a/sound/soc/codecs/wm8997.c
+++ b/sound/soc/codecs/wm8997.c
@@ -40,7 +40,7 @@ struct wm8997_priv {
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
-static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);
+static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct reg_default wm8997_sysclk_reva_patch[] = {
diff --git a/sound/soc/davinci/davinci-evm.c b/sound/soc/davinci/davinci-evm.c
index f40a7a4..5e3bc3c 100644
--- a/sound/soc/davinci/davinci-evm.c
+++ b/sound/soc/davinci/davinci-evm.c
@@ -384,8 +384,18 @@ static int davinci_evm_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static int davinci_evm_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
 static struct platform_driver davinci_evm_driver = {
 	.probe		= davinci_evm_probe,
+	.remove		= davinci_evm_remove,
 	.driver		= {
 		.name	= "davinci_evm",
 		.owner	= THIS_MODULE,
diff --git a/sound/soc/dwc/designware_i2s.c b/sound/soc/dwc/designware_i2s.c
index 1b6cbbc..2f63575 100644
--- a/sound/soc/dwc/designware_i2s.c
+++ b/sound/soc/dwc/designware_i2s.c
@@ -100,10 +100,10 @@ static inline void i2s_clear_irqs(struct dw_i2s_dev *dev, u32 stream)
 
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		for (i = 0; i < 4; i++)
-			i2s_read_reg(dev->i2s_base, TOR(i));
+			i2s_write_reg(dev->i2s_base, TOR(i), 0);
 	} else {
 		for (i = 0; i < 4; i++)
-			i2s_read_reg(dev->i2s_base, ROR(i));
+			i2s_write_reg(dev->i2s_base, ROR(i), 0);
 	}
 }
 
diff --git a/sound/soc/fsl/fsl_esai.h b/sound/soc/fsl/fsl_esai.h
index dfdbaa0..75e1403 100644
--- a/sound/soc/fsl/fsl_esai.h
+++ b/sound/soc/fsl/fsl_esai.h
@@ -302,7 +302,7 @@
 #define ESAI_xCCR_xFP_MASK	(((1 << ESAI_xCCR_xFP_WIDTH) - 1) << ESAI_xCCR_xFP_SHIFT)
 #define ESAI_xCCR_xFP(v)	((((v) - 1) << ESAI_xCCR_xFP_SHIFT) & ESAI_xCCR_xFP_MASK)
 #define ESAI_xCCR_xDC_SHIFT     9
-#define ESAI_xCCR_xDC_WIDTH	5
+#define ESAI_xCCR_xDC_WIDTH	4
 #define ESAI_xCCR_xDC_MASK	(((1 << ESAI_xCCR_xDC_WIDTH) - 1) << ESAI_xCCR_xDC_SHIFT)
 #define ESAI_xCCR_xDC(v)	((((v) - 1) << ESAI_xCCR_xDC_SHIFT) & ESAI_xCCR_xDC_MASK)
 #define ESAI_xCCR_xPSR_SHIFT	8
diff --git a/sound/soc/fsl/imx-wm8962.c b/sound/soc/fsl/imx-wm8962.c
index 6644525..3a3d17c 100644
--- a/sound/soc/fsl/imx-wm8962.c
+++ b/sound/soc/fsl/imx-wm8962.c
@@ -190,7 +190,7 @@ static int imx_wm8962_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "audmux internal port setup failed\n");
 		return ret;
 	}
-	ret = imx_audmux_v2_configure_port(ext_port,
+	imx_audmux_v2_configure_port(ext_port,
 			IMX_AUDMUX_V2_PTCR_SYN,
 			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
 	if (ret) {
diff --git a/sound/soc/jz4740/Makefile b/sound/soc/jz4740/Makefile
index d32c540..be873c1 100644
--- a/sound/soc/jz4740/Makefile
+++ b/sound/soc/jz4740/Makefile
@@ -1,8 +1,10 @@
 #
 # Jz4740 Platform Support
 #
+snd-soc-jz4740-objs := jz4740-pcm.o
 snd-soc-jz4740-i2s-objs := jz4740-i2s.o
 
+obj-$(CONFIG_SND_JZ4740_SOC) += snd-soc-jz4740.o
 obj-$(CONFIG_SND_JZ4740_SOC_I2S) += snd-soc-jz4740-i2s.o
 
 # Jz4740 Machine Support
diff --git a/sound/soc/omap/omap-mcbsp.c b/sound/soc/omap/omap-mcbsp.c
index 6a339fb..6c19bba 100644
--- a/sound/soc/omap/omap-mcbsp.c
+++ b/sound/soc/omap/omap-mcbsp.c
@@ -436,7 +436,7 @@ static int omap_mcbsp_dai_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 	case SND_SOC_DAIFMT_CBM_CFS:
 		/* McBSP slave. FS clock as output */
 		regs->srgr2	|= FSGM;
-		regs->pcr0	|= FSXM | FSRM;
+		regs->pcr0	|= FSXM;
 		break;
 	case SND_SOC_DAIFMT_CBM_CFM:
 		/* McBSP slave */
diff --git a/sound/soc/omap/omap-pcm.c b/sound/soc/omap/omap-pcm.c
index 81f6a75..07b8b7b 100644
--- a/sound/soc/omap/omap-pcm.c
+++ b/sound/soc/omap/omap-pcm.c
@@ -200,7 +200,7 @@ static int omap_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	struct snd_pcm *pcm = rtd->pcm;
 	int ret;
 
-	ret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));
+	ret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(64));
 	if (ret)
 		return ret;
 
diff --git a/sound/soc/pxa/Kconfig b/sound/soc/pxa/Kconfig
index 9f4ea3f..6473052 100644
--- a/sound/soc/pxa/Kconfig
+++ b/sound/soc/pxa/Kconfig
@@ -1,6 +1,7 @@
 config SND_PXA2XX_SOC
 	tristate "SoC Audio for the Intel PXA2xx chip"
 	depends on ARCH_PXA
+	select SND_ARM
 	select SND_PXA2XX_LIB
 	help
 	  Say Y or M if you want to add support for codecs attached to
@@ -23,6 +24,7 @@ config SND_PXA2XX_AC97
 config SND_PXA2XX_SOC_AC97
 	tristate
 	select AC97_BUS
+	select SND_ARM
 	select SND_PXA2XX_LIB_AC97
 	select SND_SOC_AC97_BUS
 
diff --git a/sound/soc/pxa/pxa2xx-ac97.c b/sound/soc/pxa/pxa2xx-ac97.c
index 593e320..ae956e3 100644
--- a/sound/soc/pxa/pxa2xx-ac97.c
+++ b/sound/soc/pxa/pxa2xx-ac97.c
@@ -49,7 +49,7 @@ static struct snd_ac97_bus_ops pxa2xx_ac97_ops = {
 	.reset	= pxa2xx_ac97_cold_reset,
 };
 
-static unsigned long pxa2xx_ac97_pcm_stereo_in_req = 11;
+static unsigned long pxa2xx_ac97_pcm_stereo_in_req = 12;
 static struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_stereo_in = {
 	.addr		= __PREG(PCDR),
 	.addr_width	= DMA_SLAVE_BUSWIDTH_4_BYTES,
@@ -57,7 +57,7 @@ static struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_stereo_in = {
 	.filter_data	= &pxa2xx_ac97_pcm_stereo_in_req,
 };
 
-static unsigned long pxa2xx_ac97_pcm_stereo_out_req = 12;
+static unsigned long pxa2xx_ac97_pcm_stereo_out_req = 11;
 static struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_stereo_out = {
 	.addr		= __PREG(PCDR),
 	.addr_width	= DMA_SLAVE_BUSWIDTH_4_BYTES,
diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c
index e5601f9..5e9690c 100644
--- a/sound/soc/soc-compress.c
+++ b/sound/soc/soc-compress.c
@@ -665,34 +665,17 @@ int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)
 	struct snd_pcm *be_pcm;
 	char new_name[64];
 	int ret = 0, direction = 0;
-	int playback = 0, capture = 0;
 
 	/* check client and interface hw capabilities */
 	snprintf(new_name, sizeof(new_name), "%s %s-%d",
 			rtd->dai_link->stream_name, codec_dai->name, num);
 
 	if (codec_dai->driver->playback.channels_min)
-		playback = 1;
-	if (codec_dai->driver->capture.channels_min)
-		capture = 1;
-
-	capture = capture && cpu_dai->driver->capture.channels_min;
-	playback = playback && cpu_dai->driver->playback.channels_min;
-
-	/*
-	 * Compress devices are unidirectional so only one of the directions
-	 * should be set, check for that (xor)
-	 */
-	if (playback + capture != 1) {
-		dev_err(rtd->card->dev, "Invalid direction for compress P %d, C %d\n",
-				playback, capture);
-		return -EINVAL;
-	}
-
-	if(playback)
 		direction = SND_COMPRESS_PLAYBACK;
-	else
+	else if (codec_dai->driver->capture.channels_min)
 		direction = SND_COMPRESS_CAPTURE;
+	else
+		return -EINVAL;
 
 	compr = kzalloc(sizeof(*compr), GFP_KERNEL);
 	if (compr == NULL) {
@@ -713,8 +696,7 @@ int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)
 			rtd->dai_link->stream_name);
 
 		ret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,
-				rtd->dai_link->dpcm_playback,
-				rtd->dai_link->dpcm_capture, &be_pcm);
+				1, 0, &be_pcm);
 		if (ret < 0) {
 			dev_err(rtd->card->dev, "ASoC: can't create compressed for %s\n",
 				rtd->dai_link->name);
@@ -723,10 +705,8 @@ int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)
 
 		rtd->pcm = be_pcm;
 		rtd->fe_compr = 1;
-		if (rtd->dai_link->dpcm_playback)
-			be_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;
-		else if (rtd->dai_link->dpcm_capture)
-			be_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;
+		be_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;
+		be_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;
 		memcpy(compr->ops, &soc_compr_dyn_ops, sizeof(soc_compr_dyn_ops));
 	} else
 		memcpy(compr->ops, &soc_compr_ops, sizeof(soc_compr_ops));
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index 431a89b..e28704e 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -1404,8 +1404,7 @@ int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED) &&
-		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &&
-		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))
+		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))
 			continue;
 
 		dev_dbg(be->dev, "ASoC: hw_free BE %s\n",
-- 
1.9.1

