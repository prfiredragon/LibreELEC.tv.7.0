From ffbb8acf186b5bfed033c1949f17a4ff0f1527f2 Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Sun, 2 Oct 2016 20:43:51 +0800
Subject: [PATCH] Update: amports

---
 drivers/amlogic/amports/Kconfig                 |   18 +
 drivers/amlogic/amports/Makefile                |   72 +-
 drivers/amlogic/amports/adec.c                  |    6 +-
 drivers/amlogic/amports/amstream_profile.c      |    2 +-
 drivers/amlogic/amports/amvdec.c                |    4 +-
 drivers/amlogic/amports/amvideocap.c            |  359 +-
 drivers/amlogic/amports/arch/clk.c              |   15 +-
 drivers/amlogic/amports/arch/register_map.c     |   12 +-
 drivers/amlogic/amports/arch/register_ops.c     |   14 +-
 drivers/amlogic/amports/arch/register_ops.h     |    3 +-
 drivers/amlogic/amports/arch/register_ops_m8.c  |   20 +-
 drivers/amlogic/amports/arch/regs/di_regs.h     |    3 +
 drivers/amlogic/amports/arch/regs/dos_regs.h    |   20 +
 drivers/amlogic/amports/arch/regs/hcodec_regs.h |   26 +
 drivers/amlogic/amports/arch/regs/hhi_regs.h    |    3 +
 drivers/amlogic/amports/arch/regs/viu_regs.h    |   23 +-
 drivers/amlogic/amports/arch/regs/vpp_regs.h    |   19 +-
 drivers/amlogic/amports/avs.h                   |   70 +
 drivers/amlogic/amports/avsp_trans.c            | 4940 +++++++++++++++++++
 drivers/amlogic/amports/cnm/Makefile            |    1 +
 drivers/amlogic/amports/cnm/vmm.h               |  661 +++
 drivers/amlogic/amports/cnm/vpu.c               | 1989 ++++++++
 drivers/amlogic/amports/cnm/vpu.h               |  287 ++
 drivers/amlogic/amports/encoder.c               | 1348 ++++-
 drivers/amlogic/amports/encoder.h               |   32 +-
 drivers/amlogic/amports/jpegdec.c               |  195 +-
 drivers/amlogic/amports/jpegenc.c               |  113 +-
 drivers/amlogic/amports/jpegenc.h               |    5 +
 drivers/amlogic/amports/picdec.c                |  385 +-
 drivers/amlogic/amports/picdec.h                |  215 +-
 drivers/amlogic/amports/rdma.c                  |    8 +-
 drivers/amlogic/amports/vavs.c                  |  818 +++-
 drivers/amlogic/amports/vh264mvc.c              |   17 +-
 drivers/amlogic/amports/video.h                 |   10 +-
 drivers/amlogic/amports/vmjpeg.c                |   16 +-
 drivers/amlogic/amports/vmpeg12.c               |   42 +-
 drivers/amlogic/amports/vmpeg4.c                |  186 +-
 drivers/amlogic/amports/vp9_mm.c                |  205 +
 drivers/amlogic/amports/vpp.c                   | 1093 ++++-
 drivers/amlogic/amports/vpp.h                   |   57 +-
 drivers/amlogic/amports/vreal.c                 |   15 +-
 drivers/amlogic/amports/vvc1.c                  |   19 +-
 drivers/amlogic/amports/vvp9.c                  | 5987 +++++++++++++++++++++++
 drivers/amlogic/amports/vvp9.h                  |   32 +
 44 files changed, 18187 insertions(+), 1178 deletions(-)
 create mode 100644 drivers/amlogic/amports/avs.h
 create mode 100644 drivers/amlogic/amports/avsp_trans.c
 create mode 100644 drivers/amlogic/amports/cnm/Makefile
 create mode 100644 drivers/amlogic/amports/cnm/vmm.h
 create mode 100644 drivers/amlogic/amports/cnm/vpu.c
 create mode 100644 drivers/amlogic/amports/cnm/vpu.h
 create mode 100644 drivers/amlogic/amports/vp9_mm.c
 create mode 100644 drivers/amlogic/amports/vvp9.c
 create mode 100644 drivers/amlogic/amports/vvp9.h

diff --git a/drivers/amlogic/amports/Kconfig b/drivers/amlogic/amports/Kconfig
index b6447a1..ab81b0e 100644
--- a/drivers/amlogic/amports/Kconfig
+++ b/drivers/amlogic/amports/Kconfig
@@ -136,6 +136,18 @@ config AM_VDEC_H265
 	  need more...
 	  more...
 
+config AM_VDEC_VP9
+        tristate "Amlogic VP9 Video Decoder"
+        default y
+
+        select AM_PTSSERVER
+        ---help---
+          Driver for vp9 video decoder.
+	  need write more details...
+	  write need more.....
+	  need more...
+	  more...
+
 config AM_VDEC_MJPEG
 	tristate "Amlogic Motion JPEG Video Decoder"
 	default y
@@ -241,5 +253,11 @@ config AM_VIDEOCAPTURE
 	default n
 	---help---
 		Internal Video Capture driver
+
+config AM_HEVCENC
+	boolean "Amlogic Hevc Encoder support"
+	default n
+	---help---
+		Internal Hevc Encoder driver
 endmenu
 
diff --git a/drivers/amlogic/amports/Makefile b/drivers/amlogic/amports/Makefile
index ad7f265..8bc3ea6 100644
--- a/drivers/amlogic/amports/Makefile
+++ b/drivers/amlogic/amports/Makefile
@@ -4,75 +4,15 @@
 
 # Object file lists.
 
-ifeq ($(CONFIG_ARCH_MESON1),y)
-obj-y = m1/
-endif
-ifeq ($(CONFIG_ARCH_MESON2),y)
-obj-y = m2/
-endif
-ifeq ($(CONFIG_ARCH_MESON3),y)
-obj-y = m3/
-endif
-ifeq ($(CONFIG_ARCH_MESON6),y)
-obj-y = m6/
-endif
-ifeq ($(CONFIG_ARCH_MESON6TV),y)
-obj-y = m6tv/
-endif
-ifeq ($(CONFIG_ARCH_MESON6TVD),y)
-obj-y = m6tvd/
-endif
-ifeq ($(CONFIG_ARCH_MESON8),y)
-obj-y = m8/
-endif
-ifeq ($(CONFIG_ARCH_MESON8B),y)
-obj-y = m8b/
-endif
-ifeq ($(CONFIG_ARCH_MESONG9TV),y)
-obj-y = g9tv/
-endif
 
 
 obj-$(CONFIG_AM_STREAMING) += amports.o
 
 AMPORTS_OBJS = amstream.o streambuf.o vdec.o adec.o tsdemux.o psparser.o esparser.o rmparser.o amvdec.o amstream_profile.o tsync_pcr.o amports_gate.o gp_pll.o thread_rw.o
 
-ifeq ($(CONFIG_ARCH_MESON8B),y)
-amports-y    := amstream.o streambuf.o vdec.o adec.o tsdemux.o psparser.o esparser.o rmparser.o amvdec.o amstream_profile.o  tsync_pcr.o
-else
-ifeq ($(CONFIG_ARCH_MESON8),y)
-amports-objs := $(AMPORTS_OBJS)
-amports-y    := $(AMPORTS_OBJS)
-else
-ifeq ($(CONFIG_ARCH_MESONG9TV),y)
-amports-objs := $(AMPORTS_OBJS)
-amports-y    := $(AMPORTS_OBJS)
-else
-ifeq ($(CONFIG_ARCH_MESON6),y)
-amports-objs := $(AMPORTS_OBJS)
-amports-y    := $(AMPORTS_OBJS)
-else
-ifeq ($(CONFIG_ARCH_MESON6TV),y)
 amports-objs := $(AMPORTS_OBJS)
 amports-y    := $(AMPORTS_OBJS)
-else
-ifeq ($(CONFIG_ARCH_MESON6TVD),y)
-amports-objs := $(AMPORTS_OBJS)
-amports-y    := $(AMPORTS_OBJS)
-else
-ifeq ($(CONFIG_ARCH_MESONG9TV),y)
-amports-objs := $(AMPORTS_OBJS)
-amports-y    := $(AMPORTS_OBJS)
-else
-amports-objs := $(AMPORTS_OBJS)
-amports-y    := $(AMPORTS_OBJS)
-endif
-endif
-endif
-endif
-endif
-endif
-endif
+
 
 obj-$(CONFIG_AM_VDEC_MPEG12) += amvdec_mpeg12.o
 amvdec_mpeg12-objs := vmpeg12.o
@@ -102,6 +42,10 @@ obj-$(CONFIG_AM_VDEC_H265) += amvdec_h265.o
 amvdec_h265-objs := vh265.o
 amvdec_h265-y    := vh265.o
 
+obj-$(CONFIG_AM_VDEC_VP9) += amvdec_vp9.o
+amvdec_vp9-objs := vvp9.o vp9_mm.o
+amvdec_vp9-y    := vvp9.o vp9_mm.o
+
 obj-$(CONFIG_AM_VDEC_MJPEG) += amvdec_mjpeg.o
 amvdec_mjpeg-objs := vmjpeg.o
 amvdec_mjpeg-y    := vmjpeg.o
@@ -111,8 +55,8 @@ amvdec_real-objs := vreal.o
 amvdec_real-y    := vreal.o
 
 obj-$(CONFIG_AM_VDEC_AVS) += amvdec_avs.o
-amvdec_avs-objs := vavs.o
-amvdec_avs-y    := vavs.o
+amvdec_avs-objs := vavs.o avsp_trans.o
+amvdec_avs-y    := vavs.o avsp_trans.o
 
 obj-$(CONFIG_AM_JPEGDEC) += jpegdec.o
 
@@ -154,8 +98,8 @@ obj-$(CONFIG_AM_SUBTITLE) += subtitle.o
 
 obj-$(CONFIG_VSYNC_RDMA) += rdma.o
 
-
 obj-y += arch/
+obj-y += cnm/
 
 ifneq ($(CONFIG_AM_DVB),)
 ##EXTRA_CFLAGS = -DENABLE_DEMUX_DRIVER -DMODIFY_TIMESTAMP_INC_WITH_PLL -DCALC_CACHED_TIME #-DUSE_VMASTER_MODE
diff --git a/drivers/amlogic/amports/adec.c b/drivers/amlogic/amports/adec.c
index 2ffa249..ebdcd19 100644
--- a/drivers/amlogic/amports/adec.c
+++ b/drivers/amlogic/amports/adec.c
@@ -209,8 +209,10 @@ s32 adec_init(struct stream_port_s *port)
 	astream_dev->datawidth = port->adatawidth;
 
 	/*wmb();don't need it...*/
-	astream_dev->format = astream_format[af];
-
+	if (af <= ARRAY_SIZE(astream_format))
+		astream_dev->format = astream_format[af];
+	else
+		astream_dev->format = NULL;
 	return 0;
 }
 
diff --git a/drivers/amlogic/amports/amstream_profile.c b/drivers/amlogic/amports/amstream_profile.c
index 966618d..b6a075c 100644
--- a/drivers/amlogic/amports/amstream_profile.c
+++ b/drivers/amlogic/amports/amstream_profile.c
@@ -43,7 +43,7 @@ int vcodec_profile_register(const struct codec_profile_t *vdec_profile)
 	if (vcodec_profile_idx < SUPPORT_VDEC_NUM) {
 		vcodec_profile[vcodec_profile_idx] = vdec_profile;
 		vcodec_profile_idx++;
-		pr_info("regist %s codec profile\n", vdec_profile->name);
+		pr_debug("regist %s codec profile\n", vdec_profile->name);
 
 	}
 
diff --git a/drivers/amlogic/amports/amvdec.c b/drivers/amlogic/amports/amvdec.c
index bed81fb..8ec2ce7 100644
--- a/drivers/amlogic/amports/amvdec.c
+++ b/drivers/amlogic/amports/amvdec.c
@@ -260,11 +260,11 @@ static s32 am_loadmc_ex(enum vformat_e type,
 	}
 	err = (*load)((u32 *) pmc_addr);
 	if (err < 0) {
-		pr_info("loading firmware %s to vdec ram  failed!\n", name);
+		pr_err("loading firmware %s to vdec ram  failed!\n", name);
 		return err;
 	}
 	vfree(mc_addr);
-	pr_info("loading firmware %s to vdec ram  ok!\n", name);
+	pr_debug("loading firmware %s to vdec ram  ok!\n", name);
 	return err;
 }
 
diff --git a/drivers/amlogic/amports/amvideocap.c b/drivers/amlogic/amports/amvideocap.c
index e2d0abc..564b347 100644
--- a/drivers/amlogic/amports/amvideocap.c
+++ b/drivers/amlogic/amports/amvideocap.c
@@ -40,11 +40,14 @@
 #include <linux/amlogic/canvas/canvas_mgr.h>
 #include <linux/amlogic/ge2d/ge2d.h>
 #include <linux/delay.h>
+#include <linux/time.h>
 
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/dma-mapping.h>
 
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
 #include "amports_priv.h"
 #include "amvideocap_priv.h"
 /*
@@ -86,11 +89,18 @@ struct amvideocap_global_data {
 	u64 wait_max_ms;
 };
 static struct amvideocap_global_data amvideocap_gdata;
+static struct ge2d_context_s *ge2d_amvideocap_context;
 static inline struct amvideocap_global_data *getgctrl(void)
 {
 	return &amvideocap_gdata;
 }
 
+static int use_cma;
+#ifdef CONFIG_CMA
+static struct platform_device *amvideocap_pdev;
+static int cma_max_size;
+#define CMA_NAME "amvideocap"
+#endif
 #define gLOCK() mutex_lock(&(getgctrl()->lock))
 #define gUNLOCK() mutex_unlock(&(getgctrl()->lock))
 #define gLOCKINIT() mutex_init(&(getgctrl()->lock))
@@ -101,26 +111,36 @@ static inline struct amvideocap_global_data *getgctrl(void)
 static int amvideocap_open(struct inode *inode, struct file *file)
 {
 	struct amvideocap_private *priv;
-	dma_addr_t dma_handle;
 	gLOCK();
-	getgctrl()->size = BUF_SIZE_MAX;
-	getgctrl()->vaddr =
-		(unsigned long)dma_alloc_coherent(amports_get_dma_device(),
-						  getgctrl()->size, &dma_handle,
-						  GFP_KERNEL);
-	if (!getgctrl()->vaddr) {
-		gUNLOCK();
-		pr_err("%s: failed to remap y addr\n", __func__);
-		return -ENOMEM;
+#ifdef CONFIG_CMA
+	if (use_cma && amvideocap_pdev) {
+		unsigned long phybufaddr;
+		phybufaddr = codec_mm_alloc_for_dma(CMA_NAME,
+				cma_max_size * SZ_1M / PAGE_SIZE,
+				4 + PAGE_SHIFT, CODEC_MM_FLAGS_CPU);
+		/* pr_err("%s: codec_mm_alloc_for_dma:%p\n",
+				__func__, (void *)phybufaddr);
+		*/
+		amvideocap_register_memory((unsigned char *)phybufaddr,
+					cma_max_size * SZ_1M);
 	}
-	getgctrl()->phyaddr = (unsigned long)(dma_handle);
-
+#endif
 	if (!getgctrl()->phyaddr) {
 		gUNLOCK();
 		pr_err("Error,no memory have register for amvideocap\n");
 		return -ENOMEM;
 	}
-
+#ifdef CONFIG_CMA
+	if (!getgctrl()->vaddr) {
+		getgctrl()->vaddr = (unsigned long)codec_mm_phys_to_virt(
+						getgctrl()->phyaddr);
+		if (!getgctrl()->vaddr) {
+			pr_err("%s: failed to remap y addr\n", __func__);
+			gUNLOCK();
+			return -ENOMEM;
+		}
+	}
+#endif
 	if (getgctrl()->opened_cnt > AMCAP_MAX_OPEND) {
 		gUNLOCK();
 		pr_err("Too Many opend video cap files\n");
@@ -150,12 +170,15 @@ static int amvideocap_release(struct inode *inode, struct file *file)
 {
 	struct amvideocap_private *priv = file->private_data;
 	kfree(priv);
-	if (getgctrl()->vaddr != 0) {
-		dma_free_coherent(amports_get_dma_device(),
-				  getgctrl()->size, (void *)getgctrl()->vaddr,
-				  (dma_addr_t) getgctrl()->phyaddr);
-		getgctrl()->vaddr = 0;
+#ifdef CONFIG_CMA
+	if (use_cma && amvideocap_pdev) {
+		codec_mm_free_for_dma(CMA_NAME, getgctrl()->phyaddr);
+		/*
+		   pr_err("%s: codec_mm_free_for_dma:%p\n", __func__,
+		   (void *)getgctrl()->phyaddr);
+		 */
 	}
+#endif
 	gLOCK();
 	getgctrl()->opened_cnt--;
 
@@ -225,9 +248,38 @@ static ssize_t amvideocap_YUV_to_RGB(
 	u32 cur_index, int w, int h,
 	struct vframe_s *vf, int outfmt)
 {
-
 	struct config_para_ex_s ge2d_config;
 	struct canvas_s cs0, cs1, cs2, cd;
+
+	void __iomem *psrc;
+	void __iomem *pdst;
+	int temp_cma_buf_size = 0;
+	unsigned long phybufaddr_8bit = 0;
+	struct timeval start, end;
+	unsigned long time_use;
+	int ret = 0;
+	struct canvas_s temp_cs0, temp_cs1, temp_cs2;
+	int temp_canvas_idx = -1;
+	int temp_y_index = -1;
+	int temp_u_index = -1;
+	int temp_v_index = -1;
+	unsigned char buf1[16];
+	unsigned char buf2[16];
+	unsigned char buf3[16];
+	unsigned char buf_in[48];
+	unsigned char buf_out[32];
+	unsigned char tmp_buf[8];
+	unsigned char in_cursor;
+	unsigned char out_cursor;
+	unsigned long read_size = 0;
+	unsigned int i;
+	unsigned char *line_start;
+	unsigned long counter = 0;
+	unsigned int w_align;
+	unsigned int h_align;
+	unsigned char tmp_char1;
+	int height_after_di;
+
 	const char *amvideocap_owner = "amvideocapframe";
 	int canvas_idx = canvas_pool_map_alloc_canvas(amvideocap_owner);
 	int y_index = cur_index & 0xff;
@@ -235,10 +287,21 @@ static ssize_t amvideocap_YUV_to_RGB(
 	int v_index = (cur_index >> 16) & 0xff;
 	int input_x, input_y, input_width, input_height, intfmt;
 	unsigned long RGB_addr;
-	struct ge2d_context_s *context = create_ge2d_work_queue();
 	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
 	intfmt = amvideocap_get_input_format(vf);
 
+	if (((vf->bitdepth & BITDEPTH_Y10)) &&
+		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		temp_canvas_idx =
+			canvas_pool_map_alloc_canvas(amvideocap_owner);
+		if (temp_canvas_idx < 0) {
+			pr_err("alloc temp_canvas_idx failed");
+			return -1;
+		}
+		temp_y_index = temp_canvas_idx & 0xff;
+		temp_u_index = (temp_canvas_idx >> 8) & 0xff;
+		temp_v_index = (temp_canvas_idx >> 16) & 0xff;
+	}
 	/* /unsigned long RGB_phy_addr=getgctrl()->phyaddr; */
 
 	if (!priv->phyaddr) {
@@ -287,9 +350,39 @@ static ssize_t amvideocap_YUV_to_RGB(
 	} else
 		input_height = priv->src_rect.height;
 
-	if (intfmt == GE2D_FORMAT_S16_YUV422)
-		input_height = input_height / 2;
-
+	height_after_di = vf->height;
+	if (((vf->bitdepth & BITDEPTH_Y10)) &&
+		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		pr_info("input_height = %d , vf->type_original = %x\n" ,
+			input_height, vf->type_original);
+		if ((vf->source_type == VFRAME_SOURCE_TYPE_HDMI) ||
+			(vf->source_type == VFRAME_SOURCE_TYPE_CVBS) ||
+			(vf->source_type == VFRAME_SOURCE_TYPE_TUNER)) {
+			if (vf->type_original & VIDTYPE_INTERLACE) {
+				height_after_di = vf->height >> 1;
+				input_height >>= 1;
+			} else {
+				height_after_di = vf->height;
+			}
+		} else {
+			/*local playback and DTV*/
+			pr_info("vf->prog_proc_config = %d",
+				vf->prog_proc_config);
+			if ((!vf->prog_proc_config) &&
+				(!(vf->type_original & VIDTYPE_INTERLACE))) {
+				height_after_di = vf->height;
+			} else {
+				height_after_di = vf->height >> 1;
+				input_height >>= 1;
+			}
+		}
+	} else if (is_meson_g9tv_cpu() || is_meson_gxtvbb_cpu()) {
+		if (vf->type_original & VIDTYPE_INTERLACE)
+			input_height = input_height / 2;
+	} else {
+		if (intfmt == GE2D_FORMAT_S16_YUV422)
+			input_height = input_height / 2;
+	}
 	ge2d_config.alu_const_color = 0;
 	ge2d_config.bitmask_en = 0;
 	ge2d_config.src1_gb_alpha = 0;
@@ -298,26 +391,153 @@ static ssize_t amvideocap_YUV_to_RGB(
 	canvas_read(y_index, &cs0);
 	canvas_read(u_index, &cs1);
 	canvas_read(v_index, &cs2);
+
+	if (((vf->bitdepth & BITDEPTH_Y10)) &&
+		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		pr_info("vf->width = %d , vf->height = %d , vf->bitdepth = %d\n",
+		vf->width, vf->height, vf->bitdepth);
+		do_gettimeofday(&start);
+		psrc = phys_to_virt(cs0.addr);
+		w_align = ((vf->width + 32 - 1) & ~(32 - 1));
+		h_align = ((vf->height + 32 - 1) & ~(32 - 1));
+		temp_cma_buf_size =
+		(int)((w_align * h_align * 2)/(1024 * 1024)) + 1;
+		pr_info("phybufaddr_8bit buffer size = %d\n",
+			temp_cma_buf_size);
+		phybufaddr_8bit = codec_mm_alloc_for_dma(CMA_NAME,
+			temp_cma_buf_size * SZ_1M / PAGE_SIZE,
+			4 + PAGE_SHIFT, CODEC_MM_FLAGS_CPU);
+		if (!phybufaddr_8bit)
+			pr_err("failed to alloc phybufaddr_8bit\n");
+
+		canvas_config(temp_canvas_idx, phybufaddr_8bit,
+			w_align * 2, h_align,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		canvas_read(temp_y_index, &temp_cs0);
+		canvas_read(temp_u_index, &temp_cs1);
+		canvas_read(temp_v_index, &temp_cs2);
+
+		pdst = phys_to_virt(temp_cs0.addr);
+
+		pr_info("height_after_di = %d" , height_after_di);
+		line_start = psrc;
+		for (i = 0; i < height_after_di; i++) {
+			for (read_size = 0; read_size < w_align*3;
+				read_size += 48) {
+				/* swap 64bit */
+				memcpy(buf1, line_start+read_size, 16);
+				memcpy(tmp_buf,	buf1,		8);
+				memcpy(buf1,	buf1+8,		8);
+				memcpy(buf1+8,  tmp_buf,	8);
+				memcpy(buf_in+32, buf1, 16);
+
+				memcpy(buf2, line_start+read_size+16, 16);
+				memcpy(tmp_buf,	buf2,		8);
+				memcpy(buf2,	buf2+8,		8);
+				memcpy(buf2+8,  tmp_buf,	8);
+				memcpy(buf_in+16, buf2, 16);
+
+				memcpy(buf3, line_start+read_size+32, 16);
+				memcpy(tmp_buf,	buf3,		8);
+				memcpy(buf3,	buf3+8,		8);
+				memcpy(buf3+8,  tmp_buf,	8);
+				memcpy(buf_in, buf3, 16);
+
+				in_cursor = 47;
+				out_cursor = 0;
+
+				for (out_cursor = 0; out_cursor <= 30;
+					out_cursor += 2, in_cursor -= 3) {
+					buf_out[out_cursor] =
+					(buf_in[in_cursor-1] << 4) |
+					(buf_in[in_cursor-2] >> 4);
+					buf_out[out_cursor+1] =
+						buf_in[in_cursor];
+				}
+				for (out_cursor = 0; out_cursor <= 24;
+					out_cursor += 8) {
+					/* y1 y4 */
+					tmp_char1 = buf_out[1+out_cursor];
+					buf_out[1+out_cursor] =
+						buf_out[7+out_cursor];
+					buf_out[7+out_cursor] = tmp_char1;
+
+					/* y2 y3 */
+					tmp_char1 = buf_out[3+out_cursor];
+					buf_out[3+out_cursor] =
+						buf_out[5+out_cursor];
+					buf_out[5+out_cursor] = tmp_char1;
+
+					/* u1 u2 */
+					tmp_char1 = buf_out[out_cursor];
+					buf_out[out_cursor] =
+						buf_out[2+out_cursor];
+					buf_out[2+out_cursor] = tmp_char1;
+
+					/* v1 v2 */
+					tmp_char1 = buf_out[4+out_cursor];
+					buf_out[4+out_cursor] =
+						buf_out[6+out_cursor];
+					buf_out[6+out_cursor] = tmp_char1;
+				}
+
+				memcpy(pdst+counter*32, buf_out, 32);
+				counter += 1;
+			}
+			line_start += cs0.width;
+		}
+
+		codec_mm_dma_flush(pdst,
+			temp_cma_buf_size * SZ_1M, DMA_TO_DEVICE);
+
+		counter = 0;
+		do_gettimeofday(&end);
+		time_use = (end.tv_sec - start.tv_sec) * 1000 +
+		(end.tv_usec - start.tv_usec) / 1000;
+		pr_info("10to8 conversion cost time: %ldms\n", time_use);
+	}
+
 	pr_info("y_index=[0x%x]  u_index=[0x%x] cur_index:%x\n", y_index,
 			u_index, cur_index);
-	ge2d_config.src_planes[0].addr = cs0.addr;
-	ge2d_config.src_planes[0].w = cs0.width;
-	ge2d_config.src_planes[0].h = cs0.height;
-	ge2d_config.src_planes[1].addr = cs1.addr;
-	ge2d_config.src_planes[1].w = cs1.width;
-	ge2d_config.src_planes[1].h = cs1.height;
-	ge2d_config.src_planes[2].addr = cs2.addr;
-	ge2d_config.src_planes[2].w = cs2.width;
-	ge2d_config.src_planes[2].h = cs2.height;
-	pr_info("w=%d-height=%d cur_index:%x\n", cs0.width, cs0.height,
-			cur_index);
+
+	if (((vf->bitdepth & BITDEPTH_Y10)) &&
+		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		ge2d_config.src_planes[0].addr = temp_cs0.addr;
+		ge2d_config.src_planes[0].w = temp_cs0.width;
+		ge2d_config.src_planes[0].h = temp_cs0.height;
+		ge2d_config.src_planes[1].addr = temp_cs1.addr;
+		ge2d_config.src_planes[1].w = temp_cs1.width;
+		ge2d_config.src_planes[1].h = temp_cs1.height;
+		ge2d_config.src_planes[2].addr = temp_cs2.addr;
+		ge2d_config.src_planes[2].w = temp_cs2.width;
+		ge2d_config.src_planes[2].h = temp_cs2.height;
+		pr_info("w=%d-height=%d\n", temp_cs0.width, temp_cs0.height);
+		pr_info("cs0.width=%d, cs0.height=%d\n", cs0.width, cs0.height);
+	} else {
+		ge2d_config.src_planes[0].addr = cs0.addr;
+		ge2d_config.src_planes[0].w = cs0.width;
+		ge2d_config.src_planes[0].h = cs0.height;
+		ge2d_config.src_planes[1].addr = cs1.addr;
+		ge2d_config.src_planes[1].w = cs1.width;
+		ge2d_config.src_planes[1].h = cs1.height;
+		ge2d_config.src_planes[2].addr = cs2.addr;
+		ge2d_config.src_planes[2].w = cs2.width;
+		ge2d_config.src_planes[2].h = cs2.height;
+		pr_info("w=%d-height=%d cur_index:%x\n",
+			cs0.width, cs0.height, cur_index);
+	}
 
 	ge2d_config.src_key.key_enable = 0;
 	ge2d_config.src_key.key_mask = 0;
 	ge2d_config.src_key.key_mode = 0;
 	ge2d_config.src_key.key_color = 0;
 
-	ge2d_config.src_para.canvas_index = cur_index;
+	if (((vf->bitdepth & BITDEPTH_Y10)) &&
+		(intfmt == GE2D_FORMAT_S16_YUV422))
+		ge2d_config.src_para.canvas_index = temp_canvas_idx;
+	else
+		ge2d_config.src_para.canvas_index = cur_index;
+
 	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
 	ge2d_config.src_para.format = intfmt;
 	ge2d_config.src_para.fill_color_en = 0;
@@ -350,12 +570,12 @@ static ssize_t amvideocap_YUV_to_RGB(
 	ge2d_config.dst_para.width = w;
 	ge2d_config.dst_para.height = h;
 
-	if (ge2d_context_config_ex(context, &ge2d_config) < 0) {
+	if (ge2d_context_config_ex(ge2d_amvideocap_context, &ge2d_config) < 0) {
 		pr_err("++ge2d configing error.\n");
 		return -1;
 	}
 
-	stretchblt_noalpha(context,
+	stretchblt_noalpha(ge2d_amvideocap_context,
 					   0,
 					   0,
 					   ge2d_config.src_para.width,
@@ -364,12 +584,20 @@ static ssize_t amvideocap_YUV_to_RGB(
 					   0,
 					   ge2d_config.dst_para.width,
 					   ge2d_config.dst_para.height);
-	if (context) {
-		destroy_ge2d_work_queue(context);
-		context = NULL;
-	}
 	if (canvas_idx)
 		canvas_pool_map_free_canvas(canvas_idx);
+
+	if (((vf->bitdepth & BITDEPTH_Y10)) &&
+		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		if (phybufaddr_8bit) {
+			ret = codec_mm_free_for_dma(CMA_NAME, phybufaddr_8bit);
+			if (ret != 0)
+				pr_err("phybufaddr_8bit cma buffer free failed .\n");
+		}
+	if (temp_canvas_idx)
+		canvas_pool_map_free_canvas(temp_canvas_idx);
+	}
+
 	return 0;
 	/* vfs_write(video_rgb_filp,RGB_addr,size, &video_yuv_pos); */
 }
@@ -695,6 +923,11 @@ static ssize_t amvideocap_read(struct file *file, char __user *buf,
 			pr_info
 			(" priv->outfmt_byteppix=%d, size=%d\n",
 			 priv->out.byte_per_pix, size);
+#ifdef CONFIG_CMA
+			codec_mm_dma_flush(priv->vaddr,
+					cma_max_size * SZ_1M, DMA_FROM_DEVICE);
+#endif
+
 			copied = copy_to_user(buf, priv->vaddr, size);
 			if (copied) {
 				pr_err
@@ -823,7 +1056,7 @@ s32 amvideocap_register_memory(unsigned char *phybufaddr,
 	return 0;
 }
 
-s32 amvideocap_dev_register(void)
+s32 amvideocap_dev_register(unsigned char *phybufaddr, int phybufsize)
 {
 	s32 r = 0;
 	pr_info("amvideocap_dev_register\n");
@@ -849,7 +1082,10 @@ s32 amvideocap_dev_register(void)
 		r = -EEXIST;
 		goto err2;
 	}
-
+	if (phybufaddr != NULL) {
+		getgctrl()->phyaddr = (unsigned long)phybufaddr;
+		getgctrl()->size = (unsigned long)phybufsize;
+	}
 	getgctrl()->wait_max_ms = 0;
 	getgctrl()->want.fmt = GE2D_FORMAT_S24_RGB;
 	getgctrl()->want.width = 0;
@@ -880,10 +1116,39 @@ s32 amvideocap_dev_unregister(void)
  *
  * ******************************************************************/
 
+static struct resource memobj;
 /* for driver. */
 static int amvideocap_probe(struct platform_device *pdev)
 {
-	amvideocap_dev_register();
+	unsigned int buf_size;
+	struct resource *mem;
+
+#ifdef CONFIG_CMA
+	char buf[32];
+	u32 value;
+	int ret;
+#endif
+
+	pr_err("amvideocap_probe,%s\n", pdev->dev.of_node->name);
+
+#ifdef CONFIG_CMA
+	snprintf(buf, sizeof(buf), "max_size");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if (ret < 0) {
+		pr_err("cma size undefined.\n");
+		use_cma = 0;
+	} else {
+		pr_err("use cma buf.\n");
+		mem = &memobj;
+		mem->start = 0;
+		buf_size = 0;
+		cma_max_size = value;
+		amvideocap_pdev = pdev;
+		use_cma = 1;
+	}
+#endif
+
+	amvideocap_dev_register((unsigned char *)mem->start, buf_size);
 	return 0;
 }
 
@@ -918,6 +1183,8 @@ static int __init amvideocap_init_module(void)
 {
 
 	pr_info("amvideocap_init_module\n");
+	if (ge2d_amvideocap_context == NULL)
+		ge2d_amvideocap_context = create_ge2d_work_queue();
 	if ((platform_driver_register(&amvideocap_drv))) {
 		pr_err("failed to register amstream module\n");
 		return -ENODEV;
@@ -929,6 +1196,10 @@ static int __init amvideocap_init_module(void)
 static void __exit amvideocap_remove_module(void)
 {
 	platform_driver_unregister(&amvideocap_drv);
+	if (ge2d_amvideocap_context) {
+		destroy_ge2d_work_queue(ge2d_amvideocap_context);
+		ge2d_amvideocap_context = NULL;
+	}
 	pr_info("amvideocap module removed.\n");
 }
 
diff --git a/drivers/amlogic/amports/arch/clk.c b/drivers/amlogic/amports/arch/clk.c
index 1b9ad2e..c1ca77d 100644
--- a/drivers/amlogic/amports/arch/clk.c
+++ b/drivers/amlogic/amports/arch/clk.c
@@ -49,7 +49,7 @@ static int clock_source_wxhxfps_saved[VDEC_MAX + 1];
 
 #define IF_HAVE_RUN_P1_RET(p, fn, p1)\
 			do {\
-				pr_info("%s-----%d\n", __func__, clk);\
+				pr_debug("%s-----%d\n", __func__, clk);\
 				if (p && p->fn)\
 					return p->fn(p1);\
 				else\
@@ -218,7 +218,10 @@ int vdec_source_changed_for_clk_set(int format, int width, int height, int fps)
 	if (clk < 0) {
 		pr_info("can't get valid clk for source ,%d,%d,%d\n",
 			width, height, fps);
-		return -1;
+		if (format >= 1920 && width >= 1080 && fps >= 30)
+			clk = 2;/*default high clk*/
+		else
+			clk = 0;/*default clk.*/
 	}
 	if (width * height * fps == 0)
 		clk = 0;
@@ -229,7 +232,7 @@ int vdec_source_changed_for_clk_set(int format, int width, int height, int fps)
 		changed to default  min clk.
 	*/
 
-	if (format == VFORMAT_HEVC) {
+	if (format == VFORMAT_HEVC || format == VFORMAT_VP9) {
 		ret_clk = hevc_clock_set(clk);
 		clock_source_wxhxfps_saved[VDEC_HEVC] = width * height * fps;
 	} else if (format == VFORMAT_H264_ENC && format == VFORMAT_JPEG_ENC) {
@@ -237,8 +240,10 @@ int vdec_source_changed_for_clk_set(int format, int width, int height, int fps)
 		clock_source_wxhxfps_saved[VDEC_HCODEC] = width * height * fps;
 	} else if (format == VFORMAT_H264_4K2K &&
 			get_cpu_type() == MESON_CPU_MAJOR_ID_M8) {
-		ret_clk = hcodec_clock_set(clk);
-		clock_source_wxhxfps_saved[VDEC_HCODEC] = width * height * fps;
+		ret_clk = vdec2_clock_set(clk);
+		clock_source_wxhxfps_saved[VDEC_2] = width * height * fps;
+		ret_clk = vdec_clock_set(clk);
+		clock_source_wxhxfps_saved[VDEC_1] = width * height * fps;
 	} else{
 		ret_clk = vdec_clock_set(clk);
 		clock_source_wxhxfps_saved[VDEC_1] = width * height * fps;
diff --git a/drivers/amlogic/amports/arch/register_map.c b/drivers/amlogic/amports/arch/register_map.c
index 220ff62..8eb2c1d 100644
--- a/drivers/amlogic/amports/arch/register_map.c
+++ b/drivers/amlogic/amports/arch/register_map.c
@@ -162,6 +162,10 @@ void codecio_write_aobus(unsigned int reg, unsigned int val)
 int codecio_read_vcbus(unsigned int reg)
 {
 	int ret, val;
+	if ((reg >= 0x1900) && (reg < 0x1a00)) {
+		pr_err("read vcbus reg %x error!\n", reg);
+		return 0;
+	}
 	ret = codecio_reg_read(CODECIO_VCBUS_BASE, reg<<2, &val);
 	if (ret) {
 		pr_err("read vcbus reg %x error %d\n", reg, ret);
@@ -173,6 +177,10 @@ int codecio_read_vcbus(unsigned int reg)
 void codecio_write_vcbus(unsigned int reg, unsigned int val)
 {
 	int ret;
+	if ((reg >= 0x1900) && (reg < 0x1a00)) {
+		pr_err("write vcbus reg %x error!\n", reg);
+		return;
+	}
 	ret = codecio_reg_write(CODECIO_VCBUS_BASE, reg<<2, val);
 	if (ret) {
 		pr_err("write vcbus reg %x error %d\n", reg, ret);
@@ -232,13 +240,13 @@ static int codec_io_probe(struct platform_device *pdev)
 			if (res.start != 0) {
 				codecio_reg_map[i] =
 					ioremap(res.start, resource_size(&res));
-				pr_info("codec map io source 0x%p,size=%d to 0x%p\n",
+				pr_debug("codec map io source 0x%p,size=%d to 0x%p\n",
 					(void *)res.start,
 					(int)resource_size(&res),
 					codecio_reg_map[i]);
 			} else{
 				codecio_reg_map[i] = 0;
-				pr_info("ignore io source start %p,size=%d\n",
+				pr_debug("ignore io source start %p,size=%d\n",
 				(void *)res.start, (int)resource_size(&res));
 			}
 			i++;
diff --git a/drivers/amlogic/amports/arch/register_ops.c b/drivers/amlogic/amports/arch/register_ops.c
index 424d6da..22ed813 100644
--- a/drivers/amlogic/amports/arch/register_ops.c
+++ b/drivers/amlogic/amports/arch/register_ops.c
@@ -94,7 +94,7 @@ static int register_reg_onebus_ops(struct chip_register_ops *ops)
 {
 	if (ops->bus_type >= BUS_MAX)
 		return -1;
-	pr_info("register amports ops for bus[%d]\n", ops->bus_type);
+	pr_debug("register amports ops for bus[%d]\n", ops->bus_type);
 	if (amports_ops[ops->bus_type] != NULL)
 		;
 	/*TODO.
@@ -110,7 +110,7 @@ int register_reg_ops_per_cpu(int cputype,
 	int i;
 
 	if (cputype != get_cpu_type()) {
-		pr_info("ignore bus ops for cpu=%d\n",
+		pr_debug("ignore bus ops for cpu=%d\n",
 			cputype);
 		return 0;	/* ignore don't needed firmare. */
 	}
@@ -133,4 +133,14 @@ int register_reg_ops_mgr(int cputype[],
 	}
 	return 0;
 }
+int register_reg_ex_ops_mgr(int cputype[],
+	struct chip_register_ops *ex_ops_list, int ops_size)
+{
+	int i = 0;
+	while (cputype[i] > 0) {
+		register_reg_ops_per_cpu(cputype[i], ex_ops_list, ops_size);
+		i++;
+	}
+	return 0;
+}
 
diff --git a/drivers/amlogic/amports/arch/register_ops.h b/drivers/amlogic/amports/arch/register_ops.h
index 30229ae..a212afc 100644
--- a/drivers/amlogic/amports/arch/register_ops.h
+++ b/drivers/amlogic/amports/arch/register_ops.h
@@ -63,7 +63,8 @@ int register_reg_ops_per_cpu(int cputype, struct chip_register_ops *sops,
 
 int register_reg_ops_mgr(int cputype[], struct chip_register_ops *sops_list,
 						 int ops_size);
-
+int register_reg_ex_ops_mgr(int cputype[],
+		 struct chip_register_ops *ex_ops_list, int ops_size);
 #define DEF_BUS_OPS(BUS_TYPE, name)\
 static inline void codec_##name##bus_write(unsigned int reg, u32 val)\
 {\
diff --git a/drivers/amlogic/amports/arch/register_ops_m8.c b/drivers/amlogic/amports/arch/register_ops_m8.c
index 61434a5..e37cb0d 100644
--- a/drivers/amlogic/amports/arch/register_ops_m8.c
+++ b/drivers/amlogic/amports/arch/register_ops_m8.c
@@ -22,9 +22,19 @@
 #define REGISTER_FOR_CPU {\
 			MESON_CPU_MAJOR_ID_M8,\
 			MESON_CPU_MAJOR_ID_M8M2,\
-			MESON_CPU_MAJOR_ID_GXBB, \
+	MESON_CPU_MAJOR_ID_GXBB, \
+	MESON_CPU_MAJOR_ID_GXTVBB, \
+	MESON_CPU_MAJOR_ID_GXL, \
+	MESON_CPU_MAJOR_ID_GXM, \
+	MESON_CPU_MAJOR_ID_TXL, \
+			0}
+#define REGISTER_FOR_GXCPU {\
+	MESON_CPU_MAJOR_ID_GXBB, \
+	MESON_CPU_MAJOR_ID_GXTVBB, \
+	MESON_CPU_MAJOR_ID_GXL, \
+	MESON_CPU_MAJOR_ID_GXM, \
+	MESON_CPU_MAJOR_ID_TXL, \
 			0}
-
 int codec_apb_read(unsigned int reg)
 {
 	unsigned int val = 0;
@@ -64,12 +74,12 @@ static struct chip_register_ops ex_gx_ops[] __initdata = {
 static int __init vdec_reg_ops_init(void)
 {
 	int cpus[] = REGISTER_FOR_CPU;
+	int gxcpus[] = REGISTER_FOR_GXCPU;
 	register_reg_ops_mgr(cpus, m8_ops,
 		sizeof(m8_ops) / sizeof(struct chip_register_ops));
 
-	register_reg_ops_per_cpu(MESON_CPU_MAJOR_ID_GXBB,
-		ex_gx_ops, sizeof(ex_gx_ops) /
-		sizeof(struct chip_register_ops));
+	register_reg_ex_ops_mgr(gxcpus, ex_gx_ops,
+		sizeof(ex_gx_ops) / sizeof(struct chip_register_ops));
 
 	return 0;
 }
diff --git a/drivers/amlogic/amports/arch/regs/di_regs.h b/drivers/amlogic/amports/arch/regs/di_regs.h
index 85878b2..c3e95bc 100644
--- a/drivers/amlogic/amports/arch/regs/di_regs.h
+++ b/drivers/amlogic/amports/arch/regs/di_regs.h
@@ -275,6 +275,9 @@
 #define DI_CHAN2_FMT_CTRL 0x17b8
 #define DI_CHAN2_FMT_W 0x17b9
 
+#define VD1_IF0_GEN_REG3 0x1aa7
+#define DI_IF1_GEN_REG3  0x20a7
+#define DI_IF2_GEN_REG3  0x2022
 #endif
 
 
diff --git a/drivers/amlogic/amports/arch/regs/dos_regs.h b/drivers/amlogic/amports/arch/regs/dos_regs.h
index 41c297d..21f395b 100644
--- a/drivers/amlogic/amports/arch/regs/dos_regs.h
+++ b/drivers/amlogic/amports/arch/regs/dos_regs.h
@@ -38,8 +38,23 @@
 #define MC_OM_MB_XY 0x090f
 #define PSCALE_RST 0x0910
 #define PSCALE_CTRL 0x0911
+#define PSCALE_PICI_W 0x912
+#define PSCALE_PICI_H 0x913
+#define PSCALE_PICO_W 0x914
+#define PSCALE_PICO_H 0x915
 #define PSCALE_BMEM_ADDR 0x091f
 #define PSCALE_BMEM_DAT 0x0920
+
+#define PSCALE_RBUF_START_BLKX 0x925
+#define PSCALE_RBUF_START_BLKY 0x926
+#define PSCALE_PICO_SHIFT_XY 0x928
+#define PSCALE_CTRL1 0x929
+#define PSCALE_SRCKEY_CTRL0 0x92a
+#define PSCALE_SRCKEY_CTRL1 0x92b
+#define PSCALE_CANVAS_RD_ADDR 0x92c
+#define PSCALE_CANVAS_WR_ADDR 0x92d
+
+
 /**/
 #define MC_MPORT_CTRL 0x0940
 #define MC_MPORT_DAT 0x0941
@@ -315,6 +330,11 @@
 #define DOS_HEVC_INT_EN 0x3f36
 /**/
 
+#define DOS_SW_RESET4 0x3f37
+#define DOS_GCLK_EN4 0x3f38
+#define DOS_MEM_PD_WAVE420L 0x3f39
+#define DOS_WAVE420L_CNTL_STAT 0x3f3a
+
 /**/
 #define DOS_VDEC_MCRCC_STALL_CTRL 0x3f40
 #define DOS_VDEC_MCRCC_STALL2_CTRL 0x3f42
diff --git a/drivers/amlogic/amports/arch/regs/hcodec_regs.h b/drivers/amlogic/amports/arch/regs/hcodec_regs.h
index 7d74c84..6fd0853 100644
--- a/drivers/amlogic/amports/arch/regs/hcodec_regs.h
+++ b/drivers/amlogic/amports/arch/regs/hcodec_regs.h
@@ -682,5 +682,31 @@
 #define HCODEC_ADV_MV_CTL1 0x1f6a
 #define HCODEC_ADV_MV_CTL2 0x1f6b
 
+/* add from GXTVBB */
+#define HCODEC_V3_SKIP_CONTROL 0x1f6c
+#define HCODEC_V3_TOP_LEFT_CTL 0x1f6d
+#define HCODEC_V3_TOP_MV 0x1f6e
+#define HCODEC_V3_LEFT_MV 0x1f6f
+#define HCODEC_V3_SKIP_WEIGHT 0x1f70
+#define HCODEC_V3_L1_SKIP_MAX_SAD 0x1f71
+#define HCODEC_V3_L2_SKIP_WEIGHT 0x1f72
+#define HCODEC_V3_MV_SAD_TABLE 0x1f73
+#define HCODEC_V3_F_ZERO_CTL_0 0x1f74
+#define HCODEC_V3_F_ZERO_CTL_1 0x1f75
+#define HCODEC_V3_TOP_INTRA_INFO 0x1f76
+#define HCODEC_V3_LEFT_INTRA_INFO 0x1f77
+#define HCODEC_V3_IPRED_TYPE_WEIGHT_0 0x1f78
+#define HCODEC_V3_IPRED_TYPE_WEIGHT_1 0x1f79
+#define HCODEC_V3_LEFT_SMALL_MAX_SAD 0x1f7a
+
+/* add from GXL */
+#define HCODEC_V4_FORCE_SKIP_CFG 0x1f7b
+
+/* add from TXL */
+#define HCODEC_V5_MB_DIFF_SUM 0x1f7c
+#define HCODEC_V5_SMALL_DIFF_CNT 0x1f7d
+#define HCODEC_V5_SIMPLE_MB_CTL 0x1f7e
+#define HCODEC_V5_SIMPLE_MB_DQUANT 0x1f7f
+#define HCODEC_V5_SIMPLE_MB_ME_WEIGHT 0x1f80
 #endif
 
diff --git a/drivers/amlogic/amports/arch/regs/hhi_regs.h b/drivers/amlogic/amports/arch/regs/hhi_regs.h
index 05e614e..b565549 100644
--- a/drivers/amlogic/amports/arch/regs/hhi_regs.h
+++ b/drivers/amlogic/amports/arch/regs/hhi_regs.h
@@ -52,5 +52,8 @@
 #define HHI_VDEC3_CLK_CNTL 0x107a
 #define HHI_VDEC4_CLK_CNTL 0x107b
 
+/* add from GXM */
+#define HHI_WAVE420L_CLK_CNTL 0x109a
+
 #endif
 
diff --git a/drivers/amlogic/amports/arch/regs/viu_regs.h b/drivers/amlogic/amports/arch/regs/viu_regs.h
index 0299ca6..214c728 100644
--- a/drivers/amlogic/amports/arch/regs/viu_regs.h
+++ b/drivers/amlogic/amports/arch/regs/viu_regs.h
@@ -24,6 +24,7 @@
 #define VIU_ADDR_END 0x1aff
 #define VIU_SW_RESET 0x1a01
 #define VIU_MISC_CTRL0 0x1a06
+#define VIU_MISC_CTRL1 0x1a07
 #define D2D3_INTF_LENGTH 0x1a08
 #define D2D3_INTF_CTRL0 0x1a09
 #define VIU_OSD1_CTRL_STAT 0x1a10
@@ -146,6 +147,7 @@
 #define VD2_IF0_PROT_CNTL 0x1a8e
 #define VIU_VD2_FMT_CTRL 0x1a88
 #define VIU_VD2_FMT_W 0x1a89
+#if 0
 #define LDIM_STTS_GCLK_CTRL0 0x1a90
 #define LDIM_STTS_CTRL0 0x1a91
 #define LDIM_STTS_WIDTHM1_HEIGHTM1 0x1a92
@@ -164,6 +166,7 @@
 #define LDIM_STTS_HIST_REGION_IDX 0x1aa0
 #define LDIM_STTS_HIST_SET_REGION 0x1aa1
 #define LDIM_STTS_HIST_READ_REGION 0x1aa2
+#endif
 #define AFBC_ENABLE 0x1ae0
 #define AFBC_MODE 0x1ae1
 #define AFBC_SIZE_IN 0x1ae2
@@ -172,7 +175,7 @@
 #define AFBC_LBUF_DEPTH 0x1ae5
 #define AFBC_HEAD_BADDR 0x1ae6
 #define AFBC_BODY_BADDR 0x1ae7
-#define AFBC_OUT_XSCOPE 0x1ae8
+#define AFBC_SIZE_OUT     0x1ae8
 #define AFBC_OUT_YSCOPE 0x1ae9
 #define AFBC_STAT 0x1aea
 #define AFBC_VD_CFMT_CTRL 0x1aeb
@@ -182,6 +185,24 @@
 #define AFBC_PIXEL_HOR_SCOPE 0x1aef
 #define AFBC_PIXEL_VER_SCOPE 0x1af0
 #define AFBC_VD_CFMT_H 0x1af1
+#define VD2_AFBC_ENABLE 0x3180
+#define VD2_AFBC_MODE  0x3181
+#define VD2_AFBC_SIZE_IN 0x3182
+#define VD2_AFBC_DEC_DEF_COLOR 0x3183
+#define VD2_AFBC_CONV_CTRL 0x3184
+#define VD2_AFBC_LBUF_DEPTH 0x3185
+#define VD2_AFBC_HEAD_BADDR 0x3186
+#define VD2_AFBC_BODY_BADDR 0x3187
+#define VD2_AFBC_OUT_XSCOPE 0x3188
+#define VD2_AFBC_OUT_YSCOPE 0x3189
+#define VD2_AFBC_STAT 0x318a
+#define VD2_AFBC_VD_CFMT_CTRL 0x318b
+#define VD2_AFBC_VD_CFMT_W 0x318c
+#define VD2_AFBC_MIF_HOR_SCOPE  0x318d
+#define VD2_AFBC_MIF_VER_SCOPE 0x318e
+#define VD2_AFBC_PIXEL_HOR_SCOPE 0x318f
+#define VD2_AFBC_PIXEL_VER_SCOPE 0x3190
+#define VD2_AFBC_VD_CFMT_H 0x3191
 
 #endif
 
diff --git a/drivers/amlogic/amports/arch/regs/vpp_regs.h b/drivers/amlogic/amports/arch/regs/vpp_regs.h
index 44230c4..872a560 100644
--- a/drivers/amlogic/amports/arch/regs/vpp_regs.h
+++ b/drivers/amlogic/amports/arch/regs/vpp_regs.h
@@ -128,9 +128,11 @@
 #define VPP_DNLP_CTRL_13 0x1d8e
 #define VPP_DNLP_CTRL_14 0x1d8f
 #define VPP_DNLP_CTRL_15 0x1d90
-#define VPP_PEAKING_HGAIN 0x1d91
-#define VPP_PEAKING_VGAIN 0x1d92
+#define VPP_SRSHARP0_CTRL 0x1d91
+#define VPP_SRSHARP1_CTRL 0x1d92
 #define VPP_PEAKING_NLP_1 0x1d93
+/* gxm has no super-core */
+#define VPP_DOLBY_CTRL    0x1d93
 #define VPP_PEAKING_NLP_2 0x1d94
 #define VPP_PEAKING_NLP_3 0x1d95
 #define VPP_PEAKING_NLP_4 0x1d96
@@ -147,6 +149,8 @@
 #define VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH 0x1da2
 #define VPP_VE_DEMO_CENTER_BAR 0x1da3
 #define VPP_VE_H_V_SIZE 0x1da4
+#define VPP_PSR_H_V_SIZE 0x1da5
+#define VPP_IN_H_V_SIZE 0x1da6
 #define VPP_VDO_MEAS_CTRL 0x1da8
 #define VPP_VDO_MEAS_VS_COUNT_HI 0x1da9
 #define VPP_VDO_MEAS_VS_COUNT_LO 0x1daa
@@ -302,6 +306,15 @@
 #define VPP2_OSD_SCALE_COEF_IDX 0x19cc
 #define VPP2_OSD_SCALE_COEF 0x19cd
 #define VPP2_INT_LINE_NUM 0x19ce
-
+#define SRSHARP0_SHARP_HVSIZE 0x3200
+#define SRSHARP0_SHARP_HVBLANK_NUM 0x3201
+#define SRSHARP0_SHARP_PK_NR_ENABLE 0x3227
+#define SRSHARP0_SHARP_DNLP_EN 0x3245
+#define SRSHARP0_SHARP_SR2_CTRL 0x3257
+#define SRSHARP1_SHARP_HVSIZE 0x3280
+#define SRSHARP1_SHARP_HVBLANK_NUM 0x3281
+#define SRSHARP1_SHARP_PK_NR_ENABLE 0x32a7
+#define SRSHARP1_SHARP_DNLP_EN 0x32c5
+#define SRSHARP1_SHARP_SR2_CTRL 0x32d7
 #endif
 
diff --git a/drivers/amlogic/amports/avs.h b/drivers/amlogic/amports/avs.h
new file mode 100644
index 0000000..d415645
--- /dev/null
+++ b/drivers/amlogic/amports/avs.h
@@ -0,0 +1,70 @@
+#ifndef AVS_H_
+#define AVS_H_
+
+#define AVSP_LONG_CABAC
+/*#define BITSTREAM_READ_TMP_NO_CACHE*/
+
+#ifdef AVSP_LONG_CABAC
+#define MAX_CODED_FRAME_SIZE 1500000         /*!< bytes for one frame*/
+#define LOCAL_HEAP_SIZE    (1024*1024*10)
+/*
+#define MAX_CODED_FRAME_SIZE  240000
+#define MAX_CODED_FRAME_SIZE  700000
+*/
+#define SVA_STREAM_BUF_SIZE 1024
+
+extern void *es_write_addr_virt;
+extern dma_addr_t es_write_addr_phy;
+
+extern void *bitstream_read_tmp;
+extern dma_addr_t bitstream_read_tmp_phy;
+extern void *avsp_heap_adr;
+
+int avs_get_debug_flag(void);
+
+int process_long_cabac(void);
+
+/* bit [6] - skip_mode_flag
+ bit [5:4] - picture_type
+ bit [3] - picture_structure (0-Field, 1-Frame)
+ bit [2] - fixed_picture_qp
+ bit [1] - progressive_sequence
+ bit [0] - active
+*/
+#define LONG_CABAC_REQ        AV_SCRATCH_K
+#define LONG_CABAC_SRC_ADDR   AV_SCRATCH_H
+#define LONG_CABAC_DES_ADDR   AV_SCRATCH_I
+/* bit[31:16] - vertical_size
+ bit[15:0] - horizontal_size
+*/
+#define LONG_CABAC_PIC_SIZE   AV_SCRATCH_J
+
+#endif
+
+/*
+#define PERFORMANCE_DEBUG
+#define DUMP_DEBUG
+*/
+#define AVS_DEBUG_PRINT         0x01
+#define AVS_DEBUG_UCODE         0x02
+#define AVS_DEBUG_OLD_ERROR_HANDLE	0x10
+#define AVS_DEBUG_USE_FULL_SPEED 0x80
+#define AEC_DUMP				0x100
+#define STREAM_INFO_DUMP		0x200
+#define SLICE_INFO_DUMP			0x400
+#define MB_INFO_DUMP			0x800
+#define MB_NUM_DUMP				0x1000
+#define BLOCK_NUM_DUMP			0x2000
+#define COEFF_DUMP				0x4000
+#define ES_DUMP					0x8000
+#define DQUANT_DUMP				0x10000
+#define STREAM_INFO_DUMP_MORE   0x20000
+#define STREAM_INFO_DUMP_MORE2  0x40000
+
+extern void *es_write_addr_virt;
+extern void *bitstream_read_tmp;
+extern dma_addr_t bitstream_read_tmp_phy;
+int read_bitstream(unsigned char *Buf, int size);
+int u_v(int LenInBits, char *tracestring);
+
+#endif
diff --git a/drivers/amlogic/amports/avsp_trans.c b/drivers/amlogic/amports/avsp_trans.c
new file mode 100644
index 0000000..9b585b2
--- /dev/null
+++ b/drivers/amlogic/amports/avsp_trans.c
@@ -0,0 +1,4940 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/vformat.h>
+#include <linux/dma-mapping.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/slab.h>
+/* #include <mach/am_regs.h> */
+#include <linux/module.h>
+#include "vdec_reg.h"
+#include "streambuf_reg.h"
+#include "amvdec.h"
+#include "arch/register.h"
+#include "amports_priv.h"
+
+#include "avs.h"
+#ifdef AVSP_LONG_CABAC
+
+#define DECODING_SANITY_CHECK
+
+#define TRACE 0
+#define LIWR_FIX 0
+#define pow2(a, b) (1<<b)
+#define io_printf pr_info
+
+static unsigned char *local_heap_adr;
+static int local_heap_size;
+static int local_heap_pos;
+static int transcoding_error_flag;
+
+unsigned char *local_alloc(int num, int size)
+{
+	unsigned char *ret_buf = NULL;
+	int alloc_size = num * size;
+	if ((local_heap_pos + alloc_size) <= local_heap_size) {
+		ret_buf = local_heap_adr + local_heap_pos;
+		local_heap_pos += alloc_size;
+	} else {
+		pr_info(
+				"!!!local_alloc(%d) error, local_heap (size %d) is not enough\r\n",
+				alloc_size, local_heap_size);
+	}
+	return ret_buf;
+}
+
+int local_heap_init(int size)
+{
+	/*local_heap_adr = &local_heap[0];*/
+	local_heap_adr = (unsigned char *)(avsp_heap_adr +
+	MAX_CODED_FRAME_SIZE);
+	memset(local_heap_adr, 0, LOCAL_HEAP_SIZE);
+
+	local_heap_size = LOCAL_HEAP_SIZE;
+	local_heap_pos = 0;
+	return 0;
+}
+
+void local_heap_uninit(void)
+{
+	local_heap_adr = NULL;
+	local_heap_size = 0;
+	local_heap_pos = 0;
+}
+
+#define CODE2D_ESCAPE_SYMBOL 59
+
+const int vlc_golomb_order[3][7][2] =
+
+{{{2, 9}, {2, 9}, {2, 9}, {2, 9}, {2, 9}, {2, 9}, {2, 9}, }, {{3, 9}, {2, 9}, {
+		2, 9}, {2, 9}, {2, 9}, {2, 9}, {2, 9}, }, {{2, 9}, {0, 9},
+		{1, 9}, {1, 9}, {0, 9}, {-1, -1}, {-1, -1}, }, };
+
+const int MaxRun[3][7] = {{22, 14, 9, 6, 4, 2, 1}, {25, 18, 13, 9, 6, 4, 3}, {
+		24, 19, 10, 7, 4, -1, -1} };
+
+const int refabslevel[19][26] = {{4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		2, 2, 2, 2, 2, 2, 2, 2, -1, -1, -1}, {7, 4, 4, 3, 3, 3, 3, 3, 2,
+		2, 2, 2, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		10, 6, 4, 4, 3, 3, 3, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1}, {13, 7, 5, 4, 3, 2, 2, -1, -1,
+		-1 - 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {18, 8, 4, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {22, 7, 3, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {27, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4,
+		3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		2, 2, 2, 2}, {5, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		2, 2, -1, -1, -1, -1, -1, -1, -1}, {7, 5, 4, 4, 3, 3, 3, 2, 2,
+		2, 2, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+		{10, 6, 5, 4, 3, 3, 2, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1}, {13, 7, 5, 4,
+				3, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1}, {17, 8, 4,
+				3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				22, 6, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1}, {5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+				2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1}, {6, 4, 3,
+				3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+				2, -1, -1, -1, -1, -1, -1}, {10, 6, 4, 4, 3, 3,
+				2, 2, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {14, 7, 4, 3, 3, 2,
+				2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1}, {20, 7, 3, 2,
+				2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1} };
+
+static const int incvlc_intra[7] = {0, 1, 2, 4, 7, 10, 3000};
+static const int incvlc_chroma[5] = {0, 1, 2, 4, 3000};
+
+const int AVS_2DVLC_INTRA[7][26][27] = {{{0, 22, 38, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {2, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, 44, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {6, 50, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {8, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {10, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {12, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {14, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {18, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {20, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {24, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {28, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {30, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {34, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {40, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {42, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {46, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {52, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {56, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, }, {{8, 0, 4, 15, 27, 41,
+		55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, 2, 17, 35, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+		{-1, 6, 25, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, 9, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, 11, 39, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, 13, 45, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, 19, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, 21, 51, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, 23, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, 31, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, 37, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, 47, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, 57, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, }, {{8, 0, 2, 6,
+		13, 17, 27, 35, 45, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, 4, 11, 21, 33, 49, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, 9, 23, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 15,
+		29, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 19, 39, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, 25, 43, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, 31, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 41,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 47, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, 57, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, }, {{8, 0, 2, 4, 9, 11, 17, 21, 25, 33, 39, 45, 55, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 6, 13, 19,
+		29, 35, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, 15, 27, 41, 57, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, 23, 37, 53, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, 31, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 43, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, 49, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, }, {{6, 0, 2, 4, 7, 9, 11, 15, 17,
+		21, 23, 29, 33, 35, 43, 47, 49, 57, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, 13, 19, 27, 31, 37, 45, 55, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+		25, 41, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 39, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {-1, 53, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, }, {{0,
+		1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 23, 25, 27, 31, 33, 37, 41,
+		45, 49, 51, 55, -1, -1, -1, -1, -1}, {-1, 21, 29, 35, 43, 47,
+		53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, 39, 57, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1}, }, {{0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19,
+		21, 23, 25, 27, 29, 31, 35, 37, 39, 41, 43, 47, 49, 51, 53, 57},
+		{-1, 33, 45, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1} } };
+
+const int AVS_2DVLC_CHROMA[5][26][27] = {{{0, 14, 32, 56, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {2, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1}, {6, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {10,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {12, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {16, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {20,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {22, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {24, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {28,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {30, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {34, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {38,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {40, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {42, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {46,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {50, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {52, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1}, {54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, }, {{0, 1, 5, 15, 29,
+		43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1}, {-1, 3, 21, 45, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1}, {-1, 7, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 9, 41, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, 11, 53, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 19, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, 23, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 31, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, 33, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 47, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, 49, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, 57, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, },
+		{{2, 0, 3, 7, 11, 17, 27, 33, 47, 53, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {
+				-1, 5, 13, 21, 37, 55, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1}, {-1, 9, 23, 41, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, 15, 31, 57, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				19, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, 25, 45, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, 29, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, 39, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, 49, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, }, {{0, 1, 3, 5, 7, 11, 15, 19, 23, 29,
+				35, 43, 47, 53, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1}, {-1, 9, 13, 21, 31, 39, 51,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1}, {-1, 17, 27,
+				37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+				{-1, 25, 41, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, 33, 55, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, 45, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, 49, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, 57, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, {
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1}, {-1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1, -1,
+						-1, -1, -1, -1, -1, -1, -1}, },
+		{{0, 1, 3, 5, 7, 9, 11, 13, 15, 19, 21, 23, 27, 29, 33, 37, 41,
+				43, 51, 55, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				17, 25, 31, 39, 45, 53, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, 35, 49, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, 47, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+				-1, -1}, } };
+
+const int UE[64][2] = {{1, 1}, {2, 3}, {3, 3}, {4, 5}, {5, 5}, {6, 5}, {7, 5}, {
+		8, 7}, {9, 7}, {10, 7}, {11, 7}, {12, 7}, {13, 7}, {14, 7}, {15,
+		7}, {16, 9}, {17, 9}, {18, 9}, {19, 9}, {20, 9}, {21, 9},
+		{22, 9}, {23, 9}, {24, 9}, {25, 9}, {26, 9}, {27, 9}, {28, 9}, {
+				29, 9}, {30, 9}, {31, 9}, {32, 11}, {33, 11}, {
+				34, 11}, {35, 11}, {36, 11}, {37, 11}, {38, 11},
+		{39, 11}, {40, 11}, {41, 11}, {42, 11}, {43, 11}, {44, 11}, {45,
+				11}, {46, 11}, {47, 11}, {48, 11}, {49, 11}, {
+				50, 11}, {51, 11}, {52, 11}, {53, 11}, {54, 11},
+		{55, 11}, {56, 11}, {57, 11}, {58, 11}, {59, 11}, {60, 11}, {61,
+				11}, {62, 11}, {63, 11}, {64, 13} };
+
+unsigned int src_start;
+unsigned int des_start;
+
+#ifdef AVSP_LONG_CABAC
+
+unsigned char *es_buf;
+int es_buf_ptr;
+int es_write_addr;
+#else
+FILE *f_es;
+#endif
+int es_ptr;
+unsigned int es_res;
+int es_res_ptr;
+unsigned int previous_es;
+
+void init_es(void)
+{
+
+#ifdef AVSP_LONG_CABAC
+	es_write_addr = des_start;
+	es_buf[0] = 0x00;
+	es_buf[1] = 0x00;
+	es_buf[2] = 0x01;
+	es_buf_ptr = 3;
+	es_ptr = 3;
+#else
+	f_es = fopen("es.out", "wb");
+	if (f_es == NULL)
+		io_printf(" ERROR : Can not open es.out for write\n");
+	putc(0x00, f_es);
+	putc(0x00, f_es);
+	putc(0x01, f_es);
+
+	es_ptr = 3;
+#endif
+	es_res = 0;
+	es_res_ptr = 0;
+	previous_es = 0xff;
+
+}
+
+void push_es(int value, int num)
+{
+	unsigned char wr_es_data;
+	int push_num;
+	int push_value;
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & ES_DUMP)
+		io_printf(" push_es : value : 0x%x, num : %d\n", value, num);
+#endif
+	while (num > 0) {
+		if (num >= 8)
+			push_num = 8;
+		else
+			push_num = num;
+
+		num = num - push_num;
+		push_value = (value >> num);
+
+		es_res = (es_res << push_num) | push_value;
+		es_res_ptr = es_res_ptr + push_num;
+
+#ifdef DUMP_DEBUG
+		if (avs_get_debug_flag() & ES_DUMP)
+			io_printf(" #### es_res : 0x%X, es_res_ptr : %d\n",
+				es_res, es_res_ptr);
+#endif
+
+		while (es_res_ptr >= 8) {
+			es_res_ptr = es_res_ptr & 7;
+			wr_es_data = (es_res >> es_res_ptr) & 0xff;
+			if ((previous_es == 0) & (wr_es_data < 4)) {
+				io_printf(
+						" Insert 2'b10 for emu at position : %d\n",
+						es_ptr);
+
+				es_res_ptr = es_res_ptr + 2;
+				wr_es_data = 2;
+			}
+#ifdef AVSP_LONG_CABAC
+#ifdef DUMP_DEBUG
+			if (avs_get_debug_flag() & ES_DUMP)
+				pr_info("es_buf[%d] = 0x%02x\r\n",
+					es_buf_ptr, wr_es_data);
+#endif
+			es_buf[es_buf_ptr++] = wr_es_data;
+#else
+			putc(wr_es_data, f_es);
+#endif
+			es_ptr++;
+			previous_es = ((previous_es << 8) | wr_es_data)
+					& 0xffff;
+		}
+
+	}
+}
+
+#define MIN_QP          0
+#define MAX_QP          63
+
+#define BLOCK_SIZE      4
+#define B8_SIZE         8
+#define MB_BLOCK_SIZE   16
+
+#define BLOCK_MULTIPLE      (MB_BLOCK_SIZE/(BLOCK_SIZE*2))
+
+#define DECODE_COPY_MB  0
+#define DECODE_MB       1
+
+#define NO_INTRA_PMODE  5
+#define INTRA_PMODE_4x4   10
+#define NO_INTRA_PMODE_4x4	19
+/* 8x8 intra prediction modes */
+#define VERT_PRED             0
+#define HOR_PRED              1
+#define DC_PRED               2
+#define DOWN_LEFT_PRED   3
+#define DOWN_RIGHT_PRED  4
+
+#define VERT_PRED_4x4   0
+#define HOR_PRED_4x4	1
+#define DC_PRED_4x4		2
+#define DOWN_LEFT_PRED_4x4	3
+#define DOWN_RIGHT_PRED_4x4	4
+
+#define HOR_DOWN_PRED_4x4		5
+#define VERT_LEFT_PRED_4x4	6
+#define HOR_UP_PRED_4x4	   7
+#define VERT_RIGHT_PRED_4x4	8
+
+#define DC_PRED_8       0
+#define HOR_PRED_8      1
+#define VERT_PRED_8     2
+#define PLANE_8         3
+
+#define LUMA_16DC       0
+#define LUMA_16AC       1
+#define LUMA_8x8        2
+#define LUMA_8x4        3
+#define LUMA_4x8        4
+#define LUMA_4x4        5
+#define CHROMA_DC       6
+#define CHROMA_AC       7
+#define NUM_BLOCK_TYPES 8
+
+#define I_PICTURE_START_CODE    0xB3
+#define PB_PICTURE_START_CODE   0xB6
+#define SLICE_START_CODE_MIN    0x00
+#define SLICE_START_CODE_MAX    0xAF
+#define USER_DATA_START_CODE    0xB2
+#define SEQUENCE_HEADER_CODE    0xB0
+#define EXTENSION_START_CODE    0xB5
+#define SEQUENCE_END_CODE       0xB1
+#define VIDEO_EDIT_CODE         0xB7
+
+#define EOS             1
+#define SOP             2
+#define SOS             3
+#define P8x8    8
+#define I8MB    9
+#define I4MB   10
+#define IBLOCK  11
+#define SI4MB   12
+#define MAXMODE 13
+
+#define IS_INTRA(MB)    ((MB)->mb_type == I8MB  || (MB)->mb_type == I4MB)
+#define IS_NEWINTRA(MB) ((MB)->mb_type == I4MB)
+#define IS_OLDINTRA(MB) ((MB)->mb_type == I8MB)
+#define IS_INTER(MB)    ((MB)->mb_type != I8MB  && (MB)->mb_type != I4MB)
+#define IS_INTERMV(MB)  ((MB)->mb_type != I8MB  && (MB)->mb_type != I4MB\
+	&& (MB)->mb_type != 0)
+
+#define IS_DIRECT(MB)   ((MB)->mb_type == 0     && (img->type == B_IMG))
+#define IS_COPY(MB)     ((MB)->mb_type == 0     && (img->type == P_IMG))
+#define IS_P8x8(MB)     ((MB)->mb_type == P8x8)
+
+#define P_IMG     0
+#define B_IMG     1
+#define I_IMG     2
+
+#define FIELD     0
+#define FRAME     1
+
+#define SE_CABP    21
+struct decoding_environment_s {
+	unsigned int dbuffer;
+	int dbits_to_go;
+	unsigned char *dcodestrm;
+	int *dcodestrm_len;
+};
+
+struct bi_context_type_s {
+	unsigned char MPS;
+	unsigned int LG_PMPS;
+	unsigned char cycno;
+};
+
+
+/**********************************************************************
+ * C O N T E X T S   F O R   R M   S Y N T A X   E L E M E N T S
+ **********************************************************************
+ */
+
+#define NUM_MB_TYPE_CTX  11
+#define NUM_B8_TYPE_CTX  9
+#define NUM_MV_RES_CTX   10
+#define NUM_REF_NO_CTX   6
+#define NUM_DELTA_QP_CTX 4
+#define NUM_MB_AFF_CTX 4
+
+struct motion_info_contexts_s {
+	struct bi_context_type_s mb_type_contexts[4][NUM_MB_TYPE_CTX];
+	struct bi_context_type_s b8_type_contexts[2][NUM_B8_TYPE_CTX];
+	struct bi_context_type_s mv_res_contexts[2][NUM_MV_RES_CTX];
+	struct bi_context_type_s ref_no_contexts[2][NUM_REF_NO_CTX];
+	struct bi_context_type_s delta_qp_contexts[NUM_DELTA_QP_CTX];
+	struct bi_context_type_s mb_aff_contexts[NUM_MB_AFF_CTX];
+#ifdef TEST_WEIGHTING_AEC
+struct bi_context_type_s mb_weighting_pred;
+#endif
+};
+
+#define NUM_IPR_CTX    2
+#define NUM_CIPR_CTX   4
+#define NUM_CBP_CTX    4
+#define NUM_BCBP_CTX   4
+#define NUM_MAP_CTX   16
+#define NUM_LAST_CTX  16
+
+#define NUM_ONE_CTX    5
+#define NUM_ABS_CTX    5
+
+struct texture_info_contexts {
+	struct bi_context_type_s ipr_contexts[NUM_IPR_CTX];
+	struct bi_context_type_s cipr_contexts[NUM_CIPR_CTX];
+	struct bi_context_type_s cbp_contexts[3][NUM_CBP_CTX];
+	struct bi_context_type_s bcbp_contexts[NUM_BLOCK_TYPES][NUM_BCBP_CTX];
+	struct bi_context_type_s one_contexts[NUM_BLOCK_TYPES][NUM_ONE_CTX];
+	struct bi_context_type_s abs_contexts[NUM_BLOCK_TYPES][NUM_ABS_CTX];
+	struct bi_context_type_s fld_map_contexts[NUM_BLOCK_TYPES][NUM_MAP_CTX];
+	struct bi_context_type_s fld_last_contexts
+	[NUM_BLOCK_TYPES][NUM_LAST_CTX];
+	struct bi_context_type_s map_contexts[NUM_BLOCK_TYPES][NUM_MAP_CTX];
+	struct bi_context_type_s last_contexts[NUM_BLOCK_TYPES][NUM_LAST_CTX];
+};
+struct img_par;
+
+struct syntaxelement {
+	int type;
+	int value1;
+	int value2;
+	int len;
+	int inf;
+	unsigned int bitpattern;
+	int context;
+	int k;
+	int golomb_grad;
+	int golomb_maxlevels;
+#if TRACE
+#define       TRACESTRING_SIZE 100
+	char tracestring[TRACESTRING_SIZE];
+#endif
+
+	void (*mapping)(int len, int info, int *value1, int *value2);
+
+	void (*reading)(struct syntaxelement *, struct img_par *,
+			struct decoding_environment_s *);
+
+};
+
+struct bitstream_s {
+
+	int read_len;
+	int code_len;
+
+	int frame_bitoffset;
+	int bitstream_length;
+
+	unsigned char *stream_buffer;
+};
+
+struct datapartition {
+
+	struct bitstream_s *bitstream;
+	struct decoding_environment_s de_aec;
+
+	int (*read_syntax_element)(struct syntaxelement *, struct img_par *,
+			struct datapartition *);
+/*!< virtual function;
+ actual method depends on chosen data partition and
+ entropy coding method  */
+};
+
+struct slice_s {
+	int picture_id;
+	int qp;
+	int picture_type;
+	int start_mb_nr;
+	int max_part_nr;
+	int num_mb;
+
+	struct datapartition *part_arr;
+	struct motion_info_contexts_s *mot_ctx;
+	struct texture_info_contexts *tex_ctx;
+	int field_ctx[3][2];
+};
+
+struct img_par {
+	int number;
+	int current_mb_nr;
+	int max_mb_nr;
+	int current_slice_nr;
+	int tr;
+	int qp;
+	int type;
+
+	int typeb;
+
+	int width;
+	int height;
+	int width_cr;
+	int height_cr;
+	int source_bitdepth;
+	int mb_y;
+	int mb_x;
+	int block_y;
+	int pix_y;
+	int pix_x;
+	int pix_c_y;
+	int block_x;
+	int pix_c_x;
+
+	int ***mv;
+	int mpr[16][16];
+
+	int m7[16][16];
+	int m8[/*2*/4][8][8];
+	int cof[4][/*6*/8][4][4];
+	int cofu[4];
+	int **ipredmode;
+	int quad[256];
+	int cod_counter;
+
+	int ***dfmv;
+	int ***dbmv;
+	int **fw_reffrarr;
+	int **bw_reffrarr;
+
+	int ***mv_frm;
+	int **fw_reffrarr_frm;
+	int **bw_reffrarr_frm;
+	int imgtr_next_p;
+	int imgtr_last_p;
+	int tr_frm;
+	int tr_fld;
+	int imgtr_last_prev_p;
+
+	int no_forward_reference;
+	int seq_header_indicate;
+	int b_discard_flag;
+
+	int ***fw_mv;
+	int ***bw_mv;
+	int subblock_x;
+	int subblock_y;
+
+	int buf_cycle;
+
+	int direct_type;
+
+	int ***mv_top;
+	int ***mv_bot;
+	int **fw_reffrarr_top;
+	int **bw_reffrarr_top;
+	int **fw_reffrarr_bot;
+	int **bw_reffrarr_bot;
+
+	int **ipredmode_top;
+	int **ipredmode_bot;
+	int ***fw_mv_top;
+	int ***fw_mv_bot;
+	int ***bw_mv_top;
+	int ***bw_mv_bot;
+	int ***dfmv_top;
+	int ***dbmv_top;
+	int ***dfmv_bot;
+	int ***dbm_bot;
+
+	int toppoc;
+	int bottompoc;
+	int framepoc;
+	unsigned int frame_num;
+
+	unsigned int pic_distance;
+	int delta_pic_order_cnt_bottom;
+
+	signed int pic_distance_msb;
+	unsigned int prev_pic_distance_lsb;
+	signed int curr_pic_distance_msb;
+	unsigned int this_poc;
+
+	int pic_width_inmbs;
+	int pic_height_inmbs;
+	int pic_size_inmbs;
+
+	int block8_x, block8_y;
+	int structure;
+	int pn;
+	int buf_used;
+	int buf_size;
+	int picture_structure;
+	int advanced_pred_mode_disable;
+	int types;
+	int current_mb_nr_fld;
+
+	int p_field_enhanced;
+	int b_field_enhanced;
+
+	int slice_weighting_flag;
+	int lum_scale[4];
+	int lum_shift[4];
+	int chroma_scale[4];
+	int chroma_shift[4];
+	int mb_weighting_flag;
+	int weighting_prediction;
+	int mpr_weight[16][16];
+	int top_bot;
+	int bframe_number;
+
+	int auto_crop_right;
+	int auto_crop_bottom;
+
+	struct slice_s *current_slice;
+	int is_v_block;
+	int is_intra_block;
+
+	int new_seq_header_flag;
+	int new_sequence_flag;
+	int last_pic_bbv_delay;
+
+	int sequence_end_flag;
+	int is_top_field;
+
+	int abt_flag;
+	int qp_shift;
+
+#ifdef EIGHTH
+int eighth_subpixel_flag;
+int subpixel_precision;
+int unit_length;
+int subpixel_mask;
+
+int max_mvd;
+int min_mvd;
+#endif
+
+};
+
+struct macroblock {
+	int qp;
+	int slice_nr;
+	int delta_quant;
+	struct macroblock *mb_available[3][3];
+	/*!< pointer to neighboring MBs in a 3x3 window of current MB,
+	which is located at [1][1]
+	 NULL pointer identifies neighboring MBs which are unavailable */
+
+	int mb_type;
+	int mvd[2][BLOCK_MULTIPLE][BLOCK_MULTIPLE][2];
+	int cbp, cbp_blk, cbp01;
+	unsigned long cbp_bits;
+
+	int b8mode[4];
+	int b8pdir[4];
+	int mb_type_2;
+	int c_ipred_mode_2;
+	int dct_mode;
+
+	int c_ipred_mode;
+	int lf_disable;
+	int lf_alpha_c0_offset;
+	int lf_beta_offset;
+
+	int CABT[4];
+	int CABP[4];
+	int cbp_4x4[4];
+
+	int skip_flag;
+
+	struct macroblock *mb_available_up;
+	struct macroblock *mb_available_left;
+	int mbaddr_a, mbaddr_b, mbaddr_c, mbaddr_d;
+	int mbavail_a, mbavail_b, mbavail_c, mbavail_d;
+
+};
+
+struct macroblock *mb_data;
+
+struct img_par *img;
+
+struct bitstream_s *curr_stream;
+
+struct datapartition *alloc_partition(int n);
+
+unsigned int vld_mem_start_addr;
+unsigned int vld_mem_end_addr;
+
+int marker_bit;
+
+int progressive_sequence;
+int horizontal_size;
+int vertical_size;
+
+int second_ifield;
+int pre_img_type;
+
+/* slice_header() */
+int slice_vertical_position;
+int slice_vertical_position_extension;
+int fixed_picture_qp;
+int fixed_slice_qp;
+int slice_qp;
+
+/*
+ *************************************************************************
+ * Function:ue_v, reads an u(v) syntax element, the length in bits is stored in
+ the global UsedBits variable
+ * Input:
+ tracestring
+ the string for the trace file
+ bitstream
+ the stream to be read from
+ * Output:
+ * Return: the value of the coded syntax element
+ * Attention:
+ *************************************************************************
+ */
+/*!
+ *  definition of AVS syntaxelements
+ *  order of elements follow dependencies for picture reconstruction
+ */
+/*!
+ * \brief   Assignment of old TYPE partition elements to new
+ *          elements
+ *
+ *  old element     | new elements
+ *  TYPE_HEADER     | SE_HEADER, SE_PTYPE
+ *  TYPE_MBHEADER    | SE_MBTYPE, SE_REFFRAME, SE_INTRAPREDMODE
+ *  TYPE_MVD        | SE_MVD
+ *  TYPE_CBP        | SE_CBP_INTRA, SE_CBP_INTER * SE_DELTA_QUANT_INTER
+ *  SE_DELTA_QUANT_INTRA
+ *  TYPE_COEFF_Y    | SE_LUM_DC_INTRA, SE_LUM_AC_INTRA,
+    SE_LUM_DC_INTER, SE_LUM_AC_INTER
+ *  TYPE_2x2DC      | SE_CHR_DC_INTRA, SE_CHR_DC_INTER
+ *  TYPE_COEFF_C    | SE_CHR_AC_INTRA, SE_CHR_AC_INTER
+ *  TYPE_EOS        | SE_EOS
+ */
+
+#define SE_HEADER           0
+#define SE_PTYPE            1
+#define SE_MBTYPE           2
+#define SE_REFFRAME         3
+#define SE_INTRAPREDMODE    4
+#define SE_MVD              5
+#define SE_CBP_INTRA        6
+#define SE_LUM_DC_INTRA     7
+#define SE_CHR_DC_INTRA     8
+#define SE_LUM_AC_INTRA     9
+#define SE_CHR_AC_INTRA     10
+#define SE_CBP_INTER        11
+#define SE_LUM_DC_INTER     12
+#define SE_CHR_DC_INTER     13
+#define SE_LUM_AC_INTER     14
+#define SE_CHR_AC_INTER     15
+#define SE_DELTA_QUANT_INTER      16
+#define SE_DELTA_QUANT_INTRA      17
+#define SE_BFRAME           18
+#define SE_EOS              19
+#define SE_MAX_ELEMENTS     20
+#define SE_CBP01            21
+int chroma_format;
+/*
+ *************************************************************************
+ * Function:Reads bits from the bitstream buffer
+ * Input:
+ byte buffer[]
+ containing VLC-coded data bits
+ int totbitoffset
+ bit offset from start of partition
+ int bytecount
+ total bytes in bitstream
+ int numbits
+ number of bits to read
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+int get_bits(unsigned char buffer[], int totbitoffset, int *info, int bytecount,
+		int numbits)
+{
+	register int inf;
+	long byteoffset;
+	int bitoffset;
+
+	int bitcounter = numbits;
+
+	byteoffset = totbitoffset / 8;
+	bitoffset = 7 - (totbitoffset % 8);
+
+	inf = 0;
+	while (numbits) {
+		inf <<= 1;
+		inf |= (buffer[byteoffset] & (0x01 << bitoffset)) >> bitoffset;
+		numbits--;
+		bitoffset--;
+		if (bitoffset < 0) {
+			byteoffset++;
+			bitoffset += 8;
+			if (byteoffset > bytecount)
+				return -1;
+		}
+	}
+
+	*info = inf;
+
+
+	return bitcounter;
+}
+
+/*
+ *************************************************************************
+ * Function:read FLC codeword from UVLC-partition
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+int read_syntaxelement_flc(struct syntaxelement *sym)
+{
+	int frame_bitoffset = curr_stream->frame_bitoffset;
+	unsigned char *buf = curr_stream->stream_buffer;
+	int bitstreamlengthinbytes = curr_stream->bitstream_length;
+
+	if ((get_bits(buf, frame_bitoffset, &(sym->inf), bitstreamlengthinbytes,
+			sym->len)) < 0)
+		return -1;
+
+	curr_stream->frame_bitoffset += sym->len;
+	sym->value1 = sym->inf;
+
+#if TRACE
+	tracebits2(sym->tracestring, sym->len, sym->inf);
+#endif
+
+	return 1;
+}
+
+/*
+ *************************************************************************
+ * Function:ue_v, reads an u(1) syntax element, the length in bits is stored in
+ the global UsedBits variable
+ * Input:
+ tracestring
+ the string for the trace file
+ bitstream
+ the stream to be read from
+ * Output:
+ * Return: the value of the coded syntax element
+ * Attention:
+ *************************************************************************
+ */
+int u_1(char *tracestring)
+{
+	return u_v(1, tracestring);
+}
+
+/*
+ *************************************************************************
+ * Function:mapping rule for ue(v) syntax elements
+ * Input:lenght and info
+ * Output:number in the code table
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+void linfo_ue(int len, int info, int *value1, int *dummy)
+{
+	*value1 = (int)pow2(2, (len / 2)) + info - 1;
+}
+
+int u_v(int leninbits, char *tracestring)
+{
+	struct syntaxelement symbol, *sym = &symbol;
+
+#ifdef AVSP_LONG_CABAC
+#else
+	assert(curr_stream->stream_buffer != NULL);
+#endif
+	sym->type = SE_HEADER;
+	sym->mapping = linfo_ue;
+	sym->len = leninbits;
+	read_syntaxelement_flc(sym);
+
+	return sym->inf;
+}
+
+/*
+ *************************************************************************
+ * Function:mapping rule for se(v) syntax elements
+ * Input:lenght and info
+ * Output:signed mvd
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void linfo_se(int len, int info, int *value1, int *dummy)
+{
+	int n;
+	n = (int)pow2(2, (len / 2)) + info - 1;
+	*value1 = (n + 1) / 2;
+	if ((n & 0x01) == 0)
+		*value1 = -*value1;
+
+}
+
+/*
+ *************************************************************************
+ * Function:lenght and info
+ * Input:
+ * Output:cbp (intra)
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void linfo_cbp_intra(int len, int info, int *cbp, int *dummy)
+{
+}
+
+const int NCBP[64][2] = {{4, 0}, {16, 19}, {17, 16}, {19, 15}, {14, 18},
+		{9, 11}, {22, 31}, {8, 13}, {11, 17}, {21, 30}, {10, 12},
+		{7, 9}, {12, 10}, {6, 7}, {5, 8}, {1, 1}, {35, 4}, {47, 42}, {
+				48, 38}, {38, 27}, {46, 39}, {36, 33}, {50, 59},
+		{26, 26}, {45, 40}, {52, 58}, {41, 35}, {28, 25}, {37, 29}, {23,
+				24}, {31, 28}, {2, 3}, {43, 5}, {51, 51}, {56,
+				52}, {39, 37}, {55, 50}, {33, 43}, {62, 63}, {
+				27, 44}, {54, 53}, {60, 62}, {40, 48}, {32, 47},
+		{42, 34}, {24, 45}, {29, 49}, {3, 6}, {49, 14}, {53, 55}, {57,
+				56}, {25, 36}, {58, 54}, {30, 41}, {59, 60}, {
+				15, 21}, {61, 57}, {63, 61}, {44, 46}, {18, 22},
+		{34, 32}, {13, 20}, {20, 23}, {0, 2} };
+
+unsigned int s1, t1, value_s, value_t;
+unsigned char dec_bypass, dec_final;
+
+#define get_byte() {                                         \
+	dbuffer = dcodestrm[(*dcodestrm_len)++];\
+	dbits_to_go = 7;                        \
+}
+
+#define dbuffer         (dep->dbuffer)
+#define dbits_to_go     (dep->dbits_to_go)
+#define dcodestrm       (dep->dcodestrm)
+#define dcodestrm_len   (dep->dcodestrm_len)
+
+#define B_BITS	10
+
+#define LG_PMPS_SHIFTNO 2
+
+#define HALF      (1 << (B_BITS-1))
+#define QUARTER   (1 << (B_BITS-2))
+
+unsigned int biari_decode_symbol(struct decoding_environment_s *dep,
+		struct bi_context_type_s *bi_ct)
+{
+	register unsigned char bit;
+	register unsigned char s_flag;
+	register unsigned char is_lps = 0;
+	register unsigned char cwr;
+	register unsigned char cycno = bi_ct->cycno;
+	register unsigned int lg_pmps = bi_ct->LG_PMPS;
+	register unsigned int t_rlps;
+	register unsigned int s2, t2;
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & AEC_DUMP)
+		io_printf("LG_PMPS : %03X, MPS : %d, cycno : %d -- %p\n",
+			bi_ct->LG_PMPS, bi_ct->MPS, bi_ct->cycno, bi_ct);
+#endif
+
+	bit = bi_ct->MPS;
+
+	cwr = (cycno <= 1) ? 3 : (cycno == 2) ? 4 : 5;
+
+	if (t1 >= (lg_pmps >> LG_PMPS_SHIFTNO)) {
+		s2 = s1;
+		t2 = t1 - (lg_pmps >> LG_PMPS_SHIFTNO);
+		s_flag = 0;
+	} else {
+		s2 = s1 + 1;
+		t2 = 256 + t1 - (lg_pmps >> LG_PMPS_SHIFTNO);
+		s_flag = 1;
+	}
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & AEC_DUMP)
+		io_printf(" s2 : %d, t2 : %03X\n", s2, t2);
+#endif
+
+	if (s2 > value_s || (s2 == value_s && value_t >= t2)) {
+		is_lps = 1;
+		bit = !bit;
+
+		t_rlps = (s_flag == 0) ?
+				(lg_pmps >> LG_PMPS_SHIFTNO) :
+				(t1 + (lg_pmps >> LG_PMPS_SHIFTNO));
+
+		if (s2 == value_s)
+			value_t = (value_t - t2);
+		else {
+			if (--dbits_to_go < 0)
+				get_byte();
+
+			value_t = (value_t << 1)
+					| ((dbuffer >> dbits_to_go) & 0x01);
+			value_t = 256 + value_t - t2;
+
+		}
+
+		while (t_rlps < QUARTER) {
+			t_rlps = t_rlps << 1;
+			if (--dbits_to_go < 0)
+				get_byte();
+
+			value_t = (value_t << 1)
+					| ((dbuffer >> dbits_to_go) & 0x01);
+		}
+
+		s1 = 0;
+		t1 = t_rlps & 0xff;
+
+		value_s = 0;
+		while (value_t < QUARTER) {
+			int j;
+			if (--dbits_to_go < 0)
+				get_byte();
+			j = (dbuffer >> dbits_to_go) & 0x01;
+
+			value_t = (value_t << 1) | j;
+			value_s++;
+		}
+		value_t = value_t & 0xff;
+	} else {
+
+		s1 = s2;
+		t1 = t2;
+	}
+
+	if (dec_bypass)
+		return bit;
+
+	if (is_lps)
+		cycno = (cycno <= 2) ? (cycno + 1) : 3;
+	else if (cycno == 0)
+		cycno = 1;
+	bi_ct->cycno = cycno;
+
+	if (is_lps) {
+		switch (cwr) {
+		case 3:
+			lg_pmps = lg_pmps + 197;
+			break;
+		case 4:
+			lg_pmps = lg_pmps + 95;
+			break;
+		default:
+			lg_pmps = lg_pmps + 46;
+		}
+
+		if (lg_pmps >= (256 << LG_PMPS_SHIFTNO)) {
+			lg_pmps = (512 << LG_PMPS_SHIFTNO) - 1 - lg_pmps;
+			bi_ct->MPS = !(bi_ct->MPS);
+		}
+	} else {
+#ifdef DUMP_DEBUG
+		if (avs_get_debug_flag() & AEC_DUMP)
+			io_printf(" - lg_pmps_MPS : %X (%X - %X - %X)\n",
+					lg_pmps - (unsigned int)(lg_pmps>>cwr)
+					- (unsigned int)(lg_pmps>>(cwr+2)),
+					lg_pmps,
+					(unsigned int)(lg_pmps>>cwr),
+					(unsigned int)(lg_pmps>>(cwr+2))
+			);
+#endif
+		lg_pmps = lg_pmps - (unsigned int)(lg_pmps >> cwr)
+				- (unsigned int)(lg_pmps >> (cwr + 2));
+	}
+
+	bi_ct->LG_PMPS = lg_pmps;
+
+	return bit;
+}
+
+unsigned int biari_decode_symbolw(struct decoding_environment_s *dep,
+		struct bi_context_type_s *bi_ct1,
+		struct bi_context_type_s *bi_ct2)
+{
+	register unsigned char bit1, bit2;
+	register unsigned char pred_mps, bit;
+	register unsigned int lg_pmps;
+	register unsigned char cwr1, cycno1 = bi_ct1->cycno;
+	register unsigned char cwr2, cycno2 = bi_ct2->cycno;
+	register unsigned int lg_pmps1 = bi_ct1->LG_PMPS;
+	register unsigned int lg_pmps2 =
+			bi_ct2->LG_PMPS;
+	register unsigned int t_rlps;
+	register unsigned char s_flag, is_lps = 0;
+	register unsigned int s2, t2;
+
+
+	bit1 = bi_ct1->MPS;
+	bit2 = bi_ct2->MPS;
+
+	cwr1 = (cycno1 <= 1) ? 3 : (cycno1 == 2) ? 4 : 5;
+	cwr2 = (cycno2 <= 1) ? 3 : (cycno2 == 2) ? 4 : 5;
+
+	if (bit1 == bit2) {
+		pred_mps = bit1;
+		lg_pmps = (lg_pmps1 + lg_pmps2) / 2;
+	} else {
+		if (lg_pmps1 < lg_pmps2) {
+			pred_mps = bit1;
+			lg_pmps = (256 << LG_PMPS_SHIFTNO) - 1
+					- ((lg_pmps2 - lg_pmps1) >> 1);
+		} else {
+			pred_mps = bit2;
+			lg_pmps = (256 << LG_PMPS_SHIFTNO) - 1
+					- ((lg_pmps1 - lg_pmps2) >> 1);
+		}
+	}
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & AEC_DUMP)
+		io_printf(" - Begin - LG_PMPS : %03X, MPS : %d\n",
+			lg_pmps, pred_mps);
+#endif
+	if (t1 >= (lg_pmps >> LG_PMPS_SHIFTNO)) {
+		s2 = s1;
+		t2 = t1 - (lg_pmps >> LG_PMPS_SHIFTNO);
+		s_flag = 0;
+	} else {
+		s2 = s1 + 1;
+		t2 = 256 + t1 - (lg_pmps >> LG_PMPS_SHIFTNO);
+		s_flag = 1;
+	}
+
+	bit = pred_mps;
+	if (s2 > value_s || (s2 == value_s && value_t >= t2)) {
+		is_lps = 1;
+		bit = !bit;
+		t_rlps = (s_flag == 0) ?
+				(lg_pmps >> LG_PMPS_SHIFTNO) :
+				(t1 + (lg_pmps >> LG_PMPS_SHIFTNO));
+
+		if (s2 == value_s)
+			value_t = (value_t - t2);
+		else {
+			if (--dbits_to_go < 0)
+				get_byte();
+
+			value_t = (value_t << 1)
+					| ((dbuffer >> dbits_to_go) & 0x01);
+			value_t = 256 + value_t - t2;
+		}
+
+		while (t_rlps < QUARTER) {
+			t_rlps = t_rlps << 1;
+			if (--dbits_to_go < 0)
+				get_byte();
+
+			value_t = (value_t << 1)
+					| ((dbuffer >> dbits_to_go) & 0x01);
+		}
+		s1 = 0;
+		t1 = t_rlps & 0xff;
+
+		value_s = 0;
+		while (value_t < QUARTER) {
+			int j;
+			if (--dbits_to_go < 0)
+				get_byte();
+			j = (dbuffer >> dbits_to_go) & 0x01;
+
+			value_t = (value_t << 1) | j;
+			value_s++;
+		}
+		value_t = value_t & 0xff;
+	} else {
+		s1 = s2;
+		t1 = t2;
+	}
+
+	if (bit != bit1) {
+		cycno1 = (cycno1 <= 2) ? (cycno1 + 1) : 3;
+	} else {
+		if (cycno1 == 0)
+			cycno1 = 1;
+	}
+
+	if (bit != bit2) {
+		cycno2 = (cycno2 <= 2) ? (cycno2 + 1) : 3;
+	} else {
+		if (cycno2 == 0)
+			cycno2 = 1;
+	}
+	bi_ct1->cycno = cycno1;
+	bi_ct2->cycno = cycno2;
+
+	{
+
+		if (bit == bit1) {
+			lg_pmps1 =
+					lg_pmps1
+				- (unsigned int)(lg_pmps1
+					>> cwr1)
+				- (unsigned int)(lg_pmps1
+					>> (cwr1
+					+ 2));
+		} else {
+			switch (cwr1) {
+			case 3:
+				lg_pmps1 = lg_pmps1 + 197;
+				break;
+			case 4:
+				lg_pmps1 = lg_pmps1 + 95;
+				break;
+			default:
+				lg_pmps1 = lg_pmps1 + 46;
+			}
+
+			if (lg_pmps1 >= (256 << LG_PMPS_SHIFTNO)) {
+				lg_pmps1 = (512 << LG_PMPS_SHIFTNO) - 1
+						- lg_pmps1;
+				bi_ct1->MPS = !(bi_ct1->MPS);
+			}
+		}
+		bi_ct1->LG_PMPS = lg_pmps1;
+
+		if (bit == bit2) {
+			lg_pmps2 =
+					lg_pmps2
+				- (unsigned int)(lg_pmps2
+				>> cwr2)
+				- (unsigned int)(lg_pmps2
+				>> (cwr2
+				+ 2));
+		} else {
+			switch (cwr2) {
+			case 3:
+				lg_pmps2 = lg_pmps2 + 197;
+				break;
+			case 4:
+				lg_pmps2 = lg_pmps2 + 95;
+				break;
+			default:
+				lg_pmps2 = lg_pmps2 + 46;
+			}
+
+			if (lg_pmps2 >= (256 << LG_PMPS_SHIFTNO)) {
+				lg_pmps2 = (512 << LG_PMPS_SHIFTNO) - 1
+						- lg_pmps2;
+				bi_ct2->MPS = !(bi_ct2->MPS);
+			}
+		}
+		bi_ct2->LG_PMPS = lg_pmps2;
+	}
+
+
+	return bit;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    biari_decode_symbol_eq_prob():
+ * \return
+ *    the decoded symbol
+ ************************************************************************
+ */
+unsigned int biari_decode_symbol_eq_prob(struct decoding_environment_s *dep)
+{
+	unsigned char bit;
+	struct bi_context_type_s octx;
+	struct bi_context_type_s *ctx = &octx;
+	ctx->LG_PMPS = (QUARTER << LG_PMPS_SHIFTNO) - 1;
+	ctx->MPS = 0;
+	ctx->cycno = 0xfe;
+	dec_bypass = 1;
+	bit = biari_decode_symbol(dep, ctx);
+	dec_bypass = 0;
+	return bit;
+}
+
+unsigned int biari_decode_final(struct decoding_environment_s *dep)
+{
+	unsigned char bit;
+	struct bi_context_type_s octx;
+	struct bi_context_type_s *ctx = &octx;
+	ctx->LG_PMPS = 1 << LG_PMPS_SHIFTNO;
+	ctx->MPS = 0;
+	ctx->cycno = 0xff;
+	dec_final = 1;
+	bit = biari_decode_symbol(dep, ctx);
+	dec_final = 0;
+	return bit;
+}
+
+int i_8(char *tracestring)
+{
+	int frame_bitoffset = curr_stream->frame_bitoffset;
+	unsigned char *buf = curr_stream->stream_buffer;
+	int bitstreamlengthinbytes = curr_stream->bitstream_length;
+	struct syntaxelement symbol, *sym = &symbol;
+#ifdef AVSP_LONG_CABAC
+#else
+	assert(curr_stream->stream_buffer != NULL);
+#endif
+
+	sym->len = 8;
+	sym->type = SE_HEADER;
+	sym->mapping = linfo_ue;
+
+	if ((get_bits(buf, frame_bitoffset, &(sym->inf), bitstreamlengthinbytes,
+			sym->len)) < 0)
+		return -1;
+	curr_stream->frame_bitoffset += sym->len;
+	sym->value1 = sym->inf;
+	if (sym->inf & 0x80)
+		sym->inf = -(~((int)0xffffff00 | sym->inf) + 1);
+#if TRACE
+	tracebits2(sym->tracestring, sym->len, sym->inf);
+#endif
+	return sym->inf;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    arideco_bits_read
+ ************************************************************************
+ */
+int arideco_bits_read(struct decoding_environment_s *dep)
+{
+
+	return 8 * ((*dcodestrm_len) - 1) + (8 - dbits_to_go);
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    arithmetic decoding
+ ************************************************************************
+ */
+int read_syntaxelement_aec(struct syntaxelement *se, struct img_par *img,
+		struct datapartition *this_data_part)
+{
+	int curr_len;
+	struct decoding_environment_s *dep_dp = &(this_data_part->de_aec);
+
+	curr_len = arideco_bits_read(dep_dp);
+
+	se->reading(se, img, dep_dp);
+
+	se->len = (arideco_bits_read(dep_dp) - curr_len);
+	return se->len;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    This function is used to arithmetically decode the
+ *    run length info of the skip mb
+ ************************************************************************
+ */
+void readrunlenghtfrombuffer_aec(struct syntaxelement *se, struct img_par *img,
+		struct decoding_environment_s *dep_dp)
+{
+	struct bi_context_type_s *pctx;
+	int ctx, symbol;
+	pctx = img->current_slice->tex_ctx->one_contexts[0];
+	symbol = 0;
+	ctx = 0;
+	while (biari_decode_symbol(dep_dp, pctx + ctx) == 0) {
+		symbol += 1;
+		ctx++;
+		if (ctx >= 3)
+			ctx = 3;
+	}
+	se->value1 = symbol;
+#if TRACE
+	fprintf(p_trace, "@%d%s\t\t\t%d\n",
+		symbol_count++, se->tracestring, se->value1);
+	fflush(p_trace);
+#endif
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    This function is used to arithmetically decode a pair of
+ *    intra prediction modes of a given MB.
+ ************************************************************************
+ */
+int mapd_intrap[5] = {0, 2, 3, 4, 1};
+void read_intrapredmode_aec(struct syntaxelement *se, struct img_par *img,
+		struct decoding_environment_s *dep_dp)
+{
+	struct bi_context_type_s *pctx;
+	int ctx, symbol;
+	pctx = img->current_slice->tex_ctx->one_contexts[1];
+	symbol = 0;
+	ctx = 0;
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & AEC_DUMP)
+		io_printf(" -- read_intrapredmode_aec ctx : %d\n", ctx);
+#endif
+	while (biari_decode_symbol(dep_dp, pctx + ctx) == 0) {
+		symbol += 1;
+		ctx++;
+		if (ctx >= 3)
+			ctx = 3;
+#ifdef DUMP_DEBUG
+		if (avs_get_debug_flag() & AEC_DUMP)
+			io_printf(" -- read_intrapredmode_aec ctx : %d\n", ctx);
+#endif
+		if (symbol == 4)
+			break;
+		}
+	se->value1 = mapd_intrap[symbol] - 1;
+
+#if TRACE
+	fprintf(p_trace, "@%d %s\t\t\t%d\n",
+		symbol_count++, se->tracestring, se->value1);
+	fflush(p_trace);
+#endif
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    decoding of unary binarization using one or 2 distinct
+ *    models for the first and all remaining bins; no terminating
+ *    "0" for max_symbol
+ ***********************************************************************
+ */
+unsigned int unary_bin_max_decode(struct decoding_environment_s *dep_dp,
+		struct bi_context_type_s *ctx,
+		int ctx_offset, unsigned int max_symbol)
+{
+	unsigned int l;
+	unsigned int symbol;
+	struct bi_context_type_s *ictx;
+
+	symbol = biari_decode_symbol(dep_dp, ctx);
+
+	if (symbol == 0)
+		return 0;
+	else {
+		if (max_symbol == 1)
+			return symbol;
+		symbol = 0;
+		ictx = ctx + ctx_offset;
+		do {
+			l = biari_decode_symbol(dep_dp, ictx);
+			symbol++;
+		} while ((l != 0) && (symbol < max_symbol - 1));
+		if ((l != 0) && (symbol == max_symbol - 1))
+			symbol++;
+		return symbol;
+	}
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    decoding of unary binarization using one or 2 distinct
+ *    models for the first and all remaining bins
+ ***********************************************************************
+ */
+unsigned int unary_bin_decode(struct decoding_environment_s *dep_dp,
+		struct bi_context_type_s *ctx, int ctx_offset)
+{
+	unsigned int l;
+	unsigned int symbol;
+	struct bi_context_type_s *ictx;
+
+	symbol = 1 - biari_decode_symbol(dep_dp, ctx);
+
+	if (symbol == 0)
+		return 0;
+	else {
+		symbol = 0;
+		ictx = ctx + ctx_offset;
+		do {
+			l = 1 - biari_decode_symbol(dep_dp, ictx);
+			symbol++;
+		} while (l != 0);
+		return symbol;
+	}
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    This function is used to arithmetically decode the chroma
+ *    intra prediction mode of a given MB.
+ ************************************************************************
+ */
+void read_cipredmode_aec(struct syntaxelement *se,
+	struct img_par *img,
+		struct decoding_environment_s *dep_dp)
+{
+	struct texture_info_contexts *ctx = img->current_slice->tex_ctx;
+	struct macroblock *curr_mb = &mb_data[img->current_mb_nr];
+	int act_ctx, a, b;
+	int act_sym = se->value1;
+
+	if (curr_mb->mb_available_up == NULL)
+		b = 0;
+	else {
+		/*if ( (curr_mb->mb_available_up)->mb_type==IPCM)
+		 b=0;
+		 else*/
+		b = (((curr_mb->mb_available_up)->c_ipred_mode != 0) ? 1 : 0);
+	}
+
+	if (curr_mb->mb_available_left == NULL)
+		a = 0;
+	else {
+		/* if ( (curr_mb->mb_available_left)->mb_type==IPCM)
+		 a=0;
+		 else*/
+		a = (((curr_mb->mb_available_left)->c_ipred_mode != 0) ? 1 : 0);
+	}
+
+	act_ctx = a + b;
+
+
+	act_sym = biari_decode_symbol(dep_dp, ctx->cipr_contexts + act_ctx);
+
+	if (act_sym != 0)
+		act_sym = unary_bin_max_decode(dep_dp, ctx->cipr_contexts + 3,
+				0, 2) + 1;
+
+	se->value1 = act_sym;
+
+#if TRACE
+	fprintf(p_trace, "@%d %s\t\t%d\n",
+		symbol_count++, se->tracestring, se->value1);
+	fflush(p_trace);
+#endif
+
+}
+
+int slice_header(char *buf, int startcodepos, int length)
+{
+	int i;
+
+	int weight_para_num = 0;
+	int mb_row;
+	int mb_column;
+	int mb_index;
+	int mb_width, mb_height;
+
+	mb_column = 0;
+
+	memcpy(curr_stream->stream_buffer, buf, length);
+	curr_stream->code_len = curr_stream->bitstream_length = length;
+
+	curr_stream->read_len =
+	curr_stream->frame_bitoffset = (startcodepos) * 8;
+	slice_vertical_position = u_v(8, "slice vertical position");
+
+	push_es(slice_vertical_position, 8);
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & SLICE_INFO_DUMP)
+		io_printf(" * 8-bits slice_vertical_position : %d\n",
+			slice_vertical_position);
+#endif
+
+	if (vertical_size > 2800) {
+		slice_vertical_position_extension = u_v(3,
+				"slice vertical position extension");
+		push_es(slice_vertical_position_extension, 3);
+
+	}
+
+	if (vertical_size > 2800)
+		mb_row = (slice_vertical_position_extension << 7)
+				+ slice_vertical_position;
+	else
+		mb_row = slice_vertical_position;
+
+	mb_width = (horizontal_size + 15) / 16;
+	if (!progressive_sequence)
+		mb_height = 2 * ((vertical_size + 31) / 32);
+	else
+		mb_height = (vertical_size + 15) / 16;
+
+
+	mb_index = mb_row * mb_width + mb_column;
+
+	if (!img->picture_structure && img->type == I_IMG
+			&& (mb_index >= mb_width * mb_height / 2)) {
+		second_ifield = 1;
+		img->type = P_IMG;
+		pre_img_type = P_IMG;
+	}
+
+	{
+		if (!fixed_picture_qp) {
+			fixed_slice_qp = u_v(1, "fixed_slice_qp");
+			push_es(fixed_slice_qp, 1);
+#ifdef DUMP_DEBUG
+			if (avs_get_debug_flag() & SLICE_INFO_DUMP)
+				io_printf(" * 1-bit fixed_slice_qp : %d\n",
+					fixed_slice_qp);
+#endif
+			slice_qp = u_v(6, "slice_qp");
+			push_es(slice_qp, 6);
+#ifdef DUMP_DEBUG
+			if (avs_get_debug_flag() & SLICE_INFO_DUMP)
+				io_printf(" * 6-bits slice_qp : %d\n",
+					slice_qp);
+#endif
+
+			img->qp = slice_qp;
+		}
+
+		if (img->type != I_IMG) {
+			img->slice_weighting_flag = u_v(1,
+					"slice weighting flag");
+
+			if (img->slice_weighting_flag) {
+
+				if (second_ifield && !img->picture_structure)
+					weight_para_num = 1;
+				else if (img->type == P_IMG
+						&& img->picture_structure)
+					weight_para_num = 2;
+				else if (img->type == P_IMG
+						&& !img->picture_structure)
+					weight_para_num = 4;
+				else if (img->type == B_IMG
+						&& img->picture_structure)
+					weight_para_num = 2;
+				else if (img->type == B_IMG
+						&& !img->picture_structure)
+					weight_para_num = 4;
+
+#ifdef DUMP_DEBUG
+				if (avs_get_debug_flag() & SLICE_INFO_DUMP)
+					io_printf(" - weight_para_num : %d\n",
+						weight_para_num);
+#endif
+				for (i = 0; i < weight_para_num; i++) {
+					img->lum_scale[i] = u_v(8,
+							"luma scale");
+
+					img->lum_shift[i] = i_8("luma shift");
+
+					marker_bit = u_1("insert bit");
+
+
+					{
+						img->chroma_scale[i] = u_v(8,
+								"chroma scale");
+
+						img->chroma_shift[i] = i_8(
+								"chroma shift");
+
+						marker_bit = u_1("insert bit");
+
+					}
+				}
+				img->mb_weighting_flag = u_v(1,
+						"MB weighting flag");
+
+			}
+		}
+	}
+
+
+#if 1
+	return mb_index;
+#endif
+}
+
+void no_mem_exit(char *where)
+{
+	io_printf("%s\r\n", where);
+}
+
+unsigned char bit[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};
+
+struct inputstream_s {
+	/*FILE *f;*/
+	unsigned char buf[SVA_STREAM_BUF_SIZE];
+	unsigned int uclear_bits;
+	unsigned int upre_3bytes;
+	int ibyte_position;
+	int ibuf_bytesnum;
+	int iclear_bitsnum;
+	int istuff_bitsnum;
+	int ibits_count;
+};
+
+struct inputstream_s IRABS;
+struct inputstream_s *p_irabs = &IRABS;
+
+struct stat_bits {
+	int curr_frame_bits;
+	int prev_frame_bits;
+	int emulate_bits;
+	int prev_emulate_bits;
+	int last_unit_bits;
+	int bitrate;
+	int total_bitrate[1000];
+	int coded_pic_num;
+	int time_s;
+};
+
+struct stat_bits *stat_bits_ptr;
+
+unsigned char *temp_slice_buf;
+int start_codeposition;
+int first_slice_length;
+int first_slice_startpos;
+
+int bitstream_buf_used;
+int startcode_offset;
+
+int bitstream_read_ptr;
+
+int demulate_enable;
+
+int last_dquant;
+
+int total_mb_count;
+
+int current_mb_skip;
+
+int skip_mode_flag;
+
+int current_mb_intra;
+
+/*
+ *************************************************************************
+ * Function: Check start code's type
+ * Input:
+ * Output:
+ * Return:
+ * Author: XZHENG, 20080515
+ *************************************************************************
+ */
+void check_type(int startcode)
+{
+	startcode = startcode & 0x000000ff;
+	switch (startcode) {
+	case 0xb0:
+	case 0xb2:
+	case 0xb5:
+		demulate_enable = 0;
+		break;
+	default:
+		demulate_enable = 1;
+		break;
+	}
+
+}
+/*
+ *************************************************************************
+ * Function:
+ * Input:
+ * Output:
+ * Return:  0 : OK
+ -1 : arrive at stream end
+ -2 : meet another start code
+ * Attention:
+ *************************************************************************
+ */
+int clear_nextbyte(struct inputstream_s *p)
+{
+	int i, k, j;
+	unsigned char temp[3];
+	i = p->ibyte_position;
+	k = p->ibuf_bytesnum - i;
+	if (k < 3) {
+		for (j = 0; j < k; j++)
+			temp[j] = p->buf[i + j];
+
+		p->ibuf_bytesnum = read_bitstream(p->buf + k,
+				SVA_STREAM_BUF_SIZE - k);
+		bitstream_buf_used++;
+		if (p->ibuf_bytesnum == 0) {
+			if (k > 0) {
+				while (k > 0) {
+					p->upre_3bytes = ((p->upre_3bytes << 8)
+							| p->buf[i])
+							& 0x00ffffff;
+					if (p->upre_3bytes < 4
+							&& demulate_enable) {
+						p->uclear_bits =
+						(p->uclear_bits
+						<< 6)
+						| (p->buf[i]
+						>> 2);
+						p->iclear_bitsnum += 6;
+						stat_bits_ptr->emulate_bits
+						+= 2;
+					} else {
+						p->uclear_bits = (p->uclear_bits
+						<< 8)
+						| p->buf[i];
+						p->iclear_bitsnum += 8;
+					}
+					p->ibyte_position++;
+					k--;
+					i++;
+				}
+				return 0;
+			} else {
+				return -1;
+			}
+		} else {
+			for (j = 0; j < k; j++)
+				p->buf[j] = temp[j];
+			p->ibuf_bytesnum += k;
+			i = p->ibyte_position = 0;
+		}
+	}
+	if (p->buf[i] == 0 && p->buf[i + 1] == 0 && p->buf[i + 2] == 1)
+		return -2;
+	p->upre_3bytes = ((p->upre_3bytes << 8) | p->buf[i]) & 0x00ffffff;
+	if (p->upre_3bytes < 4 && demulate_enable) {
+		p->uclear_bits = (p->uclear_bits << 6) | (p->buf[i] >> 2);
+		p->iclear_bitsnum += 6;
+		stat_bits_ptr->emulate_bits += 2;
+	} else {
+		p->uclear_bits = (p->uclear_bits << 8) | p->buf[i];
+		p->iclear_bitsnum += 8;
+	}
+	p->ibyte_position++;
+	return 0;
+}
+
+/*
+ *************************************************************************
+ * Function:
+ * Input:
+ * Output:
+ * Return:  0 : OK
+ -1 : arrive at stream end
+ -2 : meet another start code
+ * Attention:
+ *************************************************************************
+ */
+int read_n_bit(struct inputstream_s *p, int n, int *v)
+{
+	int r;
+	unsigned int t;
+	while (n > p->iclear_bitsnum) {
+		r = clear_nextbyte(p);
+		if (r) {
+			if (r == -1) {
+				if (p->ibuf_bytesnum - p->ibyte_position > 0)
+					break;
+			}
+			return r;
+		}
+	}
+	t = p->uclear_bits;
+	r = 32 - p->iclear_bitsnum;
+	*v = (t << r) >> (32 - n);
+	p->iclear_bitsnum -= n;
+	return 0;
+}
+
+#ifdef AVSP_LONG_CABAC
+unsigned char TMP_BUF[2 * SVA_STREAM_BUF_SIZE];
+int tmp_buf_wr_ptr;
+int tmp_buf_rd_ptr;
+int tmp_buf_count;
+#endif
+void open_irabs(struct inputstream_s *p)
+{
+	p->uclear_bits = 0xffffffff;
+	p->ibyte_position = 0;
+	p->ibuf_bytesnum = 0;
+	p->iclear_bitsnum = 0;
+	p->istuff_bitsnum = 0;
+	p->ibits_count = 0;
+	p->upre_3bytes = 0;
+
+	bitstream_buf_used = 0;
+	bitstream_read_ptr = (src_start - 16) & 0xfffffff0;
+
+#ifdef AVSP_LONG_CABAC
+	tmp_buf_count = 0;
+	tmp_buf_wr_ptr = 0;
+	tmp_buf_rd_ptr = 0;
+#endif
+
+}
+
+void move_bitstream(unsigned int move_from_addr, unsigned int move_to_addr,
+		int move_size)
+{
+	int move_bytes_left = move_size;
+	unsigned int move_read_addr;
+	unsigned int move_write_addr = move_to_addr;
+
+	int move_byte;
+	unsigned int data32;
+
+	while (move_from_addr > vld_mem_end_addr) {
+		move_from_addr = move_from_addr + vld_mem_start_addr
+				- vld_mem_end_addr - 8;
+	}
+	move_read_addr = move_from_addr;
+	while (move_bytes_left > 0) {
+		move_byte = move_bytes_left;
+		if (move_byte > 512)
+			move_byte = 512;
+		if ((move_read_addr + move_byte) > vld_mem_end_addr)
+			move_byte = (vld_mem_end_addr + 8) - move_read_addr;
+
+		WRITE_VREG(LMEM_DMA_ADR, move_read_addr);
+		WRITE_VREG(LMEM_DMA_COUNT, move_byte / 2);
+		WRITE_VREG(LMEM_DMA_CTRL, 0xc200);
+
+		data32 = 0x8000;
+		while (data32 & 0x8000)
+			data32 = READ_VREG(LMEM_DMA_CTRL);
+
+		WRITE_VREG(LMEM_DMA_ADR, move_write_addr);
+		WRITE_VREG(LMEM_DMA_COUNT, move_byte / 2);
+		WRITE_VREG(LMEM_DMA_CTRL, 0x8200);
+
+		data32 = 0x8000;
+		while (data32 & 0x8000)
+			data32 = READ_VREG(LMEM_DMA_CTRL);
+
+		data32 = 0x0fff;
+		while (data32 & 0x0fff)
+			data32 = READ_VREG(WRRSP_LMEM);
+
+#ifdef DUMP_DEBUG
+		if (avs_get_debug_flag() & STREAM_INFO_DUMP)
+			io_printf("  2 MOVE %d Bytes from 0x%x to 0x%x\n",
+				move_byte, move_read_addr, move_write_addr);
+#endif
+
+		move_read_addr = move_read_addr + move_byte;
+		if (move_read_addr > vld_mem_end_addr)
+			move_read_addr = vld_mem_start_addr;
+		move_write_addr = move_write_addr + move_byte;
+		move_bytes_left = move_bytes_left - move_byte;
+	}
+
+}
+
+int read_bitstream(unsigned char *buf, int size)
+{
+	int i;
+
+#ifdef AVSP_LONG_CABAC
+
+	unsigned int *TMP_BUF_32 = (unsigned int *)bitstream_read_tmp;
+	if (tmp_buf_count < size) {
+		dma_sync_single_for_cpu(amports_get_dma_device(),
+				bitstream_read_tmp_phy, SVA_STREAM_BUF_SIZE,
+				DMA_FROM_DEVICE);
+
+		move_bitstream(bitstream_read_ptr, bitstream_read_tmp_phy,
+				SVA_STREAM_BUF_SIZE);
+
+		for (i = 0; i < SVA_STREAM_BUF_SIZE / 8; i++) {
+			TMP_BUF[tmp_buf_wr_ptr++] =
+					(TMP_BUF_32[2 * i + 1] >> 24) & 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+			TMP_BUF[tmp_buf_wr_ptr++] =
+					(TMP_BUF_32[2 * i + 1] >> 16) & 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+			TMP_BUF[tmp_buf_wr_ptr++] = (TMP_BUF_32[2 * i + 1] >> 8)
+					& 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+			TMP_BUF[tmp_buf_wr_ptr++] = (TMP_BUF_32[2 * i + 1] >> 0)
+					& 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+			TMP_BUF[tmp_buf_wr_ptr++] =
+					(TMP_BUF_32[2 * i + 0] >> 24) & 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+			TMP_BUF[tmp_buf_wr_ptr++] =
+					(TMP_BUF_32[2 * i + 0] >> 16) & 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+			TMP_BUF[tmp_buf_wr_ptr++] = (TMP_BUF_32[2 * i + 0] >> 8)
+					& 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+			TMP_BUF[tmp_buf_wr_ptr++] = (TMP_BUF_32[2 * i + 0] >> 0)
+					& 0xff;
+			if (tmp_buf_wr_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+				tmp_buf_wr_ptr = 0;
+		}
+		tmp_buf_count = tmp_buf_count + SVA_STREAM_BUF_SIZE;
+		bitstream_read_ptr = bitstream_read_ptr + SVA_STREAM_BUF_SIZE;
+	}
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & STREAM_INFO_DUMP)
+		io_printf(" Read %d bytes from %d, size left : %d\n",
+			size, tmp_buf_rd_ptr, tmp_buf_count);
+#endif
+	for (i = 0; i < size; i++) {
+		buf[i] = TMP_BUF[tmp_buf_rd_ptr++];
+		if (tmp_buf_rd_ptr >= (2 * SVA_STREAM_BUF_SIZE))
+			tmp_buf_rd_ptr = 0;
+	}
+	tmp_buf_count = tmp_buf_count - size;
+
+#else
+	for (i = 0; i < size; i++)
+		buf[i] = tmp_stream[bitstream_read_ptr + i];
+	bitstream_read_ptr = bitstream_read_ptr + size;
+#endif
+
+	return size;
+}
+
+int next_startcode(struct inputstream_s *p)
+{
+	int i, m;
+	unsigned char a = 0, b = 0;
+	m = 0;
+
+	while (1) {
+		if (p->ibyte_position >= p->ibuf_bytesnum - 2) {
+			m = p->ibuf_bytesnum - p->ibyte_position;
+			if (m < 0)
+				return -2;
+			if (m == 1)
+				b = p->buf[p->ibyte_position + 1];
+			if (m == 2) {
+				b = p->buf[p->ibyte_position + 1];
+				a = p->buf[p->ibyte_position];
+			}
+			p->ibuf_bytesnum = read_bitstream(p->buf,
+					SVA_STREAM_BUF_SIZE);
+			p->ibyte_position = 0;
+			bitstream_buf_used++;
+		}
+
+		if (p->ibuf_bytesnum + m < 3)
+			return -1;
+
+		if (m == 1 && b == 0 && p->buf[0] == 0 && p->buf[1] == 1) {
+			p->ibyte_position = 2;
+			p->iclear_bitsnum = 0;
+			p->istuff_bitsnum = 0;
+			p->ibits_count += 24;
+			p->upre_3bytes = 1;
+			return 0;
+		}
+
+		if (m == 2 && b == 0 && a == 0 && p->buf[0] == 1) {
+			p->ibyte_position = 1;
+			p->iclear_bitsnum = 0;
+			p->istuff_bitsnum = 0;
+			p->ibits_count += 24;
+			p->upre_3bytes = 1;
+			return 0;
+		}
+
+		if (m == 2 && b == 0 && p->buf[0] == 0 && p->buf[1] == 1) {
+			p->ibyte_position = 2;
+			p->iclear_bitsnum = 0;
+			p->istuff_bitsnum = 0;
+			p->ibits_count += 24;
+			p->upre_3bytes = 1;
+			return 0;
+		}
+
+		for (i = p->ibyte_position; i < p->ibuf_bytesnum - 2; i++) {
+			if (p->buf[i] == 0 && p->buf[i + 1] == 0
+					&& p->buf[i + 2] == 1) {
+				p->ibyte_position = i + 3;
+				p->iclear_bitsnum = 0;
+				p->istuff_bitsnum = 0;
+				p->ibits_count += 24;
+				p->upre_3bytes = 1;
+				return 0;
+			}
+			p->ibits_count += 8;
+		}
+		p->ibyte_position = i;
+	}
+}
+
+int get_oneunit(char *buf, int *startcodepos, int *length)
+{
+	int i, j, k;
+	i = next_startcode(p_irabs);
+
+	if (i != 0) {
+		if (i == -1)
+			io_printf(
+					"\narrive at stream end and start code is not found!");
+		if (i == -2)
+			io_printf("\np->ibyte_position error!");
+
+	}
+	startcode_offset =
+			p_irabs->ibyte_position
+					- 3 + (bitstream_buf_used-1)
+					* SVA_STREAM_BUF_SIZE;
+	buf[0] = 0;
+	buf[1] = 0;
+	buf[2] = 1;
+	*startcodepos = 3;
+	i = read_n_bit(p_irabs, 8, &j);
+	buf[3] = (char)j;
+
+	check_type(buf[3]);
+	if (buf[3] == SEQUENCE_END_CODE) {
+		*length = 4;
+		return -1;
+	}
+	k = 4;
+	while (1) {
+		i = read_n_bit(p_irabs, 8, &j);
+		if (i < 0)
+			break;
+		buf[k++] = (char)j;
+		if (k >= (MAX_CODED_FRAME_SIZE - 1))
+			break;
+	}
+	if (p_irabs->iclear_bitsnum > 0) {
+		int shift;
+		shift = 8 - p_irabs->iclear_bitsnum;
+		i = read_n_bit(p_irabs, p_irabs->iclear_bitsnum, &j);
+
+		if (j != 0)
+			buf[k++] = (char)(j << shift);
+		stat_bits_ptr->last_unit_bits += shift;
+	}
+	*length = k;
+	return k;
+}
+
+/*unsigned char tmp_buf[MAX_CODED_FRAME_SIZE] __attribute__ ((aligned(64)));*/
+/*unsigned char tmp_buf[MAX_CODED_FRAME_SIZE] __aligned(64);*/
+int header(void)
+{
+	unsigned char *buf;
+	int startcodepos, length;
+
+	unsigned char *tmp_buf;
+	tmp_buf = (unsigned char *)avsp_heap_adr;
+
+	buf = &tmp_buf[0];
+	while (1) {
+		start_codeposition = get_oneunit(buf, &startcodepos, &length);
+
+		switch (buf[startcodepos]) {
+		case SEQUENCE_HEADER_CODE:
+			io_printf(
+					"# SEQUENCE_HEADER_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+			break;
+		case EXTENSION_START_CODE:
+			io_printf(
+					"# EXTENSION_START_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+			break;
+		case USER_DATA_START_CODE:
+			io_printf(
+					"# USER_DATA_START_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+			break;
+		case VIDEO_EDIT_CODE:
+			io_printf(
+					"# VIDEO_EDIT_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+			break;
+		case I_PICTURE_START_CODE:
+			io_printf(
+					"# I_PICTURE_START_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+			break;
+		case PB_PICTURE_START_CODE:
+			io_printf(
+					"# PB_PICTURE_START_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+			break;
+		case SEQUENCE_END_CODE:
+			io_printf(
+					"# SEQUENCE_END_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+			break;
+		default:
+			io_printf(
+					"# SLICE_START_CODE (0x%02x) found at offset %d (0x%x)\n",
+					buf[startcodepos], startcode_offset,
+					startcode_offset);
+#if 0
+			io_printf("VLD_MEM_VIFIFO_START_PTR %x\r\n",
+					READ_VREG(VLD_MEM_VIFIFO_START_PTR));
+			io_printf("VLD_MEM_VIFIFO_CURR_PTR %x\r\n",
+					READ_VREG(VLD_MEM_VIFIFO_CURR_PTR));
+			io_printf("VLD_MEM_VIFIFO_END_PTR %x\r\n",
+					READ_VREG(VLD_MEM_VIFIFO_END_PTR));
+			io_printf("VLD_MEM_VIFIFO_WP %x\r\n"
+					READ_VREG(VLD_MEM_VIFIFO_WP));
+			io_printf("VLD_MEM_VIFIFO_RP %x\r\n",
+					READ_VREG(VLD_MEM_VIFIFO_RP));
+			io_printf("VLD_MEM_VBUF_RD_PTR %x\r\n"
+					READ_VREG(VLD_MEM_VBUF_RD_PTR));
+			io_printf("VLD_MEM_VIFIFO_BUF_CNTL %x\r\n",
+					READ_VREG(VLD_MEM_VIFIFO_BUF_CNTL));
+			io_printf("PARSER_VIDEO_HOLE %x\r\n",
+					READ_MPEG_REG(PARSER_VIDEO_HOLE));
+#endif
+			if ((buf[startcodepos] >= SLICE_START_CODE_MIN
+				&& buf[startcodepos]
+				<= SLICE_START_CODE_MAX)
+				&& ((!img->seq_header_indicate)
+				|| (img->type == B_IMG
+				&& img->b_discard_flag
+				== 1
+				&& !img->no_forward_reference))) {
+				break;
+			} else if (buf[startcodepos] >= SLICE_START_CODE_MIN) {
+
+				first_slice_length = length;
+				first_slice_startpos = startcodepos;
+
+				temp_slice_buf = &tmp_buf[0];
+				return SOP;
+			} else {
+				io_printf("Can't find start code");
+				return -EOS;
+			}
+		}
+	}
+
+}
+
+/*
+ *************************************************************************
+ * Function:Allocates a Bitstream
+ * Input:
+ * Output:allocated Bitstream point
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+struct bitstream_s *alloc_bitstream(void)
+{
+	struct bitstream_s *bitstream;
+
+	bitstream = (struct bitstream_s *)local_alloc(1,
+		sizeof(struct bitstream_s));
+	if (bitstream == NULL) {
+		io_printf(
+			"AllocBitstream: Memory allocation for Bitstream failed");
+	}
+	bitstream->stream_buffer = (unsigned char *)local_alloc(
+			MAX_CODED_FRAME_SIZE,
+			sizeof(unsigned char));
+	if (bitstream->stream_buffer == NULL) {
+		io_printf(
+				"AllocBitstream: Memory allocation for streamBuffer failed");
+	}
+
+	return bitstream;
+}
+
+void biari_init_context_logac(struct bi_context_type_s *ctx)
+{
+	ctx->LG_PMPS = (QUARTER << LG_PMPS_SHIFTNO) - 1;
+	ctx->MPS = 0;
+	ctx->cycno = 0;
+}
+
+#define BIARI_CTX_INIT1_LOG(jj, ctx)\
+{\
+	for (j = 0; j < jj; j++)\
+		biari_init_context_logac(&(ctx[j]));\
+}
+
+#define BIARI_CTX_INIT2_LOG(ii, jj, ctx)\
+{\
+	for (i = 0; i < ii; i++)\
+		for (j = 0; j < jj; j++)\
+			biari_init_context_logac(&(ctx[i][j]));\
+}
+
+#define BIARI_CTX_INIT3_LOG(ii, jj, kk, ctx)\
+{\
+	for (i = 0; i < ii; i++)\
+		for (j = 0; j < jj; j++)\
+			for (k = 0; k < kk; k++)\
+				biari_init_context_logac(&(ctx[i][j][k]));\
+}
+
+#define BIARI_CTX_INIT4_LOG(ii, jj, kk, ll, ctx)\
+{\
+	for (i = 0; i < ii; i++)\
+		for (j = 0; j < jj; j++)\
+			for (k = 0; k < kk; k++)\
+				for (l = 0; l < ll; l++)\
+					biari_init_context_logac\
+					(&(ctx[i][j][k][l]));\
+}
+
+void init_contexts(struct img_par *img)
+{
+	struct motion_info_contexts_s *mc = img->current_slice->mot_ctx;
+	struct texture_info_contexts *tc = img->current_slice->tex_ctx;
+	int i, j;
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & SLICE_INFO_DUMP)
+		io_printf(" ---- init_contexts ----\n");
+#endif
+
+	BIARI_CTX_INIT2_LOG(3, NUM_MB_TYPE_CTX, mc->mb_type_contexts);
+	BIARI_CTX_INIT2_LOG(2, NUM_B8_TYPE_CTX, mc->b8_type_contexts);
+	BIARI_CTX_INIT2_LOG(2, NUM_MV_RES_CTX, mc->mv_res_contexts);
+	BIARI_CTX_INIT2_LOG(2, NUM_REF_NO_CTX, mc->ref_no_contexts);
+	BIARI_CTX_INIT1_LOG(NUM_DELTA_QP_CTX, mc->delta_qp_contexts);
+	BIARI_CTX_INIT1_LOG(NUM_MB_AFF_CTX, mc->mb_aff_contexts);
+
+	BIARI_CTX_INIT1_LOG(NUM_IPR_CTX, tc->ipr_contexts);
+	BIARI_CTX_INIT1_LOG(NUM_CIPR_CTX, tc->cipr_contexts);
+	BIARI_CTX_INIT2_LOG(3, NUM_CBP_CTX, tc->cbp_contexts);
+	BIARI_CTX_INIT2_LOG(NUM_BLOCK_TYPES, NUM_BCBP_CTX, tc->bcbp_contexts);
+	BIARI_CTX_INIT2_LOG(NUM_BLOCK_TYPES, NUM_ONE_CTX, tc->one_contexts);
+	BIARI_CTX_INIT2_LOG(NUM_BLOCK_TYPES, NUM_ABS_CTX, tc->abs_contexts);
+	BIARI_CTX_INIT2_LOG(NUM_BLOCK_TYPES, NUM_MAP_CTX, tc->fld_map_contexts);
+	BIARI_CTX_INIT2_LOG(NUM_BLOCK_TYPES, NUM_LAST_CTX,
+			tc->fld_last_contexts);
+	BIARI_CTX_INIT2_LOG(NUM_BLOCK_TYPES, NUM_MAP_CTX, tc->map_contexts);
+	BIARI_CTX_INIT2_LOG(NUM_BLOCK_TYPES, NUM_LAST_CTX, tc->last_contexts);
+#ifdef TEST_WEIGHTING_AEC
+	biari_init_context_logac(&mc->mb_weighting_pred);
+#endif
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Allocation of contexts models for the motion info
+ *    used for arithmetic decoding
+ *
+ ************************************************************************
+ */
+struct motion_info_contexts_s *create_contexts_motioninfo(void)
+{
+	struct motion_info_contexts_s *deco_ctx;
+
+	deco_ctx = (struct motion_info_contexts_s *)local_alloc(1,
+			sizeof(struct motion_info_contexts_s));
+	if (deco_ctx == NULL)
+		no_mem_exit("create_contexts_motioninfo: deco_ctx");
+
+	return deco_ctx;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Allocates of contexts models for the texture info
+ *    used for arithmetic decoding
+ ************************************************************************
+ */
+struct texture_info_contexts *create_contexts_textureinfo(void)
+{
+	struct texture_info_contexts *deco_ctx;
+
+	deco_ctx = (struct texture_info_contexts *)local_alloc(1,
+			sizeof(struct texture_info_contexts));
+	if (deco_ctx == NULL)
+		no_mem_exit("create_contexts_textureinfo: deco_ctx");
+
+	return deco_ctx;
+}
+
+struct datapartition *alloc_partition(int n)
+{
+	struct datapartition *part_arr, *datapart;
+	int i;
+
+	part_arr =
+	(struct datapartition *)local_alloc(n, sizeof(struct datapartition));
+	if (part_arr == NULL) {
+		no_mem_exit(
+				"alloc_partition: Memory allocation for Data Partition failed");
+	}
+
+#if LIWR_FIX
+	part_arr[0].bitstream = NULL;
+#else
+	for (i = 0; i < n; i++) {
+		datapart = &(part_arr[i]);
+		datapart->bitstream = (struct bitstream_s *)local_alloc(1,
+				sizeof(struct bitstream_s));
+		if (datapart->bitstream == NULL) {
+			no_mem_exit(
+					"alloc_partition: Memory allocation for Bitstream failed");
+		}
+	}
+#endif
+	return part_arr;
+}
+
+void malloc_slice(struct img_par *img)
+{
+	struct slice_s *currslice;
+
+	img->current_slice =
+	(struct slice_s *)local_alloc(1, sizeof(struct slice_s));
+	currslice = img->current_slice;
+	if (currslice == NULL)
+		no_mem_exit(
+			"Memory allocation for struct slice_s datastruct Failed"
+			);
+	if (1) {
+
+		currslice->mot_ctx = create_contexts_motioninfo();
+		currslice->tex_ctx = create_contexts_textureinfo();
+	}
+#if LIWR_FIX
+	currslice->max_part_nr = 1;
+#else
+	currslice->max_part_nr = 3;
+#endif
+	currslice->part_arr = alloc_partition(currslice->max_part_nr);
+}
+
+void init(struct img_par *img)
+{
+	int i;
+
+	for (i = 0; i < 256; i++)
+		img->quad[i] = i * i;
+}
+
+/*
+ *************************************************************************
+ * Function:Allocate 2D memory array -> int array2D[rows][columns]
+ * Input:
+ * Output: memory size in bytes
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+int get_mem2Dint(int ***array2D, int rows, int columns)
+{
+	int i;
+
+	*array2D = (int **)local_alloc(rows, sizeof(int *));
+	if (*array2D == NULL)
+		no_mem_exit("get_mem2Dint: array2D");
+	(*array2D)[0] = (int *)local_alloc(rows * columns, sizeof(int));
+	if ((*array2D)[0] == NULL)
+		no_mem_exit("get_mem2Dint: array2D");
+
+	for (i = 1; i < rows; i++)
+		(*array2D)[i] = (*array2D)[i - 1] + columns;
+
+	return rows * columns * sizeof(int);
+}
+
+void initial_decode(void)
+{
+	int i, j;
+	int img_height = (vertical_size + img->auto_crop_bottom);
+	int memory_size = 0;
+
+	malloc_slice(img);
+	mb_data = (struct macroblock *)local_alloc(
+			(img->width / MB_BLOCK_SIZE)
+			* (img_height /*vertical_size*/
+			/ MB_BLOCK_SIZE), sizeof(struct macroblock));
+	if (mb_data == NULL)
+		no_mem_exit("init_global_buffers: mb_data");
+
+	if (progressive_sequence)
+		memory_size += get_mem2Dint(&(img->ipredmode),
+				img->width / B8_SIZE * 2 + 4,
+				vertical_size / B8_SIZE * 2 + 4);
+	else
+		memory_size += get_mem2Dint(&(img->ipredmode),
+				img->width / B8_SIZE * 2 + 4,
+				(vertical_size + 32) / (2 * B8_SIZE) * 4 + 4);
+
+	for (i = 0; i < img->width / (B8_SIZE) * 2 + 4; i++) {
+		for (j = 0; j < img->height / (B8_SIZE) * 2 + 4; j++)
+			img->ipredmode[i][j] = -1;
+	}
+
+	init(img);
+	img->number = 0;
+	img->type = I_IMG;
+	img->imgtr_last_p = 0;
+	img->imgtr_next_p = 0;
+
+	img->new_seq_header_flag = 1;
+	img->new_sequence_flag = 1;
+
+}
+
+void aec_new_slice(void)
+{
+	last_dquant = 0;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Initializes the DecodingEnvironment for the arithmetic coder
+ ************************************************************************
+ */
+
+void arideco_start_decoding(struct decoding_environment_s *dep,
+	unsigned char *cpixcode,
+		int firstbyte, int *cpixcode_len, int slice_type)
+{
+
+	dcodestrm = cpixcode;
+	dcodestrm_len = cpixcode_len;
+	*dcodestrm_len = firstbyte;
+
+	s1 = 0;
+	t1 = QUARTER - 1;
+	value_s = 0;
+
+	value_t = 0;
+
+	{
+		int i;
+		dbits_to_go = 0;
+		for (i = 0; i < B_BITS - 1; i++) {
+			if (--dbits_to_go < 0)
+				get_byte();
+
+			value_t = (value_t << 1)
+					| ((dbuffer >> dbits_to_go) & 0x01);
+		}
+	}
+
+	while (value_t < QUARTER) {
+		if (--dbits_to_go < 0)
+			get_byte();
+
+		value_t = (value_t << 1) | ((dbuffer >> dbits_to_go) & 0x01);
+		value_s++;
+	}
+	value_t = value_t & 0xff;
+
+	dec_final = dec_bypass = 0;
+
+
+
+}
+
+/*
+ *************************************************************************
+ * Function:Checks the availability of neighboring macroblocks of
+ the current macroblock for prediction and context determination;
+ marks the unavailable MBs for intra prediction in the
+ ipredmode-array by -1. Only neighboring MBs in the causal
+ past of the current MB are checked.
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void checkavailabilityofneighbors(struct img_par *img)
+{
+	int i, j;
+	const int mb_width = img->width / MB_BLOCK_SIZE;
+	const int mb_nr = img->current_mb_nr;
+	struct macroblock *curr_mb = &mb_data[mb_nr];
+	int check_value;
+	int remove_prediction;
+
+	curr_mb->mb_available_up = NULL;
+	curr_mb->mb_available_left = NULL;
+
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			mb_data[mb_nr].mb_available[i][j] = NULL;
+
+	mb_data[mb_nr].mb_available[1][1] = curr_mb;
+
+	if (img->pix_x >= MB_BLOCK_SIZE) {
+		remove_prediction = curr_mb->slice_nr
+				!= mb_data[mb_nr - 1].slice_nr;
+
+		if (remove_prediction)
+
+		{
+
+			img->ipredmode[(img->block_x + 1) * 2 - 1][(img->block_y
+					+ 1) * 2] = -1;
+			img->ipredmode[(img->block_x + 1) * 2 - 1][(img->block_y
+					+ 1) * 2 + 1] = -1;
+			img->ipredmode[(img->block_x + 1) * 2 - 1][(img->block_y
+					+ 2) * 2] = -1;
+			img->ipredmode[(img->block_x + 1) * 2 - 1][(img->block_y
+					+ 2) * 2 + 1] = -1;
+		}
+		if (!remove_prediction)
+			curr_mb->mb_available[1][0] = &(mb_data[mb_nr - 1]);
+
+	}
+
+	check_value = (img->pix_y >= MB_BLOCK_SIZE);
+	if (check_value) {
+		remove_prediction = curr_mb->slice_nr
+				!= mb_data[mb_nr - mb_width].slice_nr;
+
+		if (remove_prediction) {
+			img->ipredmode
+			[(img->block_x + 1) * 2][(img->block_y + 1)
+					* 2 - 1] = -1;
+			img->ipredmode[(img->block_x + 1) * 2 + 1][(img->block_y
+					+ 1) * 2 - 1] = -1;
+			img->ipredmode[(img->block_x + 1) * 2 + 2][(img->block_y
+					+ 1) * 2 - 1] = -1;
+			img->ipredmode[(img->block_x + 1) * 2 + 3][(img->block_y
+					+ 1) * 2 - 1] = -1;
+		}
+
+		if (!remove_prediction) {
+			curr_mb->mb_available[0][1] =
+					&(mb_data[mb_nr - mb_width]);
+		}
+	}
+
+	if (img->pix_y >= MB_BLOCK_SIZE && img->pix_x >= MB_BLOCK_SIZE) {
+		remove_prediction = curr_mb->slice_nr
+				!= mb_data[mb_nr - mb_width - 1].slice_nr;
+
+		if (remove_prediction) {
+			img->ipredmode[img->block_x * 2 + 1][img->block_y * 2
+					+ 1] = -1;
+		}
+		if (!remove_prediction) {
+			curr_mb->mb_available[0][0] = &(mb_data[mb_nr - mb_width
+					- 1]);
+		}
+	}
+
+	if (img->pix_y >= MB_BLOCK_SIZE
+			&& img->pix_x < (img->width - MB_BLOCK_SIZE)) {
+		if (curr_mb->slice_nr == mb_data[mb_nr - mb_width + 1].slice_nr)
+			curr_mb->mb_available[0][2] = &(mb_data[mb_nr - mb_width
+					+ 1]);
+	}
+
+	if (1) {
+		curr_mb->mbaddr_a = mb_nr - 1;
+		curr_mb->mbaddr_b = mb_nr - img->pic_width_inmbs;
+		curr_mb->mbaddr_c = mb_nr - img->pic_width_inmbs + 1;
+		curr_mb->mbaddr_d = mb_nr - img->pic_width_inmbs - 1;
+
+		curr_mb->mbavail_a =
+		(curr_mb->mb_available[1][0] != NULL) ? 1 : 0;
+		curr_mb->mbavail_b =
+		(curr_mb->mb_available[0][1] != NULL) ? 1 : 0;
+		curr_mb->mbavail_c =
+		(curr_mb->mb_available[0][2] != NULL) ? 1 : 0;
+		curr_mb->mbavail_d =
+		(curr_mb->mb_available[0][0] != NULL) ? 1 : 0;
+
+	}
+
+}
+
+void checkavailabilityofneighborsaec(void)
+{
+
+	int i, j;
+	const int mb_width = img->width / MB_BLOCK_SIZE;
+	const int mb_nr = img->current_mb_nr;
+	struct macroblock *curr_mb = &(mb_data[mb_nr]);
+	int check_value;
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			mb_data[mb_nr].mb_available[i][j] = NULL;
+	mb_data[mb_nr].mb_available[1][1] = &(mb_data[mb_nr]);
+
+	if (img->pix_x >= MB_BLOCK_SIZE) {
+		int remove_prediction = curr_mb->slice_nr
+				!= mb_data[mb_nr - 1].slice_nr;
+		if (!remove_prediction)
+			curr_mb->mb_available[1][0] = &(mb_data[mb_nr - 1]);
+	}
+
+	check_value = (img->pix_y >= MB_BLOCK_SIZE);
+	if (check_value) {
+		int remove_prediction = curr_mb->slice_nr
+				!= mb_data[mb_nr - mb_width].slice_nr;
+
+		if (!remove_prediction) {
+			curr_mb->mb_available[0][1] =
+					&(mb_data[mb_nr - mb_width]);
+		}
+	}
+
+	if (img->pix_y >= MB_BLOCK_SIZE && img->pix_x >= MB_BLOCK_SIZE) {
+		int remove_prediction = curr_mb->slice_nr
+				!= mb_data[mb_nr - mb_width - 1].slice_nr;
+		if (!remove_prediction) {
+			curr_mb->mb_available[0][0] = &(mb_data[mb_nr - mb_width
+					- 1]);
+		}
+	}
+
+	if (img->pix_y >= MB_BLOCK_SIZE
+			&& img->pix_x < (img->width - MB_BLOCK_SIZE)) {
+		if (curr_mb->slice_nr == mb_data[mb_nr - mb_width + 1].slice_nr)
+			curr_mb->mb_available[0][2] = &(mb_data[mb_nr - mb_width
+					+ 1]);
+	}
+	curr_mb->mb_available_left = curr_mb->mb_available[1][0];
+	curr_mb->mb_available_up = curr_mb->mb_available[0][1];
+	curr_mb->mbaddr_a = mb_nr - 1;
+	curr_mb->mbaddr_b = mb_nr - img->pic_width_inmbs;
+	curr_mb->mbaddr_c = mb_nr - img->pic_width_inmbs + 1;
+	curr_mb->mbaddr_d = mb_nr - img->pic_width_inmbs - 1;
+
+	curr_mb->mbavail_a = (curr_mb->mb_available[1][0] != NULL) ? 1 : 0;
+	curr_mb->mbavail_b = (curr_mb->mb_available[0][1] != NULL) ? 1 : 0;
+	curr_mb->mbavail_c = (curr_mb->mb_available[0][2] != NULL) ? 1 : 0;
+	curr_mb->mbavail_d = (curr_mb->mb_available[0][0] != NULL) ? 1 : 0;
+}
+
+/*
+ *************************************************************************
+ * Function:initializes the current macroblock
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void start_macroblock(struct img_par *img)
+{
+	int i, j, k, l;
+	struct macroblock *curr_mb;
+
+#ifdef AVSP_LONG_CABAC
+#else
+
+#endif
+
+	curr_mb = &mb_data[img->current_mb_nr];
+
+	/* Update coordinates of the current macroblock */
+	img->mb_x = (img->current_mb_nr) % (img->width / MB_BLOCK_SIZE);
+	img->mb_y = (img->current_mb_nr) / (img->width / MB_BLOCK_SIZE);
+
+#ifdef DUMP_DEBUG
+	if (avs_get_debug_flag() & MB_NUM_DUMP)
+		io_printf(" #Begin MB : %d, (%x, %x) es_ptr %d\n",
+			img->current_mb_nr, img->mb_x, img->mb_y, es_ptr);
+#endif
+
+
+	total_mb_count = total_mb_count + 1;
+
+	/* Define vertical positions */
+	img->block_y = img->mb_y * BLOCK_SIZE / 2; /* luma block position */
+	img->block8_y = img->mb_y * BLOCK_SIZE / 2;
+	img->pix_y = img->mb_y * MB_BLOCK_SIZE; /* luma macroblock position */
+	if (chroma_format == 2)
+		img->pix_c_y = img->mb_y *
+		MB_BLOCK_SIZE; /* chroma macroblock position */
+	else
+		img->pix_c_y = img->mb_y *
+		MB_BLOCK_SIZE / 2; /* chroma macroblock position */
+
+	/* Define horizontal positions */
+	img->block_x = img->mb_x * BLOCK_SIZE / 2; /* luma block position */
+	img->block8_x = img->mb_x * BLOCK_SIZE / 2;
+	img->pix_x = img->mb_x * MB_BLOCK_SIZE; /* luma pixel position */
+	img->pix_c_x = img->mb_x *
+	MB_BLOCK_SIZE / 2; /* chroma pixel position */
+
+	checkavailabilityofneighbors(img);
+
+	/*<!*******EDIT START BY lzhang ******************/
+
+	if (1)
+		checkavailabilityofneighborsaec();
+	/*<!*******EDIT end BY lzhang ******************/
+
+	curr_mb->qp = img->qp;
+	curr_mb->mb_type = 0;
+	curr_mb->delta_quant = 0;
+	curr_mb->cbp = 0;
+	curr_mb->cbp_blk = 0;
+	curr_mb->c_ipred_mode = DC_PRED_8;
+	curr_mb->c_ipred_mode_2 = DC_PRED_8;
+
+	for (l = 0; l < 2; l++)
+		for (j = 0; j < BLOCK_MULTIPLE; j++)
+			for (i = 0; i < BLOCK_MULTIPLE; i++)
+				for (k = 0; k < 2; k++)
+					curr_mb->mvd[l][j][i][k] = 0;
+
+	curr_mb->cbp_bits = 0;
+
+	for (j = 0; j < MB_BLOCK_SIZE; j++)
+		for (i = 0; i < MB_BLOCK_SIZE; i++)
+			img->m7[i][j] = 0;
+
+	for (j = 0; j < 2 * BLOCK_SIZE; j++)
+		for (i = 0; i < 2 * BLOCK_SIZE; i++) {
+			img->m8[0][i][j] = 0;
+			img->m8[1][i][j] = 0;
+			img->m8[2][i][j] = 0;
+			img->m8[3][i][j] = 0;
+		}
+
+	curr_mb->lf_disable = 1;
+
+	img->weighting_prediction = 0;
+}
+
+/*
+ *************************************************************************
+ * Function:init macroblock I and P frames
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void init_macroblock(struct img_par *img)
+{
+	int i, j;
+
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++) {
+			img->ipredmode[img->block_x * 2 + i + 2][img->block_y
+					* 2 + j + 2] = -1;
+		}
+	}
+
+}
+
+/*
+ *************************************************************************
+ * Function:Interpret the mb mode for I-Frames
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void interpret_mb_mode_i(struct img_par *img)
+{
+	int i;
+
+	struct macroblock *curr_mb = &mb_data[img->current_mb_nr];
+	int num = 4;
+
+	curr_mb->mb_type = I8MB;
+
+
+	current_mb_intra = 1;
+
+	for (i = 0; i < 4; i++) {
+		curr_mb->b8mode[i] = IBLOCK;
+		curr_mb->b8pdir[i] = -1;
+	}
+
+	for (i = num; i < 4; i++) {
+		curr_mb->b8mode[i] =
+				curr_mb->mb_type_2 == P8x8 ?
+						4 : curr_mb->mb_type_2;
+		curr_mb->b8pdir[i] = 0;
+	}
+}
+
+const int pred_4x4[9][9] = {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 1, 1, 1, 1, 1, 1,
+		1, 1}, {0, 1, 2, 3, 4, 5, 6, 7, 8}, {0, 0, 0, 3, 3, 3, 3, 3, 3},
+		{0, 1, 4, 4, 4, 4, 4, 4, 4}, {0, 1, 5, 5, 5, 5, 5, 5, 5}, {0, 0,
+				0, 0, 0, 0, 6, 0, 0},
+		{0, 1, 7, 7, 7, 7, 7, 7, 7}, {0, 0, 0, 0, 4, 5, 6, 7, 8}
+
+};
+
+const int pred_4x4to8x8[9] = {0, 1, 2, 3, 4, 1, 0, 1, 0
+
+};
+
+const int pred_8x8to4x4[5] = {0, 1, 2, 3, 4};
+
+void read_ipred_block_modes(struct img_par *img, int b8)
+{
+	int bi, bj, dec;
+	struct syntaxelement curr_se;
+	struct macroblock *curr_mb;
+	int j2;
+	int mostprobableintrapredmode;
+	int upintrapredmode;
+	int uprightintrapredmode;
+	int leftintrapredmode;
+	int leftdownintrapredmode;
+	int intrachromapredmodeflag;
+
+	struct slice_s *currslice = img->current_slice;
+	struct datapartition *dp;
+
+	curr_mb = mb_data + img->current_mb_nr;
+	intrachromapredmodeflag = IS_INTRA(curr_mb);
+
+	curr_se.type = SE_INTRAPREDMODE;
+#if TRACE
+	strncpy(curr_se.tracestring, "Ipred Mode", TRACESTRING_SIZE);
+#endif
+
+	if (b8 < 4) {
+		if (curr_mb->b8mode[b8] == IBLOCK) {
+			intrachromapredmodeflag = 1;
+
+			if (1) {
+				dp = &(currslice->part_arr[0]);
+				curr_se.reading = read_intrapredmode_aec;
+				dp->read_syntax_element(&curr_se, img, dp);
+
+				if (curr_se.value1 == -1)
+					push_es(1, 1);
+				else
+					push_es(curr_se.value1, 3);
+
+
+			}
+			bi = img->block_x + (b8 & 1);
+			bj = img->block_y + (b8 / 2);
+
+			upintrapredmode = img->ipredmode[(bi + 1) * 2][(bj) * 2
+					+ 1];
+			uprightintrapredmode =
+					img->ipredmode[(bi + 1) * 2 + 1][(bj)
+							* 2 + 1];
+			leftintrapredmode =
+					img->ipredmode[(bi) * 2 + 1][(bj + 1)
+							* 2];
+			leftdownintrapredmode = img->ipredmode[(bi) * 2 + 1][(bj
+					+ 1) * 2 + 1];
+
+			if ((upintrapredmode < 0) || (leftintrapredmode < 0)) {
+				mostprobableintrapredmode = DC_PRED;
+			} else if ((upintrapredmode < NO_INTRA_PMODE)
+					&& (leftintrapredmode <
+						NO_INTRA_PMODE)) {
+				mostprobableintrapredmode =
+					upintrapredmode
+					< leftintrapredmode ?
+					upintrapredmode :
+					leftintrapredmode;
+			} else if (upintrapredmode < NO_INTRA_PMODE) {
+				mostprobableintrapredmode = upintrapredmode;
+			} else if (leftintrapredmode < NO_INTRA_PMODE) {
+				mostprobableintrapredmode = leftintrapredmode;
+			} else {
+				mostprobableintrapredmode =
+					pred_4x4[leftintrapredmode
+					- INTRA_PMODE_4x4][upintrapredmode
+					- INTRA_PMODE_4x4];
+				mostprobableintrapredmode =
+				pred_4x4to8x8[mostprobableintrapredmode];
+			}
+
+
+
+			dec =
+					(curr_se.value1 == -1) ?
+					mostprobableintrapredmode :
+					curr_se.value1
+					+ (curr_se.value1
+					>= mostprobableintrapredmode);
+
+#ifdef DUMP_DEBUG
+			if (avs_get_debug_flag() & MB_INFO_DUMP)
+				io_printf(" - ipredmode[%d] : %d\n", b8, dec);
+#endif
+
+			img->ipredmode[(1 + bi) * 2][(1 + bj) * 2] = dec;
+			img->ipredmode[(1 + bi) * 2 + 1][(1 + bj) * 2] = dec;
+			img->ipredmode[(1 + bi) * 2][(1 + bj) * 2 + 1] = dec;
+			img->ipredmode[(1 + bi) * 2 + 1][(1 + bj) * 2 + 1] =
+					dec;
+
+			j2 = bj;
+		}
+	} else if (b8 == 4 && curr_mb->b8mode[b8 - 3] == IBLOCK) {
+
+		curr_se.type = SE_INTRAPREDMODE;
+#if TRACE
+		strncpy(curr_se.tracestring,
+			"Chroma intra pred mode", TRACESTRING_SIZE);
+#endif
+
+		if (1) {
+			dp = &(currslice->part_arr[0]);
+			curr_se.reading = read_cipredmode_aec;
+			dp->read_syntax_element(&curr_se, img, dp);
+		} else
+
+		{
+		}
+		curr_mb->c_ipred_mode = curr_se.value1;
+
+		push_es(UE[curr_se.value1][0], UE[curr_se.value1][1]);
+
+#ifdef DUMP_DEBUG
+		if (avs_get_debug_flag() & MB_INFO_DUMP)
+			io_printf(" * UE c_ipred_mode read : %d\n",
+				curr_mb->c_ipred_mode);
+#endif
+
+		if (curr_se.value1 < DC_PRED_8 || curr_se.value1 > PLANE_8) {
+#ifdef DUMP_DEBUG
+			if (avs_get_debug_flag() & MB_INFO_DUMP)
+				io_printf("%d\n", img->current_mb_nr);
+#endif
+			pr_info("illegal chroma intra pred mode!\n");
+		}
+	}
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    This function is used to arithmetically decode the coded
+ *    block pattern of a given MB.
+ ************************************************************************
+ */
+void readcp_aec(struct syntaxelement *se, struct img_par *img,
+		struct decoding_environment_s *dep_dp)
+{
+	struct texture_info_contexts *ctx = img->current_slice->tex_ctx;
+	struct macroblock *curr_mb = &mb_data[img->current_mb_nr];
+
+	int mb_x, mb_y;
+	int a, b;
+	int curr_cbp_ctx, curr_cbp_idx;
+	int cbp = 0;
+	int cbp_bit;
+	int mask;
+
+	for (mb_y = 0; mb_y < 4; mb_y += 2) {
+		for (mb_x = 0; mb_x < 4; mb_x += 2) {
+			if (curr_mb->b8mode[mb_y + (mb_x / 2)] == IBLOCK)
+				curr_cbp_idx = 0;
+			else
+				curr_cbp_idx = 1;
+
+			if (mb_y == 0) {
+				if (curr_mb->mb_available_up == NULL)
+					b = 0;
+				else {
+					b = ((((curr_mb->mb_available_up)->cbp
+							& (1 << (2 + mb_x / 2)))
+							== 0) ? 1 : 0);
+				}
+
+			} else
+				b = (((cbp & (1 << (mb_x / 2))) == 0) ? 1 : 0);
+
+			if (mb_x == 0) {
+				if (curr_mb->mb_available_left == NULL)
+					a = 0;
+				else {
+					a =
+					((((curr_mb->mb_available_left)->cbp
+					& (1
+					<< (2
+					* (mb_y
+					/ 2)
+					+ 1)))
+					== 0) ?
+					1 : 0);
+				}
+			} else
+				a = (((cbp & (1 << mb_y)) == 0) ? 1 : 0);
+			curr_cbp_ctx = a + 2 * b;
+			mask = (1 << (mb_y + mb_x / 2));
+			cbp_bit = biari_decode_symbol(dep_dp,
+					ctx->cbp_contexts[0] + curr_cbp_ctx);
+
+			if (cbp_bit)
+				cbp += mask;
+		}
+	}
+	curr_cbp_ctx = 0;
+	cbp_bit = biari_decode_symbol(dep_dp,
+			ctx->cbp_contexts[1] + curr_cbp_ctx);
+
+	if (cbp_bit) {
+		curr_cbp_ctx = 1;
+		cbp_bit = biari_decode_symbol(dep_dp,
+				ctx->cbp_contexts[1] + curr_cbp_ctx);
+		if (cbp_bit) {
+			cbp += 48;
+
+		} else {
+			curr_cbp_ctx = 1;
+			cbp_bit = biari_decode_symbol(dep_dp,
+					ctx->cbp_contexts[1] + curr_cbp_ctx);
+			cbp += (cbp_bit == 1) ? 32 : 16;
+
+		}
+	}
+
+	se->value1 = cbp;
+	if (!cbp)
+		last_dquant = 0;
+
+
+
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    This function is used to arithmetically decode the delta qp
+ *     of a given MB.
+ ************************************************************************
+ */
+void readdquant_aec(struct syntaxelement *se, struct img_par *img,
+		struct decoding_environment_s *dep_dp)
+{
+	struct motion_info_contexts_s *ctx = img->current_slice->mot_ctx;
+
+	int act_ctx;
+	int act_sym;
+	int dquant;
+
+
+	act_ctx = ((last_dquant != 0) ? 1 : 0);
+
+	act_sym = 1
+			- biari_decode_symbol(dep_dp,
+					ctx->delta_qp_contexts + act_ctx);
+	if (act_sym != 0) {
+		act_ctx = 2;
+		act_sym = unary_bin_decode(dep_dp,
+				ctx->delta_qp_contexts + act_ctx, 1);
+		act_sym++;
+	}
+	act_sym &= 0x3f;
+	push_es(UE[act_sym][0], UE[act_sym][1]);
+
+	dquant = (act_sym + 1) / 2;
+	if ((act_sym & 0x01) == 0)
+		dquant = -dquant;
+	se->value1 = dquant;
+
+	last_dquant = dquant;
+
+}
+
+int csyntax;
+
+#define CHECKDELTAQP {\
+	if (img->qp+curr_mb->delta_quant > 63\
+			|| img->qp+curr_mb->delta_quant < 0) {\
+		csyntax = 0;\
+		transcoding_error_flag = 1;\
+		io_printf("error(0) (%3d|%3d) @ MB%d\n",\
+			curr_mb->delta_quant,\
+			img->qp+curr_mb->delta_quant,\
+			img->picture_structure == 0 \
+			? img->current_mb_nr_fld : img->current_mb_nr);\
+		} }
+
+int dct_level[65];
+int dct_run[65];
+int pair_pos;
+int dct_pairs = -1;
+const int t_chr[5] = {0, 1, 2, 4, 3000};
+
+void readrunlevel_aec_ref(struct syntaxelement *se, struct img_par *img,
+		struct decoding_environment_s *dep_dp)
+{
+	int pairs, rank, pos;
+	int run, level, abslevel, symbol;
+	int sign;
+
+	if (dct_pairs < 0) {
+		struct bi_context_type_s (*primary)[NUM_MAP_CTX];
+		struct bi_context_type_s *pctx;
+		struct bi_context_type_s *pCTX2;
+		int ctx, ctx2, offset;
+		if (se->context == LUMA_8x8) {
+			if (img->picture_structure == 0) {
+				primary =
+				img->current_slice->tex_ctx->fld_map_contexts;
+			} else {
+				primary =
+				img->current_slice->tex_ctx->map_contexts;
+			}
+		} else {
+			if (img->picture_structure == 0) {
+				primary =
+				img->current_slice->tex_ctx->fld_last_contexts;
+			} else {
+				primary =
+				img->current_slice->tex_ctx->last_contexts;
+			}
+		}
+
+		rank = 0;
+		pos = 0;
+		for (pairs = 0; pairs < 65; pairs++) {
+#ifdef DECODING_SANITY_CHECK
+			/*max index is NUM_BLOCK_TYPES - 1*/
+			pctx = primary[rank & 0x7];
+#else
+			pctx = primary[rank];
+#endif
+			if (rank > 0) {
+#ifdef DECODING_SANITY_CHECK
+				/*max index is NUM_BLOCK_TYPES - 1*/
+				pCTX2 = primary[(5 + (pos >> 5)) & 0x7];
+#else
+				pCTX2 = primary[5 + (pos >> 5)];
+#endif
+				ctx2 = (pos >> 1) & 0x0f;
+				ctx = 0;
+
+
+				if (biari_decode_symbolw(dep_dp, pctx + ctx,
+						pCTX2 + ctx2)) {
+					break;
+				}
+			}
+
+			ctx = 1;
+			symbol = 0;
+			while (biari_decode_symbol(dep_dp, pctx + ctx) == 0) {
+				symbol += 1;
+				ctx++;
+				if (ctx >= 2)
+					ctx = 2;
+			}
+			abslevel = symbol + 1;
+
+			if (biari_decode_symbol_eq_prob(dep_dp)) {
+				level = -abslevel;
+				sign = 1;
+			} else {
+				level = abslevel;
+				sign = 0;
+			}
+#if TRACE
+			tracebits2("level", 1, level);
+#endif
+
+			if (abslevel == 1)
+				offset = 4;
+			else
+				offset = 6;
+			symbol = 0;
+			ctx = 0;
+			while (biari_decode_symbol(dep_dp, pctx + ctx + offset)
+					== 0) {
+				symbol += 1;
+				ctx++;
+				if (ctx >= 1)
+					ctx = 1;
+			}
+			run = symbol;
+
+#if TRACE
+			tracebits2("run", 1, run);
+#endif
+			dct_level[pairs] = level;
+			dct_run[pairs] = run;
+			if (abslevel > t_chr[rank]) {
+				if (abslevel <= 2)
+					rank = abslevel;
+				else if (abslevel <= 4)
+					rank = 3;
+				else
+					rank = 4;
+			}
+			pos += (run + 1);
+			if (pos >= 64)
+				pos = 63;
+		}
+		dct_pairs = pairs;
+		pair_pos = dct_pairs;
+	}
+
+	if (dct_pairs > 0) {
+		se->value1 = dct_level[pair_pos - 1];
+		se->value2 = dct_run[pair_pos - 1];
+		pair_pos--;
+	} else {
+
+		se->value1 = se->value2 = 0;
+	}
+
+	if ((dct_pairs--) == 0)
+		pair_pos = 0;
+}
+
+int b8_ctr;
+#if 0
+int curr_residual_chroma[4][16][16];
+int curr_residual_luma[16][16];
+#endif
+
+const int SCAN[2][64][2] = {{{0, 0}, {0, 1}, {0, 2}, {1, 0}, {0, 3}, {0, 4}, {1,
+		1}, {1, 2}, {0, 5}, {0, 6}, {1, 3}, {2, 0}, {2, 1}, {0, 7}, {1,
+		4}, {2, 2}, {3, 0}, {1, 5}, {1, 6}, {2, 3}, {3, 1}, {3, 2}, {4,
+		0}, {1, 7}, {2, 4}, {4, 1}, {2, 5}, {3, 3}, {4, 2}, {2, 6}, {3,
+		4}, {4, 3}, {5, 0}, {5, 1}, {2, 7}, {3, 5}, {4, 4}, {5, 2}, {6,
+		0}, {5, 3}, {3, 6}, {4, 5}, {6, 1}, {6, 2}, {5, 4}, {3, 7}, {4,
+		6}, {6, 3}, {5, 5}, {4, 7}, {6, 4}, {5, 6}, {6, 5}, {5, 7}, {6,
+		6}, {7, 0}, {6, 7}, {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7,
+		6}, {7, 7} }, {{0, 0}, {1, 0}, {0, 1}, {0, 2}, {1, 1}, {2, 0}, {
+		3, 0}, {2, 1}, {1, 2}, {0, 3}, {0, 4}, {1, 3}, {2, 2}, {3, 1}, {
+		4, 0}, {5, 0}, {4, 1}, {3, 2}, {2, 3}, {1, 4}, {0, 5}, {0, 6}, {
+		1, 5}, {2, 4}, {3, 3}, {4, 2}, {5, 1}, {6, 0}, {7, 0}, {6, 1}, {
+		5, 2}, {4, 3}, {3, 4}, {2, 5}, {1, 6}, {0, 7}, {1, 7}, {2, 6}, {
+		3, 5}, {4, 4}, {5, 3}, {6, 2}, {7, 1}, {7, 2}, {6, 3}, {5, 4}, {
+		4, 5}, {3, 6}, {2, 7}, {3, 7}, {4, 6}, {5, 5}, {6, 4}, {7, 3}, {
+		7, 4}, {6, 5}, {5, 6}, {4, 7}, {5, 7}, {6, 6}, {7, 5}, {7, 6}, {
+		6, 7}, {7, 7} } };
+
+const int SCAN_4x4[16][2] = {{0, 0}, {1, 0}, {0, 1}, {0, 2}, {1, 1}, {2, 0}, {3,
+		0}, {2, 1}, {1, 2}, {0, 3}, {1, 3}, {2, 2}, {3, 1}, {3, 2}, {2,
+		3}, {3, 3} };
+
+/*
+ *************************************************************************
+ * Function:
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void encode_golomb_word(unsigned int symbol, unsigned int grad0,
+		unsigned int max_levels, unsigned int *res_bits,
+		unsigned int *res_len)
+{
+	unsigned int level, res, numbits;
+
+	res = 1UL << grad0;
+	level = 1UL;
+	numbits = 1UL + grad0;
+
+	while (symbol >= res && level < max_levels) {
+		symbol -= res;
+		res = res << 1;
+		level++;
+		numbits += 2UL;
+	}
+
+	if (level >= max_levels) {
+		if (symbol >= res)
+			symbol = res - 1UL;
+	}
+
+	*res_bits = res | symbol;
+	*res_len = numbits;
+}
+
+/*
+ *************************************************************************
+ * Function:
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void encode_multilayer_golomb_word(unsigned int symbol,
+		const unsigned int *grad, const unsigned int *max_levels,
+		unsigned int *res_bits, unsigned int *res_len)
+{
+	unsigned accbits, acclen, bits, len, tmp;
+
+	accbits = acclen = 0UL;
+
+	while (1) {
+		encode_golomb_word(symbol, *grad, *max_levels, &bits, &len);
+		accbits = (accbits << len) | bits;
+		acclen += len;
+#ifdef AVSP_LONG_CABAC
+#else
+		assert(acclen <= 32UL);
+#endif
+		tmp = *max_levels - 1UL;
+
+		if (!((len == (tmp << 1) + (*grad))
+				&& (bits == (1UL << (tmp + *grad)) - 1UL)))
+			break;
+
+		tmp = *max_levels;
+		symbol -= (((1UL << tmp) - 1UL) << (*grad)) - 1UL;
+		grad++;
+		max_levels++;
+	}
+	*res_bits = accbits;
+	*res_len = acclen;
+}
+
+/*
+ *************************************************************************
+ * Function:
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+int writesyntaxelement_golomb(struct syntaxelement *se, int write_to_stream)
+{
+	unsigned int bits, len, i;
+	unsigned int grad[4], max_lev[4];
+
+	if (!(se->golomb_maxlevels & ~0xFF))
+		encode_golomb_word(se->value1, se->golomb_grad,
+				se->golomb_maxlevels, &bits, &len);
+	else {
+		for (i = 0UL; i < 4UL; i++) {
+			grad[i] = (se->golomb_grad >> (i << 3)) & 0xFFUL;
+			max_lev[i] = (se->golomb_maxlevels >> (i << 3))
+					& 0xFFUL;
+		}
+		encode_multilayer_golomb_word(se->value1, grad, max_lev, &bits,
+				&len);
+	}
+
+	se->len = len;
+	se->bitpattern = bits;
+
+	if (write_to_stream)
+		push_es(bits, len);
+	return se->len;
+}
+
+/*
+ *************************************************************************
+ * Function:Get coded block pattern and coefficients (run/level)
+ from the bitstream
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+void read_cbpandcoeffsfrom_nal(struct img_par *img)
+{
+
+	int tablenum;
+	int inumblk;
+	int inumcoeff;
+	int symbol2D;
+	int escape_level_diff;
+	const int (*AVS_2DVLC_table_intra)[26][27];
+	const int (*AVS_2DVLC_table_chroma)[26][27];
+	int write_to_stream;
+	struct syntaxelement currse_enc;
+	struct syntaxelement *e_currse = &currse_enc;
+
+	int coeff_save[65][2];
+	int coeff_ptr;
+
+	int ii, jj;
+	int mb_nr = img->current_mb_nr;
+
+	int m2, jg2;
+	struct macroblock *curr_mb = &mb_data[mb_nr];
+
+	int block8x8;
+
+	int block_x, block_y;
+
+	struct slice_s *currslice = img->current_slice;
+	int level, run, coef_ctr, len, k, i0, j0, uv, qp;
+
+	int boff_x, boff_y, start_scan;
+	struct syntaxelement curr_se;
+	struct datapartition *dp;
+
+	AVS_2DVLC_table_intra = AVS_2DVLC_INTRA;
+	AVS_2DVLC_table_chroma = AVS_2DVLC_CHROMA;
+	write_to_stream = 1;
+
+	dct_pairs = -1;
+
+	curr_mb->qp = img->qp;
+	qp = curr_mb->qp;
+
+
+	for (block_y = 0; block_y < 4; block_y += 2) {/* all modes */
+	for (block_x = 0; block_x < 4; block_x += 2) {
+		block8x8 = 2 * (block_y / 2) + block_x / 2;
+		if (curr_mb->cbp & (1 << block8x8)) {
+			tablenum = 0;
+			inumblk = 1;
+			inumcoeff = 65;
+			coeff_save[0][0] = 0;
+			coeff_save[0][1] = 0;
+			coeff_ptr = 1;
+
+			b8_ctr = block8x8;
+
+			boff_x = (block8x8 % 2) << 3;
+			boff_y = (block8x8 / 2) << 3;
+
+			img->subblock_x = boff_x >> 2;
+			img->subblock_y = boff_y >> 2;
+
+			start_scan = 0;
+			coef_ctr = start_scan - 1;
+			level = 1;
+			img->is_v_block = 0;
+			img->is_intra_block = IS_INTRA(curr_mb);
+			for (k = start_scan;
+				(k < 65) && (level != 0);
+				k++) {
+
+				curr_se.context = LUMA_8x8;
+				curr_se.type =
+				(IS_INTRA(curr_mb)) ?
+					SE_LUM_AC_INTRA :
+					SE_LUM_AC_INTER;
+
+				dp = &(currslice->part_arr[0]);
+				curr_se.reading =
+					readrunlevel_aec_ref;
+				dp->
+				read_syntax_element(&curr_se,
+					img, dp);
+				level = curr_se.value1;
+				run = curr_se.value2;
+				len = curr_se.len;
+
+				if (level != 0) {
+					coeff_save[coeff_ptr][0] =
+					run;
+					coeff_save[coeff_ptr][1] =
+					level;
+					coeff_ptr++;
+				}
+
+
+
+				if (level != 0) {/* leave if len = 1 */
+					coef_ctr += run + 1;
+					if ((img->picture_structure
+						== FRAME)) {
+						ii =
+						SCAN[img->picture_structure]
+						[coef_ctr][0];
+						jj =
+						SCAN[img->picture_structure]
+						[coef_ctr][1];
+					} else {
+						ii =
+						SCAN[img->picture_structure]
+						[coef_ctr][0];
+						jj =
+						SCAN[img->picture_structure]
+						[coef_ctr][1];
+					}
+
+				}
+			}
+
+			while (coeff_ptr > 0) {
+				run =
+						coeff_save[coeff_ptr
+								- 1][0];
+				level =
+						coeff_save[coeff_ptr
+								- 1][1];
+
+				coeff_ptr--;
+
+				symbol2D = CODE2D_ESCAPE_SYMBOL;
+				if (level > -27 && level < 27
+					&& run < 26) {
+					if (tablenum == 0)
+
+						symbol2D =
+						AVS_2DVLC_table_intra
+						[tablenum]
+						[run][abs(
+						level)
+						- 1];
+					else
+
+						symbol2D =
+						AVS_2DVLC_table_intra
+						[tablenum]
+						[run][abs(
+					level)];
+					if (symbol2D >= 0
+							&& level
+									< 0)
+						symbol2D++;
+					if (symbol2D < 0)
+
+						symbol2D =
+						(CODE2D_ESCAPE_SYMBOL
+						+ (run
+						<< 1)
+						+ ((level
+						> 0) ?
+						1 :
+						0));
+				}
+
+				else {
+
+					symbol2D =
+						(CODE2D_ESCAPE_SYMBOL
+						+ (run
+						<< 1)
+						+ ((level
+						> 0) ?
+						1 :
+						0));
+				}
+
+
+
+				e_currse->type = SE_LUM_AC_INTER;
+				e_currse->value1 = symbol2D;
+				e_currse->value2 = 0;
+
+				e_currse->golomb_grad =
+						vlc_golomb_order
+						[0][tablenum][0];
+				e_currse->golomb_maxlevels =
+						vlc_golomb_order
+						[0][tablenum][1];
+
+				writesyntaxelement_golomb(
+						e_currse,
+						write_to_stream);
+
+				if (symbol2D
+						>= CODE2D_ESCAPE_SYMBOL) {
+
+					e_currse->type =
+							SE_LUM_AC_INTER;
+					e_currse->golomb_grad =
+							1;
+					e_currse->golomb_maxlevels =
+							11;
+					escape_level_diff =
+						abs(
+						level)
+						- ((run
+						> MaxRun[0][tablenum]) ?
+						1 :
+						refabslevel[tablenum][run]);
+					e_currse->value1 =
+							escape_level_diff;
+
+					writesyntaxelement_golomb(
+							e_currse,
+							write_to_stream);
+
+				}
+
+				if (abs(level)
+					> incvlc_intra[tablenum]) {
+					if (abs(level) <= 2)
+						tablenum =
+						abs(
+						level);
+					else if (abs(level) <= 4)
+						tablenum = 3;
+					else if (abs(level) <= 7)
+						tablenum = 4;
+					else if (abs(level)
+							<= 10)
+						tablenum = 5;
+					else
+						tablenum = 6;
+				}
+			}
+
+
+		}
+		}
+	}
+
+
+
+	m2 = img->mb_x * 2;
+	jg2 = img->mb_y * 2;
+
+
+	uv = -1;
+	block_y = 4;
+#if 0
+	qp = QP_SCALE_CR[curr_mb->qp];
+#endif
+	for (block_x = 0; block_x < 4; block_x += 2) {
+
+		uv++;
+
+
+		b8_ctr = (uv + 4);
+		if ((curr_mb->cbp >> (uv + 4)) & 0x1) {
+
+			tablenum = 0;
+			inumblk = 1;
+			inumcoeff = 65;
+			coeff_save[0][0] = 0;
+			coeff_save[0][1] = 0;
+			coeff_ptr = 1;
+
+			coef_ctr = -1;
+			level = 1;
+			img->subblock_x = 0;
+			img->subblock_y = 0;
+			curr_se.context = CHROMA_AC;
+			curr_se.type = (IS_INTRA(curr_mb) ?
+					SE_CHR_AC_INTRA :
+					SE_CHR_AC_INTER);
+			dp = &(currslice->part_arr[0]);
+			curr_se.reading = readrunlevel_aec_ref;
+			img->is_v_block = uv;
+			img->is_intra_block = IS_INTRA(curr_mb);
+			for (k = 0; (k < 65) && (level != 0); k++) {
+
+				dp->read_syntax_element
+				(&curr_se, img, dp);
+				level = curr_se.value1;
+				run = curr_se.value2;
+				len = curr_se.len;
+
+				if (level != 0) {
+					coeff_save[coeff_ptr][0] = run;
+					coeff_save[coeff_ptr][1] =
+							level;
+					coeff_ptr++;
+				}
+
+
+				if (level != 0) {
+					coef_ctr = coef_ctr + run + 1;
+					if ((img->picture_structure
+						== FRAME)
+						/*&& (!curr_mb->mb_field)*/) {
+						i0 =
+						SCAN[img->picture_structure]
+						[coef_ctr][0];
+						j0 =
+						SCAN[img->picture_structure]
+						[coef_ctr][1];
+					} else {
+						i0 =
+						SCAN[img->picture_structure]
+						[coef_ctr][0];
+						j0 =
+						SCAN[img->picture_structure]
+						[coef_ctr][1];
+					}
+
+				}
+			}
+
+			while (coeff_ptr > 0) {
+
+				run = coeff_save[coeff_ptr - 1][0];
+				level = coeff_save[coeff_ptr - 1][1];
+
+				coeff_ptr--;
+
+				symbol2D = CODE2D_ESCAPE_SYMBOL;
+				if (level > -27 && level < 27
+						&& run < 26) {
+					if (tablenum == 0)
+
+						symbol2D =
+						AVS_2DVLC_table_chroma
+						[tablenum][run][abs(
+						level)
+						- 1];
+					else
+						symbol2D =
+							AVS_2DVLC_table_chroma
+							[tablenum][run][abs(
+							level)];
+					if (symbol2D >= 0
+						&& level < 0)
+						symbol2D++;
+					if (symbol2D < 0)
+						symbol2D =
+						(CODE2D_ESCAPE_SYMBOL
+						+ (run
+						<< 1)
+						+ ((level
+						> 0) ?
+						1 :
+						0));
+				}
+
+				else {
+					symbol2D =
+					(CODE2D_ESCAPE_SYMBOL
+					+ (run
+					<< 1)
+					+ ((level
+					> 0) ?
+					1 :
+					0));
+				}
+
+				e_currse->type = SE_LUM_AC_INTER;
+				e_currse->value1 = symbol2D;
+				e_currse->value2 = 0;
+				e_currse->golomb_grad =
+						vlc_golomb_order[2]
+						[tablenum][0];
+				e_currse->golomb_maxlevels =
+						vlc_golomb_order[2]
+						[tablenum][1];
+
+				writesyntaxelement_golomb(e_currse,
+						write_to_stream);
+
+				/*
+				 if (write_to_stream)
+				 {
+				 bitCount[BITS_COEFF_UV_MB]+=e_currse->len;
+				 e_currse++;
+				 curr_mb->currSEnr++;
+				 }
+				 no_bits+=e_currse->len;
+
+
+				 if (icoef == 0) break;
+				 */
+
+				if (symbol2D >= CODE2D_ESCAPE_SYMBOL) {
+
+					e_currse->type = SE_LUM_AC_INTER;
+					e_currse->golomb_grad = 0;
+					e_currse->golomb_maxlevels = 11;
+					escape_level_diff =
+						abs(level)
+						- ((run
+						> MaxRun[2][tablenum]) ?
+						1 :
+						refabslevel[tablenum
+						+ 14][run]);
+					e_currse->value1 =
+							escape_level_diff;
+
+					writesyntaxelement_golomb(
+							e_currse,
+							write_to_stream);
+
+				}
+
+				if (abs(level)
+				> incvlc_chroma[tablenum]) {
+					if (abs(level) <= 2)
+						tablenum = abs(level);
+					else if (abs(level) <= 4)
+						tablenum = 3;
+					else
+						tablenum = 4;
+				}
+			}
+
+		}
+	}
+}
+
+/*
+ *************************************************************************
+ * Function:Get the syntax elements from the NAL
+ * Input:
+ * Output:
+ * Return:
+ * Attention:
+ *************************************************************************
+ */
+
+int read_one_macroblock(struct img_par *img)
+{
+	int i, j;
+
+	struct syntaxelement curr_se;
+	struct macroblock *curr_mb = &mb_data[img->current_mb_nr];
+
+	int cabp_flag;
+
+	int tempcbp;
+	int fixqp;
+
+	struct slice_s *currslice = img->current_slice;
+	struct datapartition *dp;
+
+	fixqp = (fixed_picture_qp || fixed_slice_qp);
+
+	for (i = 0; i < 8; i++)
+		for (j = 0; j < 8; j++) {
+			img->m8[0][i][j] = 0;
+			img->m8[1][i][j] = 0;
+			img->m8[2][i][j] = 0;
+			img->m8[3][i][j] = 0;
+		}
+
+	current_mb_skip = 0;
+
+	curr_mb->qp = img->qp;
+	curr_se.type = SE_MBTYPE;
+	curr_se.mapping = linfo_ue;
+
+	curr_mb->mb_type_2 = 0;
+
+	if (img->type == I_IMG)
+		curr_mb->mb_type = 0;
+
+	interpret_mb_mode_i(img);
+
+	init_macroblock(img);
+
+	if ((IS_INTRA(curr_mb)) && (img->abt_flag)) {
+
+#if TRACE
+		strncpy(curr_se.tracestring, "cabp_flag", TRACESTRING_SIZE);
+#endif
+
+		curr_se.len = 1;
+		curr_se.type = SE_CABP;
+		read_syntaxelement_flc(&curr_se);
+		cabp_flag = curr_se.value1;
+		if (cabp_flag == 0) {
+			curr_mb->CABP[0] = 0;
+			curr_mb->CABP[1] = 0;
+			curr_mb->CABP[2] = 0;
+			curr_mb->CABP[3] = 0;
+		} else {
+			for (i = 0; i < 4; i++) {
+				curr_se.len = 1;
+				curr_se.type = SE_CABP;
+				read_syntaxelement_flc(&curr_se);
+				curr_mb->CABP[i] = curr_se.value1;
+			}
+		}
+
+	} else {
+		curr_mb->CABP[0] = 0;
+		curr_mb->CABP[1] = 0;
+		curr_mb->CABP[2] = 0;
+		curr_mb->CABP[3] = 0;
+
+	}
+
+	if (IS_INTRA(curr_mb)) {
+		for (i = 0; i < /*5*/(chroma_format + 4); i++)
+
+			read_ipred_block_modes(img, i);
+	}
+
+	curr_se.type = SE_CBP_INTRA;
+	curr_se.mapping = linfo_cbp_intra;
+
+#if TRACE
+	snprintf(curr_se.tracestring, TRACESTRING_SIZE, "CBP");
+#endif
+
+	if (img->type == I_IMG || IS_INTER(curr_mb)) {
+		curr_se.golomb_maxlevels = 0;
+
+		if (1) {
+			dp = &(currslice->part_arr[0]);
+			curr_se.reading = readcp_aec;
+			dp->read_syntax_element(&curr_se, img, dp);
+		}
+
+
+		curr_mb->cbp = curr_se.value1;
+		push_es(UE[NCBP[curr_se.value1][0]][0],
+				UE[NCBP[curr_se.value1][0]][1]);
+
+	}
+
+# if 1
+	if (curr_mb->cbp != 0)
+		tempcbp = 1;
+	else
+		tempcbp = 0;
+#else
+
+	if (chroma_format == 2)	{
+#if TRACE
+		snprintf(curr_se.tracestring, TRACESTRING_SIZE, "CBP422");
+#endif
+		curr_se.mapping = /*linfo_se*/linfo_ue;
+		curr_se.type = SE_CBP_INTRA;
+		readsyntaxelement_uvlc(&curr_se, inp);
+		curr_mb->cbp01 = curr_se.value1;
+		io_printf(" * UE cbp01 read : 0x%02X\n", curr_mb->cbp01);
+	}
+
+	if (chroma_format == 2)	{
+		if (curr_mb->cbp != 0 || curr_mb->cbp01 != 0)
+			tempcbp = 1;
+		else
+			tempcbp = 0;
+
+	} else {
+		if (curr_mb->cbp != 0)
+			tempcbp = 1;
+		else
+			tempcbp = 0;
+	}
+
+#endif
+
+	if (IS_INTRA(curr_mb) && (img->abt_flag) && (curr_mb->cbp & (0xF))) {
+		curr_mb->CABT[0] = curr_mb->CABP[0];
+		curr_mb->CABT[1] = curr_mb->CABP[1];
+		curr_mb->CABT[2] = curr_mb->CABP[2];
+		curr_mb->CABT[3] = curr_mb->CABP[3];
+	} else {
+
+		curr_mb->CABT[0] = 0;
+		curr_mb->CABT[1] = 0;
+		curr_mb->CABT[2] = 0;
+		curr_mb->CABT[3] = 0;
+
+		if (!fixqp && (tempcbp)) {
+			if (IS_INTER(curr_mb))
+				curr_se.type = SE_DELTA_QUANT_INTER;
+			else
+				curr_se.type = SE_DELTA_QUANT_INTRA;
+
+#if TRACE
+			snprintf(curr_se.tracestring,
+				TRACESTRING_SIZE, "Delta quant ");
+#endif
+
+			if (1) {
+				dp = &(currslice->part_arr[0]);
+				curr_se.reading = readdquant_aec;
+				dp->read_syntax_element(&curr_se, img, dp);
+			}
+
+			curr_mb->delta_quant = curr_se.value1;
+#ifdef DUMP_DEBUG
+			if (avs_get_debug_flag() & MB_INFO_DUMP) {
+				io_printf(" * SE delta_quant read : %d\n",
+					curr_mb->delta_quant);
+			}
+#endif
+			CHECKDELTAQP
+
+			img->qp = (img->qp - MIN_QP + curr_mb->delta_quant
+					+ (MAX_QP - MIN_QP + 1))
+					% (MAX_QP - MIN_QP + 1) + MIN_QP;
+		}
+
+		if (fixqp) {
+			curr_mb->delta_quant = 0;
+			img->qp = (img->qp - MIN_QP + curr_mb->delta_quant
+					+ (MAX_QP - MIN_QP + 1))
+					% (MAX_QP - MIN_QP + 1) + MIN_QP;
+
+		}
+#ifdef DUMP_DEBUG
+		if (avs_get_debug_flag() & MB_INFO_DUMP)
+			io_printf(" - img->qp : %d\n", img->qp);
+#endif
+	}
+
+	read_cbpandcoeffsfrom_nal(img);
+	return DECODE_MB;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    finding end of a slice in case this is not the end of a frame
+ *
+ * Unsure whether the "correction" below actually solves an off-by-one
+ * problem or whether it introduces one in some cases :-(  Anyway,
+ * with this change the bit stream format works with AEC again.
+ * StW, 8.7.02
+ ************************************************************************
+ */
+int aec_startcode_follows(struct img_par *img, int eos_bit)
+{
+	struct slice_s *currslice = img->current_slice;
+	struct datapartition *dp;
+	unsigned int bit;
+	struct decoding_environment_s *dep_dp;
+
+	dp = &(currslice->part_arr[0]);
+	dep_dp = &(dp->de_aec);
+
+	if (eos_bit)
+		bit = biari_decode_final(dep_dp);
+	else
+		bit = 0;
+
+	return bit == 1 ? 1 : 0;
+}
+
+#ifdef AVSP_LONG_CABAC
+int process_long_cabac(void)
+#else
+void main(void)
+#endif
+{
+	int data32;
+	int current_header;
+	int i;
+	int tmp;
+
+	int byte_startposition;
+	int aec_mb_stuffing_bit;
+	struct slice_s *currslice;
+#ifdef PERFORMANCE_DEBUG
+	pr_info("enter %s\r\n", __func__);
+#endif
+	transcoding_error_flag = 0;
+	es_buf = es_write_addr_virt;
+
+	if (local_heap_init(MAX_CODED_FRAME_SIZE * 4) < 0)
+		return -1;
+
+	img = (struct img_par *)local_alloc(1, sizeof(struct img_par));
+	if (img	== NULL)
+		no_mem_exit("main: img");
+	stat_bits_ptr = (struct stat_bits *)local_alloc(1,
+			sizeof(struct stat_bits));
+	if (stat_bits_ptr == NULL)
+		no_mem_exit("main: stat_bits");
+
+	curr_stream = alloc_bitstream();
+
+	chroma_format = 1;
+	demulate_enable = 0;
+	img->seq_header_indicate = 1;
+
+#ifdef AVSP_LONG_CABAC
+	data32 = READ_VREG(LONG_CABAC_REQ);
+	progressive_sequence = (data32 >> 1) & 1;
+	fixed_picture_qp = (data32 >> 2) & 1;
+	img->picture_structure = (data32 >> 3) & 1;
+	img->type = (data32 >> 4) & 3;
+	skip_mode_flag = (data32 >> 6) & 1;
+
+	src_start = READ_VREG(LONG_CABAC_SRC_ADDR);
+	des_start = READ_VREG(LONG_CABAC_DES_ADDR);
+
+	data32 = READ_VREG(LONG_CABAC_PIC_SIZE);
+	horizontal_size = (data32 >> 0) & 0xffff;
+	vertical_size = (data32 >> 16) & 0xffff;
+
+	vld_mem_start_addr = READ_VREG(VLD_MEM_VIFIFO_START_PTR);
+	vld_mem_end_addr = READ_VREG(VLD_MEM_VIFIFO_END_PTR);
+
+#else
+	progressive_sequence = 0;
+	fixed_picture_qp = 0;
+	img->picture_structure = 0;
+	img->type = I_IMG;
+	skip_mode_flag = 1;
+	horizontal_size = 1920;
+	vertical_size = 1080;
+
+	src_start = 0;
+#endif
+
+	if (horizontal_size % 16 != 0)
+		img->auto_crop_right = 16 - (horizontal_size % 16);
+	else
+		img->auto_crop_right = 0;
+
+	if (!progressive_sequence) {
+		if (vertical_size % 32 != 0)
+			img->auto_crop_bottom = 32 - (vertical_size % 32);
+		else
+			img->auto_crop_bottom = 0;
+	} else {
+		if (vertical_size % 16 != 0)
+			img->auto_crop_bottom = 16 - (vertical_size % 16);
+		else
+			img->auto_crop_bottom = 0;
+	}
+
+	img->width = (horizontal_size + img->auto_crop_right);
+	if (img->picture_structure)
+		img->height = (vertical_size + img->auto_crop_bottom);
+	else
+		img->height = (vertical_size + img->auto_crop_bottom) / 2;
+	img->width_cr = (img->width >> 1);
+
+	img->pic_width_inmbs = img->width / MB_BLOCK_SIZE;
+	img->pic_height_inmbs = img->height / MB_BLOCK_SIZE;
+	img->pic_size_inmbs = img->pic_width_inmbs * img->pic_height_inmbs;
+
+	io_printf(
+			"[LONG CABAC] Start Transcoding from 0x%x to 0x%x Size : %d x %d\r\n",
+			src_start, des_start, horizontal_size, vertical_size);
+#if 0
+	io_printf("VLD_MEM_VIFIFO_START_PTR %x\r\n",
+			READ_VREG(VLD_MEM_VIFIFO_START_PTR));
+	io_printf("VLD_MEM_VIFIFO_CURR_PTR %x\r\n",
+			READ_VREG(VLD_MEM_VIFIFO_CURR_PTR));
+	io_printf("VLD_MEM_VIFIFO_END_PTR %x\r\n",
+			READ_VREG(VLD_MEM_VIFIFO_END_PTR));
+	io_printf("VLD_MEM_VIFIFO_WP %x\r\n",
+			READ_VREG(VLD_MEM_VIFIFO_WP));
+	io_printf("VLD_MEM_VIFIFO_RP %x\r\n",
+			READ_VREG(VLD_MEM_VIFIFO_RP));
+	io_printf("VLD_MEM_VBUF_RD_PTR %x\r\n",
+			READ_VREG(VLD_MEM_VBUF_RD_PTR));
+	io_printf("VLD_MEM_VIFIFO_BUF_CNTL %x\r\n",
+			READ_VREG(VLD_MEM_VIFIFO_BUF_CNTL));
+#endif
+	io_printf(
+			"[LONG CABAC] progressive_sequence : %d, fixed_picture_qp : %d, skip_mode_flag : %d\r\n",
+			progressive_sequence, fixed_picture_qp, skip_mode_flag);
+	io_printf("[LONG CABAC] picture_structure : %d, picture_type : %d\r\n",
+			img->picture_structure, img->type);
+
+	open_irabs(p_irabs);
+
+	initial_decode();
+
+	init_es();
+
+	current_header = header();
+	io_printf("[LONG CABAC] header Return : %d\n", current_header);
+
+	tmp = slice_header(temp_slice_buf, first_slice_startpos,
+			first_slice_length);
+
+	init_contexts(img);
+	aec_new_slice();
+	byte_startposition = (curr_stream->frame_bitoffset) / 8;
+
+	currslice = img->current_slice;
+
+	if (1) {
+		for (i = 0; i < 1; i++) {
+			img->current_slice->part_arr[i].read_syntax_element =
+					read_syntaxelement_aec;
+			img->current_slice->part_arr[i].bitstream = curr_stream;
+		}
+		curr_stream = currslice->part_arr[0].bitstream;
+	}
+	if ((curr_stream->frame_bitoffset) % 8 != 0)
+		byte_startposition++;
+
+	arideco_start_decoding(&img->current_slice->part_arr[0].de_aec,
+			curr_stream->stream_buffer, (byte_startposition),
+			&(curr_stream->read_len), img->type);
+
+	img->current_mb_nr = 0;
+	total_mb_count = 0;
+	while (img->current_mb_nr < img->pic_size_inmbs)
+
+	{
+		start_macroblock(img);
+		read_one_macroblock(img);
+		if (img->cod_counter <= 0/*==-1*/)
+			aec_mb_stuffing_bit = aec_startcode_follows(img, 1);
+		img->current_mb_nr++;
+	}
+
+	push_es(0xff, 8);
+	io_printf(" Total ES_LENGTH : %d\n", es_ptr);
+
+#ifdef AVSP_LONG_CABAC
+	push_es(0xff, 64);
+
+	if (transcoding_error_flag == 0) {
+#if 1
+		dma_sync_single_for_device(amports_get_dma_device(),
+			es_write_addr_phy,
+			es_ptr, DMA_TO_DEVICE);
+
+		wmb(); /**/
+#endif
+		WRITE_VREG(LONG_CABAC_REQ, 0);
+	}
+#else
+	fclose(f_es);
+#endif
+
+	local_heap_uninit();
+#ifdef PERFORMANCE_DEBUG
+	pr_info("exit %s\r\n", __func__);
+#endif
+	return (transcoding_error_flag == 0) ? 0 : -1;
+}
+#endif
diff --git a/drivers/amlogic/amports/cnm/Makefile b/drivers/amlogic/amports/cnm/Makefile
new file mode 100644
index 0000000..c5206a3
--- /dev/null
+++ b/drivers/amlogic/amports/cnm/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_AM_HEVCENC) += vpu.o
diff --git a/drivers/amlogic/amports/cnm/vmm.h b/drivers/amlogic/amports/cnm/vmm.h
new file mode 100644
index 0000000..cb0112e
--- /dev/null
+++ b/drivers/amlogic/amports/cnm/vmm.h
@@ -0,0 +1,661 @@
+/*
+ * vmm.h
+ *
+ * memory allocator for VPU
+ *
+ * Copyright (C) 2006 - 2013  CHIPS&MEDIA INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __CNM_VIDEO_MEMORY_MANAGEMENT_H__
+#define __CNM_VIDEO_MEMORY_MANAGEMENT_H__
+
+#define VMEM_PAGE_SIZE (16 * 1024)
+#define MAKE_KEY(_a, _b) (((vmem_key_t)_a) << 32 | _b)
+#define KEY_TO_VALUE(_key) (_key >> 32)
+
+#define VMEM_P_ALLOC(_x) vmalloc(_x)
+#define VMEM_P_FREE(_x) vfree(_x)
+
+#define VMEM_ASSERT \
+	pr_info("VMEM_ASSERT at %s:%d\n", __FILE__, __LINE__)
+
+
+#define VMEM_HEIGHT(_tree) (_tree == NULL ? -1 : _tree->height)
+
+#define MAX(_a, _b) (_a >= _b ? _a : _b)
+
+struct avl_node_t;
+#define vmem_key_t unsigned long long
+
+struct vmem_info_t {
+	ulong total_pages;
+	ulong alloc_pages;
+	ulong free_pages;
+	ulong page_size;
+};
+
+struct page_t {
+	s32 pageno;
+	ulong addr;
+	s32 used;
+	s32 alloc_pages;
+	s32 first_pageno;
+};
+
+struct avl_node_t {
+	vmem_key_t key;
+	s32 height;
+	struct page_t *page;
+	struct avl_node_t *left;
+	struct avl_node_t *right;
+};
+
+struct video_mm_t {
+	struct avl_node_t *free_tree;
+	struct avl_node_t *alloc_tree;
+	struct page_t *page_list;
+	s32 num_pages;
+	ulong base_addr;
+	ulong mem_size;
+	s32 free_page_count;
+	s32 alloc_page_count;
+};
+
+enum rotation_dir_t {
+	LEFT,
+	RIGHT
+};
+
+struct avl_node_data_t {
+	s32 key;
+	struct page_t *page;
+};
+
+static struct avl_node_t *make_avl_node(
+	vmem_key_t key,
+	struct page_t *page)
+{
+	struct avl_node_t *node =
+		(struct avl_node_t *)VMEM_P_ALLOC(sizeof(struct avl_node_t));
+	node->key = key;
+	node->page = page;
+	node->height = 0;
+	node->left = NULL;
+	node->right = NULL;
+	return node;
+}
+
+static s32 get_balance_factor(struct avl_node_t *tree)
+{
+	s32 factor = 0;
+	if (tree)
+		factor = VMEM_HEIGHT(tree->right) - VMEM_HEIGHT(tree->left);
+	return factor;
+}
+
+/*
+ * Left Rotation
+ *
+ *	  A					  B
+ *	   \					/ \
+ *		B		 =>	   A   C
+ *	   /  \				 \
+ *	  D	C				 D
+ *
+ */
+static struct avl_node_t *rotation_left(struct avl_node_t *tree)
+{
+	struct avl_node_t *rchild;
+	struct avl_node_t *lchild;
+
+	if (tree == NULL)
+		return NULL;
+
+	rchild = tree->right;
+	if (rchild == NULL)
+		return tree;
+
+	lchild = rchild->left;
+	rchild->left = tree;
+	tree->right = lchild;
+
+	tree->height =
+		MAX(VMEM_HEIGHT(tree->left), VMEM_HEIGHT(tree->right)) + 1;
+	rchild->height =
+		MAX(VMEM_HEIGHT(rchild->left), VMEM_HEIGHT(rchild->right)) + 1;
+	return rchild;
+}
+
+
+/*
+ * Reft Rotation
+ *
+ *		 A				  B
+ *	   \				  /  \
+ *	  B		 =>	   D	A
+ *	/  \					 /
+ *   D	C				   C
+ *
+ */
+static struct avl_node_t *rotation_right(struct avl_node_t *tree)
+{
+	struct avl_node_t *rchild;
+	struct avl_node_t *lchild;
+
+	if (tree == NULL)
+		return NULL;
+
+	lchild = tree->left;
+	if (lchild == NULL)
+		return NULL;
+
+	rchild = lchild->right;
+	lchild->right = tree;
+	tree->left = rchild;
+
+	tree->height =
+		MAX(VMEM_HEIGHT(tree->left),
+		VMEM_HEIGHT(tree->right)) + 1;
+	lchild->height =
+		MAX(VMEM_HEIGHT(lchild->left),
+		VMEM_HEIGHT(lchild->right)) + 1;
+	return lchild;
+}
+
+static struct avl_node_t *do_balance(struct avl_node_t *tree)
+{
+	s32 bfactor = 0, child_bfactor;
+	bfactor = get_balance_factor(tree);
+	if (bfactor >= 2) {
+		child_bfactor = get_balance_factor(tree->right);
+		if (child_bfactor == 1 || child_bfactor == 0) {
+			tree = rotation_left(tree);
+		} else if (child_bfactor == -1) {
+			tree->right = rotation_right(tree->right);
+			tree	 = rotation_left(tree);
+		} else {
+			pr_info(
+				"invalid balancing factor: %d\n",
+				child_bfactor);
+			VMEM_ASSERT;
+			return NULL;
+		}
+	} else if (bfactor <= -2) {
+		child_bfactor = get_balance_factor(tree->left);
+		if (child_bfactor == -1 || child_bfactor == 0) {
+			tree = rotation_right(tree);
+		} else if (child_bfactor == 1) {
+			tree->left = rotation_left(tree->left);
+			tree	 = rotation_right(tree);
+		} else {
+			pr_info(
+				"invalid balancing factor: %d\n",
+				child_bfactor);
+			VMEM_ASSERT;
+			return NULL;
+		}
+	}
+	return tree;
+}
+
+static struct avl_node_t *unlink_end_node(
+	struct avl_node_t *tree,
+	s32 dir,
+	struct avl_node_t **found_node)
+{
+	struct avl_node_t *node;
+	*found_node = NULL;
+
+	if (tree == NULL)
+		return NULL;
+
+	if (dir == LEFT) {
+		if (tree->left == NULL) {
+			*found_node = tree;
+			return NULL;
+		}
+	} else {
+		if (tree->right == NULL) {
+			*found_node = tree;
+			return NULL;
+		}
+	}
+
+	if (dir == LEFT) {
+		node = tree->left;
+		tree->left = unlink_end_node(tree->left, LEFT, found_node);
+		if (tree->left == NULL) {
+			tree->left = (*found_node)->right;
+			(*found_node)->left = NULL;
+			(*found_node)->right = NULL;
+		}
+	} else {
+		node = tree->right;
+		tree->right = unlink_end_node(tree->right, RIGHT, found_node);
+		if (tree->right == NULL) {
+			tree->right = (*found_node)->left;
+			(*found_node)->left = NULL;
+			(*found_node)->right = NULL;
+		}
+	}
+	tree->height =
+		MAX(VMEM_HEIGHT(tree->left), VMEM_HEIGHT(tree->right)) + 1;
+	return do_balance(tree);
+}
+
+
+static struct avl_node_t *avltree_insert(
+	struct avl_node_t *tree,
+	vmem_key_t key,
+	struct page_t *page)
+{
+	if (tree == NULL) {
+		tree = make_avl_node(key, page);
+	} else {
+		if (key >= tree->key)
+			tree->right =
+				avltree_insert(tree->right, key, page);
+		else
+			tree->left =
+				avltree_insert(tree->left, key, page);
+	}
+	tree = do_balance(tree);
+	tree->height =
+		MAX(VMEM_HEIGHT(tree->left), VMEM_HEIGHT(tree->right)) + 1;
+	return tree;
+}
+
+static struct avl_node_t *do_unlink(struct avl_node_t *tree)
+{
+	struct avl_node_t *node;
+	struct avl_node_t *end_node;
+	node = unlink_end_node(tree->right, LEFT, &end_node);
+	if (node) {
+		tree->right = node;
+	} else {
+		node =
+			unlink_end_node(tree->left, RIGHT, &end_node);
+		if (node)
+			tree->left = node;
+	}
+
+	if (node == NULL) {
+		node = tree->right ? tree->right : tree->left;
+		end_node = node;
+	}
+
+	if (end_node) {
+		end_node->left =
+			(tree->left != end_node) ?
+			tree->left : end_node->left;
+		end_node->right =
+			(tree->right != end_node) ?
+			tree->right : end_node->right;
+		end_node->height =
+			MAX(VMEM_HEIGHT(end_node->left),
+			VMEM_HEIGHT(end_node->right)) + 1;
+	}
+	tree = end_node;
+	return tree;
+}
+
+static struct avl_node_t *avltree_remove(
+	struct avl_node_t *tree,
+	struct avl_node_t **found_node,
+	vmem_key_t key)
+{
+	*found_node = NULL;
+	if (tree == NULL) {
+		pr_info("failed to find key %d\n", (s32)key);
+		return NULL;
+	}
+
+	if (key == tree->key) {
+		*found_node = tree;
+		tree = do_unlink(tree);
+	} else if (key > tree->key) {
+		tree->right =
+			avltree_remove(tree->right, found_node, key);
+	} else {
+		tree->left =
+			avltree_remove(tree->left, found_node, key);
+	}
+
+	if (tree)
+		tree->height =
+			MAX(VMEM_HEIGHT(tree->left),
+			VMEM_HEIGHT(tree->right)) + 1;
+
+	tree = do_balance(tree);
+	return tree;
+}
+
+void avltree_free(struct avl_node_t *tree)
+{
+	if (tree == NULL)
+		return;
+	if (tree->left == NULL && tree->right == NULL) {
+		VMEM_P_FREE(tree);
+		return;
+	}
+
+	avltree_free(tree->left);
+	tree->left = NULL;
+	avltree_free(tree->right);
+	tree->right = NULL;
+	VMEM_P_FREE(tree);
+}
+
+static struct avl_node_t *remove_approx_value(
+	struct avl_node_t *tree,
+	struct avl_node_t **found,
+	vmem_key_t key)
+{
+	*found = NULL;
+	if (tree == NULL)
+		return NULL;
+
+	if (key == tree->key) {
+		*found = tree;
+		tree = do_unlink(tree);
+	} else if (key > tree->key) {
+		tree->right = remove_approx_value(tree->right, found, key);
+	} else {
+		tree->left = remove_approx_value(tree->left, found, key);
+		if (*found == NULL) {
+			*found = tree;
+			tree = do_unlink(tree);
+		}
+	}
+	if (tree)
+		tree->height =
+			MAX(VMEM_HEIGHT(tree->left),
+			VMEM_HEIGHT(tree->right)) + 1;
+	tree = do_balance(tree);
+	return tree;
+}
+
+static void set_blocks_free(
+	struct video_mm_t *mm,
+	s32 pageno,
+	s32 npages)
+{
+	s32 last_pageno = pageno + npages - 1;
+	s32 i;
+	struct page_t *page;
+	struct page_t *last_page;
+
+	if (npages == 0)
+		VMEM_ASSERT;
+
+	if (last_pageno >= mm->num_pages) {
+		pr_info(
+			"set_blocks_free: invalid last page number: %d\n",
+			last_pageno);
+		VMEM_ASSERT;
+		return;
+	}
+
+	for (i = pageno; i <= last_pageno; i++) {
+		mm->page_list[i].used	= 0;
+		mm->page_list[i].alloc_pages = 0;
+		mm->page_list[i].first_pageno = -1;
+	}
+
+	page = &mm->page_list[pageno];
+	page->alloc_pages = npages;
+	last_page = &mm->page_list[last_pageno];
+	last_page->first_pageno = pageno;
+	mm->free_tree =
+		avltree_insert(mm->free_tree, MAKE_KEY(npages, pageno), page);
+}
+
+static void set_blocks_alloc(
+	struct video_mm_t *mm,
+	s32 pageno,
+	s32 npages)
+{
+	s32 last_pageno = pageno + npages - 1;
+	s32 i;
+	struct page_t *page;
+	struct page_t *last_page;
+
+	if (last_pageno >= mm->num_pages) {
+		pr_info(
+			"set_blocks_free: invalid last page number: %d\n",
+			last_pageno);
+		VMEM_ASSERT;
+		return;
+	}
+
+	for (i = pageno; i <= last_pageno; i++) {
+		mm->page_list[i].used	= 1;
+		mm->page_list[i].alloc_pages = 0;
+		mm->page_list[i].first_pageno = -1;
+	}
+
+	page = &mm->page_list[pageno];
+	page->alloc_pages = npages;
+	last_page = &mm->page_list[last_pageno];
+	last_page->first_pageno = pageno;
+	mm->alloc_tree =
+		avltree_insert(mm->alloc_tree, MAKE_KEY(page->addr, 0), page);
+}
+
+
+s32 vmem_init(struct video_mm_t *mm, ulong addr, ulong size)
+{
+	s32 i;
+
+	if (NULL == mm)
+		return -1;
+
+	mm->base_addr = (addr + (VMEM_PAGE_SIZE - 1))
+		& ~(VMEM_PAGE_SIZE - 1);
+	mm->mem_size = size & ~VMEM_PAGE_SIZE;
+	mm->num_pages = mm->mem_size / VMEM_PAGE_SIZE;
+	mm->free_tree = NULL;
+	mm->alloc_tree = NULL;
+	mm->free_page_count = mm->num_pages;
+	mm->alloc_page_count = 0;
+	mm->page_list =
+		(struct page_t *)VMEM_P_ALLOC(
+		mm->num_pages * sizeof(struct page_t));
+	if (mm->page_list == NULL) {
+		pr_err("%s:%d failed to kmalloc(%ld)\n",
+			__func__, __LINE__,
+			mm->num_pages * sizeof(struct page_t));
+		return -1;
+	}
+
+	for (i = 0; i < mm->num_pages; i++) {
+		mm->page_list[i].pageno = i;
+		mm->page_list[i].addr =
+			mm->base_addr + i * VMEM_PAGE_SIZE;
+		mm->page_list[i].alloc_pages = 0;
+		mm->page_list[i].used = 0;
+		mm->page_list[i].first_pageno = -1;
+	}
+	set_blocks_free(mm, 0, mm->num_pages);
+	return 0;
+}
+
+s32 vmem_exit(struct video_mm_t *mm)
+{
+	if (mm == NULL) {
+		pr_info("vmem_exit: invalid handle\n");
+		return -1;
+	}
+
+	if (mm->free_tree)
+		avltree_free(mm->free_tree);
+	if (mm->alloc_tree)
+		avltree_free(mm->alloc_tree);
+
+	if (mm->page_list) {
+		VMEM_P_FREE(mm->page_list);
+		mm->page_list = NULL;
+	}
+
+	mm->base_addr = 0;
+	mm->mem_size = 0;
+	mm->num_pages = 0;
+	mm->page_list = NULL;
+	mm->free_tree = NULL;
+	mm->alloc_tree = NULL;
+	mm->free_page_count = 0;
+	mm->alloc_page_count = 0;
+	return 0;
+}
+
+ulong vmem_alloc(struct video_mm_t *mm, s32 size, ulong pid)
+{
+	struct avl_node_t *node;
+	struct page_t *free_page;
+	s32 npages, free_size;
+	s32 alloc_pageno;
+	ulong ptr;
+
+	if (mm == NULL) {
+		pr_info("vmem_alloc: invalid handle\n");
+		return -1;
+	}
+
+	if (size <= 0)
+		return -1;
+
+	npages = (size + VMEM_PAGE_SIZE - 1) / VMEM_PAGE_SIZE;
+	mm->free_tree = remove_approx_value(mm->free_tree,
+		&node, MAKE_KEY(npages, 0));
+
+	if (node == NULL)
+		return -1;
+
+	free_page = node->page;
+	free_size = KEY_TO_VALUE(node->key);
+	alloc_pageno = free_page->pageno;
+	set_blocks_alloc(mm, alloc_pageno, npages);
+	if (npages != free_size) {
+		s32 free_pageno = alloc_pageno + npages;
+		set_blocks_free(mm, free_pageno, (free_size-npages));
+	}
+	VMEM_P_FREE(node);
+
+	ptr = mm->page_list[alloc_pageno].addr;
+	mm->alloc_page_count += npages;
+	mm->free_page_count -= npages;
+	return ptr;
+}
+
+s32 vmem_free(struct video_mm_t *mm, ulong ptr, ulong pid)
+{
+	ulong addr;
+	struct avl_node_t *found;
+	struct page_t *page;
+	s32 pageno, prev_free_pageno, next_free_pageno;
+	s32 prev_size, next_size;
+	s32 merge_page_no, merge_page_size, free_page_size;
+
+	if (mm == NULL) {
+		pr_info("vmem_free: invalid handle\n");
+		return -1;
+	}
+
+	addr = ptr;
+	mm->alloc_tree = avltree_remove(mm->alloc_tree, &found,
+		MAKE_KEY(addr, 0));
+
+	if (found == NULL) {
+		pr_info("vmem_free: 0x%08x not found\n", (s32)addr);
+		VMEM_ASSERT;
+		return -1;
+	}
+
+	/* find previous free block */
+	page = found->page;
+	pageno = page->pageno;
+	free_page_size = page->alloc_pages;
+	prev_free_pageno = pageno - 1;
+	prev_size = -1;
+	if (prev_free_pageno >= 0) {
+		if (mm->page_list[prev_free_pageno].used == 0) {
+			prev_free_pageno =
+				mm->page_list[prev_free_pageno].first_pageno;
+			prev_size =
+				mm->page_list[prev_free_pageno].alloc_pages;
+		}
+	}
+
+	/* find next free block */
+	next_free_pageno = pageno + page->alloc_pages;
+	next_free_pageno =
+		(next_free_pageno == mm->num_pages) ? -1 : next_free_pageno;
+	next_size = -1;
+	if (next_free_pageno >= 0) {
+		if (mm->page_list[next_free_pageno].used == 0) {
+			next_size =
+				mm->page_list[next_free_pageno].alloc_pages;
+		}
+	}
+	VMEM_P_FREE(found);
+
+	/* merge */
+	merge_page_no = page->pageno;
+	merge_page_size = page->alloc_pages;
+	if (prev_size >= 0) {
+		mm->free_tree = avltree_remove(mm->free_tree, &found,
+			MAKE_KEY(prev_size, prev_free_pageno));
+		if (found == NULL) {
+			VMEM_ASSERT;
+			return -1;
+		}
+		merge_page_no = found->page->pageno;
+		merge_page_size += found->page->alloc_pages;
+		VMEM_P_FREE(found);
+	}
+	if (next_size >= 0) {
+		mm->free_tree = avltree_remove(mm->free_tree, &found,
+			MAKE_KEY(next_size, next_free_pageno));
+		if (found == NULL) {
+			VMEM_ASSERT;
+			return -1;
+		}
+		merge_page_size += found->page->alloc_pages;
+		VMEM_P_FREE(found);
+	}
+	page->alloc_pages = 0;
+	page->first_pageno = -1;
+	set_blocks_free(mm, merge_page_no, merge_page_size);
+	mm->alloc_page_count -= free_page_size;
+	mm->free_page_count += free_page_size;
+	return 0;
+}
+
+s32 vmem_get_info(struct video_mm_t *mm, struct vmem_info_t *info)
+{
+	if (mm == NULL) {
+		pr_info("vmem_get_info: invalid handle\n");
+		return -1;
+	}
+
+	if (info == NULL)
+		return -1;
+
+	info->total_pages = mm->num_pages;
+	info->alloc_pages = mm->alloc_page_count;
+	info->free_pages = mm->free_page_count;
+	info->page_size = VMEM_PAGE_SIZE;
+	return 0;
+}
+#endif /* __CNM_VIDEO_MEMORY_MANAGEMENT_H__ */
diff --git a/drivers/amlogic/amports/cnm/vpu.c b/drivers/amlogic/amports/cnm/vpu.c
new file mode 100644
index 0000000..6658ece
--- /dev/null
+++ b/drivers/amlogic/amports/cnm/vpu.c
@@ -0,0 +1,1989 @@
+/*
+ * vpu.c
+ *
+ * linux device driver for VPU.
+ *
+ * Copyright (C) 2006 - 2013  CHIPS&MEDIA INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/reset.h>
+#include <linux/clk.h>
+#include <linux/compat.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/of_address.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
+#include "../vdec_reg.h"
+#include "../amports_gate.h"
+
+#include "vpu.h"
+#include "vmm.h"
+
+/* definitions to be changed as customer  configuration */
+/* if you want to have clock gating scheme frame by frame */
+/* #define VPU_SUPPORT_CLOCK_CONTROL */
+
+#define VPU_PLATFORM_DEVICE_NAME "HevcEnc"
+#define VPU_DEV_NAME "HevcEnc"
+#define VPU_CLASS_NAME "HevcEnc"
+
+#ifndef VM_RESERVED	/*for kernel up to 3.7.0 version*/
+#define VM_RESERVED (VM_DONTEXPAND | VM_DONTDUMP)
+#endif
+
+#define VPU_INIT_VIDEO_MEMORY_SIZE_IN_BYTE (64 * SZ_1M)
+
+#define LOG_ALL 0
+#define LOG_INFO 1
+#define LOG_DEBUG 2
+#define LOG_ERROR 3
+
+#define enc_pr(level, x...) \
+	do { \
+		if (level >= print_level) \
+			printk(x); \
+	} while (0)
+
+static s32 print_level = LOG_DEBUG;
+
+static struct video_mm_t s_vmem;
+static struct vpudrv_buffer_t s_video_memory = {0};
+static bool use_reserve;
+static ulong cma_pool_size;
+
+/* end customer definition */
+static struct vpudrv_buffer_t s_instance_pool = {0};
+static struct vpudrv_buffer_t s_common_memory = {0};
+static struct vpu_drv_context_t s_vpu_drv_context;
+static s32 s_vpu_major;
+static struct device *hevcenc_dev;
+
+static s32 s_vpu_open_ref_count;
+static s32 s_vpu_irq;
+static bool s_vpu_irq_requested;
+
+static struct vpudrv_buffer_t s_vpu_register = {0};
+
+static s32 s_interrupt_flag;
+static wait_queue_head_t s_interrupt_wait_q;
+
+static spinlock_t s_vpu_lock = __SPIN_LOCK_UNLOCKED(s_vpu_lock);
+static DEFINE_SEMAPHORE(s_vpu_sem);
+static struct list_head s_vbp_head = LIST_HEAD_INIT(s_vbp_head);
+static struct list_head s_inst_list_head = LIST_HEAD_INIT(s_inst_list_head);
+static struct tasklet_struct hevc_tasklet;
+static struct platform_device *hevc_pdev;
+
+static struct vpu_bit_firmware_info_t s_bit_firmware_info[MAX_NUM_VPU_CORE];
+
+static void dma_flush(u32 buf_start , u32 buf_size)
+{
+	if (hevc_pdev)
+		dma_sync_single_for_device(
+			&hevc_pdev->dev, buf_start,
+			buf_size, DMA_TO_DEVICE);
+}
+
+static void cache_flush(u32 buf_start , u32 buf_size)
+{
+	if (hevc_pdev)
+		dma_sync_single_for_cpu(
+			&hevc_pdev->dev, buf_start,
+			buf_size, DMA_FROM_DEVICE);
+}
+
+s32 vpu_hw_reset(void)
+{
+	enc_pr(LOG_DEBUG, "request vpu reset from application.\n");
+	return 0;
+}
+
+s32 vpu_clk_config(u32 enable)
+{
+	if (enable)
+		HevcEnc_clock_enable(4);
+	else
+		HevcEnc_clock_disable();
+	return 0;
+}
+
+static s32 vpu_alloc_dma_buffer(struct vpudrv_buffer_t *vb)
+{
+	if (!vb)
+		return -1;
+
+	vb->phys_addr = (ulong)vmem_alloc(&s_vmem, vb->size, 0);
+	if ((ulong)vb->phys_addr == (ulong)-1) {
+		enc_pr(LOG_ERROR,
+			"Physical memory allocation error size=%d\n", vb->size);
+		return -1;
+	}
+
+	vb->base = (ulong)(s_video_memory.base +
+		(vb->phys_addr - s_video_memory.phys_addr));
+	return 0;
+}
+
+static void vpu_free_dma_buffer(struct vpudrv_buffer_t *vb)
+{
+	if (!vb)
+		return;
+
+	if (vb->base)
+		vmem_free(&s_vmem, vb->phys_addr, 0);
+}
+
+static s32 vpu_free_instances(struct file *filp)
+{
+	struct vpudrv_instanace_list_t *vil, *n;
+	struct vpudrv_instance_pool_t *vip;
+	void *vip_base;
+
+	enc_pr(LOG_DEBUG, "vpu_free_instances\n");
+
+	list_for_each_entry_safe(vil, n, &s_inst_list_head, list)
+	{
+		if (vil->filp == filp) {
+			vip_base = (void *)s_instance_pool.base;
+			enc_pr(LOG_INFO,
+				"free_instances instIdx=%d, coreIdx=%d, vip_base=%p\n",
+				(s32)vil->inst_idx,
+				(s32)vil->core_idx,
+				vip_base);
+			vip = (struct vpudrv_instance_pool_t *)vip_base;
+			if (vip) {
+				/* only first 4 byte is key point
+					(inUse of CodecInst in vpuapi)
+				    to free the corresponding instance. */
+				memset(&vip->codecInstPool[vil->inst_idx],
+					0x00, 4);
+			}
+			s_vpu_open_ref_count--;
+			list_del(&vil->list);
+			kfree(vil);
+		}
+	}
+	return 1;
+}
+
+static s32 vpu_free_buffers(struct file *filp)
+{
+	struct vpudrv_buffer_pool_t *pool, *n;
+	struct vpudrv_buffer_t vb;
+
+	enc_pr(LOG_DEBUG, "vpu_free_buffers\n");
+
+	list_for_each_entry_safe(pool, n, &s_vbp_head, list)
+	{
+		if (pool->filp == filp) {
+			vb = pool->vb;
+			if (vb.base) {
+				vpu_free_dma_buffer(&vb);
+				list_del(&pool->list);
+				kfree(pool);
+			}
+		}
+	}
+	return 0;
+}
+
+static u32 vpu_is_buffer_cached(struct file *filp, ulong vm_pgoff)
+{
+	struct vpudrv_buffer_pool_t *pool, *n;
+	struct vpudrv_buffer_t vb;
+	bool find = false;
+	u32 cached = 0;
+
+	enc_pr(LOG_ALL, "[+]vpu_is_buffer_cached\n");
+	spin_lock(&s_vpu_lock);
+	list_for_each_entry_safe(pool, n, &s_vbp_head, list)
+	{
+		if (pool->filp == filp) {
+			vb = pool->vb;
+			if (((vb.phys_addr  >> PAGE_SHIFT) == vm_pgoff)
+				&& find == false){
+				cached = vb.cached;
+				find = true;
+			}
+		}
+	}
+	spin_unlock(&s_vpu_lock);
+	enc_pr(LOG_ALL, "[-]vpu_is_buffer_cached, ret:%d\n", cached);
+	return cached;
+}
+
+static void hevcenc_isr_tasklet(ulong data)
+{
+	struct vpu_drv_context_t *dev = (struct vpu_drv_context_t *)data;
+	enc_pr(LOG_INFO, "hevcenc_isr_tasklet  interruput:0x%08lx\n",
+		dev->interrupt_reason);
+	if (dev->interrupt_reason) {
+		/* notify the interrupt to user space */
+		if (dev->async_queue) {
+			enc_pr(LOG_ALL, "kill_fasync e %s\n", __func__);
+			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
+		}
+		s_interrupt_flag = 1;
+		wake_up_interruptible(&s_interrupt_wait_q);
+	}
+	enc_pr(LOG_ALL, "[-]%s\n", __func__);
+}
+
+static irqreturn_t vpu_irq_handler(s32 irq, void *dev_id)
+{
+	struct vpu_drv_context_t *dev = (struct vpu_drv_context_t *)dev_id;
+	/* this can be removed.
+		it also work in VPU_WaitInterrupt of API function */
+	u32 core;
+	ulong interrupt_reason = 0;
+	enc_pr(LOG_ALL, "[+]%s\n", __func__);
+
+	for (core = 0; core < MAX_NUM_VPU_CORE; core++) {
+		if (s_bit_firmware_info[core].size == 0) {
+			/* it means that we didn't get an information
+				the current core from API layer.
+				No core activated.*/
+			enc_pr(LOG_ERROR,
+				"s_bit_firmware_info[core].size is zero\n");
+			continue;
+		}
+		if (ReadVpuRegister(W4_VPU_VPU_INT_STS)) {
+			interrupt_reason = ReadVpuRegister(W4_VPU_INT_REASON);
+			WriteVpuRegister(W4_VPU_INT_REASON_CLEAR,
+				interrupt_reason);
+			WriteVpuRegister(W4_VPU_VINT_CLEAR, 0x1);
+			dev->interrupt_reason |= interrupt_reason;
+		}
+		enc_pr(LOG_INFO,
+			"intr_reason: 0x%08lx\n", dev->interrupt_reason);
+	}
+	if (dev->interrupt_reason)
+		tasklet_schedule(&hevc_tasklet);
+	enc_pr(LOG_ALL, "[-]%s\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static s32 vpu_open(struct inode *inode, struct file *filp)
+{
+	bool alloc_buffer = false;
+	s32 r = 0;
+	enc_pr(LOG_DEBUG, "[+] %s\n", __func__);
+	spin_lock(&s_vpu_lock);
+	s_vpu_drv_context.open_count++;
+	if (s_vpu_drv_context.open_count == 1) {
+		alloc_buffer = true;
+	} else {
+		r = -EBUSY;
+		s_vpu_drv_context.open_count--;
+		spin_unlock(&s_vpu_lock);
+		goto Err;
+	}
+	filp->private_data = (void *)(&s_vpu_drv_context);
+	spin_unlock(&s_vpu_lock);
+	if (alloc_buffer && !use_reserve) {
+#ifdef CONFIG_CMA
+		s_video_memory.size = VPU_INIT_VIDEO_MEMORY_SIZE_IN_BYTE;
+		s_video_memory.phys_addr =
+			(ulong)codec_mm_alloc_for_dma(VPU_DEV_NAME,
+			VPU_INIT_VIDEO_MEMORY_SIZE_IN_BYTE >> PAGE_SHIFT, 0,
+			CODEC_MM_FLAGS_CPU);
+		if (s_video_memory.phys_addr)
+			s_video_memory.base =
+				(ulong)phys_to_virt(s_video_memory.phys_addr);
+		else
+			s_video_memory.base = 0;
+		if (s_video_memory.base) {
+			enc_pr(LOG_DEBUG,
+				"allocating phys 0x%lx, virt addr 0x%lx, size %dk\n",
+				s_video_memory.phys_addr,
+				s_video_memory.base,
+				s_video_memory.size >> 10);
+			if (vmem_init(&s_vmem,
+				s_video_memory.phys_addr,
+				s_video_memory.size) < 0) {
+				enc_pr(LOG_ERROR, "fail to init vmem system\n");
+				r = -ENOMEM;
+				codec_mm_free_for_dma(
+					VPU_DEV_NAME,
+					(u32)s_video_memory.phys_addr);
+				vmem_exit(&s_vmem);
+				memset(&s_video_memory, 0,
+					sizeof(struct vpudrv_buffer_t));
+				memset(&s_vmem, 0,
+					sizeof(struct video_mm_t));
+			}
+		} else {
+			enc_pr(LOG_ERROR,
+				"CMA failed to allocate dma buffer for %s, phys: 0x%lx\n",
+				VPU_DEV_NAME, s_video_memory.phys_addr);
+			if (s_video_memory.phys_addr)
+				codec_mm_free_for_dma(
+					VPU_DEV_NAME,
+					(u32)s_video_memory.phys_addr);
+			s_video_memory.phys_addr = 0;
+			r = -ENOMEM;
+		}
+#else
+		enc_pr(LOG_ERROR,
+			"No CMA and reserved memory for HevcEnc!!!\n");
+		r = -ENOMEM;
+#endif
+	} else if (!s_video_memory.base) {
+		enc_pr(LOG_ERROR,
+			"HevcEnc memory is not malloced!!!\n");
+		r = -ENOMEM;
+	}
+	if (alloc_buffer) {
+		ulong flags;
+		u32 data32;
+		if ((s_vpu_irq >= 0) && (s_vpu_irq_requested == false)) {
+			s32 err;
+			err = request_irq(s_vpu_irq, vpu_irq_handler, 0,
+				"HevcEnc-irq", (void *)(&s_vpu_drv_context));
+			if (err) {
+				enc_pr(LOG_ERROR,
+					"fail to register interrupt handler\n");
+				return -EFAULT;
+			}
+			s_vpu_irq_requested = true;
+		}
+		amports_switch_gate("vdec", 1);
+		spin_lock_irqsave(&s_vpu_lock, flags);
+		WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0,
+			READ_AOREG(AO_RTI_GEN_PWR_SLEEP0) & ~(0x3<<24));
+		udelay(10);
+
+		data32 = 0x700;
+		data32 |= READ_VREG(DOS_SW_RESET4);
+		WRITE_VREG(DOS_SW_RESET4, data32);
+		data32 &= ~0x700;
+		WRITE_VREG(DOS_SW_RESET4, data32);
+
+		WRITE_MPEG_REG(RESET0_REGISTER, data32 & ~(1<<21));
+		WRITE_MPEG_REG(RESET0_REGISTER, data32 | (1<<21));
+		READ_MPEG_REG(RESET0_REGISTER);
+		READ_MPEG_REG(RESET0_REGISTER);
+		READ_MPEG_REG(RESET0_REGISTER);
+		READ_MPEG_REG(RESET0_REGISTER);
+#ifndef VPU_SUPPORT_CLOCK_CONTROL
+		vpu_clk_config(1);
+#endif
+		/* Enable wave420l_vpu_idle_rise_irq,
+			Disable wave420l_vpu_idle_fall_irq */
+		WRITE_VREG(DOS_WAVE420L_CNTL_STAT, 0x1);
+		WRITE_VREG(DOS_MEM_PD_WAVE420L, 0x0);
+
+		WRITE_AOREG(AO_RTI_GEN_PWR_ISO0,
+			READ_AOREG(AO_RTI_GEN_PWR_ISO0) & ~(0x3<<12));
+		udelay(10);
+
+		spin_unlock_irqrestore(&s_vpu_lock, flags);
+	}
+Err:
+	enc_pr(LOG_DEBUG, "[-] %s, ret: %d\n", __func__, r);
+	return r;
+}
+
+static long vpu_ioctl(struct file *filp, u32 cmd, ulong arg)
+{
+	s32 ret = 0;
+	struct vpu_drv_context_t *dev =
+		(struct vpu_drv_context_t *)filp->private_data;
+
+	switch (cmd) {
+	case VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY:
+		{
+			struct vpudrv_buffer_pool_t *vbp;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY\n");
+			ret = down_interruptible(&s_vpu_sem);
+			if (ret == 0) {
+				vbp = kzalloc(sizeof(*vbp), GFP_KERNEL);
+				if (!vbp) {
+					up(&s_vpu_sem);
+					return -ENOMEM;
+				}
+
+				ret = copy_from_user(&(vbp->vb),
+					(struct vpudrv_buffer_t *)arg,
+					sizeof(struct vpudrv_buffer_t));
+				if (ret) {
+					kfree(vbp);
+					up(&s_vpu_sem);
+					return -EFAULT;
+				}
+
+				ret = vpu_alloc_dma_buffer(&(vbp->vb));
+				if (ret == -1) {
+					ret = -ENOMEM;
+					kfree(vbp);
+					up(&s_vpu_sem);
+					break;
+				}
+				ret = copy_to_user((void __user *)arg,
+					&(vbp->vb),
+					sizeof(struct vpudrv_buffer_t));
+				if (ret) {
+					kfree(vbp);
+					ret = -EFAULT;
+					up(&s_vpu_sem);
+					break;
+				}
+
+				vbp->filp = filp;
+				spin_lock(&s_vpu_lock);
+				list_add(&vbp->list, &s_vbp_head);
+				spin_unlock(&s_vpu_lock);
+
+				up(&s_vpu_sem);
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY\n");
+		}
+		break;
+	case VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY32:
+		{
+			struct vpudrv_buffer_pool_t *vbp;
+			struct compat_vpudrv_buffer_t buf32;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY32\n");
+			ret = down_interruptible(&s_vpu_sem);
+			if (ret == 0) {
+				vbp = kzalloc(sizeof(*vbp), GFP_KERNEL);
+				if (!vbp) {
+					up(&s_vpu_sem);
+					return -ENOMEM;
+				}
+
+				ret = copy_from_user(&buf32,
+					(struct compat_vpudrv_buffer_t *)arg,
+					sizeof(struct compat_vpudrv_buffer_t));
+				if (ret) {
+					kfree(vbp);
+					up(&s_vpu_sem);
+					return -EFAULT;
+				}
+
+				vbp->vb.size = buf32.size;
+				vbp->vb.cached = buf32.cached;
+				vbp->vb.phys_addr =
+					(ulong)buf32.phys_addr;
+				vbp->vb.base =
+					(ulong)buf32.base;
+				vbp->vb.virt_addr =
+					(ulong)buf32.virt_addr;
+				ret = vpu_alloc_dma_buffer(&(vbp->vb));
+				if (ret == -1) {
+					ret = -ENOMEM;
+					kfree(vbp);
+					up(&s_vpu_sem);
+					break;
+				}
+
+				buf32.size = vbp->vb.size;
+				buf32.phys_addr =
+					(compat_ulong_t)vbp->vb.phys_addr;
+				buf32.base =
+					(compat_ulong_t)vbp->vb.base;
+				buf32.virt_addr =
+					(compat_ulong_t)vbp->vb.virt_addr;
+
+				ret = copy_to_user((void __user *)arg,
+					&buf32,
+					sizeof(struct compat_vpudrv_buffer_t));
+				if (ret) {
+					kfree(vbp);
+					ret = -EFAULT;
+					up(&s_vpu_sem);
+					break;
+				}
+
+				vbp->filp = filp;
+				spin_lock(&s_vpu_lock);
+				list_add(&vbp->list, &s_vbp_head);
+				spin_unlock(&s_vpu_lock);
+
+				up(&s_vpu_sem);
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY32\n");
+		}
+		break;
+	case VDI_IOCTL_FREE_PHYSICALMEMORY:
+		{
+			struct vpudrv_buffer_pool_t *vbp, *n;
+			struct vpudrv_buffer_t vb;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_FREE_PHYSICALMEMORY\n");
+			ret = down_interruptible(&s_vpu_sem);
+			if (ret == 0) {
+				ret = copy_from_user(&vb,
+					(struct vpudrv_buffer_t *)arg,
+					sizeof(struct vpudrv_buffer_t));
+				if (ret) {
+					up(&s_vpu_sem);
+					return -EACCES;
+				}
+
+				if (vb.base)
+					vpu_free_dma_buffer(&vb);
+
+				spin_lock(&s_vpu_lock);
+				list_for_each_entry_safe(vbp, n,
+					&s_vbp_head, list)
+				{
+					if (vbp->vb.base == vb.base) {
+						list_del(&vbp->list);
+						kfree(vbp);
+						break;
+					}
+				}
+				spin_unlock(&s_vpu_lock);
+				up(&s_vpu_sem);
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_FREE_PHYSICALMEMORY\n");
+		}
+		break;
+	case VDI_IOCTL_FREE_PHYSICALMEMORY32:
+		{
+			struct vpudrv_buffer_pool_t *vbp, *n;
+			struct compat_vpudrv_buffer_t buf32;
+			struct vpudrv_buffer_t vb;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_FREE_PHYSICALMEMORY32\n");
+			ret = down_interruptible(&s_vpu_sem);
+			if (ret == 0) {
+				ret = copy_from_user(&buf32,
+					(struct compat_vpudrv_buffer_t *)arg,
+					sizeof(struct compat_vpudrv_buffer_t));
+				if (ret) {
+					up(&s_vpu_sem);
+					return -EACCES;
+				}
+
+				vb.size = buf32.size;
+				vb.phys_addr =
+					(ulong)buf32.phys_addr;
+				vb.base =
+					(ulong)buf32.base;
+				vb.virt_addr =
+					(ulong)buf32.virt_addr;
+
+				if (vb.base)
+					vpu_free_dma_buffer(&vb);
+
+				spin_lock(&s_vpu_lock);
+				list_for_each_entry_safe(vbp, n,
+					&s_vbp_head, list)
+				{
+					if ((compat_ulong_t)vbp->vb.base
+						== buf32.base) {
+						list_del(&vbp->list);
+						kfree(vbp);
+						break;
+					}
+				}
+				spin_unlock(&s_vpu_lock);
+				up(&s_vpu_sem);
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_FREE_PHYSICALMEMORY32\n");
+		}
+		break;
+	case VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO:
+		{
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO\n");
+			if (s_video_memory.base != 0) {
+				ret = copy_to_user((void __user *)arg,
+					&s_video_memory,
+					sizeof(struct vpudrv_buffer_t));
+				if (ret != 0)
+					ret = -EFAULT;
+			} else {
+				ret = -EFAULT;
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO\n");
+		}
+		break;
+	case VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO32:
+		{
+			struct compat_vpudrv_buffer_t buf32;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO32\n");
+
+			buf32.size = s_video_memory.size;
+			buf32.phys_addr =
+				(compat_ulong_t)s_video_memory.phys_addr;
+			buf32.base =
+				(compat_ulong_t)s_video_memory.base;
+			buf32.virt_addr =
+				(compat_ulong_t)s_video_memory.virt_addr;
+			if (s_video_memory.base != 0) {
+				ret = copy_to_user((void __user *)arg,
+					&buf32,
+					sizeof(struct compat_vpudrv_buffer_t));
+				if (ret != 0)
+					ret = -EFAULT;
+			} else {
+				ret = -EFAULT;
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO32\n");
+		}
+		break;
+	case VDI_IOCTL_WAIT_INTERRUPT:
+		{
+			struct vpudrv_intr_info_t info;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_WAIT_INTERRUPT\n");
+			ret = copy_from_user(&info,
+				(struct vpudrv_intr_info_t *)arg,
+				sizeof(struct vpudrv_intr_info_t));
+			if (ret != 0)
+				return -EFAULT;
+
+			ret = wait_event_interruptible_timeout(
+				s_interrupt_wait_q,
+				s_interrupt_flag != 0,
+				msecs_to_jiffies(info.timeout));
+			if (!ret) {
+				ret = -ETIME;
+				break;
+			}
+			if (dev->interrupt_reason & (1 << W4_INT_ENC_PIC)) {
+				u32 start, end, size, core = 0;
+				start = ReadVpuRegister(W4_BS_RD_PTR);
+				end = ReadVpuRegister(W4_BS_WR_PTR);
+				size = ReadVpuRegister(W4_RET_ENC_PIC_BYTE);
+				enc_pr(LOG_INFO, "flush output buffer, ");
+				enc_pr(LOG_INFO,
+					"start:0x%x, end:0x%x, size:0x%x\n",
+					start, end, size);
+				if (end - start > size && end > start)
+					size = end - start;
+				if (size > 0)
+					cache_flush(start, size);
+			}
+
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+
+			enc_pr(LOG_INFO,
+				"s_interrupt_flag(%d), reason(0x%08lx)\n",
+				s_interrupt_flag, dev->interrupt_reason);
+
+			info.intr_reason = dev->interrupt_reason;
+			s_interrupt_flag = 0;
+			dev->interrupt_reason = 0;
+			ret = copy_to_user((void __user *)arg,
+				&info, sizeof(struct vpudrv_intr_info_t));
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_WAIT_INTERRUPT\n");
+			if (ret != 0)
+				return -EFAULT;
+		}
+		break;
+	case VDI_IOCTL_SET_CLOCK_GATE:
+		{
+			u32 clkgate;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_SET_CLOCK_GATE\n");
+			if (get_user(clkgate, (u32 __user *) arg))
+				return -EFAULT;
+#ifdef VPU_SUPPORT_CLOCK_CONTROL
+			vpu_clk_config(clkgate);
+#endif
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_SET_CLOCK_GATE\n");
+		}
+		break;
+	case VDI_IOCTL_GET_INSTANCE_POOL:
+		{
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_INSTANCE_POOL\n");
+			ret = down_interruptible(&s_vpu_sem);
+			if (ret != 0)
+				break;
+
+			if (s_instance_pool.base != 0) {
+				ret = copy_to_user((void __user *)arg,
+					&s_instance_pool,
+					sizeof(struct vpudrv_buffer_t));
+				ret = (ret != 0) ? -EFAULT : 0;
+			} else {
+				ret = copy_from_user(&s_instance_pool,
+					(struct vpudrv_buffer_t *)arg,
+					sizeof(struct vpudrv_buffer_t));
+				if (ret == 0) {
+					s_instance_pool.size =
+						PAGE_ALIGN(
+						s_instance_pool.size);
+					s_instance_pool.base =
+						(ulong)vmalloc(
+						s_instance_pool.size);
+					s_instance_pool.phys_addr =
+						s_instance_pool.base;
+					if (s_instance_pool.base == 0) {
+						ret = -EFAULT;
+						up(&s_vpu_sem);
+						break;
+					}
+					/*clearing memory*/
+					memset((void *)s_instance_pool.base,
+						0, s_instance_pool.size);
+					ret = copy_to_user((void __user *)arg,
+						&s_instance_pool,
+						sizeof(struct vpudrv_buffer_t));
+					if (ret != 0)
+						ret = -EFAULT;
+				} else
+					ret = -EFAULT;
+			}
+			up(&s_vpu_sem);
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_INSTANCE_POOL\n");
+		}
+		break;
+	case VDI_IOCTL_GET_INSTANCE_POOL32:
+		{
+			struct compat_vpudrv_buffer_t buf32;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_INSTANCE_POOL32\n");
+			ret = down_interruptible(&s_vpu_sem);
+			if (ret != 0)
+				break;
+			if (s_instance_pool.base != 0) {
+				buf32.size = s_instance_pool.size;
+				buf32.phys_addr =
+					(compat_ulong_t)
+					s_instance_pool.phys_addr;
+				buf32.base =
+					(compat_ulong_t)
+					s_instance_pool.base;
+				buf32.virt_addr =
+					(compat_ulong_t)
+					s_instance_pool.virt_addr;
+				ret = copy_to_user((void __user *)arg,
+					&buf32,
+					sizeof(struct compat_vpudrv_buffer_t));
+				ret = (ret != 0) ? -EFAULT : 0;
+			} else {
+				ret = copy_from_user(&buf32,
+					(struct compat_vpudrv_buffer_t *)arg,
+					sizeof(struct compat_vpudrv_buffer_t));
+				if (ret == 0) {
+					s_instance_pool.size = buf32.size;
+					s_instance_pool.size =
+						PAGE_ALIGN(
+						s_instance_pool.size);
+					s_instance_pool.base =
+						(ulong)vmalloc(
+						s_instance_pool.size);
+					s_instance_pool.phys_addr =
+						s_instance_pool.base;
+					buf32.size =
+						s_instance_pool.size;
+					buf32.phys_addr =
+						(compat_ulong_t)
+						s_instance_pool.phys_addr;
+					buf32.base =
+						(compat_ulong_t)
+						s_instance_pool.base;
+					buf32.virt_addr =
+						(compat_ulong_t)
+						s_instance_pool.virt_addr;
+					if (s_instance_pool.base == 0) {
+						ret = -EFAULT;
+						up(&s_vpu_sem);
+						break;
+					}
+					/*clearing memory*/
+					memset((void *)s_instance_pool.base,
+						0x0, s_instance_pool.size);
+					ret = copy_to_user((void __user *)arg,
+						&buf32,
+						sizeof(
+						struct compat_vpudrv_buffer_t));
+					if (ret != 0)
+						ret = -EFAULT;
+				} else
+					ret = -EFAULT;
+			}
+			up(&s_vpu_sem);
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_INSTANCE_POOL32\n");
+		}
+		break;
+	case VDI_IOCTL_GET_COMMON_MEMORY:
+		{
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_COMMON_MEMORY\n");
+			if (s_common_memory.base != 0) {
+				ret = copy_to_user((void __user *)arg,
+					&s_common_memory,
+					sizeof(struct vpudrv_buffer_t));
+				if (ret != 0)
+					ret = -EFAULT;
+			} else {
+				ret = copy_from_user(&s_common_memory,
+					(struct vpudrv_buffer_t *)arg,
+					sizeof(struct vpudrv_buffer_t));
+				if (ret != 0) {
+					ret = -EFAULT;
+					break;
+				}
+				if (vpu_alloc_dma_buffer(
+					&s_common_memory) != -1) {
+					ret = copy_to_user((void __user *)arg,
+						&s_common_memory,
+						sizeof(struct vpudrv_buffer_t));
+					if (ret != 0)
+						ret = -EFAULT;
+				} else
+					ret = -EFAULT;
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_COMMON_MEMORY\n");
+		}
+		break;
+	case VDI_IOCTL_GET_COMMON_MEMORY32:
+		{
+			struct compat_vpudrv_buffer_t buf32;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_COMMON_MEMORY32\n");
+
+			buf32.size = s_common_memory.size;
+			buf32.phys_addr =
+				(compat_ulong_t)
+				s_common_memory.phys_addr;
+			buf32.base =
+				(compat_ulong_t)
+				s_common_memory.base;
+			buf32.virt_addr =
+				(compat_ulong_t)
+				s_common_memory.virt_addr;
+			if (s_common_memory.base != 0) {
+				ret = copy_to_user((void __user *)arg,
+					&buf32,
+					sizeof(struct compat_vpudrv_buffer_t));
+				if (ret != 0)
+					ret = -EFAULT;
+			} else {
+				ret = copy_from_user(&buf32,
+					(struct compat_vpudrv_buffer_t *)arg,
+					sizeof(struct compat_vpudrv_buffer_t));
+				if (ret != 0) {
+					ret = -EFAULT;
+					break;
+				}
+				s_common_memory.size = buf32.size;
+				if (vpu_alloc_dma_buffer(
+					&s_common_memory) != -1) {
+					buf32.size =
+						s_common_memory.size;
+					buf32.phys_addr =
+						(compat_ulong_t)
+						s_common_memory.phys_addr;
+					buf32.base =
+						(compat_ulong_t)
+						s_common_memory.base;
+					buf32.virt_addr =
+						(compat_ulong_t)
+						s_common_memory.virt_addr;
+					ret = copy_to_user((void __user *)arg,
+						&buf32,
+						sizeof(
+						struct compat_vpudrv_buffer_t));
+					if (ret != 0)
+						ret = -EFAULT;
+				} else
+					ret = -EFAULT;
+			}
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_COMMON_MEMORY32\n");
+		}
+		break;
+	case VDI_IOCTL_OPEN_INSTANCE:
+		{
+			struct vpudrv_inst_info_t inst_info;
+			struct vpudrv_instanace_list_t *vil, *n;
+
+			vil = kzalloc(sizeof(*vil), GFP_KERNEL);
+			if (!vil)
+				return -ENOMEM;
+
+			if (copy_from_user(&inst_info,
+				(struct vpudrv_inst_info_t *)arg,
+				sizeof(struct vpudrv_inst_info_t)))
+				return -EFAULT;
+
+			vil->inst_idx = inst_info.inst_idx;
+			vil->core_idx = inst_info.core_idx;
+			vil->filp = filp;
+
+			spin_lock(&s_vpu_lock);
+			list_add(&vil->list, &s_inst_list_head);
+
+			/* counting the current open instance number */
+			inst_info.inst_open_count = 0;
+			list_for_each_entry_safe(vil, n,
+				&s_inst_list_head, list)
+			{
+				if (vil->core_idx == inst_info.core_idx)
+					inst_info.inst_open_count++;
+			}
+
+			 /* flag just for that vpu is in opened or closed */
+			s_vpu_open_ref_count++;
+			spin_unlock(&s_vpu_lock);
+
+			if (copy_to_user((void __user *)arg,
+				&inst_info,
+				sizeof(struct vpudrv_inst_info_t))) {
+				kfree(vil);
+				return -EFAULT;
+			}
+
+			enc_pr(LOG_DEBUG,
+				"VDI_IOCTL_OPEN_INSTANCE ");
+			enc_pr(LOG_DEBUG,
+				"core_idx=%d, inst_idx=%d, ",
+				(u32)inst_info.core_idx,
+				(u32)inst_info.inst_idx);
+			enc_pr(LOG_DEBUG,
+				"s_vpu_open_ref_count=%d, inst_open_count=%d\n",
+				s_vpu_open_ref_count,
+				inst_info.inst_open_count);
+		}
+		break;
+	case VDI_IOCTL_CLOSE_INSTANCE:
+		{
+			struct vpudrv_inst_info_t inst_info;
+			struct vpudrv_instanace_list_t *vil, *n;
+
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_CLOSE_INSTANCE\n");
+			if (copy_from_user(&inst_info,
+				(struct vpudrv_inst_info_t *)arg,
+				sizeof(struct vpudrv_inst_info_t)))
+				return -EFAULT;
+
+			spin_lock(&s_vpu_lock);
+			list_for_each_entry_safe(vil, n,
+				&s_inst_list_head, list)
+			{
+				if (vil->inst_idx == inst_info.inst_idx &&
+					vil->core_idx == inst_info.core_idx) {
+					list_del(&vil->list);
+					kfree(vil);
+					break;
+				}
+			}
+
+			/* counting the current open instance number */
+			inst_info.inst_open_count = 0;
+			list_for_each_entry_safe(vil, n,
+				&s_inst_list_head, list)
+			{
+				if (vil->core_idx == inst_info.core_idx)
+					inst_info.inst_open_count++;
+			}
+
+			/* flag just for that vpu is in opened or closed */
+			s_vpu_open_ref_count--;
+			spin_unlock(&s_vpu_lock);
+
+			if (copy_to_user((void __user *)arg,
+				&inst_info,
+				sizeof(struct vpudrv_inst_info_t)))
+				return -EFAULT;
+
+			enc_pr(LOG_DEBUG,
+				"VDI_IOCTL_CLOSE_INSTANCE ");
+			enc_pr(LOG_DEBUG,
+				"core_idx=%d, inst_idx=%d, ",
+				(u32)inst_info.core_idx,
+				(u32)inst_info.inst_idx);
+			enc_pr(LOG_DEBUG,
+				"s_vpu_open_ref_count=%d, inst_open_count=%d\n",
+				s_vpu_open_ref_count,
+				inst_info.inst_open_count);
+		}
+		break;
+	case VDI_IOCTL_GET_INSTANCE_NUM:
+		{
+			struct vpudrv_inst_info_t inst_info;
+			struct vpudrv_instanace_list_t *vil, *n;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_INSTANCE_NUM\n");
+
+			ret = copy_from_user(&inst_info,
+				(struct vpudrv_inst_info_t *)arg,
+				sizeof(struct vpudrv_inst_info_t));
+			if (ret != 0)
+				break;
+
+			inst_info.inst_open_count = 0;
+
+			spin_lock(&s_vpu_lock);
+			list_for_each_entry_safe(vil, n,
+				&s_inst_list_head, list)
+			{
+				if (vil->core_idx == inst_info.core_idx)
+					inst_info.inst_open_count++;
+			}
+			spin_unlock(&s_vpu_lock);
+
+			ret = copy_to_user((void __user *)arg,
+				&inst_info,
+				sizeof(struct vpudrv_inst_info_t));
+
+			enc_pr(LOG_DEBUG,
+				"VDI_IOCTL_GET_INSTANCE_NUM ");
+			enc_pr(LOG_DEBUG,
+				"core_idx=%d, inst_idx=%d, open_count=%d\n",
+				(u32)inst_info.core_idx,
+				(u32)inst_info.inst_idx,
+				inst_info.inst_open_count);
+		}
+		break;
+	case VDI_IOCTL_RESET:
+		{
+			vpu_hw_reset();
+		}
+		break;
+	case VDI_IOCTL_GET_REGISTER_INFO:
+		{
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_REGISTER_INFO\n");
+			ret = copy_to_user((void __user *)arg,
+				&s_vpu_register,
+				sizeof(struct vpudrv_buffer_t));
+			if (ret != 0)
+				ret = -EFAULT;
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_REGISTER_INFO ");
+			enc_pr(LOG_ALL,
+				"s_vpu_register.phys_addr=0x%lx, ",
+				s_vpu_register.phys_addr);
+			enc_pr(LOG_ALL,
+				"s_vpu_register.virt_addr=0x%lx, ",
+				s_vpu_register.virt_addr);
+			enc_pr(LOG_ALL,
+				"s_vpu_register.size=0x%x\n",
+				s_vpu_register.size);
+		}
+		break;
+	case VDI_IOCTL_GET_REGISTER_INFO32:
+		{
+			struct compat_vpudrv_buffer_t buf32;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_GET_REGISTER_INFO32\n");
+
+			buf32.size = s_vpu_register.size;
+			buf32.phys_addr =
+				(compat_ulong_t)
+				s_vpu_register.phys_addr;
+			buf32.base =
+				(compat_ulong_t)
+				s_vpu_register.base;
+			buf32.virt_addr =
+				(compat_ulong_t)
+				s_vpu_register.virt_addr;
+			ret = copy_to_user((void __user *)arg,
+				&buf32,
+				sizeof(
+				struct compat_vpudrv_buffer_t));
+			if (ret != 0)
+				ret = -EFAULT;
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_GET_REGISTER_INFO32 ");
+			enc_pr(LOG_ALL,
+				"s_vpu_register.phys_addr=0x%lx, ",
+				s_vpu_register.phys_addr);
+			enc_pr(LOG_ALL,
+				"s_vpu_register.virt_addr=0x%lx, ",
+				s_vpu_register.virt_addr);
+			enc_pr(LOG_ALL,
+				"s_vpu_register.size=0x%x\n",
+				s_vpu_register.size);
+		}
+		break;
+	case VDI_IOCTL_FLUSH_BUFFER32:
+		{
+			struct vpudrv_buffer_pool_t *pool, *n;
+			struct compat_vpudrv_buffer_t buf32;
+			struct vpudrv_buffer_t vb;
+			bool find = false;
+			u32 cached = 0;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_FLUSH_BUFFER32\n");
+
+			ret = copy_from_user(&buf32,
+				(struct compat_vpudrv_buffer_t *)arg,
+				sizeof(struct compat_vpudrv_buffer_t));
+			if (ret)
+				return -EFAULT;
+			spin_lock(&s_vpu_lock);
+			list_for_each_entry_safe(pool, n,
+				&s_vbp_head, list)
+			{
+				if (pool->filp == filp) {
+					vb = pool->vb;
+					if (((compat_ulong_t)vb.phys_addr
+						== buf32.phys_addr)
+						&& find == false){
+						cached = vb.cached;
+						find = true;
+					}
+				}
+			}
+			spin_unlock(&s_vpu_lock);
+			if (find && cached)
+				dma_flush(
+					(u32)buf32.phys_addr,
+					(u32)buf32.size);
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_FLUSH_BUFFER32\n");
+		}
+		break;
+	case VDI_IOCTL_FLUSH_BUFFER:
+		{
+			struct vpudrv_buffer_pool_t *pool, *n;
+			struct vpudrv_buffer_t vb, buf;
+			bool find = false;
+			u32 cached = 0;
+			enc_pr(LOG_ALL,
+				"[+]VDI_IOCTL_FLUSH_BUFFER\n");
+
+			ret = copy_from_user(&buf,
+				(struct vpudrv_buffer_t *)arg,
+				sizeof(struct vpudrv_buffer_t));
+			if (ret)
+				return -EFAULT;
+			spin_lock(&s_vpu_lock);
+			list_for_each_entry_safe(pool, n,
+				&s_vbp_head, list)
+			{
+				if (pool->filp == filp) {
+					vb = pool->vb;
+					if ((vb.phys_addr
+						== buf.phys_addr)
+						&& find == false){
+						cached = vb.cached;
+						find = true;
+					}
+				}
+			}
+			spin_unlock(&s_vpu_lock);
+			if (find && cached)
+				dma_flush(
+					(u32)buf.phys_addr,
+					(u32)buf.size);
+			enc_pr(LOG_ALL,
+				"[-]VDI_IOCTL_FLUSH_BUFFER\n");
+		}
+		break;
+	default:
+		{
+			enc_pr(LOG_ERROR,
+				"No such IOCTL, cmd is %d\n", cmd);
+		}
+		break;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long vpu_compat_ioctl(struct file *filp, u32 cmd, ulong arg)
+{
+	long ret;
+
+	arg = (ulong)compat_ptr(arg);
+	ret = vpu_ioctl(filp, cmd, arg);
+	return ret;
+}
+#endif
+
+static ssize_t vpu_write(struct file *filp,
+	const char *buf,
+	size_t len,
+	loff_t *ppos)
+{
+	enc_pr(LOG_INFO, "vpu_write len=%d\n", (int)len);
+
+	if (!buf) {
+		enc_pr(LOG_ERROR, "vpu_write buf = NULL error\n");
+		return -EFAULT;
+	}
+
+	if (len == sizeof(struct vpu_bit_firmware_info_t))	{
+		struct vpu_bit_firmware_info_t *bit_firmware_info;
+		bit_firmware_info =
+			kmalloc(sizeof(struct vpu_bit_firmware_info_t),
+			GFP_KERNEL);
+		if (!bit_firmware_info) {
+			enc_pr(LOG_ERROR,
+				"vpu_write bit_firmware_info allocation error\n");
+			return -EFAULT;
+		}
+
+		if (copy_from_user(bit_firmware_info, buf, len)) {
+			enc_pr(LOG_ERROR,
+				"vpu_write copy_from_user error for bit_firmware_info\n");
+			return -EFAULT;
+		}
+
+		if (bit_firmware_info->size ==
+			sizeof(struct vpu_bit_firmware_info_t)) {
+			enc_pr(LOG_INFO,
+				"vpu_write set bit_firmware_info coreIdx=0x%x, ",
+				bit_firmware_info->core_idx);
+			enc_pr(LOG_INFO,
+				"reg_base_offset=0x%x size=0x%x, bit_code[0]=0x%x\n",
+				bit_firmware_info->reg_base_offset,
+				bit_firmware_info->size,
+				bit_firmware_info->bit_code[0]);
+
+			if (bit_firmware_info->core_idx
+				> MAX_NUM_VPU_CORE) {
+				enc_pr(LOG_ERROR,
+					"vpu_write coreIdx[%d] is ",
+					bit_firmware_info->core_idx);
+				enc_pr(LOG_ERROR,
+					"exceeded than MAX_NUM_VPU_CORE[%d]\n",
+					MAX_NUM_VPU_CORE);
+				return -ENODEV;
+			}
+
+			memcpy((void *)&s_bit_firmware_info
+				[bit_firmware_info->core_idx],
+				bit_firmware_info,
+				sizeof(struct vpu_bit_firmware_info_t));
+			kfree(bit_firmware_info);
+			return len;
+		}
+		kfree(bit_firmware_info);
+	}
+	return -1;
+}
+
+static s32 vpu_release(struct inode *inode, struct file *filp)
+{
+	s32 ret = 0;
+	ulong flags;
+	enc_pr(LOG_DEBUG, "vpu_release\n");
+	ret = down_interruptible(&s_vpu_sem);
+	if (ret == 0) {
+		vpu_free_buffers(filp);
+		vpu_free_instances(filp);
+		s_vpu_drv_context.open_count--;
+		if (s_vpu_drv_context.open_count == 0) {
+			if (s_instance_pool.base) {
+				enc_pr(LOG_DEBUG, "free instance pool\n");
+				vfree((const void *)s_instance_pool.base);
+				s_instance_pool.base = 0;
+			}
+			if (s_common_memory.base) {
+				enc_pr(LOG_DEBUG, "free common memory\n");
+				vpu_free_dma_buffer(&s_common_memory);
+				s_common_memory.base = 0;
+			}
+
+			if (s_video_memory.base && !use_reserve) {
+				codec_mm_free_for_dma(
+					VPU_DEV_NAME,
+					(u32)s_video_memory.phys_addr);
+				vmem_exit(&s_vmem);
+				memset(&s_video_memory,
+					0, sizeof(struct vpudrv_buffer_t));
+				memset(&s_vmem,
+					0, sizeof(struct video_mm_t));
+			}
+			if ((s_vpu_irq >= 0) && (s_vpu_irq_requested == true)) {
+				free_irq(s_vpu_irq, &s_vpu_drv_context);
+				s_vpu_irq_requested = false;
+			}
+			spin_lock_irqsave(&s_vpu_lock, flags);
+			WRITE_AOREG(AO_RTI_GEN_PWR_ISO0,
+				READ_AOREG(AO_RTI_GEN_PWR_ISO0) | (0x3<<12));
+			udelay(10);
+
+			WRITE_VREG(DOS_MEM_PD_WAVE420L, 0xffffffff);
+#ifndef VPU_SUPPORT_CLOCK_CONTROL
+			vpu_clk_config(0);
+#endif
+			WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0,
+				READ_AOREG(AO_RTI_GEN_PWR_SLEEP0) | (0x3<<24));
+			udelay(10);
+			spin_unlock_irqrestore(&s_vpu_lock, flags);
+			amports_switch_gate("vdec", 0);
+		}
+	}
+	up(&s_vpu_sem);
+	return 0;
+}
+
+static s32 vpu_fasync(s32 fd, struct file *filp, s32 mode)
+{
+	struct vpu_drv_context_t *dev =
+		(struct vpu_drv_context_t *)filp->private_data;
+	return fasync_helper(fd, filp, mode, &dev->async_queue);
+}
+
+static s32 vpu_map_to_register(struct file *fp, struct vm_area_struct *vm)
+{
+	ulong pfn;
+	vm->vm_flags |= VM_IO | VM_RESERVED;
+	vm->vm_page_prot =
+		pgprot_noncached(vm->vm_page_prot);
+	pfn = s_vpu_register.phys_addr >> PAGE_SHIFT;
+	return remap_pfn_range(vm, vm->vm_start, pfn,
+		vm->vm_end - vm->vm_start,
+		vm->vm_page_prot) ? -EAGAIN : 0;
+}
+
+static s32 vpu_map_to_physical_memory(
+	struct file *fp, struct vm_area_struct *vm)
+{
+	vm->vm_flags |= VM_IO | VM_RESERVED;
+	if (vm->vm_pgoff ==
+		(s_common_memory.phys_addr >> PAGE_SHIFT)) {
+		vm->vm_page_prot =
+			pgprot_noncached(vm->vm_page_prot);
+	} else {
+		if (vpu_is_buffer_cached(fp, vm->vm_pgoff) == 0)
+			vm->vm_page_prot =
+				pgprot_noncached(vm->vm_page_prot);
+	}
+	/* vm->vm_page_prot = pgprot_writecombine(vm->vm_page_prot); */
+	return remap_pfn_range(vm, vm->vm_start, vm->vm_pgoff,
+		vm->vm_end - vm->vm_start, vm->vm_page_prot) ? -EAGAIN : 0;
+}
+
+static s32 vpu_map_to_instance_pool_memory(
+	struct file *fp, struct vm_area_struct *vm)
+{
+	s32 ret;
+	long length = vm->vm_end - vm->vm_start;
+	ulong start = vm->vm_start;
+	s8 *vmalloc_area_ptr = (s8 *)s_instance_pool.base;
+	ulong pfn;
+
+	vm->vm_flags |= VM_RESERVED;
+
+	/* loop over all pages, map it page individually */
+	while (length > 0) {
+		pfn = vmalloc_to_pfn(vmalloc_area_ptr);
+		ret = remap_pfn_range(vm, start, pfn,
+			PAGE_SIZE, PAGE_SHARED);
+		if (ret < 0)
+			return ret;
+		start += PAGE_SIZE;
+		vmalloc_area_ptr += PAGE_SIZE;
+		length -= PAGE_SIZE;
+	}
+	return 0;
+}
+
+/*
+ * @brief memory map interface for vpu file operation
+ * @return 0 on success or negative error code on error
+ */
+static s32 vpu_mmap(struct file *fp, struct vm_area_struct *vm)
+{
+	if (vm->vm_pgoff == 0)
+		return vpu_map_to_instance_pool_memory(fp, vm);
+
+	if (vm->vm_pgoff == (s_vpu_register.phys_addr >> PAGE_SHIFT))
+		return vpu_map_to_register(fp, vm);
+
+	return vpu_map_to_physical_memory(fp, vm);
+}
+
+static const struct file_operations vpu_fops = {
+	.owner = THIS_MODULE,
+	.open = vpu_open,
+	.release = vpu_release,
+	.write = vpu_write,
+	.unlocked_ioctl = vpu_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = vpu_compat_ioctl,
+#endif
+	.fasync = vpu_fasync,
+	.mmap = vpu_mmap,
+};
+
+static ssize_t hevcenc_status_show(struct class *cla,
+				  struct class_attribute *attr, char *buf)
+{
+	return snprintf(buf, 40, "hevcenc_status_show\n");
+}
+
+static struct class_attribute hevcenc_class_attrs[] = {
+	__ATTR(encode_status,
+	S_IRUGO | S_IWUSR,
+	hevcenc_status_show,
+	NULL),
+	__ATTR_NULL
+};
+
+static struct class hevcenc_class = {
+	.name = VPU_CLASS_NAME,
+	.class_attrs = hevcenc_class_attrs,
+};
+
+s32 init_HevcEnc_device(void)
+{
+	s32  r = 0;
+	r = register_chrdev(0, VPU_DEV_NAME, &vpu_fops);
+	if (r <= 0) {
+		enc_pr(LOG_ERROR, "register hevcenc device error.\n");
+		return  r;
+	}
+	s_vpu_major = r;
+
+	r = class_register(&hevcenc_class);
+	if (r < 0) {
+		enc_pr(LOG_ERROR, "error create hevcenc class.\n");
+		return r;
+	}
+
+	hevcenc_dev = device_create(&hevcenc_class, NULL,
+				       MKDEV(s_vpu_major, 0), NULL,
+				       VPU_DEV_NAME);
+
+	if (IS_ERR(hevcenc_dev)) {
+		enc_pr(LOG_ERROR, "create hevcenc device error.\n");
+		class_unregister(&hevcenc_class);
+		return -1;
+	}
+	return r;
+}
+
+s32 uninit_HevcEnc_device(void)
+{
+	if (hevcenc_dev)
+		device_destroy(&hevcenc_class, MKDEV(s_vpu_major, 0));
+
+	class_destroy(&hevcenc_class);
+
+	unregister_chrdev(s_vpu_major, VPU_DEV_NAME);
+	return 0;
+}
+
+static s32 hevc_mem_device_init(
+	struct reserved_mem *rmem, struct device *dev)
+{
+	s32 r;
+	if (!rmem) {
+		enc_pr(LOG_ERROR,
+			"Can not obtain I/O memory, will allocate hevc buffer!\n");
+		r = -EFAULT;
+		return r;
+	}
+
+	if ((!rmem->base) ||
+		(rmem->size < VPU_INIT_VIDEO_MEMORY_SIZE_IN_BYTE)) {
+		enc_pr(LOG_ERROR,
+			"memory range error, 0x%lx - 0x%lx\n",
+			 (ulong)rmem->base, (ulong)rmem->size);
+		r = -EFAULT;
+		return r;
+	}
+	r = 0;
+	s_video_memory.size = rmem->size;
+	s_video_memory.phys_addr = (ulong)rmem->base;
+	s_video_memory.base =
+		(ulong)phys_to_virt(s_video_memory.phys_addr);
+	if (!s_video_memory.base) {
+		enc_pr(LOG_ERROR, "fail to remap video memory ");
+		enc_pr(LOG_ERROR,
+			"physical phys_addr=0x%lx, base=0x%lx, size=0x%x\n",
+			(ulong)s_video_memory.phys_addr,
+			(ulong)s_video_memory.base,
+			(u32)s_video_memory.size);
+		s_video_memory.phys_addr = 0;
+		r = -EFAULT;
+	}
+	return r;
+}
+
+static s32 vpu_probe(struct platform_device *pdev)
+{
+	s32 err = 0, irq, reg_count, idx;
+	struct resource res;
+	struct device_node *np, *child;
+
+	enc_pr(LOG_DEBUG, "vpu_probe\n");
+
+	s_vpu_major = 0;
+	use_reserve = false;
+	s_vpu_irq = -1;
+	cma_pool_size = 0;
+	s_vpu_irq_requested = false;
+	s_vpu_open_ref_count = 0;
+	hevcenc_dev = NULL;
+	hevc_pdev = NULL;
+	memset(&s_video_memory, 0, sizeof(struct vpudrv_buffer_t));
+	memset(&s_vpu_register, 0, sizeof(struct vpudrv_buffer_t));
+	memset(&s_vmem, 0, sizeof(struct video_mm_t));
+	memset(&s_bit_firmware_info[0], 0, sizeof(s_bit_firmware_info));
+	memset(&res, 0, sizeof(struct resource));
+
+	idx = of_reserved_mem_device_init(&pdev->dev);
+	if (idx != 0) {
+		enc_pr(LOG_DEBUG,
+			"HevcEnc reserved memory config fail.\n");
+	} else if (s_video_memory.phys_addr) {
+		use_reserve = true;
+	}
+
+	if (use_reserve == false) {
+#ifndef CONFIG_CMA
+		enc_pr(LOG_ERROR,
+			"HevcEnc reserved memory is invaild, probe fail!\n");
+		err = -EFAULT;
+		goto ERROR_PROVE_DEVICE;
+#else
+		cma_pool_size =
+			(codec_mm_get_total_size() >
+			(VPU_INIT_VIDEO_MEMORY_SIZE_IN_BYTE)) ?
+			(VPU_INIT_VIDEO_MEMORY_SIZE_IN_BYTE) :
+			codec_mm_get_total_size();
+		enc_pr(LOG_DEBUG,
+			"HevcEnc - cma memory pool size: %d MB\n",
+			(u32)cma_pool_size / SZ_1M);
+#endif
+	}
+
+	/* get interrupt resource */
+	irq = platform_get_irq_byname(pdev, "wave420l_irq");
+	if (irq < 0) {
+		enc_pr(LOG_ERROR, "get HevcEnc irq resource error\n");
+		err = -ENXIO;
+		goto ERROR_PROVE_DEVICE;
+	}
+	s_vpu_irq = irq;
+	enc_pr(LOG_DEBUG, "HevcEnc - wave420l_irq: %d\n", s_vpu_irq);
+#if 0
+	rstc = devm_reset_control_get(&pdev->dev, "HevcEnc");
+	if (IS_ERR(rstc)) {
+		enc_pr(LOG_ERROR,
+			"get HevcEnc rstc error: %lx\n", PTR_ERR(rstc));
+		rstc = NULL;
+		err = -ENOENT;
+		goto ERROR_PROVE_DEVICE;
+	}
+	reset_control_assert(rstc);
+	s_vpu_rstc = rstc;
+
+	clk = clk_get(&pdev->dev, "clk_HevcEnc");
+	if (IS_ERR(clk)) {
+		enc_pr(LOG_ERROR, "cannot get clock\n");
+		clk = NULL;
+		err = -ENOENT;
+		goto ERROR_PROVE_DEVICE;
+	}
+	s_vpu_clk = clk;
+#endif
+
+#ifdef VPU_SUPPORT_CLOCK_CONTROL
+#else
+	vpu_clk_config(1);
+#endif
+
+	np = pdev->dev.of_node;
+	reg_count = 0;
+	for_each_child_of_node(np, child) {
+		if (of_address_to_resource(child, 0, &res)
+			|| (reg_count > 1)) {
+			enc_pr(LOG_ERROR,
+				"no reg ranges or more reg ranges %d\n",
+				reg_count);
+			err = -ENXIO;
+			goto ERROR_PROVE_DEVICE;
+		}
+		/* if platform driver is implemented */
+		if (res.start != 0) {
+			s_vpu_register.phys_addr = res.start;
+			s_vpu_register.virt_addr =
+				(ulong)ioremap_nocache(
+				res.start, resource_size(&res));
+			s_vpu_register.size = res.end - res.start;
+			enc_pr(LOG_DEBUG,
+				"vpu base address get from platform driver ");
+			enc_pr(LOG_DEBUG,
+				"physical base addr=0x%lx, virtual base=0x%lx\n",
+				s_vpu_register.phys_addr,
+				s_vpu_register.virt_addr);
+		} else {
+			s_vpu_register.phys_addr = VPU_REG_BASE_ADDR;
+			s_vpu_register.virt_addr =
+				(ulong)ioremap_nocache(
+				s_vpu_register.phys_addr, VPU_REG_SIZE);
+			s_vpu_register.size = VPU_REG_SIZE;
+			enc_pr(LOG_DEBUG,
+				"vpu base address get from defined value ");
+			enc_pr(LOG_DEBUG,
+				"physical base addr=0x%lx, virtual base=0x%lx\n",
+				s_vpu_register.phys_addr,
+				s_vpu_register.virt_addr);
+		}
+		reg_count++;
+	}
+
+	/* get the major number of the character device */
+	if (init_HevcEnc_device()) {
+		err = -EBUSY;
+		enc_pr(LOG_ERROR, "could not allocate major number\n");
+		goto ERROR_PROVE_DEVICE;
+	}
+	enc_pr(LOG_INFO, "SUCCESS alloc_chrdev_region\n");
+
+	init_waitqueue_head(&s_interrupt_wait_q);
+	tasklet_init(&hevc_tasklet,
+		hevcenc_isr_tasklet,
+		(ulong)&s_vpu_drv_context);
+	s_common_memory.base = 0;
+	s_instance_pool.base = 0;
+
+	if (use_reserve == true) {
+		if (vmem_init(&s_vmem, s_video_memory.phys_addr,
+			s_video_memory.size) < 0) {
+			enc_pr(LOG_ERROR, "fail to init vmem system\n");
+			goto ERROR_PROVE_DEVICE;
+		}
+		enc_pr(LOG_DEBUG,
+			"success to probe vpu device with video memory ");
+		enc_pr(LOG_DEBUG,
+			"phys_addr=0x%lx, base = 0x%lx\n",
+			(ulong)s_video_memory.phys_addr,
+			(ulong)s_video_memory.base);
+	} else
+		enc_pr(LOG_DEBUG,
+			"success to probe vpu device with video memory from cma\n");
+	hevc_pdev = pdev;
+	return 0;
+
+ERROR_PROVE_DEVICE:
+	if (s_vpu_register.virt_addr) {
+		iounmap((void *)s_vpu_register.virt_addr);
+		memset(&s_vpu_register, 0, sizeof(struct vpudrv_buffer_t));
+	}
+
+	if (s_video_memory.base) {
+		vmem_exit(&s_vmem);
+		memset(&s_video_memory, 0, sizeof(struct vpudrv_buffer_t));
+		memset(&s_vmem, 0, sizeof(struct video_mm_t));
+	}
+
+	vpu_clk_config(0);
+
+	if (s_vpu_irq_requested == true) {
+		if (s_vpu_irq >= 0) {
+			free_irq(s_vpu_irq, &s_vpu_drv_context);
+			s_vpu_irq = -1;
+		}
+		s_vpu_irq_requested = false;
+	}
+	uninit_HevcEnc_device();
+	return err;
+}
+
+static s32 vpu_remove(struct platform_device *pdev)
+{
+	enc_pr(LOG_DEBUG, "vpu_remove\n");
+
+	if (s_instance_pool.base) {
+		vfree((const void *)s_instance_pool.base);
+		s_instance_pool.base = 0;
+	}
+
+	if (s_common_memory.base) {
+		vpu_free_dma_buffer(&s_common_memory);
+		s_common_memory.base = 0;
+	}
+
+	if (s_video_memory.base) {
+		if (!use_reserve)
+			codec_mm_free_for_dma(
+			VPU_DEV_NAME,
+			(u32)s_video_memory.phys_addr);
+		vmem_exit(&s_vmem);
+		memset(&s_video_memory,
+			0, sizeof(struct vpudrv_buffer_t));
+		memset(&s_vmem,
+			0, sizeof(struct video_mm_t));
+	}
+
+	if (s_vpu_irq_requested == true) {
+		if (s_vpu_irq >= 0) {
+			free_irq(s_vpu_irq, &s_vpu_drv_context);
+			s_vpu_irq = -1;
+		}
+		s_vpu_irq_requested = false;
+	}
+
+	if (s_vpu_register.virt_addr) {
+		iounmap((void *)s_vpu_register.virt_addr);
+		memset(&s_vpu_register,
+			0, sizeof(struct vpudrv_buffer_t));
+	}
+	hevc_pdev = NULL;
+	vpu_clk_config(0);
+
+	uninit_HevcEnc_device();
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static void Wave4BitIssueCommand(u32 core, u32 cmd)
+{
+	WriteVpuRegister(W4_VPU_BUSY_STATUS, 1);
+	WriteVpuRegister(W4_CORE_INDEX, 0);
+	/* coreIdx = ReadVpuRegister(W4_VPU_BUSY_STATUS); */
+	/* coreIdx = 0; */
+	/* WriteVpuRegister(W4_INST_INDEX,
+		(instanceIndex & 0xffff) | (codecMode << 16)); */
+	WriteVpuRegister(W4_COMMAND, cmd);
+	WriteVpuRegister(W4_VPU_HOST_INT_REQ, 1);
+	return;
+}
+
+static s32 vpu_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	u32 core;
+	ulong timeout = jiffies + HZ; /* vpu wait timeout to 1sec */
+	enc_pr(LOG_DEBUG, "vpu_suspend\n");
+
+	vpu_clk_config(1);
+
+	if (s_vpu_open_ref_count > 0) {
+		for (core = 0; core < MAX_NUM_VPU_CORE; core++) {
+			if (s_bit_firmware_info[core].size == 0)
+				continue;
+			while (ReadVpuRegister(W4_VPU_BUSY_STATUS)) {
+				if (time_after(jiffies, timeout)) {
+					enc_pr(LOG_ERROR,
+						"SLEEP_VPU BUSY timeout");
+					goto DONE_SUSPEND;
+				}
+			}
+			Wave4BitIssueCommand(core, W4_CMD_SLEEP_VPU);
+
+			while (ReadVpuRegister(W4_VPU_BUSY_STATUS)) {
+				if (time_after(jiffies, timeout)) {
+					enc_pr(LOG_ERROR,
+						"SLEEP_VPU BUSY timeout");
+					goto DONE_SUSPEND;
+				}
+			}
+			if (ReadVpuRegister(W4_RET_SUCCESS) == 0) {
+				enc_pr(LOG_ERROR,
+					"SLEEP_VPU failed [0x%x]",
+					ReadVpuRegister(W4_RET_FAIL_REASON));
+				goto DONE_SUSPEND;
+			}
+		}
+	}
+
+	vpu_clk_config(0);
+	return 0;
+
+DONE_SUSPEND:
+	vpu_clk_config(0);
+	return -EAGAIN;
+}
+static s32 vpu_resume(struct platform_device *pdev)
+{
+	u32 i;
+	u32 core;
+	u32 val;
+	ulong timeout = jiffies + HZ; /* vpu wait timeout to 1sec */
+	ulong code_base;
+	u32 code_size;
+	u32 remap_size;
+	u32 regVal;
+	u32 hwOption = 0;
+
+	enc_pr(LOG_DEBUG, "vpu_resume\n");
+
+	vpu_clk_config(1);
+
+	for (core = 0; core < MAX_NUM_VPU_CORE; core++) {
+		if (s_bit_firmware_info[core].size == 0)
+			continue;
+		code_base = s_common_memory.phys_addr;
+		/* ALIGN TO 4KB */
+		code_size = (s_common_memory.size & ~0xfff);
+		if (code_size < s_bit_firmware_info[core].size * 2)
+			goto DONE_WAKEUP;
+
+		/*---- LOAD BOOT CODE */
+		for (i = 0; i < 512; i += 2) {
+			val = s_bit_firmware_info[core].bit_code[i];
+			val |= (s_bit_firmware_info[core].bit_code[i+1] << 16);
+			WriteVpu(code_base+(i*2), val);
+		}
+
+		regVal = 0;
+		WriteVpuRegister(W4_PO_CONF, regVal);
+
+		/* Reset All blocks */
+		regVal = 0x7ffffff;
+		WriteVpuRegister(W4_VPU_RESET_REQ, regVal);
+
+		/* Waiting reset done */
+		while (ReadVpuRegister(W4_VPU_RESET_STATUS)) {
+			if (time_after(jiffies, timeout))
+				goto DONE_WAKEUP;
+		}
+
+		WriteVpuRegister(W4_VPU_RESET_REQ, 0);
+
+		/* remap page size */
+		remap_size = (code_size >> 12) & 0x1ff;
+		regVal = 0x80000000 | (W4_REMAP_CODE_INDEX<<12)
+			| (0 << 16) | (1<<11) | remap_size;
+		WriteVpuRegister(W4_VPU_REMAP_CTRL, regVal);
+		/* DO NOT CHANGE! */
+		WriteVpuRegister(W4_VPU_REMAP_VADDR, 0x00000000);
+		WriteVpuRegister(W4_VPU_REMAP_PADDR, code_base);
+		WriteVpuRegister(W4_ADDR_CODE_BASE, code_base);
+		WriteVpuRegister(W4_CODE_SIZE, code_size);
+		WriteVpuRegister(W4_CODE_PARAM, 0);
+		WriteVpuRegister(W4_INIT_VPU_TIME_OUT_CNT, timeout);
+		WriteVpuRegister(W4_HW_OPTION, hwOption);
+
+		/* Interrupt */
+		regVal = (1 << W4_INT_DEC_PIC_HDR);
+		regVal |= (1 << W4_INT_DEC_PIC);
+		regVal |= (1 << W4_INT_QUERY_DEC);
+		regVal |= (1 << W4_INT_SLEEP_VPU);
+		regVal |= (1 << W4_INT_BSBUF_EMPTY);
+		regVal = 0xfffffefe;
+		WriteVpuRegister(W4_VPU_VINT_ENABLE, regVal);
+		Wave4BitIssueCommand(core, W4_CMD_INIT_VPU);
+		WriteVpuRegister(W4_VPU_REMAP_CORE_START, 1);
+		while (ReadVpuRegister(W4_VPU_BUSY_STATUS)) {
+			if (time_after(jiffies, timeout))
+				goto DONE_WAKEUP;
+		}
+
+		if (ReadVpuRegister(W4_RET_SUCCESS) == 0) {
+			enc_pr(LOG_ERROR,
+				"WAKEUP_VPU failed [0x%x]",
+				ReadVpuRegister(W4_RET_FAIL_REASON));
+			goto DONE_WAKEUP;
+		}
+	}
+
+	if (s_vpu_open_ref_count == 0)
+		vpu_clk_config(0);
+DONE_WAKEUP:
+	if (s_vpu_open_ref_count > 0)
+		vpu_clk_config(1);
+	return 0;
+}
+#else
+#define vpu_suspend NULL
+#define vpu_resume NULL
+#endif /* !CONFIG_PM */
+
+static const struct of_device_id cnm_hevcenc_dt_match[] = {
+	{
+		.compatible = "cnm, HevcEnc",
+	},
+	{},
+};
+
+static struct platform_driver vpu_driver = {
+	.driver = {
+		.name = VPU_PLATFORM_DEVICE_NAME,
+		.of_match_table = cnm_hevcenc_dt_match,
+	},
+	.probe = vpu_probe,
+	.remove = vpu_remove,
+	.suspend = vpu_suspend,
+	.resume = vpu_resume,
+};
+
+static s32 __init vpu_init(void)
+{
+	s32 res;
+	enc_pr(LOG_DEBUG, "vpu_init\n");
+	if (get_cpu_type() != MESON_CPU_MAJOR_ID_GXM) {
+		enc_pr(LOG_DEBUG,
+			"The chip is not support hevc encoder\n");
+		return -1;
+	}
+	res = platform_driver_register(&vpu_driver);
+	enc_pr(LOG_INFO,
+		"end vpu_init result=0x%x\n", res);
+	return res;
+}
+
+static void __exit vpu_exit(void)
+{
+	enc_pr(LOG_DEBUG, "vpu_exit\n");
+	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
+		platform_driver_unregister(&vpu_driver);
+	return;
+}
+
+static const struct reserved_mem_ops rmem_hevc_ops = {
+	.device_init = hevc_mem_device_init,
+};
+
+static s32 __init hevc_mem_setup(struct reserved_mem *rmem)
+{
+	rmem->ops = &rmem_hevc_ops;
+	enc_pr(LOG_DEBUG, "HevcEnc reserved mem setup.\n");
+	return 0;
+}
+
+module_param(print_level, uint, 0664);
+MODULE_PARM_DESC(print_level, "\n print_level\n");
+
+MODULE_AUTHOR("Amlogic using C&M VPU, Inc.");
+MODULE_DESCRIPTION("VPU linux driver");
+MODULE_LICENSE("GPL");
+
+module_init(vpu_init);
+module_exit(vpu_exit);
+RESERVEDMEM_OF_DECLARE(cnm_hevc, "cnm, HevcEnc-memory", hevc_mem_setup);
diff --git a/drivers/amlogic/amports/cnm/vpu.h b/drivers/amlogic/amports/cnm/vpu.h
new file mode 100644
index 0000000..b406661
--- /dev/null
+++ b/drivers/amlogic/amports/cnm/vpu.h
@@ -0,0 +1,287 @@
+/*
+ * vpu.h
+ *
+ * linux device driver for VPU.
+ *
+ * Copyright (C) 2006 - 2013  CHIPS&MEDIA INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __VPU_DRV_H__
+#define __VPU_DRV_H__
+
+#include <linux/fs.h>
+#include <linux/types.h>
+
+#define MAX_INST_HANDLE_SIZE	        (32*1024)
+#define MAX_NUM_INSTANCE                4
+#define MAX_NUM_VPU_CORE                1
+
+#define W4_CMD_INIT_VPU				(0x0001)
+#define W4_CMD_SLEEP_VPU				(0x0400)
+#define W4_CMD_WAKEUP_VPU			(0x0800)
+
+/* GXM: 2000/10 = 200M */
+#define HevcEnc_L0()   WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			 (3 << 25) | (1 << 16) | (3 << 9) | (1 << 0))
+/* GXM: 2000/8 = 250M */
+#define HevcEnc_L1()   WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			 (1 << 25) | (1 << 16) | (1 << 9) | (1 << 0))
+/* GXM: 2000/7 = 285M */
+#define HevcEnc_L2()   WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			 (4 << 25) | (0 << 16) | (4 << 9) | (0 << 0))
+/*GXM: 2000/6 = 333M */
+#define HevcEnc_L3()   WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			 (2 << 25) | (1 << 16) | (2 << 9) | (1 << 0))
+/* GXM: 2000/5 = 400M */
+#define HevcEnc_L4()   WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			 (3 << 25) | (0 << 16) | (3 << 9) | (0 << 0))
+/* GXM: 2000/4 = 500M */
+#define HevcEnc_L5()   WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			 (1 << 25) | (0 << 16) | (1 << 9) | (0 << 0))
+/* GXM: 2000/3 = 667M */
+#define HevcEnc_L6()   WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			 (2 << 25) | (0 << 16) | (2 << 9) | (0 << 0))
+
+#define HevcEnc_clock_enable(level) \
+	do { \
+		WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			READ_HHI_REG(HHI_WAVE420L_CLK_CNTL) \
+			& (~(1 << 8)) & (~(1 << 24))); \
+		if (level == 0)  \
+			HevcEnc_L0(); \
+		else if (level == 1)  \
+			HevcEnc_L1(); \
+		else if (level == 2)  \
+			HevcEnc_L2(); \
+		else if (level == 3)  \
+			HevcEnc_L3(); \
+		else if (level == 4)  \
+			HevcEnc_L4(); \
+		else if (level == 5)  \
+			HevcEnc_L5(); \
+		else if (level == 6)  \
+			HevcEnc_L6(); \
+		WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			READ_HHI_REG(HHI_WAVE420L_CLK_CNTL) \
+			| (1 << 8) | (1 << 24)); \
+	} while (0)
+
+#define HevcEnc_clock_disable() \
+		WRITE_HHI_REG(HHI_WAVE420L_CLK_CNTL, \
+			READ_HHI_REG(HHI_WAVE420L_CLK_CNTL) \
+			& (~(1 << 8)) & (~(1 << 24)));
+
+struct compat_vpudrv_buffer_t {
+	u32 size;
+	u32 cached;
+	compat_ulong_t phys_addr;
+	compat_ulong_t base; /* kernel logical address in use kernel */
+	compat_ulong_t virt_addr; /* virtual user space address */
+};
+
+struct vpudrv_buffer_t {
+	u32 size;
+	u32 cached;
+	ulong phys_addr;
+	ulong base; /* kernel logical address in use kernel */
+	ulong virt_addr; /* virtual user space address */
+};
+
+struct vpu_bit_firmware_info_t {
+	u32 size; /* size of this structure*/
+	u32 core_idx;
+	u32 reg_base_offset;
+	u16 bit_code[512];
+};
+
+struct vpudrv_inst_info_t {
+	u32 core_idx;
+	u32 inst_idx;
+	s32 inst_open_count;	/* for output only*/
+};
+
+struct vpudrv_intr_info_t {
+	u32 timeout;
+	s32 intr_reason;
+};
+
+struct vpu_drv_context_t {
+	struct fasync_struct *async_queue;
+	ulong interrupt_reason;
+	u32 open_count; /*!<< device reference count. Not instance count */
+};
+
+/* To track the allocated memory buffer */
+struct vpudrv_buffer_pool_t {
+	struct list_head list;
+	struct vpudrv_buffer_t vb;
+	struct file *filp;
+};
+
+/* To track the instance index and buffer in instance pool */
+struct vpudrv_instanace_list_t {
+	struct list_head list;
+	ulong inst_idx;
+	ulong core_idx;
+	struct file *filp;
+};
+
+struct vpudrv_instance_pool_t {
+	u8 codecInstPool[MAX_NUM_INSTANCE][MAX_INST_HANDLE_SIZE];
+};
+
+#define VPUDRV_BUF_LEN struct vpudrv_buffer_t
+#define VPUDRV_BUF_LEN32 struct compat_vpudrv_buffer_t
+#define VPUDRV_INST_LEN struct vpudrv_inst_info_t
+
+#define VDI_MAGIC  'V'
+#define VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY \
+	_IOW(VDI_MAGIC, 0, VPUDRV_BUF_LEN)
+
+#define VDI_IOCTL_FREE_PHYSICALMEMORY \
+	_IOW(VDI_MAGIC, 1, VPUDRV_BUF_LEN)
+
+#define VDI_IOCTL_WAIT_INTERRUPT \
+	_IOW(VDI_MAGIC, 2, struct vpudrv_intr_info_t)
+
+#define VDI_IOCTL_SET_CLOCK_GATE \
+	_IOW(VDI_MAGIC, 3, u32)
+
+#define VDI_IOCTL_RESET \
+	_IOW(VDI_MAGIC, 4, u32)
+
+#define VDI_IOCTL_GET_INSTANCE_POOL \
+	_IOW(VDI_MAGIC, 5, VPUDRV_BUF_LEN)
+
+#define VDI_IOCTL_GET_COMMON_MEMORY \
+	_IOW(VDI_MAGIC, 6, VPUDRV_BUF_LEN)
+
+#define VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO \
+	_IOW(VDI_MAGIC, 8, VPUDRV_BUF_LEN)
+
+#define VDI_IOCTL_OPEN_INSTANCE \
+	_IOW(VDI_MAGIC, 9, VPUDRV_INST_LEN)
+
+#define VDI_IOCTL_CLOSE_INSTANCE \
+	_IOW(VDI_MAGIC, 10, VPUDRV_INST_LEN)
+
+#define VDI_IOCTL_GET_INSTANCE_NUM \
+	_IOW(VDI_MAGIC, 11, VPUDRV_INST_LEN)
+
+#define VDI_IOCTL_GET_REGISTER_INFO \
+	_IOW(VDI_MAGIC, 12, VPUDRV_BUF_LEN)
+
+#define VDI_IOCTL_FLUSH_BUFFER \
+	_IOW(VDI_MAGIC, 13, VPUDRV_BUF_LEN)
+
+#define VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY32 \
+	_IOW(VDI_MAGIC, 0, VPUDRV_BUF_LEN32)
+
+#define VDI_IOCTL_FREE_PHYSICALMEMORY32 \
+	_IOW(VDI_MAGIC, 1, VPUDRV_BUF_LEN32)
+
+#define VDI_IOCTL_GET_INSTANCE_POOL32 \
+	_IOW(VDI_MAGIC, 5, VPUDRV_BUF_LEN32)
+
+#define VDI_IOCTL_GET_COMMON_MEMORY32 \
+	_IOW(VDI_MAGIC, 6, VPUDRV_BUF_LEN32)
+
+#define VDI_IOCTL_GET_RESERVED_VIDEO_MEMORY_INFO32 \
+	_IOW(VDI_MAGIC, 8, VPUDRV_BUF_LEN32)
+
+#define VDI_IOCTL_GET_REGISTER_INFO32 \
+	_IOW(VDI_MAGIC, 12, VPUDRV_BUF_LEN32)
+
+#define VDI_IOCTL_FLUSH_BUFFER32 \
+	_IOW(VDI_MAGIC, 13, VPUDRV_BUF_LEN32)
+
+enum {
+	W4_INT_INIT_VPU = 0,
+	W4_INT_DEC_PIC_HDR = 1,
+	W4_INT_SET_PARAM = 1,
+	W4_INT_ENC_INIT_SEQ = 1,
+	W4_INT_FINI_SEQ = 2,
+	W4_INT_DEC_PIC = 3,
+	W4_INT_ENC_PIC = 3,
+	W4_INT_SET_FRAMEBUF = 4,
+	W4_INT_FLUSH_DEC = 5,
+	W4_INT_ENC_SLICE_INT = 7,
+	W4_INT_GET_FW_VERSION = 8,
+	W4_INT_QUERY_DEC = 9,
+	W4_INT_SLEEP_VPU = 10,
+	W4_INT_WAKEUP_VPU = 11,
+	W4_INT_CHANGE_INT = 12,
+	W4_INT_CREATE_INSTANCE = 14,
+	W4_INT_BSBUF_EMPTY = 15,
+    /*!<< Bitstream buffer empty[dec]/full[enc] */
+};
+
+/* WAVE4 registers */
+#define VPU_REG_BASE_ADDR	0xc8810000
+#define VPU_REG_SIZE	(0x4000 * MAX_NUM_VPU_CORE)
+
+#define W4_REG_BASE					0x0000
+#define W4_VPU_BUSY_STATUS			(W4_REG_BASE + 0x0070)
+#define W4_VPU_INT_REASON_CLEAR			(W4_REG_BASE + 0x0034)
+#define W4_VPU_VINT_CLEAR				(W4_REG_BASE + 0x003C)
+#define W4_VPU_VPU_INT_STS			(W4_REG_BASE + 0x0044)
+#define W4_VPU_INT_REASON				(W4_REG_BASE + 0x004c)
+
+#define W4_RET_SUCCESS					(W4_REG_BASE + 0x0110)
+#define W4_RET_FAIL_REASON			(W4_REG_BASE + 0x0114)
+
+/* WAVE4 INIT, WAKEUP */
+#define W4_PO_CONF					(W4_REG_BASE + 0x0000)
+#define W4_VCPU_CUR_PC					(W4_REG_BASE + 0x0004)
+
+#define W4_VPU_VINT_ENABLE			(W4_REG_BASE + 0x0048)
+
+#define W4_VPU_RESET_REQ				(W4_REG_BASE + 0x0050)
+#define W4_VPU_RESET_STATUS			(W4_REG_BASE + 0x0054)
+
+#define W4_VPU_REMAP_CTRL				(W4_REG_BASE + 0x0060)
+#define W4_VPU_REMAP_VADDR			(W4_REG_BASE + 0x0064)
+#define W4_VPU_REMAP_PADDR			(W4_REG_BASE + 0x0068)
+#define W4_VPU_REMAP_CORE_START			(W4_REG_BASE + 0x006C)
+#define W4_VPU_BUSY_STATUS			(W4_REG_BASE + 0x0070)
+
+#define W4_HW_OPTION					(W4_REG_BASE + 0x0124)
+#define W4_CODE_SIZE					(W4_REG_BASE + 0x011C)
+/* Note: W4_INIT_CODE_BASE_ADDR should be aligned to 4KB */
+#define W4_ADDR_CODE_BASE			(W4_REG_BASE + 0x0118)
+#define W4_CODE_PARAM					(W4_REG_BASE + 0x0120)
+#define W4_INIT_VPU_TIME_OUT_CNT		(W4_REG_BASE + 0x0134)
+
+/* WAVE4 Wave4BitIssueCommand */
+#define W4_CORE_INDEX					(W4_REG_BASE + 0x0104)
+#define W4_INST_INDEX					(W4_REG_BASE + 0x0108)
+#define W4_COMMAND					(W4_REG_BASE + 0x0100)
+#define W4_VPU_HOST_INT_REQ			(W4_REG_BASE + 0x0038)
+
+#define W4_BS_RD_PTR					(W4_REG_BASE + 0x0130)
+#define W4_BS_WR_PTR					(W4_REG_BASE + 0x0134)
+#define W4_RET_ENC_PIC_BYTE			(W4_REG_BASE + 0x01C8)
+
+#define W4_REMAP_CODE_INDEX			 0
+
+#define ReadVpuRegister(addr) \
+	readl((void __iomem *)(s_vpu_register.virt_addr \
+	+ s_bit_firmware_info[core].reg_base_offset + addr))
+
+#define WriteVpuRegister(addr, val) \
+	writel((u32)val, (void __iomem *)(s_vpu_register.virt_addr \
+	+ s_bit_firmware_info[core].reg_base_offset + addr))
+
+#define WriteVpu(addr, val) writel((u32)val, (void __iomem *)addr)
+#endif
diff --git a/drivers/amlogic/amports/encoder.c b/drivers/amlogic/amports/encoder.c
index efdefdd..cb67053 100644
--- a/drivers/amlogic/amports/encoder.c
+++ b/drivers/amlogic/amports/encoder.c
@@ -54,12 +54,14 @@
 
 #define ENCODE_NAME "encoder"
 #define AMVENC_CANVAS_INDEX 0xE4
-#define AMVENC_CANVAS_MAX_INDEX 0xEC
+#define AMVENC_CANVAS_MAX_INDEX 0xEF
 
-#define MIN_SIZE 18
+#define MIN_SIZE 20
 #define DUMP_INFO_BYTES_PER_MB 80
 /* #define USE_OLD_DUMP_MC */
 
+#define ADJUSTED_QP_FLAG 64
+
 static s32 avc_device_major;
 static struct device *amvenc_avc_dev;
 #define DRIVER_NAME "amvenc_avc"
@@ -83,6 +85,8 @@ static struct encode_manager_s encode_manager;
 #define DECODED_MB_Y                DOS_SCRATCH22
 #endif
 
+/* #define ENABLE_IGNORE_FUNCTION */
+
 static u32 anc0_buffer_id;
 static u32 ie_me_mb_type;
 static u32 ie_me_mode;
@@ -94,7 +98,7 @@ static u32 enable_dblk = 1;  /* 0 disable, 1 vdec 2 hdec */
 
 static u32 encode_print_level = LOG_DEBUG;
 static u32 no_timeout;
-static u32 nr_mode = 3;
+static int nr_mode = -1;
 
 static u32 me_mv_merge_ctl =
 	(0x1 << 31)  |  /* [31] me_merge_mv_en_16 */
@@ -150,131 +154,231 @@ static u32 p_mb_quant_dec_cfg = (60 << 24) | (40 << 16) | (30 << 8) | (20 << 0);
 /* [15:0] NUM_ROWS_PER_SLICE_I */
 static u32 fixed_slice_cfg;
 
+/* y tnr */
+static unsigned int y_tnr_mc_en = 1;
+static unsigned int y_tnr_txt_mode;
+static unsigned int y_tnr_mot_sad_margin = 1;
+static unsigned int y_tnr_mot_cortxt_rate = 1;
+static unsigned int y_tnr_mot_distxt_ofst = 5;
+static unsigned int y_tnr_mot_distxt_rate = 4;
+static unsigned int y_tnr_mot_dismot_ofst = 4;
+static unsigned int y_tnr_mot_frcsad_lock = 8;
+static unsigned int y_tnr_mot2alp_frc_gain = 10;
+static unsigned int y_tnr_mot2alp_nrm_gain = 216;
+static unsigned int y_tnr_mot2alp_dis_gain = 128;
+static unsigned int y_tnr_mot2alp_dis_ofst = 32;
+static unsigned int y_tnr_alpha_min = 32;
+static unsigned int y_tnr_alpha_max = 63;
+static unsigned int y_tnr_deghost_os;
+/* c tnr */
+static unsigned int c_tnr_mc_en = 1;
+static unsigned int c_tnr_txt_mode;
+static unsigned int c_tnr_mot_sad_margin = 1;
+static unsigned int c_tnr_mot_cortxt_rate = 1;
+static unsigned int c_tnr_mot_distxt_ofst = 5;
+static unsigned int c_tnr_mot_distxt_rate = 4;
+static unsigned int c_tnr_mot_dismot_ofst = 4;
+static unsigned int c_tnr_mot_frcsad_lock = 8;
+static unsigned int c_tnr_mot2alp_frc_gain = 10;
+static unsigned int c_tnr_mot2alp_nrm_gain = 216;
+static unsigned int c_tnr_mot2alp_dis_gain = 128;
+static unsigned int c_tnr_mot2alp_dis_ofst = 32;
+static unsigned int c_tnr_alpha_min = 32;
+static unsigned int c_tnr_alpha_max = 63;
+static unsigned int c_tnr_deghost_os;
+/* y snr */
+static unsigned int y_snr_err_norm = 1;
+static unsigned int y_snr_gau_bld_core = 1;
+static int y_snr_gau_bld_ofst = -1;
+static unsigned int y_snr_gau_bld_rate = 48;
+static unsigned int y_snr_gau_alp0_min;
+static unsigned int y_snr_gau_alp0_max = 63;
+static unsigned int y_bld_beta2alp_rate = 16;
+static unsigned int y_bld_beta_min;
+static unsigned int y_bld_beta_max = 63;
+/* c snr */
+static unsigned int c_snr_err_norm = 1;
+static unsigned int c_snr_gau_bld_core = 1;
+static int c_snr_gau_bld_ofst = -1;
+static unsigned int c_snr_gau_bld_rate = 48;
+static unsigned int c_snr_gau_alp0_min;
+static unsigned int c_snr_gau_alp0_max = 63;
+static unsigned int c_bld_beta2alp_rate = 16;
+static unsigned int c_bld_beta_min;
+static unsigned int c_bld_beta_max = 63;
+
 static DEFINE_SPINLOCK(lock);
 
 #define ADV_MV_LARGE_16x8 1
 #define ADV_MV_LARGE_8x16 1
 #define ADV_MV_LARGE_16x16 1
 
-#ifdef MAX_WEIGHT
-#define ME_WEIGHT_OFFSET 0x270
-#define I4MB_WEIGHT_OFFSET 0x4e0
-#define I16MB_WEIGHT_OFFSET 0x340
+/* me weight offset should not very small, it used by v1 me module. */
+/* the min real sad for me is 16 by hardware. */
+#define ME_WEIGHT_OFFSET 0x520
+#define I4MB_WEIGHT_OFFSET 0x655
+#define I16MB_WEIGHT_OFFSET 0x560
 
 #define ADV_MV_16x16_WEIGHT 0x080
-#define ADV_MV_16_8_WEIGHT 0x100
-#define ADV_MV_8x8_WEIGHT 0x200
-#define ADV_MV_4x4x4_WEIGHT 0x300
-#else
-#define ME_WEIGHT_OFFSET 0x3320
-#define I4MB_WEIGHT_OFFSET 0x3655
-#define I16MB_WEIGHT_OFFSET 0x3320
-
-#define ADV_MV_16x16_WEIGHT 0x000
-#define ADV_MV_16_8_WEIGHT 0x2000
-#define ADV_MV_8x8_WEIGHT 0x3000
+#define ADV_MV_16_8_WEIGHT 0x0e0
+#define ADV_MV_8x8_WEIGHT 0x240
 #define ADV_MV_4x4x4_WEIGHT 0x3000
-#endif
 
-#define IE_SAD_SHIFT_I16 0x003
-#define IE_SAD_SHIFT_I4 0x003
-#define ME_SAD_SHIFT_INTER 0x002
+#define IE_SAD_SHIFT_I16 0x001
+#define IE_SAD_SHIFT_I4 0x001
+#define ME_SAD_SHIFT_INTER 0x001
 
-#define STEP_2_SKIP_SAD    0x20
-#define STEP_1_SKIP_SAD    0x30
-#define STEP_0_SKIP_SAD    0x30
-#define STEP_2_SKIP_WEIGHT 0x04
-#define STEP_1_SKIP_WEIGHT 0x04
-#define STEP_0_SKIP_WEIGHT 0x04
+#define STEP_2_SKIP_SAD 0
+#define STEP_1_SKIP_SAD 0
+#define STEP_0_SKIP_SAD 0
+#define STEP_2_SKIP_WEIGHT 0
+#define STEP_1_SKIP_WEIGHT 0
+#define STEP_0_SKIP_WEIGHT 0
 
-#define ME_SAD_RANGE_0 0x0
+#define ME_SAD_RANGE_0 0x1 /* 0x0 */
 #define ME_SAD_RANGE_1 0x0
 #define ME_SAD_RANGE_2 0x0
 #define ME_SAD_RANGE_3 0x0
 
-#define ME_MV_PRE_WEIGHT_0 0x0
-#define ME_MV_PRE_WEIGHT_1 0x0
+/* use 0 for v3, 0x18 for v2 */
+#define ME_MV_PRE_WEIGHT_0 0x18
+/* use 0 for v3, 0x18 for v2 */
+#define ME_MV_PRE_WEIGHT_1 0x18
 #define ME_MV_PRE_WEIGHT_2 0x0
 #define ME_MV_PRE_WEIGHT_3 0x0
 
-#define ME_MV_STEP_WEIGHT_0 0x0
-#define ME_MV_STEP_WEIGHT_1 0x0
+/* use 0 for v3, 0x18 for v2 */
+#define ME_MV_STEP_WEIGHT_0 0x18
+/* use 0 for v3, 0x18 for v2 */
+#define ME_MV_STEP_WEIGHT_1 0x18
 #define ME_MV_STEP_WEIGHT_2 0x0
 #define ME_MV_STEP_WEIGHT_3 0x0
 
-#define ME_SAD_ENOUGH_0_DATA   0x00
-#define ME_SAD_ENOUGH_1_DATA   0x04
-#define ME_SAD_ENOUGH_2_DATA   0x11
+#define ME_SAD_ENOUGH_0_DATA 0x00
+#define ME_SAD_ENOUGH_1_DATA 0x04
+#define ME_SAD_ENOUGH_2_DATA 0x11
 #define ADV_MV_8x8_ENOUGH_DATA 0x20
 
-#ifndef USE_OLD_DUMP_MC
-static u32  quant_tbl_i4[2][8] = {
-	{
-		0x1b1a1918,
-		0x1f1e1d1c,
-		0x21212020,
-		0x22222222,
-		0x23232323,
-		0x24242424,
-		0x25252525,
-		0x26262525
-	},
-	{
-		0x1f1f1e1e,
-		0x20201f1f,
-		0x21212020,
-		0x22222121,
-		0x23232222,
-		0x24242323,
-		0x25252424,
-		0x26262525
-	}
-};
-
-static u32  quant_tbl_i16[2][8] = {
-	{
-		0x1b1a1918,
-		0x1f1e1d1c,
-		0x21212020,
-		0x22222222,
-		0x23232323,
-		0x24242424,
-		0x25252525,
-		0x26262525
-	},
-	{
-		0x1f1f1e1e,
-		0x20201f1f,
-		0x21212020,
-		0x22222121,
-		0x23232222,
-		0x24242323,
-		0x25252424,
-		0x26262525
-	}
-};
+/* V4_COLOR_BLOCK_FIX */
+#define V3_FORCE_SKIP_SAD_0 0x10
+/* 4 Blocks */
+#define V3_FORCE_SKIP_SAD_1 0x60
+/* 16 Blocks + V3_SKIP_WEIGHT_2 */
+#define V3_FORCE_SKIP_SAD_2 0x250
+/* almost disable it -- use t_lac_coeff_2 output to F_ZERO is better */
+#define V3_ME_F_ZERO_SAD (ME_WEIGHT_OFFSET + 0x10)
+
+#define V3_IE_F_ZERO_SAD_I16 (I16MB_WEIGHT_OFFSET + 0x10)
+#define V3_IE_F_ZERO_SAD_I4 (I4MB_WEIGHT_OFFSET + 0x20)
+
+#define V3_SKIP_WEIGHT_0 0x10
+/* 4 Blocks  8 seperate search sad can be very low */
+#define V3_SKIP_WEIGHT_1 0x8 /* (4 * ME_MV_STEP_WEIGHT_1 + 0x100) */
+#define V3_SKIP_WEIGHT_2 0x3
+
+#define V3_LEVEL_1_F_SKIP_MAX_SAD 0x0
+#define V3_LEVEL_1_SKIP_MAX_SAD 0x6
+
+#define I4_ipred_weight_most   0x18
+#define I4_ipred_weight_else   0x28
+
+#define C_ipred_weight_V       0x04
+#define C_ipred_weight_H       0x08
+#define C_ipred_weight_DC      0x0c
+
+#define I16_ipred_weight_V       0x04
+#define I16_ipred_weight_H       0x08
+#define I16_ipred_weight_DC      0x0c
+
+/* 0x00 same as disable */
+#define v3_left_small_max_ie_sad 0x00
+#define v3_left_small_max_me_sad 0x40
+
+#define v5_use_small_diff_cnt 0
+#define v5_simple_mb_inter_all_en 1
+#define v5_simple_mb_inter_8x8_en 1
+#define v5_simple_mb_inter_16_8_en 1
+#define v5_simple_mb_inter_16x16_en 1
+#define v5_simple_mb_intra_en 1
+#define v5_simple_mb_C_en 0
+#define v5_simple_mb_Y_en 1
+#define v5_small_diff_Y 0x10
+#define v5_small_diff_C 0x18
+/* shift 8-bits, 2, 1, 0, -1, -2, -3, -4 */
+#define v5_simple_dq_setting 0x43210fed
+#define v5_simple_me_weight_setting 0
 
-static u32  quant_tbl_me[2][8] = {
-	{
-		0x1b1a1918,
-		0x1f1e1d1c,
-		0x21212020,
-		0x22222222,
-		0x23232323,
-		0x24242424,
-		0x25252525,
-		0x26262525
-	},
-	{
-		0x1f1f1e1e,
-		0x20201f1f,
-		0x21212020,
-		0x22222121,
-		0x23232222,
-		0x24242323,
-		0x25252424,
-		0x26262525
-	}
+#ifndef USE_OLD_DUMP_MC
+static u32 qp_table_pr;
+static u32 v3_mv_sad[64] = {
+	/* For step0 */
+	0x00000004,
+	0x00010008,
+	0x00020010,
+	0x00030018,
+	0x00040020,
+	0x00050028,
+	0x00060038,
+	0x00070048,
+	0x00080058,
+	0x00090068,
+	0x000a0080,
+	0x000b0098,
+	0x000c00b0,
+	0x000d00c8,
+	0x000e00e8,
+	0x000f0110,
+	/* For step1 */
+	0x00100002,
+	0x00110004,
+	0x00120008,
+	0x0013000c,
+	0x00140010,
+	0x00150014,
+	0x0016001c,
+	0x00170024,
+	0x0018002c,
+	0x00190034,
+	0x001a0044,
+	0x001b0054,
+	0x001c0064,
+	0x001d0074,
+	0x001e0094,
+	0x001f00b4,
+	/* For step2 */
+	0x00200006,
+	0x0021000c,
+	0x0022000c,
+	0x00230018,
+	0x00240018,
+	0x00250018,
+	0x00260018,
+	0x00270030,
+	0x00280030,
+	0x00290030,
+	0x002a0030,
+	0x002b0030,
+	0x002c0030,
+	0x002d0030,
+	0x002e0030,
+	0x002f0050,
+	/* For step2 4x4-8x8 */
+	0x00300001,
+	0x00310002,
+	0x00320002,
+	0x00330004,
+	0x00340004,
+	0x00350004,
+	0x00360004,
+	0x00370006,
+	0x00380006,
+	0x00390006,
+	0x003a0006,
+	0x003b0006,
+	0x003c0006,
+	0x003d0006,
+	0x003e0006,
+	0x003f0006
 };
 #endif
 
@@ -323,6 +427,10 @@ static struct BuffInfo_s amvenc_buffspec[] = {
 		.qp_info = {
 			.buf_start = 0x438000,
 			.buf_size = 0x8000,
+		},
+			.scale_buff = {
+			.buf_start = 0,
+			.buf_size = 0,
 		}
 #ifdef USE_VDEC2
 		,
@@ -375,6 +483,10 @@ static struct BuffInfo_s amvenc_buffspec[] = {
 		.qp_info = {
 			.buf_start = 0x890000,
 			.buf_size = 0x8000,
+		},
+		.scale_buff = {
+			.buf_start = 0,
+			.buf_size = 0,
 		}
 #ifdef USE_VDEC2
 		,
@@ -387,7 +499,7 @@ static struct BuffInfo_s amvenc_buffspec[] = {
 		.lev_id = AMVENC_BUFFER_LEVEL_1080P,
 		.max_width = 1920,
 		.max_height = 1088,
-		.min_buffsize = 0x1160000,
+		.min_buffsize = 0x1370000,
 		.dct = {
 			.buf_start = 0,
 			.buf_size = 0x6ba000,
@@ -408,30 +520,34 @@ static struct BuffInfo_s amvenc_buffspec[] = {
 			.buf_start = 0xe00000,
 			.buf_size = 0x100000,
 		},
-		.inter_bits_info = {
+		.scale_buff = {
 			.buf_start = 0xf00000,
+			.buf_size = 0x200000,
+		},
+		.inter_bits_info = {
+			.buf_start = 0x1100000,
 			.buf_size = 0x8000,
 		},
 		.inter_mv_info = {
-			.buf_start = 0xf08000,
+			.buf_start = 0x1108000,
 			.buf_size = 0x80000,
 		},
 		.intra_bits_info = {
-			.buf_start = 0xf88000,
+			.buf_start = 0x1188000,
 			.buf_size = 0x8000,
 		},
 		.intra_pred_info = {
-			.buf_start = 0xf90000,
+			.buf_start = 0x1190000,
 			.buf_size = 0x80000,
 		},
 		.qp_info = {
-			.buf_start = 0x1010000,
+			.buf_start = 0x1210000,
 			.buf_size = 0x8000,
 		}
 #ifdef USE_VDEC2
 		,
 		.vdec2_info = {
-			.buf_start = 0x1020000,
+			.buf_start = 0x12b0000,
 			.buf_size = 0x13e000,
 		}
 #endif
@@ -450,6 +566,8 @@ enum ucode_type_e {
 	UCODE_SW_HDEC_GX_DBLK,
 	UCODE_VDEC2,
 	UCODE_GX,
+	UCODE_GXTV,
+	UCODE_TXL,
 	UCODE_MAX
 };
 
@@ -465,16 +583,31 @@ const char *ucode_name[] = {
 	"mix_sw_mc_hdec_gx_dblk",
 	"vdec2_encoder_mc",
 	"h264_enc_mc_gx",
+	"h264_enc_mc_gxtv",
+	"h264_enc_mc_txl",
 };
 
 static void dma_flush(u32 buf_start, u32 buf_size);
+static void cache_flush(u32 buf_start , u32 buf_size);
 
 static const char *select_ucode(u32 ucode_index)
 {
 	enum ucode_type_e ucode = UCODE_DUMP;
 	switch (ucode_index) {
 	case UCODE_MODE_FULL:
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+#ifndef USE_OLD_DUMP_MC
+			ucode = UCODE_TXL;
+#else
+			ucode = UCODE_DUMP_GX_DBLK;
+#endif
+		} else if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+#ifndef USE_OLD_DUMP_MC
+			ucode = UCODE_GXTV;
+#else
+			ucode = UCODE_DUMP_GX_DBLK;
+#endif
+		} else if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 #ifndef USE_OLD_DUMP_MC
 			ucode = UCODE_GX;
 #else
@@ -521,70 +654,70 @@ static const char *select_ucode(u32 ucode_index)
 }
 
 #ifndef USE_OLD_DUMP_MC
-static void hcodec_prog_qtbl(uint32_t index)
+static void hcodec_prog_qtbl(struct encode_wq_s *wq)
 {
 	WRITE_HREG(HCODEC_Q_QUANT_CONTROL,
 		(0 << 23) |  /* quant_table_addr */
 		(1 << 22));  /* quant_table_addr_update */
 
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][0]);
+		wq->quant_tbl_i4[wq->qp_table_id][0]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][1]);
+		wq->quant_tbl_i4[wq->qp_table_id][1]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][2]);
+		wq->quant_tbl_i4[wq->qp_table_id][2]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][3]);
+		wq->quant_tbl_i4[wq->qp_table_id][3]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][4]);
+		wq->quant_tbl_i4[wq->qp_table_id][4]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][5]);
+		wq->quant_tbl_i4[wq->qp_table_id][5]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][6]);
+		wq->quant_tbl_i4[wq->qp_table_id][6]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i4[index][7]);
+		wq->quant_tbl_i4[wq->qp_table_id][7]);
 
 	WRITE_HREG(HCODEC_Q_QUANT_CONTROL,
 		(8 << 23) |  /* quant_table_addr */
 		(1 << 22));  /* quant_table_addr_update */
 
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][0]);
+		wq->quant_tbl_i16[wq->qp_table_id][0]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][1]);
+		wq->quant_tbl_i16[wq->qp_table_id][1]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][2]);
+		wq->quant_tbl_i16[wq->qp_table_id][2]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][3]);
+		wq->quant_tbl_i16[wq->qp_table_id][3]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][4]);
+		wq->quant_tbl_i16[wq->qp_table_id][4]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][5]);
+		wq->quant_tbl_i16[wq->qp_table_id][5]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][6]);
+		wq->quant_tbl_i16[wq->qp_table_id][6]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_i16[index][7]);
+		wq->quant_tbl_i16[wq->qp_table_id][7]);
 
 	WRITE_HREG(HCODEC_Q_QUANT_CONTROL,
 		(16 << 23) | /* quant_table_addr */
 		(1 << 22));  /* quant_table_addr_update */
 
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][0]);
+		wq->quant_tbl_me[wq->qp_table_id][0]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][1]);
+		wq->quant_tbl_me[wq->qp_table_id][1]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][2]);
+		wq->quant_tbl_me[wq->qp_table_id][2]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][3]);
+		wq->quant_tbl_me[wq->qp_table_id][3]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][4]);
+		wq->quant_tbl_me[wq->qp_table_id][4]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][5]);
+		wq->quant_tbl_me[wq->qp_table_id][5]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][6]);
+		wq->quant_tbl_me[wq->qp_table_id][6]);
 	WRITE_HREG(HCODEC_QUANT_TABLE_DATA,
-		quant_tbl_me[index][7]);
+		wq->quant_tbl_me[wq->qp_table_id][7]);
 	return;
 }
 #endif
@@ -613,7 +746,7 @@ static void InitEncodeWeight(void)
 	/* need add a condition for ucode mode */
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		me_mv_weight_01 = (ME_MV_STEP_WEIGHT_1 << 24) |
-				  (ME_MV_STEP_WEIGHT_1 << 16) |
+				  (ME_MV_PRE_WEIGHT_1 << 16) |
 				  (ME_MV_STEP_WEIGHT_0 << 8) |
 				  (ME_MV_PRE_WEIGHT_0 << 0);
 
@@ -646,6 +779,14 @@ static void InitEncodeWeight(void)
 					/* force_skip_weight_0 */
 				   (STEP_0_SKIP_WEIGHT << 0);
 
+#ifndef USE_OLD_DUMP_MC
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+			me_f_skip_sad = 0;
+			me_f_skip_weight = 0;
+			me_mv_weight_01 = 0;
+			me_mv_weight_23 = 0;
+		}
+#endif
 		me_sad_enough_01 = (ME_SAD_ENOUGH_1_DATA << 12) |
 					/* me_sad_enough_1 */
 				   (ME_SAD_ENOUGH_0_DATA << 0) |
@@ -982,7 +1123,7 @@ static void avc_init_ie_me_parameter(struct encode_wq_s *wq, u32 quant)
 
 static void mfdin_basic(u32 input, u8 iformat,
 			u8 oformat, u32 picsize_x, u32 picsize_y,
-			u8 r2y_en, u8 nr)
+			u8 r2y_en, u8 nr, u8 ifmt_extra)
 {
 	u8 dsample_en; /* Downsample Enable */
 	u8 interp_en;  /* Interpolation Enable */
@@ -1009,10 +1150,30 @@ static void mfdin_basic(u32 input, u8 iformat,
 	u32 linear_bytesperline;
 	s32 reg_offset;
 	bool linear_enable = false;
+	bool format_err = false;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		if ((iformat == 7) && (ifmt_extra > 2))
+			format_err = true;
+	} else if (iformat == 7)
+		format_err = true;
+
+	if (format_err) {
+		enc_pr(LOG_ERROR,
+			"mfdin format err, iformat:%d, ifmt_extra:%d\n",
+			iformat, ifmt_extra);
+		return;
+	}
+	if (iformat != 7)
+		ifmt_extra = 0;
 
 	ifmt444 = ((iformat == 1) || (iformat == 5) || (iformat == 8) ||
 		   (iformat == 9) || (iformat == 12)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra == 1)
+		ifmt444 = 1;
 	ifmt422 = ((iformat == 0) || (iformat == 10)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra != 1)
+		ifmt422 = 1;
 	ifmt420 = ((iformat == 2) || (iformat == 3) || (iformat == 4) ||
 		   (iformat == 11)) ? 1 : 0;
 	dsample_en = ((ifmt444 && (oformat != 2)) ||
@@ -1053,43 +1214,78 @@ static void mfdin_basic(u32 input, u8 iformat,
 
 		/* NR For Y */
 		WRITE_HREG((HCODEC_MFDIN_REG0D + reg_offset),
-			((cfg_y_snr_en << 0) | (1 << 1) |
-			(4 << 2) | (((-4) & 0xff) << 6) |
-			(30 << 14) | (0 << 20) | (63 << 26)));
+			((cfg_y_snr_en << 0) |
+			(y_snr_err_norm << 1) |
+			(y_snr_gau_bld_core << 2) |
+			(((y_snr_gau_bld_ofst) & 0xff) << 6) |
+			(y_snr_gau_bld_rate << 14) |
+			(y_snr_gau_alp0_min << 20) |
+			(y_snr_gau_alp0_max << 26)));
 		WRITE_HREG((HCODEC_MFDIN_REG0E + reg_offset),
-			((cfg_y_tnr_en << 0) | (1 << 1) |
-			(0 << 2) | (1 << 3) | (8 << 7) |
-			(63 << 13) | (3 << 19)));
+			((cfg_y_tnr_en << 0) |
+			(y_tnr_mc_en << 1) |
+			(y_tnr_txt_mode << 2) |
+			(y_tnr_mot_sad_margin << 3) |
+			(y_tnr_alpha_min << 7) |
+			(y_tnr_alpha_max << 13) |
+			(y_tnr_deghost_os << 19)));
 		WRITE_HREG((HCODEC_MFDIN_REG0F + reg_offset),
-			((4 << 0) | (5 << 8) | (4 << 4) |
-			(4 << 16) | (8 << 24)));
+			((y_tnr_mot_cortxt_rate << 0) |
+			(y_tnr_mot_distxt_ofst << 8) |
+			(y_tnr_mot_distxt_rate << 4) |
+			(y_tnr_mot_dismot_ofst << 16) |
+			(y_tnr_mot_frcsad_lock << 24)));
 		WRITE_HREG((HCODEC_MFDIN_REG10 + reg_offset),
-			   ((10 << 0) | (20 << 8) | (32 << 16) | (32 << 24)));
+			((y_tnr_mot2alp_frc_gain << 0) |
+			(y_tnr_mot2alp_nrm_gain << 8) |
+			(y_tnr_mot2alp_dis_gain << 16) |
+			(y_tnr_mot2alp_dis_ofst << 24)));
 		WRITE_HREG((HCODEC_MFDIN_REG11 + reg_offset),
-			   ((24 << 0) | (0 << 8) | (63 << 14)));
+			((y_bld_beta2alp_rate << 0) |
+			(y_bld_beta_min << 8) |
+			(y_bld_beta_max << 14)));
 
 		/* NR For C */
 		WRITE_HREG((HCODEC_MFDIN_REG12 + reg_offset),
-			((cfg_c_snr_en << 0) | (0 << 1) |
-			(4 << 2) | (((-4) & 0xff) << 6) |
-			(30 << 14) | (0 << 20) | (63 << 26)));
+			((cfg_y_snr_en << 0) |
+			(c_snr_err_norm << 1) |
+			(c_snr_gau_bld_core << 2) |
+			(((c_snr_gau_bld_ofst) & 0xff) << 6) |
+			(c_snr_gau_bld_rate << 14) |
+			(c_snr_gau_alp0_min << 20) |
+			(c_snr_gau_alp0_max << 26)));
+
 		WRITE_HREG((HCODEC_MFDIN_REG13 + reg_offset),
-			((cfg_c_tnr_en << 0) | (1 << 1) |
-			(0 << 2) | (1 << 3) | (8 << 7) |
-			(63 << 13) | (3 << 19)));
+			((cfg_c_tnr_en << 0) |
+			(c_tnr_mc_en << 1) |
+			(c_tnr_txt_mode << 2) |
+			(c_tnr_mot_sad_margin << 3) |
+			(c_tnr_alpha_min << 7) |
+			(c_tnr_alpha_max << 13) |
+			(c_tnr_deghost_os << 19)));
 		WRITE_HREG((HCODEC_MFDIN_REG14 + reg_offset),
-			((4 << 0) | (5 << 8) | (4 << 4) |
-			(4 << 16) | (8 << 24)));
+			((c_tnr_mot_cortxt_rate << 0) |
+			(c_tnr_mot_distxt_ofst << 8) |
+			(c_tnr_mot_distxt_rate << 4) |
+			(c_tnr_mot_dismot_ofst << 16) |
+			(c_tnr_mot_frcsad_lock << 24)));
 		WRITE_HREG((HCODEC_MFDIN_REG15 + reg_offset),
-			((10 << 0) | (20 << 8) | (32 << 16) | (32 << 24)));
+			((c_tnr_mot2alp_frc_gain << 0) |
+			(c_tnr_mot2alp_nrm_gain << 8) |
+			(c_tnr_mot2alp_dis_gain << 16) |
+			(c_tnr_mot2alp_dis_ofst << 24)));
+
 		WRITE_HREG((HCODEC_MFDIN_REG16 + reg_offset),
-			((24 << 0) | (0 << 8) | (63 << 14)));
+			((c_bld_beta2alp_rate << 0) |
+			(c_bld_beta_min << 8) |
+			(c_bld_beta_max << 14)));
 
 		WRITE_HREG((HCODEC_MFDIN_REG1_CTRL + reg_offset),
 			(iformat << 0) | (oformat << 4) |
 			(dsample_en << 6) | (y_size << 8) |
 			(interp_en << 9) | (r2y_en << 12) |
-			(r2y_mode << 13) | (nr_enable << 19));
+			(r2y_mode << 13) | (ifmt_extra << 16) |
+			(nr_enable << 19));
 		WRITE_HREG((HCODEC_MFDIN_REG8_DMBL + reg_offset),
 			(picsize_x << 14) | (picsize_y << 0));
 	} else {
@@ -1130,6 +1326,129 @@ static void mfdin_basic(u32 input, u8 iformat,
 		(1 << 18) | (0 << 21));
 }
 
+#ifdef CONFIG_AM_GE2D
+static int scale_frame(struct encode_wq_s *wq,
+	struct encode_request_s *request,
+	struct config_para_ex_s *ge2d_config)
+{
+	struct ge2d_context_s *context = encode_manager.context;
+	int src_top, src_left, src_width, src_height;
+	struct canvas_s cs0, cs1, cs2, cd;
+	u32 src_canvas, dst_canvas;
+	u32 src_canvas_w, dst_canvas_w;
+	u32 src_h = request->src_h;
+	u32 dst_w = ((wq->pic.encoder_width + 15) >> 4) << 4;
+	u32 dst_h = ((wq->pic.encoder_height + 15) >> 4) << 4;
+	int input_format = GE2D_FORMAT_M24_NV21;
+	src_top = request->crop_top;
+	src_left = request->crop_left;
+	src_width = request->src_w - src_left - request->crop_right;
+	src_height = request->src_h - src_top - request->crop_bottom;
+	if ((request->fmt == FMT_NV21) || (request->fmt == FMT_NV12)) {
+		src_canvas_w =  ((request->src_w + 31) >> 5) << 5;
+		canvas_config(ENC_CANVAS_OFFSET + 9,
+			wq->mem.dct_buff_start_addr,
+			src_canvas_w, src_h,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		canvas_config(ENC_CANVAS_OFFSET + 10,
+			wq->mem.dct_buff_start_addr + src_canvas_w*src_h,
+			src_canvas_w , src_h / 2,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		src_canvas = ((ENC_CANVAS_OFFSET + 10) << 8) |
+			(ENC_CANVAS_OFFSET + 9);
+		input_format =  GE2D_FORMAT_M24_NV21;
+	} else {
+		src_canvas_w =  ((request->src_w + 63) >> 6) << 6;
+		canvas_config(ENC_CANVAS_OFFSET + 9,
+			wq->mem.dct_buff_start_addr,
+			src_canvas_w, src_h,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		canvas_config(ENC_CANVAS_OFFSET + 10,
+			wq->mem.dct_buff_start_addr + src_canvas_w*src_h,
+			src_canvas_w / 2, src_h / 2,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		canvas_config(ENC_CANVAS_OFFSET + 11,
+			wq->mem.dct_buff_start_addr +
+			src_canvas_w * src_h * 5 / 4,
+			src_canvas_w / 2 , src_h / 2,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		src_canvas = ((ENC_CANVAS_OFFSET + 11) << 16) |
+			((ENC_CANVAS_OFFSET + 10) << 8) |
+			(ENC_CANVAS_OFFSET + 9);
+		input_format =  GE2D_FORMAT_M24_YUV420;
+	}
+	dst_canvas_w =  ((dst_w + 31) >> 5) << 5;
+	canvas_config(ENC_CANVAS_OFFSET + 6,
+		wq->mem.scaler_buff_start_addr,
+		dst_canvas_w, dst_h,
+		CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+	canvas_config(ENC_CANVAS_OFFSET + 7,
+		wq->mem.scaler_buff_start_addr + dst_canvas_w*dst_h,
+		dst_canvas_w , dst_h / 2,
+		CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+	dst_canvas = ((ENC_CANVAS_OFFSET + 7) << 8) |
+		(ENC_CANVAS_OFFSET + 6);
+	ge2d_config->alu_const_color = 0;
+	ge2d_config->bitmask_en  = 0;
+	ge2d_config->src1_gb_alpha = 0;
+	ge2d_config->dst_xy_swap = 0;
+	canvas_read(src_canvas & 0xff, &cs0);
+	canvas_read((src_canvas >> 8) & 0xff, &cs1);
+	canvas_read((src_canvas>>16) & 0xff, &cs2);
+	ge2d_config->src_planes[0].addr = cs0.addr;
+	ge2d_config->src_planes[0].w = cs0.width;
+	ge2d_config->src_planes[0].h = cs0.height;
+	ge2d_config->src_planes[1].addr = cs1.addr;
+	ge2d_config->src_planes[1].w = cs1.width;
+	ge2d_config->src_planes[1].h = cs1.height;
+	ge2d_config->src_planes[2].addr = cs2.addr;
+	ge2d_config->src_planes[2].w = cs2.width;
+	ge2d_config->src_planes[2].h = cs2.height;
+	canvas_read(dst_canvas & 0xff, &cd);
+	ge2d_config->dst_planes[0].addr = cd.addr;
+	ge2d_config->dst_planes[0].w = cd.width;
+	ge2d_config->dst_planes[0].h = cd.height;
+	ge2d_config->src_key.key_enable = 0;
+	ge2d_config->src_key.key_mask = 0;
+	ge2d_config->src_key.key_mode = 0;
+	ge2d_config->src_para.canvas_index = src_canvas;
+	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->src_para.format = input_format | GE2D_LITTLE_ENDIAN;
+	ge2d_config->src_para.fill_color_en = 0;
+	ge2d_config->src_para.fill_mode = 0;
+	ge2d_config->src_para.x_rev = 0;
+	ge2d_config->src_para.y_rev = 0;
+	ge2d_config->src_para.color = 0xffffffff;
+	ge2d_config->src_para.top = 0;
+	ge2d_config->src_para.left = 0;
+	ge2d_config->src_para.width = request->src_w;
+	ge2d_config->src_para.height = request->src_h;
+	ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.canvas_index = dst_canvas;
+	ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.format =
+		GE2D_FORMAT_M24_NV21 | GE2D_LITTLE_ENDIAN;
+	ge2d_config->dst_para.fill_color_en = 0;
+	ge2d_config->dst_para.fill_mode = 0;
+	ge2d_config->dst_para.x_rev = 0;
+	ge2d_config->dst_para.y_rev = 0;
+	ge2d_config->dst_para.color = 0;
+	ge2d_config->dst_para.top = 0;
+	ge2d_config->dst_para.left = 0;
+	ge2d_config->dst_para.width = dst_w;
+	ge2d_config->dst_para.height = dst_h;
+	ge2d_config->dst_para.x_rev = 0;
+	ge2d_config->dst_para.y_rev = 0;
+	if (ge2d_context_config_ex(context, ge2d_config) < 0) {
+		pr_err("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+		0, 0, wq->pic.encoder_width, wq->pic.encoder_height);
+	return dst_canvas_w*dst_h * 3 / 2;
+}
+#endif
+
 static s32 set_input_format(struct encode_wq_s *wq,
 			    struct encode_request_s *request)
 {
@@ -1138,6 +1457,7 @@ static s32 set_input_format(struct encode_wq_s *wq,
 	u32 picsize_x, picsize_y;
 	u32 canvas_w = 0;
 	u32 input = request->src;
+	u8 ifmt_extra = 0;
 
 	if ((request->fmt == FMT_RGB565) || (request->fmt >= MAX_FRAME_FMT))
 		return -1;
@@ -1150,86 +1470,131 @@ static s32 set_input_format(struct encode_wq_s *wq,
 			if (request->flush_flag & AMVENC_FLUSH_FLAG_INPUT)
 				dma_flush(wq->mem.dct_buff_start_addr,
 					request->framesize);
-			input = wq->mem.dct_buff_start_addr;
+			if (request->scale_enable) {
+#ifdef CONFIG_AM_GE2D
+				struct config_para_ex_s ge2d_config;
+				memset(&ge2d_config, 0,
+					sizeof(struct config_para_ex_s));
+				if (request->flush_flag &
+					AMVENC_FLUSH_FLAG_INPUT) {
+					int scale_size =
+						scale_frame(wq, request,
+							&ge2d_config);
+					if (scale_size > 0)
+						cache_flush(
+						wq->mem.scaler_buff_start_addr,
+						scale_size);
+				}
+#else
+				enc_pr(LOG_ERROR,
+					"Warning: need enable ge2d for scale frame!\n");
+#endif
+				iformat = 2;
+				r2y_en = 0;
+				input = ((ENC_CANVAS_OFFSET + 7) << 8) |
+					(ENC_CANVAS_OFFSET + 6);
+				ret = 0;
+				goto MFDIN;
+			} else {
+				input = wq->mem.dct_buff_start_addr;
+			}
 		}
-		if (request->fmt <= FMT_YUV444_PLANE)
+		if ((request->fmt <= FMT_YUV444_PLANE) ||
+			(request->fmt >= FMT_YUV422_12BIT))
 			r2y_en = 0;
 		else
 			r2y_en = 1;
 
-		if (request->fmt == FMT_YUV422_SINGLE)
+		if (request->fmt >= FMT_YUV422_12BIT) {
+			iformat = 7;
+			ifmt_extra = request->fmt - FMT_YUV422_12BIT;
+			if (request->fmt == FMT_YUV422_12BIT)
+				canvas_w = picsize_x * 24 / 8;
+			else if (request->fmt == FMT_YUV444_10BIT)
+				canvas_w = picsize_x * 32 / 8;
+			else
+				canvas_w = (picsize_x * 20 + 7) / 8;
+			canvas_w = ((canvas_w + 31) >> 5) << 5;
+			canvas_config(ENC_CANVAS_OFFSET + 6,
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			input = ENC_CANVAS_OFFSET + 6;
+			input = input & 0xff;
+		} else if (request->fmt == FMT_YUV422_SINGLE)
 			iformat = 10;
-		else if ((request->fmt == FMT_YUV444_SINGLE) ||
-				(request->fmt == FMT_RGB888)) {
+		else if ((request->fmt == FMT_YUV444_SINGLE)
+			|| (request->fmt == FMT_RGB888)) {
 			iformat = 1;
 			if (request->fmt == FMT_RGB888)
 				r2y_en = 1;
 			canvas_w =  picsize_x * 3;
 			canvas_w = ((canvas_w + 31) >> 5) << 5;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ENC_CANVAS_OFFSET + 6;
-		} else if ((request->fmt == FMT_NV21) ||
-				(request->fmt == FMT_NV12)) {
+		} else if ((request->fmt == FMT_NV21)
+			|| (request->fmt == FMT_NV12)) {
 			canvas_w = ((wq->pic.encoder_width + 31) >> 5) << 5;
 			iformat = (request->fmt == FMT_NV21) ? 2 : 3;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 7,
-				      input + canvas_w * picsize_y,
-				      canvas_w, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 7) << 8) |
-					(ENC_CANVAS_OFFSET + 6);
+				(ENC_CANVAS_OFFSET + 6);
 		} else if (request->fmt == FMT_YUV420) {
 			iformat = 4;
 			canvas_w = ((wq->pic.encoder_width + 63) >> 6) << 6;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 7,
-				      input + canvas_w * picsize_y,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 8,
-				      input + canvas_w * picsize_y * 5 / 4,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 5 / 4,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 8) << 16) |
 				((ENC_CANVAS_OFFSET + 7) << 8) |
 				(ENC_CANVAS_OFFSET + 6);
-		} else if ((request->fmt == FMT_YUV444_PLANE) ||
-			   (request->fmt == FMT_RGB888_PLANE)) {
+		} else if ((request->fmt == FMT_YUV444_PLANE)
+			|| (request->fmt == FMT_RGB888_PLANE)) {
 			if (request->fmt == FMT_RGB888_PLANE)
 				r2y_en = 1;
 			iformat = 5;
 			canvas_w = ((wq->pic.encoder_width + 31) >> 5) << 5;
 			canvas_config(ENC_CANVAS_OFFSET + 6,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 7,
-				      input + canvas_w * picsize_y,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 8,
-				      input + canvas_w * picsize_y * 2,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 2,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 8) << 16) |
 				((ENC_CANVAS_OFFSET + 7) << 8) |
 				(ENC_CANVAS_OFFSET + 6);
@@ -1246,32 +1611,40 @@ static s32 set_input_format(struct encode_wq_s *wq,
 		} else if (request->fmt == FMT_YUV444_SINGLE) {
 			iformat = 1;
 			input = input & 0xff;
-		} else if ((request->fmt == FMT_NV21) ||
-				(request->fmt == FMT_NV12)) {
+		} else if ((request->fmt == FMT_NV21)
+			|| (request->fmt == FMT_NV12)) {
 			iformat = (request->fmt == FMT_NV21) ? 2 : 3;
 			input = input & 0xffff;
 		} else if (request->fmt == FMT_YUV420) {
 			iformat = 4;
 			input = input & 0xffffff;
-		} else if ((request->fmt == FMT_YUV444_PLANE) ||
-			   (request->fmt == FMT_RGB888_PLANE)) {
+		} else if ((request->fmt == FMT_YUV444_PLANE)
+			|| (request->fmt == FMT_RGB888_PLANE)) {
 			if (request->fmt == FMT_RGB888_PLANE)
 				r2y_en = 1;
 			iformat = 5;
 			input = input & 0xffffff;
+		} else if ((request->fmt == FMT_YUV422_12BIT)
+			|| (request->fmt == FMT_YUV444_10BIT)
+			|| (request->fmt == FMT_YUV422_10BIT)) {
+			iformat = 7;
+			ifmt_extra = request->fmt - FMT_YUV422_12BIT;
+			input = input & 0xff;
 		} else
 			ret = -1;
 	}
+MFDIN:
 	if (ret == 0)
 		mfdin_basic(input, iformat, oformat,
-			    picsize_x, picsize_y, r2y_en,
-			    (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) ?
-				request->nr_mode : 0);
+			picsize_x, picsize_y, r2y_en,
+			(get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) ?
+			request->nr_mode : 0, ifmt_extra);
 	wq->control.finish = true;
 	return ret;
 }
 
-static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
+static void avc_prot_init(struct encode_wq_s *wq,
+	struct encode_request_s *request, u32 quant, bool IDR)
 {
 	u32 data32;
 	u32 pic_width, pic_height;
@@ -1287,16 +1660,11 @@ static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
 	i_pic_qp   = quant;
 	p_pic_qp   = quant;
 
-	wq->me_weight = 0;
-	wq->i4_weight = 0;
-	wq->i16_weight = 0;
-
 #ifndef USE_OLD_DUMP_MC
 	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) &&
 	    (encode_manager.ucode_index == UCODE_MODE_FULL)) {
 		u32 pic_width_in_mb;
 		u32 slice_qp;
-		u32 qp_table_id;
 		pic_width_in_mb = (pic_width + 15) / 16;
 		WRITE_HREG(HCODEC_HDEC_MC_OMEM_AUTO,
 			   (1 << 31) | /* use_omem_mb_xy */
@@ -1355,24 +1723,51 @@ static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
 			   (1 << 2) | /* ie_I16_enable */
 			   (3 << 0)); /* ie_done_sel  // fastest when waiting */
 
-		WRITE_HREG(HCODEC_IE_WEIGHT,
-			   (I16MB_WEIGHT_OFFSET << 16) |
-			   (I4MB_WEIGHT_OFFSET << 0));
-
-		WRITE_HREG(HCODEC_ME_WEIGHT, (ME_WEIGHT_OFFSET << 0));
-
-		WRITE_HREG(HCODEC_SAD_CONTROL_0,
-				/* ie_sad_offset_I16 */
-			   (I16MB_WEIGHT_OFFSET << 16) |
-			   (I4MB_WEIGHT_OFFSET << 0)); /* ie_sad_offset_I4 */
-
-		WRITE_HREG(HCODEC_SAD_CONTROL_1,
-			   (IE_SAD_SHIFT_I16 << 24) |   /* ie_sad_shift_I16 */
-			   (IE_SAD_SHIFT_I4 << 20) |   /* ie_sad_shift_I4 */
-				/* me_sad_shift_INTER */
-			   (ME_SAD_SHIFT_INTER << 16) |
-				/* me_sad_offset_INTER */
-			   (ME_WEIGHT_OFFSET << 0));
+		if (request != NULL) {
+			WRITE_HREG(HCODEC_IE_WEIGHT,
+				   (request->i16_weight << 16) |
+				   (request->i4_weight << 0));
+
+			WRITE_HREG(HCODEC_ME_WEIGHT, (request->me_weight << 0));
+
+			WRITE_HREG(HCODEC_SAD_CONTROL_0,
+					/* ie_sad_offset_I16 */
+				   (request->i16_weight << 16) |
+					/* ie_sad_offset_I4 */
+				   (request->i4_weight << 0));
+
+			WRITE_HREG(HCODEC_SAD_CONTROL_1,
+					/* ie_sad_shift_I16 */
+				   (IE_SAD_SHIFT_I16 << 24) |
+					/* ie_sad_shift_I4 */
+				   (IE_SAD_SHIFT_I4 << 20) |
+					/* me_sad_shift_INTER */
+				   (ME_SAD_SHIFT_INTER << 16) |
+					/* me_sad_offset_INTER */
+				   (request->me_weight << 0));
+		} else {
+			WRITE_HREG(HCODEC_IE_WEIGHT,
+				   (I16MB_WEIGHT_OFFSET << 16) |
+				   (I4MB_WEIGHT_OFFSET << 0));
+
+			WRITE_HREG(HCODEC_ME_WEIGHT, (ME_WEIGHT_OFFSET << 0));
+
+			WRITE_HREG(HCODEC_SAD_CONTROL_0,
+					/* ie_sad_offset_I16 */
+				   (I16MB_WEIGHT_OFFSET << 16) |
+					/* ie_sad_offset_I4 */
+				   (I4MB_WEIGHT_OFFSET << 0));
+
+			WRITE_HREG(HCODEC_SAD_CONTROL_1,
+					/* ie_sad_shift_I16 */
+				   (IE_SAD_SHIFT_I16 << 24) |
+					/* ie_sad_shift_I4 */
+				   (IE_SAD_SHIFT_I4 << 20) |
+					/* me_sad_shift_INTER */
+				   (ME_SAD_SHIFT_INTER << 16) |
+					/* me_sad_offset_INTER */
+				   (ME_WEIGHT_OFFSET << 0));
+		}
 
 		WRITE_HREG(HCODEC_ADV_MV_CTL0,
 			   (ADV_MV_LARGE_16x8 << 31) |
@@ -1387,15 +1782,21 @@ static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
 			   (ADV_MV_LARGE_16x16 << 15) |
 			   (ADV_MV_16_8_WEIGHT << 0));  /* adv_mv_16_8_weight */
 
-		qp_table_id = 0;
-		hcodec_prog_qtbl(qp_table_id);
+		hcodec_prog_qtbl(wq);
 		if (IDR) {
-			i_pic_qp = quant_tbl_i4[qp_table_id][0] & 0xff;
+			i_pic_qp =
+				wq->quant_tbl_i4[wq->qp_table_id][0] & 0xff;
+			i_pic_qp +=
+				wq->quant_tbl_i16[wq->qp_table_id][0] & 0xff;
+			i_pic_qp /= 2;
 			p_pic_qp = i_pic_qp;
 		} else {
-			i_pic_qp = quant_tbl_i4[qp_table_id][0] & 0xff;
-			p_pic_qp = quant_tbl_me[qp_table_id][0] & 0xff;
-			slice_qp = (i_pic_qp + p_pic_qp) / 2;
+			i_pic_qp =
+				wq->quant_tbl_i4[wq->qp_table_id][0] & 0xff;
+			i_pic_qp +=
+				wq->quant_tbl_i16[wq->qp_table_id][0] & 0xff;
+			p_pic_qp = wq->quant_tbl_me[wq->qp_table_id][0] & 0xff;
+			slice_qp = (i_pic_qp + p_pic_qp) / 3;
 			i_pic_qp = slice_qp;
 			p_pic_qp = i_pic_qp;
 		}
@@ -1410,9 +1811,11 @@ static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
 			   (26 << 6) | /* vlc_max_delta_q_neg */
 			   (25 << 0)); /* vlc_max_delta_q_pos */
 
-		wq->me_weight = ME_WEIGHT_OFFSET;
-		wq->i4_weight = I4MB_WEIGHT_OFFSET;
-		wq->i16_weight = I16MB_WEIGHT_OFFSET;
+		if (request != NULL) {
+			wq->me_weight = request->me_weight;
+			wq->i4_weight = request->i4_weight;
+			wq->i16_weight = request->i16_weight;
+		}
 	}
 #endif
 
@@ -1753,6 +2156,7 @@ static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
 		   ((p_pic_qp % 6) << 4) |
 		   ((p_pic_qp / 6) << 0));
 
+#ifdef ENABLE_IGNORE_FUNCTION
 	WRITE_HREG(HCODEC_IGNORE_CONFIG,
 		   (1 << 31) | /* ignore_lac_coeff_en */
 		   (1 << 26) | /* ignore_lac_coeff_else (<1) */
@@ -1763,12 +2167,42 @@ static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
 		   (1 << 5)  | /* ignore_cac_coeff_2 (<1) */
 		   (3 << 0));  /* ignore_cac_coeff_1 (<2) */
 
-	WRITE_HREG(HCODEC_IGNORE_CONFIG_2,
-		   (1 << 31) | /* ignore_t_lac_coeff_en */
-		   (1 << 26) | /* ignore_t_lac_coeff_else (<1) */
-		   (1 << 21) | /* ignore_t_lac_coeff_2 (<1) */
-		   (5 << 16) | /* ignore_t_lac_coeff_1 (<5) */
-		   (0 << 0));
+#ifndef USE_OLD_DUMP_MC
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
+		WRITE_HREG(HCODEC_IGNORE_CONFIG_2,
+			(1 << 31) | /* ignore_t_lac_coeff_en */
+			(1 << 26) | /* ignore_t_lac_coeff_else (<1) */
+			(2 << 21) | /* ignore_t_lac_coeff_2 (<2) */
+			(6 << 16) | /* ignore_t_lac_coeff_1 (<6) */
+			(1<<15) | /* ignore_cdc_coeff_en */
+			(0<<14) | /* ignore_t_lac_coeff_else_le_3 */
+			(1<<13) | /* ignore_t_lac_coeff_else_le_4 */
+			(1<<12) | /* ignore_cdc_only_when_empty_cac_inter */
+			(1<<11) | /* ignore_cdc_only_when_one_empty_inter */
+			/* ignore_cdc_range_max_inter 0-0, 1-1, 2-2, 3-3 */
+			(2<<9) |
+			/* ignore_cdc_abs_max_inter 0-1, 1-2, 2-3, 3-4 */
+			(0<<7) |
+			/* ignore_cdc_only_when_empty_cac_intra */
+			(1<<5) |
+			/* ignore_cdc_only_when_one_empty_intra */
+			(1<<4) |
+			/* ignore_cdc_range_max_intra 0-0, 1-1, 2-2, 3-3 */
+			(1<<2) |
+			/* ignore_cdc_abs_max_intra 0-1, 1-2, 2-3, 3-4 */
+			(0<<0));
+	else
+#endif
+		WRITE_HREG(HCODEC_IGNORE_CONFIG_2,
+			(1 << 31) | /* ignore_t_lac_coeff_en */
+			(1 << 26) | /* ignore_t_lac_coeff_else (<1) */
+			(1 << 21) | /* ignore_t_lac_coeff_2 (<1) */
+			(5 << 16) | /* ignore_t_lac_coeff_1 (<5) */
+			(0 << 0));
+#else
+	WRITE_HREG(HCODEC_IGNORE_CONFIG, 0);
+	WRITE_HREG(HCODEC_IGNORE_CONFIG_2, 0);
+#endif
 
 	WRITE_HREG(HCODEC_QDCT_MB_CONTROL,
 		   (1 << 9) | /* mb_info_soft_reset */
@@ -1875,6 +2309,133 @@ static void avc_prot_init(struct encode_wq_s *wq, u32 quant, bool IDR)
 		WRITE_HREG(HCODEC_ME_MV_WEIGHT_23, me_mv_weight_23);
 		WRITE_HREG(HCODEC_ME_SAD_RANGE_INC, me_sad_range_inc);
 
+#ifndef USE_OLD_DUMP_MC
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_CTL, 0);
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_CTL,
+				(v5_use_small_diff_cnt << 7) |
+				(v5_simple_mb_inter_all_en << 6) |
+				(v5_simple_mb_inter_8x8_en << 5) |
+				(v5_simple_mb_inter_16_8_en << 4) |
+				(v5_simple_mb_inter_16x16_en << 3) |
+				(v5_simple_mb_intra_en << 2) |
+				(v5_simple_mb_C_en << 1) |
+				(v5_simple_mb_Y_en << 0));
+			WRITE_HREG(HCODEC_V5_MB_DIFF_SUM, 0);
+			WRITE_HREG(HCODEC_V5_SMALL_DIFF_CNT,
+				(v5_small_diff_C<<16) |
+				(v5_small_diff_Y<<0));
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_DQUANT,
+				v5_simple_dq_setting);
+			WRITE_HREG(HCODEC_V5_SIMPLE_MB_ME_WEIGHT,
+				v5_simple_me_weight_setting);
+			WRITE_HREG(HCODEC_QDCT_CONFIG, 1 << 0);
+		}
+
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+			WRITE_HREG(HCODEC_V4_FORCE_SKIP_CFG,
+				(i_pic_qp << 26) | /* v4_force_q_r_intra */
+				(i_pic_qp << 20) | /* v4_force_q_r_inter */
+				(0 << 19) | /* v4_force_q_y_enable */
+				(5 << 16) | /* v4_force_qr_y */
+				(6 << 12) | /* v4_force_qp_y */
+				(0 << 0)); /* v4_force_skip_sad */
+
+			/* V3 Force skip */
+			WRITE_HREG(HCODEC_V3_SKIP_CONTROL,
+				(1 << 31) | /* v3_skip_enable */
+				(0 << 30) | /* v3_step_1_weight_enable */
+				(1 << 28) | /* v3_mv_sad_weight_enable */
+				(1 << 27) | /* v3_ipred_type_enable */
+				(V3_FORCE_SKIP_SAD_1 << 12) |
+				(V3_FORCE_SKIP_SAD_0 << 0));
+			WRITE_HREG(HCODEC_V3_SKIP_WEIGHT,
+				(V3_SKIP_WEIGHT_1 << 16) |
+				(V3_SKIP_WEIGHT_0 << 0));
+			WRITE_HREG(HCODEC_V3_L1_SKIP_MAX_SAD,
+				(V3_LEVEL_1_F_SKIP_MAX_SAD << 16) |
+				(V3_LEVEL_1_SKIP_MAX_SAD << 0));
+			WRITE_HREG(HCODEC_V3_L2_SKIP_WEIGHT,
+				(V3_FORCE_SKIP_SAD_2 << 16) |
+				(V3_SKIP_WEIGHT_2 << 0));
+			if (request != NULL) {
+				unsigned int off1, off2;
+				off1 = V3_IE_F_ZERO_SAD_I4 - I4MB_WEIGHT_OFFSET;
+				off2 = V3_IE_F_ZERO_SAD_I16
+						- I16MB_WEIGHT_OFFSET;
+				WRITE_HREG(HCODEC_V3_F_ZERO_CTL_0,
+					((request->i16_weight + off2) << 16) |
+					((request->i4_weight + off1) << 0));
+				off1 = V3_ME_F_ZERO_SAD - ME_WEIGHT_OFFSET;
+				WRITE_HREG(HCODEC_V3_F_ZERO_CTL_1,
+					(0 << 25) |
+					/* v3_no_ver_when_top_zero_en */
+					(0 << 24) |
+					/* v3_no_hor_when_left_zero_en */
+					(3 << 16) |  /* type_hor break */
+					((request->me_weight + off1) << 0));
+			} else {
+				WRITE_HREG(HCODEC_V3_F_ZERO_CTL_0,
+					(V3_IE_F_ZERO_SAD_I16 << 16) |
+					(V3_IE_F_ZERO_SAD_I4 << 0));
+				WRITE_HREG(HCODEC_V3_F_ZERO_CTL_1,
+					(0 << 25) |
+					/* v3_no_ver_when_top_zero_en */
+					(0 << 24) |
+					/* v3_no_hor_when_left_zero_en */
+					(3 << 16) |  /* type_hor break */
+					(V3_ME_F_ZERO_SAD << 0));
+			}
+		} else if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+			/* V3 Force skip */
+			WRITE_HREG(HCODEC_V3_SKIP_CONTROL,
+				(1 << 31) | /* v3_skip_enable */
+				(0 << 30) | /* v3_step_1_weight_enable */
+				(1 << 28) | /* v3_mv_sad_weight_enable */
+				(1 << 27) | /* v3_ipred_type_enable */
+				(0 << 12) | /* V3_FORCE_SKIP_SAD_1 */
+				(0 << 0)); /* V3_FORCE_SKIP_SAD_0 */
+			WRITE_HREG(HCODEC_V3_SKIP_WEIGHT,
+				(V3_SKIP_WEIGHT_1 << 16) |
+				(V3_SKIP_WEIGHT_0 << 0));
+			WRITE_HREG(HCODEC_V3_L1_SKIP_MAX_SAD,
+				(V3_LEVEL_1_F_SKIP_MAX_SAD << 16) |
+				(V3_LEVEL_1_SKIP_MAX_SAD << 0));
+			WRITE_HREG(HCODEC_V3_L2_SKIP_WEIGHT,
+				(0 << 16) | /* V3_FORCE_SKIP_SAD_2 */
+				(V3_SKIP_WEIGHT_2 << 0));
+			WRITE_HREG(HCODEC_V3_F_ZERO_CTL_0,
+				(0 << 16) | /* V3_IE_F_ZERO_SAD_I16 */
+				(0 << 0)); /* V3_IE_F_ZERO_SAD_I4 */
+			WRITE_HREG(HCODEC_V3_F_ZERO_CTL_1,
+				(0 << 25) | /* v3_no_ver_when_top_zero_en */
+				(0 << 24) | /* v3_no_hor_when_left_zero_en */
+				(3 << 16) |  /* type_hor break */
+				(0 << 0)); /* V3_ME_F_ZERO_SAD */
+		}
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+			int i;
+			/* MV SAD Table */
+			for (i = 0; i < 64; i++)
+				WRITE_HREG(HCODEC_V3_MV_SAD_TABLE,
+					v3_mv_sad[i]);
+
+			/* IE PRED SAD Table*/
+			WRITE_HREG(HCODEC_V3_IPRED_TYPE_WEIGHT_0,
+				(C_ipred_weight_H << 24) |
+				(C_ipred_weight_V << 16) |
+				(I4_ipred_weight_else << 8) |
+				(I4_ipred_weight_most << 0));
+			WRITE_HREG(HCODEC_V3_IPRED_TYPE_WEIGHT_1,
+				(I16_ipred_weight_DC << 24) |
+				(I16_ipred_weight_H << 16) |
+				(I16_ipred_weight_V << 8) |
+				(C_ipred_weight_DC << 0));
+			WRITE_HREG(HCODEC_V3_LEFT_SMALL_MAX_SAD,
+				(v3_left_small_max_me_sad << 16) |
+				(v3_left_small_max_ie_sad << 0));
+		}
+#endif
 		WRITE_HREG(HCODEC_IE_DATA_FEED_BUFF_INFO, 0);
 	} else {
 		WRITE_HREG(HCODEC_QDCT_MB_CONTROL,
@@ -2020,6 +2581,7 @@ s32 amvenc_loadmc(const char *p, struct encode_wq_s *wq)
 		}
 	}
 
+	enc_pr(LOG_ALL, "avc encode ucode name is %s\n", p);
 	ret = get_decoder_firmware_data(VFORMAT_H264_ENC, p,
 		(u8 *)mc_addr, MC_SIZE);
 	if (ret < 0) {
@@ -2300,12 +2862,45 @@ static irqreturn_t enc_isr(s32 irq_number, void *para)
 	return IRQ_HANDLED;
 }
 
+static struct class *avc_enc_class;
+
+static ssize_t dg_manual_store(struct class *cls, struct class_attribute *attr,
+				const char *buf, size_t len)
+{
+	int ret = 0;
+	ret = sscanf(buf, "%x", (unsigned int *)&qp_table_pr);
+	if (ret < 0)
+		enc_pr(LOG_INFO, "set encoder table failed\n");
+	else
+		enc_pr(LOG_INFO, "set encoder table print = %d\n", qp_table_pr);
+
+	return len;
+}
+
+static ssize_t dg_manual_show(struct class *cls, struct class_attribute *attr,
+				char *buf)
+{
+	size_t len = 0;
+	enc_pr(LOG_INFO, "encoder table print = %d\n", qp_table_pr);
+	return len;
+}
+
+static CLASS_ATTR(encode_tbl_debug, 0664, dg_manual_show, dg_manual_store);
+
+
 static s32 convert_request(struct encode_wq_s *wq, u32 *cmd_info)
 {
+	int i = 0;
+	u8 *qp_tb;
+	u8 *ptr;
+	u32 weight_offset;
 	u32 cmd = cmd_info[0];
 	if (!wq)
 		return -1;
 	memset(&wq->request, 0, sizeof(struct encode_request_s));
+	wq->request.me_weight = ME_WEIGHT_OFFSET;
+	wq->request.i4_weight = I4MB_WEIGHT_OFFSET;
+	wq->request.i16_weight = I16MB_WEIGHT_OFFSET;
 
 	if (cmd == ENCODER_SEQUENCE) {
 		wq->request.cmd = cmd;
@@ -2325,9 +2920,78 @@ static s32 convert_request(struct encode_wq_s *wq, u32 *cmd_info)
 			wq->request.quant = cmd_info[6];
 			wq->request.flush_flag = cmd_info[7];
 			wq->request.timeout = cmd_info[8];
-			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB)
+			wq->request.crop_top = cmd_info[9];
+			wq->request.crop_bottom = cmd_info[10];
+			wq->request.crop_left = cmd_info[11];
+			wq->request.crop_right = cmd_info[12];
+			wq->request.src_w = cmd_info[13];
+			wq->request.src_h = cmd_info[14];
+			wq->request.scale_enable = cmd_info[15];
+
+			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 				wq->request.nr_mode =
-					(nr_mode > 0) ? nr_mode : cmd_info[9];
+					(nr_mode > 0) ? nr_mode : cmd_info[16];
+				if (cmd == ENCODER_IDR)
+					wq->request.nr_mode = 0;
+			}
+
+			if (wq->request.quant == ADJUSTED_QP_FLAG) {
+				ptr = (u8 *) &cmd_info[17];
+				memcpy(wq->quant_tbl_i4[1], ptr,
+					sizeof(wq->quant_tbl_i4[1]));
+				ptr += sizeof(wq->quant_tbl_i4[1]);
+				memcpy(wq->quant_tbl_i16[1], ptr,
+					sizeof(wq->quant_tbl_i16[1]));
+				ptr += sizeof(wq->quant_tbl_i16[1]);
+				memcpy(wq->quant_tbl_me[1], ptr,
+					sizeof(wq->quant_tbl_me[1]));
+
+				weight_offset = 17 +
+					(sizeof(wq->quant_tbl_i4[1])
+					+ sizeof(wq->quant_tbl_i16[1])
+					+ sizeof(wq->quant_tbl_me[1])) / 4;
+
+				wq->request.i4_weight -=
+					cmd_info[weight_offset];
+				wq->request.i16_weight -=
+					cmd_info[weight_offset + 1];
+				wq->request.me_weight -=
+					cmd_info[weight_offset + 2];
+
+				/* switch to 1 qp table */
+				wq->qp_table_id = 1;
+				if (qp_table_pr != 0) {
+					qp_tb = (u8 *)(&wq->quant_tbl_i4[1][0]);
+					for (i = 0; i < 32; i++) {
+						enc_pr(LOG_INFO, "%d ", *qp_tb);
+						qp_tb++;
+					}
+					enc_pr(LOG_INFO, "\n");
+
+					qp_tb = (u8 *)
+						(&wq->quant_tbl_i16[1][0]);
+					for (i = 0; i < 32; i++) {
+						enc_pr(LOG_INFO, "%d ", *qp_tb);
+						qp_tb++;
+					}
+					enc_pr(LOG_INFO, "\n");
+
+					qp_tb = (u8 *)(&wq->quant_tbl_me[1][0]);
+					for (i = 0; i < 32; i++) {
+						enc_pr(LOG_INFO, "%d ", *qp_tb);
+						qp_tb++;
+					}
+					enc_pr(LOG_INFO, "\n");
+				}
+			} else {
+				wq->qp_table_id = 0;
+				memset(wq->quant_tbl_me[0], wq->request.quant,
+						sizeof(wq->quant_tbl_me[0]));
+				memset(wq->quant_tbl_i4[0], wq->request.quant,
+						sizeof(wq->quant_tbl_i4[0]));
+				memset(wq->quant_tbl_i16[0], wq->request.quant,
+						sizeof(wq->quant_tbl_i16[0]));
+			}
 		} else {
 			wq->request.quant = cmd_info[2];
 			wq->request.qp_info_size = cmd_info[3];
@@ -2420,7 +3084,7 @@ void amvenc_avc_start_cmd(struct encode_wq_s *wq,
 			(request->cmd == ENCODER_IDR) ? true : false);
 		avc_init_input_buffer(wq);
 		avc_init_output_buffer(wq);
-		avc_prot_init(wq, request->quant,
+		avc_prot_init(wq, request, request->quant,
 			(request->cmd == ENCODER_IDR) ? true : false);
 		avc_init_assit_buffer(wq);
 		enc_pr(LOG_INFO,
@@ -2680,7 +3344,7 @@ s32 amvenc_avc_start(struct encode_wq_s *wq, u32 clock)
 #else
 	ie_me_mode = (0 & ME_PIXEL_MODE_MASK) << ME_PIXEL_MODE_SHIFT;
 #endif
-	avc_prot_init(wq, wq->pic.init_qppicture, true);
+	avc_prot_init(wq, NULL, wq->pic.init_qppicture, true);
 	if (request_irq(encode_manager.irq_num, enc_isr, IRQF_SHARED,
 			"enc-irq", (void *)&encode_manager) == 0)
 		encode_manager.irq_requested = true;
@@ -2893,6 +3557,8 @@ static s32 amvenc_avc_open(struct inode *inode, struct file *file)
 		wq->mem.buf_start + wq->mem.bufspec.intra_pred_info.buf_start;
 	wq->mem.sw_ctl_info_start_addr =
 		wq->mem.buf_start + wq->mem.bufspec.qp_info.buf_start;
+	wq->mem.scaler_buff_start_addr =
+		wq->mem.buf_start + wq->mem.bufspec.scale_buff.buf_start;
 #ifdef USE_VDEC2
 	wq->mem.vdec2_start_addr =
 		wq->mem.buf_start + wq->mem.bufspec.vdec2_info.buf_start;
@@ -2933,7 +3599,7 @@ static long amvenc_avc_ioctl(struct file *file, u32 cmd, ulong arg)
 	long r = 0;
 	u32 amrisc_cmd = 0;
 	struct encode_wq_s *wq = (struct encode_wq_s *)file->private_data;
-#define MAX_ADDR_INFO_SIZE 30
+#define MAX_ADDR_INFO_SIZE 50
 	u32 addr_info[MAX_ADDR_INFO_SIZE + 4];
 	ulong argV;
 	u32 buf_start;
@@ -3084,7 +3750,9 @@ static long amvenc_avc_ioctl(struct file *file, u32 cmd, ulong arg)
 		addr_info[20] = wq->mem.bufspec.intra_pred_info.buf_size;
 		addr_info[21] = wq->mem.bufspec.qp_info.buf_start;
 		addr_info[22] = wq->mem.bufspec.qp_info.buf_size;
-		r = copy_to_user((u32 *)arg, addr_info , 23 * sizeof(u32));
+		addr_info[23] = wq->mem.bufspec.scale_buff.buf_start;
+		addr_info[24] = wq->mem.bufspec.scale_buff.buf_size;
+		r = copy_to_user((u32 *)arg, addr_info , 25*sizeof(u32));
 		break;
 	case AMVENC_AVC_IOC_FLUSH_CACHE:
 		if (copy_from_user(addr_info, (void *)arg,
@@ -3114,7 +3782,14 @@ static long amvenc_avc_ioctl(struct file *file, u32 cmd, ulong arg)
 		put_user(wq->mem.buf_size, (u32 *)arg);
 		break;
 	case AMVENC_AVC_IOC_GET_DEVINFO:
-		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) {
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+			/* send the same id as GXTVBB to upper*/
+			r = copy_to_user((s8 *)arg, AMVENC_DEVINFO_GXTVBB,
+				strlen(AMVENC_DEVINFO_GXTVBB));
+		} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) {
+			r = copy_to_user((s8 *)arg, AMVENC_DEVINFO_GXTVBB,
+				strlen(AMVENC_DEVINFO_GXTVBB));
+		} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) {
 			r = copy_to_user((s8 *)arg, AMVENC_DEVINFO_GXBB,
 				strlen(AMVENC_DEVINFO_GXBB));
 		} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_MG9TV) {
@@ -3160,6 +3835,7 @@ static long amvenc_avc_ioctl(struct file *file, u32 cmd, ulong arg)
 			addr_info[0] = 0;
 			addr_info[1] = 0;
 		}
+		dma_flush(dst.addr, dst.width * dst.height * 3 / 2);
 		r = copy_to_user((u32 *)arg, addr_info , 2 * sizeof(u32));
 		break;
 	case AMVENC_AVC_IOC_MAX_INSTANCE:
@@ -3364,6 +4040,22 @@ Again:
 			}
 		} else {
 			manager->encode_hw_status = ENCODER_ERROR;
+			enc_pr(LOG_DEBUG, "avc encode light reset --- ");
+			enc_pr(LOG_DEBUG,
+				"frame type: %s, size: %dx%d, wq: %p\n",
+				(request->cmd == ENCODER_IDR) ? "IDR" : "P",
+				wq->pic.encoder_width,
+				wq->pic.encoder_height, (void *)wq);
+			enc_pr(LOG_DEBUG,
+				"mb info: 0x%x, encode status: 0x%x, dct status: 0x%x ",
+				READ_HREG(HCODEC_VLC_MB_INFO),
+				READ_HREG(ENCODER_STATUS),
+				READ_HREG(HCODEC_QDCT_STATUS_CTRL));
+			enc_pr(LOG_DEBUG,
+				"vlc status: 0x%x, me status: 0x%x, risc pc:0x%x\n",
+				READ_HREG(HCODEC_VLC_STATUS_CTRL),
+				READ_HREG(HCODEC_ME_STATUS),
+				READ_HREG(HCODEC_MPC_E));
 			amvenc_avc_light_reset(wq, 30);
 		}
 	}
@@ -3606,6 +4298,11 @@ static s32 encode_monitor_thread(void *data)
 				manager->current_wq = first_wq;
 				spin_unlock(&manager->event.sem_lock);
 				if (first_wq) {
+#ifdef CONFIG_AM_GE2D
+					if (!manager->context)
+						manager->context =
+						create_ge2d_work_queue();
+#endif
 					avc_init(first_wq);
 					manager->inited = true;
 				}
@@ -3629,6 +4326,12 @@ static s32 encode_monitor_thread(void *data)
 			spin_unlock(&manager->event.sem_lock);
 			manager->inited = false;
 			amvenc_avc_stop();
+#ifdef CONFIG_AM_GE2D
+			if (manager->context) {
+				destroy_ge2d_work_queue(manager->context);
+				manager->context = NULL;
+			}
+#endif
 			enc_pr(LOG_DEBUG, "power off encode.\n");
 			continue;
 		} else if (!list_empty(&manager->process_queue)) {
@@ -3672,6 +4375,19 @@ static s32 encode_start_monitor(void)
 	else
 		clock_level = 1;
 
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+		y_tnr_mot2alp_nrm_gain = 216;
+		y_tnr_mot2alp_dis_gain = 144;
+		c_tnr_mot2alp_nrm_gain = 216;
+		c_tnr_mot2alp_dis_gain = 144;
+	} else {
+		/* more tnr */
+		y_tnr_mot2alp_nrm_gain = 144;
+		y_tnr_mot2alp_dis_gain = 96;
+		c_tnr_mot2alp_nrm_gain = 144;
+		c_tnr_mot2alp_dis_gain = 96;
+	}
+
 	enc_pr(LOG_DEBUG, "encode start monitor.\n");
 	encode_manager.process_queue_state = ENCODE_PROCESS_QUEUE_START;
 	encode_manager.encode_thread = kthread_run(encode_monitor_thread,
@@ -4043,8 +4759,8 @@ static s32 amvenc_avc_probe(struct platform_device *pdev)
 		return -EFAULT;
 #else
 		encode_manager.cma_pool_size =
-			(codec_mm_get_total_size() > (32 * SZ_1M)) ?
-			(32 * SZ_1M) : codec_mm_get_total_size();
+			(codec_mm_get_total_size() > (40 * SZ_1M)) ?
+			(40 * SZ_1M) : codec_mm_get_total_size();
 		enc_pr(LOG_DEBUG,
 			"amvenc_avc - cma memory pool size: %d MB\n",
 			(u32)encode_manager.cma_pool_size / SZ_1M);
@@ -4067,6 +4783,12 @@ static s32 amvenc_avc_probe(struct platform_device *pdev)
 
 	r = init_avc_device();
 	enc_pr(LOG_INFO, "amvenc_avc probe end.\n");
+
+	avc_enc_class = class_create(THIS_MODULE, "avc_enc_debug");
+	if (IS_ERR(avc_enc_class))
+		return PTR_ERR(avc_enc_class);
+	r = class_create_file(avc_enc_class, &class_attr_encode_tbl_debug);
+
 	return r;
 }
 
@@ -4079,6 +4801,10 @@ static s32 amvenc_avc_remove(struct platform_device *pdev)
 	}
 	uninit_avc_device();
 	enc_pr(LOG_INFO, "amvenc_avc remove.\n");
+
+	class_remove_file(avc_enc_class, &class_attr_encode_tbl_debug);
+	class_destroy(avc_enc_class);
+
 	return 0;
 }
 
@@ -4176,9 +4902,109 @@ MODULE_PARM_DESC(encode_print_level, "\n encode_print_level\n");
 module_param(no_timeout, uint, 0664);
 MODULE_PARM_DESC(no_timeout, "\n no_timeout flag for process request\n");
 
-module_param(nr_mode, uint, 0664);
+module_param(nr_mode, int, 0664);
 MODULE_PARM_DESC(nr_mode, "\n nr_mode option\n");
 
+module_param(y_tnr_mc_en, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mc_en, "\n y_tnr_mc_en option\n");
+module_param(y_tnr_txt_mode, uint, 0664);
+MODULE_PARM_DESC(y_tnr_txt_mode, "\n y_tnr_txt_mode option\n");
+module_param(y_tnr_mot_sad_margin, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot_sad_margin, "\n y_tnr_mot_sad_margin option\n");
+module_param(y_tnr_mot_cortxt_rate, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot_cortxt_rate, "\n y_tnr_mot_cortxt_rate option\n");
+module_param(y_tnr_mot_distxt_ofst, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot_distxt_ofst, "\n y_tnr_mot_distxt_ofst option\n");
+module_param(y_tnr_mot_distxt_rate, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot_distxt_rate, "\n y_tnr_mot_distxt_rate option\n");
+module_param(y_tnr_mot_dismot_ofst, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot_dismot_ofst, "\n y_tnr_mot_dismot_ofst option\n");
+module_param(y_tnr_mot_frcsad_lock, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot_frcsad_lock, "\n y_tnr_mot_frcsad_lock option\n");
+module_param(y_tnr_mot2alp_frc_gain, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot2alp_frc_gain, "\n y_tnr_mot2alp_frc_gain option\n");
+module_param(y_tnr_mot2alp_nrm_gain, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot2alp_nrm_gain, "\n y_tnr_mot2alp_nrm_gain option\n");
+module_param(y_tnr_mot2alp_dis_gain, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot2alp_dis_gain, "\n y_tnr_mot2alp_dis_gain option\n");
+module_param(y_tnr_mot2alp_dis_ofst, uint, 0664);
+MODULE_PARM_DESC(y_tnr_mot2alp_dis_ofst, "\n y_tnr_mot2alp_dis_ofst option\n");
+module_param(y_tnr_alpha_min, uint, 0664);
+MODULE_PARM_DESC(y_tnr_alpha_min, "\n y_tnr_alpha_min option\n");
+module_param(y_tnr_alpha_max, uint, 0664);
+MODULE_PARM_DESC(y_tnr_alpha_max, "\n y_tnr_alpha_max option\n");
+module_param(y_tnr_deghost_os, uint, 0664);
+MODULE_PARM_DESC(y_tnr_deghost_os, "\n y_tnr_deghost_os option\n");
+
+module_param(c_tnr_mc_en, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mc_en, "\n c_tnr_mc_en option\n");
+module_param(c_tnr_txt_mode, uint, 0664);
+MODULE_PARM_DESC(c_tnr_txt_mode, "\n c_tnr_txt_mode option\n");
+module_param(c_tnr_mot_sad_margin, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot_sad_margin, "\n c_tnr_mot_sad_margin option\n");
+module_param(c_tnr_mot_cortxt_rate, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot_cortxt_rate, "\n c_tnr_mot_cortxt_rate option\n");
+module_param(c_tnr_mot_distxt_ofst, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot_distxt_ofst, "\n c_tnr_mot_distxt_ofst option\n");
+module_param(c_tnr_mot_distxt_rate, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot_distxt_rate, "\n c_tnr_mot_distxt_rate option\n");
+module_param(c_tnr_mot_dismot_ofst, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot_dismot_ofst, "\n c_tnr_mot_dismot_ofst option\n");
+module_param(c_tnr_mot_frcsad_lock, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot_frcsad_lock, "\n c_tnr_mot_frcsad_lock option\n");
+module_param(c_tnr_mot2alp_frc_gain, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot2alp_frc_gain, "\n c_tnr_mot2alp_frc_gain option\n");
+module_param(c_tnr_mot2alp_nrm_gain, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot2alp_nrm_gain, "\n c_tnr_mot2alp_nrm_gain option\n");
+module_param(c_tnr_mot2alp_dis_gain, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot2alp_dis_gain, "\n c_tnr_mot2alp_dis_gain option\n");
+module_param(c_tnr_mot2alp_dis_ofst, uint, 0664);
+MODULE_PARM_DESC(c_tnr_mot2alp_dis_ofst, "\n c_tnr_mot2alp_dis_ofst option\n");
+module_param(c_tnr_alpha_min, uint, 0664);
+MODULE_PARM_DESC(c_tnr_alpha_min, "\n c_tnr_alpha_min option\n");
+module_param(c_tnr_alpha_max, uint, 0664);
+MODULE_PARM_DESC(c_tnr_alpha_max, "\n c_tnr_alpha_max option\n");
+module_param(c_tnr_deghost_os, uint, 0664);
+MODULE_PARM_DESC(c_tnr_deghost_os, "\n c_tnr_deghost_os option\n");
+
+module_param(y_snr_err_norm, uint, 0664);
+MODULE_PARM_DESC(y_snr_err_norm, "\n y_snr_err_norm option\n");
+module_param(y_snr_gau_bld_core, uint, 0664);
+MODULE_PARM_DESC(y_snr_gau_bld_core, "\n y_snr_gau_bld_core option\n");
+module_param(y_snr_gau_bld_ofst, int, 0664);
+MODULE_PARM_DESC(y_snr_gau_bld_ofst, "\n y_snr_gau_bld_ofst option\n");
+module_param(y_snr_gau_bld_rate, uint, 0664);
+MODULE_PARM_DESC(y_snr_gau_bld_rate, "\n y_snr_gau_bld_rate option\n");
+module_param(y_snr_gau_alp0_min, uint, 0664);
+MODULE_PARM_DESC(y_snr_gau_alp0_min, "\n y_snr_gau_alp0_min option\n");
+module_param(y_snr_gau_alp0_max, uint, 0664);
+MODULE_PARM_DESC(y_snr_gau_alp0_max, "\n y_snr_gau_alp0_max option\n");
+module_param(y_bld_beta2alp_rate, uint, 0664);
+MODULE_PARM_DESC(y_bld_beta2alp_rate, "\n y_bld_beta2alp_rate option\n");
+module_param(y_bld_beta_min, uint, 0664);
+MODULE_PARM_DESC(y_bld_beta_min, "\n y_bld_beta_min option\n");
+module_param(y_bld_beta_max, uint, 0664);
+MODULE_PARM_DESC(y_bld_beta_max, "\n y_bld_beta_max option\n");
+
+module_param(c_snr_err_norm, uint, 0664);
+MODULE_PARM_DESC(c_snr_err_norm, "\n c_snr_err_norm option\n");
+module_param(c_snr_gau_bld_core, uint, 0664);
+MODULE_PARM_DESC(c_snr_gau_bld_core, "\n c_snr_gau_bld_core option\n");
+module_param(c_snr_gau_bld_ofst, int, 0664);
+MODULE_PARM_DESC(c_snr_gau_bld_ofst, "\n c_snr_gau_bld_ofst option\n");
+module_param(c_snr_gau_bld_rate, uint, 0664);
+MODULE_PARM_DESC(c_snr_gau_bld_rate, "\n c_snr_gau_bld_rate option\n");
+module_param(c_snr_gau_alp0_min, uint, 0664);
+MODULE_PARM_DESC(c_snr_gau_alp0_min, "\n c_snr_gau_alp0_min option\n");
+module_param(c_snr_gau_alp0_max, uint, 0664);
+MODULE_PARM_DESC(c_snr_gau_alp0_max, "\n c_snr_gau_alp0_max option\n");
+module_param(c_bld_beta2alp_rate, uint, 0664);
+MODULE_PARM_DESC(c_bld_beta2alp_rate, "\n c_bld_beta2alp_rate option\n");
+module_param(c_bld_beta_min, uint, 0664);
+MODULE_PARM_DESC(c_bld_beta_min, "\n c_bld_beta_min option\n");
+module_param(c_bld_beta_max, uint, 0664);
+MODULE_PARM_DESC(c_bld_beta_max, "\n c_bld_beta_max option\n");
+
 module_init(amvenc_avc_driver_init_module);
 module_exit(amvenc_avc_driver_remove_module);
 RESERVEDMEM_OF_DECLARE(amvenc_avc, "amlogic, amvenc-memory", avc_mem_setup);
diff --git a/drivers/amlogic/amports/encoder.h b/drivers/amlogic/amports/encoder.h
index be2d0fd..db01573 100644
--- a/drivers/amlogic/amports/encoder.h
+++ b/drivers/amlogic/amports/encoder.h
@@ -26,10 +26,15 @@
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
+#ifdef CONFIG_AM_GE2D
+#include <linux/amlogic/ge2d/ge2d.h>
+#endif
 
 #define AMVENC_DEVINFO_M8 "AML-M8"
 #define AMVENC_DEVINFO_G9 "AML-G9"
 #define AMVENC_DEVINFO_GXBB "AML-GXBB"
+#define AMVENC_DEVINFO_GXTVBB "AML-GXTVBB"
+#define AMVENC_DEVINFO_GXL "AML-GXL"
 
 #define HCODEC_IRQ_MBOX_CLR HCODEC_ASSIST_MBOX2_CLR_REG
 #define HCODEC_IRQ_MBOX_MASK HCODEC_ASSIST_MBOX2_MASK
@@ -148,6 +153,9 @@ enum amvenc_frame_fmt_e {
 	FMT_RGB888_PLANE,
 	FMT_RGB565,
 	FMT_RGBA8888,
+	FMT_YUV422_12BIT,
+	FMT_YUV444_10BIT,
+	FMT_YUV422_10BIT,
 	MAX_FRAME_FMT
 };
 
@@ -189,6 +197,18 @@ struct encode_request_s {
 	u32 framesize;
 	u32 qp_info_size;
 
+	u32 me_weight;
+	u32 i4_weight;
+	u32 i16_weight;
+
+	u32 crop_top;
+	u32 crop_bottom;
+	u32 crop_left;
+	u32 crop_right;
+	u32 src_w;
+	u32 src_h;
+	u32 scale_enable;
+
 	u32 nr_mode;
 	u32 flush_flag;
 	u32 timeout;
@@ -225,6 +245,7 @@ struct BuffInfo_s {
 	struct Buff_s intra_bits_info;
 	struct Buff_s intra_pred_info;
 	struct Buff_s qp_info;
+	struct Buff_s scale_buff;
 #ifdef USE_VDEC2
 	struct Buff_s vdec2_info;
 #endif
@@ -250,6 +271,7 @@ struct encode_meminfo_s {
 	u32 intra_bits_info_ddr_start_addr;
 	u32 intra_pred_info_ddr_start_addr;
 	u32 sw_ctl_info_start_addr;
+	u32 scaler_buff_start_addr;
 #ifdef USE_VDEC2
 	u32 vdec2_start_addr;
 #endif
@@ -302,6 +324,12 @@ struct encode_wq_s {
 	u32 me_weight;
 	u32 i4_weight;
 	u32 i16_weight;
+
+	u32 quant_tbl_i4[2][8];
+	u32 quant_tbl_i16[2][8];
+	u32 quant_tbl_me[2][8];
+	u32 qp_table_id;
+
 	struct encode_meminfo_s mem;
 	struct encode_picinfo_s pic;
 	struct encode_control_s control;
@@ -328,7 +356,9 @@ struct encode_manager_s {
 	u32 wq_count;
 	u32 ucode_index;
 	u32 max_instance;
-
+#ifdef CONFIG_AM_GE2D
+	struct ge2d_context_s *context;
+#endif
 	bool irq_requested;
 	bool dblk_fix_flag;
 	bool need_reset;
diff --git a/drivers/amlogic/amports/jpegdec.c b/drivers/amlogic/amports/jpegdec.c
index 37dbbc8..2a7b3a1 100644
--- a/drivers/amlogic/amports/jpegdec.c
+++ b/drivers/amlogic/amports/jpegdec.c
@@ -27,24 +27,28 @@
 #include <linux/slab.h>
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
-/* #include <mach/am_regs.h> */
-#include <plat/io.h>
 
 #include <linux/amlogic/amports/jpegdec.h>
-#include <linux/amlogic/amports/canvas.h>
-
+#include <linux/amlogic/canvas/canvas.h>
 #include <linux/uaccess.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/dma-contiguous.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+
 
 #include "amvdec.h"
 #include "streambuf.h"
 #include "vdec_reg.h"
 #include "amports_priv.h"
+/* #include "jpegdec_mc.h" */
 
 #define DEVICE_NAME "amjpegdec"
 #define DRIVER_NAME "amjpegdec"
 #define MODULE_NAME "amjpegdec"
 
 /* #define DEBUG */
+#define JPEGDEC_CANVAS_INDEX   0
 
 #define JPEGDEC_OUTPUT_CANVAS_Y (JPEGDEC_CANVAS_INDEX)
 #define JPEGDEC_OUTPUT_CANVAS_U (JPEGDEC_CANVAS_INDEX+1)
@@ -73,6 +77,8 @@
 #define JPEG_MCU_CROP_VSTART    PSCALE_PICO_W
 #define JPEG_MCU_CROP_VEND      PSCALE_PICO_H
 
+#define CMA_ALLOC_SIZE 10
+
 #ifdef DEBUG
 #define pr_dbg(fmt, args...) pr_info(KERN_DEBUG "amjpegdec: " fmt, ## args)
 #else
@@ -81,8 +87,8 @@
 #define pr_error(fmt, args...) pr_err(KERN_ERR "amjpegdec: " fmt, ## args)
 
 struct jpegdec_s {
-	jpegdec_config_t conf;
-	jpegdec_info_t info;
+	struct jpegdec_config_s conf;
+	struct jpegdec_info_s info;
 	unsigned state;
 };
 
@@ -94,10 +100,11 @@ static DEFINE_MUTEX(jpegdec_module_mutex);
 static struct jpegdec_s *dec;
 static unsigned long pbufAddr;
 static unsigned long pbufSize;
-static jpegdec_mem_info_t jegdec_mem_info;
+static struct jpegdec_mem_info_s jegdec_mem_info;
 
 static irqreturn_t jpegdec_isr(int irq, void *dev_id)
 {
+
 	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
 
 	if ((dec->state & JPEGDEC_STAT_INFO_READY) == 0) {
@@ -138,12 +145,12 @@ static int _init_dec(struct jpegdec_s *d)
 
 	amvdec_enable();
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_VREG(DOS_SW_RESET0, (1 << 11));
-	WRITE_VREG(DOS_SW_RESET0, 0);
-#else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU);
-#endif
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
+		WRITE_VREG(DOS_SW_RESET0, (1 << 11));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+	} else {
+		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU);
+	}
 
 	WRITE_VREG(ASSIST_AMR1_INT0, 0x1);
 	WRITE_VREG(ASSIST_AMR1_INT1, 0xf);
@@ -153,26 +160,28 @@ static int _init_dec(struct jpegdec_s *d)
 	WRITE_VREG(ASSIST_AMR1_INT5, 0x9);
 	WRITE_VREG(ASSIST_AMR1_INT6, 0x4);
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 7) | (1 << 6));
-	WRITE_VREG(DOS_SW_RESET0, 0);
-#else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_IQIDCT | RESET_MC);
-#endif
-
-	if (amvdec_loadmc(jpegdec_mc) < 0) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
+		WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 7) | (1 << 6));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+	} else {
+		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU |
+			RESET_IQIDCT | RESET_MC);
+	}
+	if (amvdec_loadmc_ex(VFORMAT_JPEG, "jpegdec_mc", NULL) < 0) {
 		amvdec_disable();
 
 		pr_error("jpegdec ucode loading failed.\n");
 		return -EBUSY;
 	}
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 10) | (1 << 7) | (1 << 6));
-	WRITE_VREG(DOS_SW_RESET0, 0);
-#else
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_IQIDCT | RESET_MC);
-	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
-#endif
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
+		WRITE_VREG(DOS_SW_RESET0, (1 << 11) | (1 << 10) |
+			(1 << 7) | (1 << 6));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+	} else {
+		WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU |
+			RESET_IQIDCT | RESET_MC);
+		WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
+	}
 	WRITE_VREG(PSCALE_RST, 0x7);
 	WRITE_VREG(PSCALE_RST, 0x0);
 
@@ -396,7 +405,7 @@ static int amjpegdec_open(struct inode *inode, struct file *file)
 	if (dec != NULL)
 		r = -EBUSY;
 
-	dec = kcalloc(1, sizeof(struct jpegdec_s);
+	dec = kcalloc(1, sizeof(struct jpegdec_s), GFP_KERNEL);
 	if (dec == NULL)
 		r = -ENOMEM;
 
@@ -425,17 +434,26 @@ static int amjpegdec_release(struct inode *inode, struct file *file)
 
 	amvdec_disable();
 
+	if (pbufAddr) {
+		codec_mm_free_for_dma(
+			"jpegdec",
+			pbufAddr);
+		pbufAddr = 0;
+		pbufSize = 0;
+		pr_info("jpegdec cma memory release succeed\n");
+	}
 	return 0;
 }
 
 static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 {
 	int r = 0;
+	void __user *argp;
+	argp = (void __user *)arg;
 
 	switch (cmd) {
 	case JPEGDEC_IOC_INFOCONFIG:
 		if (dec->state & JPEGDEC_STAT_WAIT_INFOCONFIG) {
-			pr_dbg("amjpegdec_ioctl:  JPEGDEC_IOC_INFOCONFIG\n");
 
 			dec->conf.opt |= arg & (JPEGDEC_OPT_THUMBNAIL_ONLY |
 				JPEGDEC_OPT_THUMBNAIL_PREFERED);
@@ -446,16 +464,65 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 
 			dec->state &= ~JPEGDEC_STAT_WAIT_INFOCONFIG;
 			dec->state |= JPEGDEC_STAT_WAIT_DATA;
-
 			amvdec_start();
 		} else
 			r = -EPERM;
 		break;
+	case JPEGDEC_IOC_DECCONFIG32:
+		if (dec->state & JPEGDEC_STAT_WAIT_DECCONFIG) {
+			ulong paddr_y, paddr_u, paddr_v , r;
+			struct compat_jpegdec_config_s __user *uf =
+				(struct compat_jpegdec_config_s *)argp;
+			memset(&dec->conf, 0, sizeof(struct jpegdec_config_s));
+			r = get_user(paddr_y, &uf->addr_y);
+			dec->conf.addr_y = paddr_y;
+			r |= get_user(paddr_u, &uf->addr_u);
+			dec->conf.addr_u = paddr_u;
+			r |= get_user(paddr_v, &uf->addr_v);
+			dec->conf.addr_v = paddr_v;
+			r |= get_user(dec->conf.canvas_width,
+				&uf->canvas_width);
+			r |= get_user(dec->conf.opt, &uf->opt);
+			r |= get_user(dec->conf.src_crop_x, &uf->src_crop_x);
+			r |= get_user(dec->conf.src_crop_y, &uf->src_crop_y);
+			r |= get_user(dec->conf.src_crop_w, &uf->src_crop_w);
+			r |= get_user(dec->conf.src_crop_h, &uf->src_crop_h);
+			r |= get_user(dec->conf.dec_x, &uf->dec_x);
+			r |= get_user(dec->conf.dec_y, &uf->dec_y);
+			r |= get_user(dec->conf.dec_w, &uf->dec_w);
+			r |= get_user(dec->conf.dec_h, &uf->dec_h);
+			r |= get_user(dec->conf.angle, &uf->angle);
+			if (r) {
+				pr_err("JPEGDEC_IOC_DECCONFIG32 get parameter failed .\n");
+				return -EFAULT;
+			}
+			pr_dbg("amjpegdec_ioctl:config,target (%d-%d-%d-%d)\n",
+				dec->conf.dec_x, dec->conf.dec_y,
+				dec->conf.dec_w, dec->conf.dec_h);
+			pr_dbg("planes (0x%lx-0x%lx-0x%lx), pbufAddr=0x%lx\n",
+				dec->conf.addr_y, dec->conf.addr_u,
+				dec->conf.addr_v, pbufAddr);
+
+			if ((dec->conf.angle & 1) == 0) {
+				if ((dec->conf.dec_w > dec->info.width) ||
+					(dec->conf.dec_h > dec->info.height))
+					return -EPERM;
+
+			} else {
+				if ((dec->conf.dec_w > dec->info.height) ||
+					(dec->conf.dec_h > dec->info.width))
+					return -EPERM;
+			}
 
+			dec->state &= ~JPEGDEC_STAT_WAIT_DECCONFIG;
+			_dec_run();
+		} else
+			r = -EPERM;
+		break;
 	case JPEGDEC_IOC_DECCONFIG:
 		if (dec->state & JPEGDEC_STAT_WAIT_DECCONFIG) {
 			if (copy_from_user(&dec->conf,
-				(void *)arg, sizeof(jpegdec_config_t)))
+				(void *)arg, sizeof(struct jpegdec_config_s)))
 				return -EFAULT;
 
 			pr_dbg("amjpegdec_ioctl:config,target (%d-%d-%d-%d)\n",
@@ -490,7 +557,7 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 				dec->info.width,
 				dec->info.height);
 			if (copy_to_user((void *)arg, &dec->info,
-					sizeof(jpegdec_info_t)))
+					sizeof(struct jpegdec_info_s)))
 				return -EFAULT;
 		} else
 			r = -EAGAIN;
@@ -500,7 +567,7 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 		return dec->state;
 	case JPEGDEC_G_MEM_INFO:
 		if (copy_from_user(&jegdec_mem_info, (void __user *)arg,
-						   sizeof(jpegdec_mem_info_t)))
+				   sizeof(struct jpegdec_mem_info_s)))
 			r = -EFAULT;
 		else {
 			unsigned pscaleCanvasbwidth =
@@ -514,7 +581,7 @@ static long amjpegdec_ioctl(struct file *file, unsigned int cmd, ulong arg)
 				pbufSize - pscaleCanvasbwidth;
 
 			if (copy_to_user((void __user *)arg, &jegdec_mem_info,
-						sizeof(jpegdec_mem_info_t)))
+					sizeof(struct jpegdec_mem_info_s)))
 				r = -EFAULT;
 		}
 		break;
@@ -546,44 +613,65 @@ static int mmap(struct file *filp, struct vm_area_struct *vma)
 
 }
 
+#ifdef CONFIG_COMPAT
+static long amjpegdec_compat_ioctl(struct file *filp,
+			      unsigned int cmd, unsigned long args)
+{
+	unsigned long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = amjpegdec_ioctl(filp, cmd, args);
+
+	return ret;
+}
+#endif
+
 static const struct file_operations amjpegdec_fops = {
 	.owner = THIS_MODULE,
 	.open = amjpegdec_open,
 	.mmap = mmap,
 	.release = amjpegdec_release,
 	.unlocked_ioctl = amjpegdec_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = amjpegdec_compat_ioctl,
+#endif
 };
 
 int AMHWJPEGDEC_MAJOR = 0;
 static int amjpegdec_probe(struct platform_device *pdev)
 {
 	int r;
+	int flags;
 
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
-
-	if (pdata == NULL) {
-		pr_info("amjpegdec memory resource undefined.\n");
-		return -EFAULT;
-	}
-
+	pr_dbg(" register amjpegdec .\n");
 	AMHWJPEGDEC_MAJOR = 0;
-	r = register_chrdev(AMHWJPEGDEC_MAJOR, "amjpegdev", &amjpegdec_fops);
+	r = register_chrdev(AMHWJPEGDEC_MAJOR, "amjpegdec", &amjpegdec_fops);
 
 	if (r < 0) {
 		pr_err("Can't register major for amjpegdec device\n");
 		return r;
 	}
 	AMHWJPEGDEC_MAJOR = r;
-
 	amjpegdec_class = class_create(THIS_MODULE, DEVICE_NAME);
 
 	amjpegdec_dev = device_create(amjpegdec_class, NULL,
 					MKDEV(AMHWJPEGDEC_MAJOR, 0),
 					NULL, DEVICE_NAME);
-	pbufAddr = pdata->mem_start;
-	pbufSize = pdata->mem_end - pdata->mem_start + 1;
 
+	flags = CODEC_MM_FLAGS_DMA_CPU|CODEC_MM_FLAGS_CMA_CLEAR;
+
+	pbufAddr = codec_mm_alloc_for_dma(
+					"jpegdec",
+					(CMA_ALLOC_SIZE*SZ_1M)/PAGE_SIZE,
+					0, flags);
+	if (!pbufAddr) {
+		pr_err("jpegdec alloc cma buffer failed\n");
+		return -1;
+	} else {
+		pbufSize = (CMA_ALLOC_SIZE*SZ_1M);
+	}
+	pr_info("jpegdec cma memory is %lx , size is  %lx\n" ,
+		pbufAddr , pbufSize);
 	return 0;
 }
 
@@ -598,19 +686,28 @@ static int amjpegdec_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id amlogic_amjpegdec_dt_match[] = {
+	{
+		.compatible = "amlogic, amjpegdec",
+	},
+	{},
+};
+
 static struct platform_driver amjpegdec_driver = {
 	.probe = amjpegdec_probe,
 	.remove = amjpegdec_remove,
 	.driver = {
 		.name = "amjpegdec",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_amjpegdec_dt_match,
 	}
 };
 
 static int __init amjpegdec_init(void)
 {
 	if (platform_driver_register(&amjpegdec_driver)) {
-		pr_error("failed to register amjpegdec module\n");
-		return -ENODEV;
+		pr_err("failed to register amjpegdec module\n");
+		return -ENOENT;
 	}
 
 	return 0;
diff --git a/drivers/amlogic/amports/jpegenc.c b/drivers/amlogic/amports/jpegenc.c
index be2b216..dc67045 100644
--- a/drivers/amlogic/amports/jpegenc.c
+++ b/drivers/amlogic/amports/jpegenc.c
@@ -2253,8 +2253,9 @@ static void jpegenc_buffspec_init(struct jpegenc_wq_s *wq)
 #define HCODEC_MFDIN_REG15			(HCODEC_MFDIN_REGB_AMPC + 0xa)
 #define HCODEC_MFDIN_REG16			(HCODEC_MFDIN_REGB_AMPC + 0xb)
 
-static void mfdin_basic_jpeg(u32 input, u8 iformat,
-	u8 oformat, u32 picsize_x, u32 picsize_y, u8 r2y_en)
+static void mfdin_basic_jpeg(
+	u32 input, u8 iformat, u8 oformat, u32 picsize_x,
+	u32 picsize_y, u8 r2y_en, u8 ifmt_extra)
 {
 	u8 dsample_en; /* Downsample Enable */
 	u8 interp_en; /* Interpolation Enable */
@@ -2276,10 +2277,30 @@ static void mfdin_basic_jpeg(u32 input, u8 iformat,
 	u32 linear_bytesperline;
 	bool linear_enable = false;
 	s32 reg_offset;
+	bool format_err = false;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		if ((iformat == 7) && (ifmt_extra > 2))
+			format_err = true;
+	} else if (iformat == 7)
+		format_err = true;
+
+	if (format_err) {
+		jenc_pr(LOG_ERROR,
+			"mfdin format err, iformat:%d, ifmt_extra:%d\n",
+			iformat, ifmt_extra);
+		return;
+	}
+	if (iformat != 7)
+		ifmt_extra = 0;
 
 	ifmt444 = ((iformat == 1) || (iformat == 5) || (iformat == 8)
 		|| (iformat == 9) || (iformat == 12)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra == 1)
+		ifmt444 = 1;
 	ifmt422 = ((iformat == 0) || (iformat == 10)) ? 1 : 0;
+	if (iformat == 7 && ifmt_extra != 1)
+		ifmt422 = 1;
 	ifmt420 = ((iformat == 2) || (iformat == 3) || (iformat == 4)
 		|| (iformat == 11)) ? 1 : 0;
 	dsample_en = ((ifmt444 && (oformat != 2))
@@ -2322,7 +2343,8 @@ static void mfdin_basic_jpeg(u32 input, u8 iformat,
 		(iformat << 0) | (oformat << 4) |
 		(dsample_en << 6) | (y_size << 8) |
 		(interp_en << 9) | (r2y_en << 12) |
-		(r2y_mode << 13) | (2 << 29));
+		(r2y_mode << 13) | (ifmt_extra << 16) |
+		(2 << 29));
 
 	if (linear_enable == false) {
 		WRITE_HREG((HCODEC_MFDIN_REG3_CANV + reg_offset),
@@ -2362,6 +2384,7 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 	u32 picsize_x, picsize_y;
 	u32 canvas_w = 0;
 	u32 input = cmd->src;
+	u8 ifmt_extra = 0;
 
 	jenc_pr(LOG_INFO, "************begin set input format**************\n");
 	jenc_pr(LOG_INFO, "type is %d\n", cmd->type);
@@ -2392,12 +2415,31 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 					cmd->framesize);
 			input = wq->InputBuffStart;
 		}
-		if (cmd->input_fmt <= JPEGENC_FMT_YUV444_PLANE)
+		if ((cmd->input_fmt <= JPEGENC_FMT_YUV444_PLANE) ||
+			(cmd->input_fmt >= JPEGENC_FMT_YUV422_12BIT))
 			r2y_en = 0;
 		else
 			r2y_en = 1;
 
-		if (cmd->input_fmt == JPEGENC_FMT_YUV422_SINGLE) {
+		if (cmd->input_fmt >= JPEGENC_FMT_YUV422_12BIT) {
+			iformat = 7;
+			ifmt_extra =
+				cmd->input_fmt - JPEGENC_FMT_YUV422_12BIT;
+			if (cmd->input_fmt == JPEGENC_FMT_YUV422_12BIT)
+				canvas_w = picsize_x * 24 / 8;
+			else if (cmd->input_fmt == JPEGENC_FMT_YUV444_10BIT)
+				canvas_w = picsize_x * 32 / 8;
+			else
+				canvas_w = (picsize_x * 20 + 7) / 8;
+			canvas_w = ((canvas_w + 31) >> 5) << 5;
+			canvas_config(ENC_CANVAS_OFFSET,
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
+			input = ENC_CANVAS_OFFSET;
+			input = input & 0xff;
+		} else if (cmd->input_fmt == JPEGENC_FMT_YUV422_SINGLE) {
 			iformat = 0;
 			canvas_w = picsize_x * 2;
 			canvas_w = ((canvas_w + 31) >> 5) << 5;
@@ -2439,20 +2481,20 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 			iformat = 4;
 			canvas_w = ((cmd->encoder_width + 63) >> 6) << 6;
 			canvas_config(ENC_CANVAS_OFFSET,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 2,
-				      input + canvas_w * picsize_y,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 2,
-				      input + canvas_w * picsize_y * 5 / 4,
-				      canvas_w / 2, picsize_y / 2,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 5 / 4,
+				canvas_w / 2, picsize_y / 2,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 2) << 16) |
 				((ENC_CANVAS_OFFSET + 1) << 8) |
 				ENC_CANVAS_OFFSET;
@@ -2463,18 +2505,18 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 				r2y_en = 1;
 			canvas_w = ((cmd->encoder_width + 31) >> 5) << 5;
 			canvas_config(ENC_CANVAS_OFFSET,
-				      input,
-				      canvas_w, picsize_y,
-				      CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input,
+				canvas_w, picsize_y,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 1,
-				      input + canvas_w * picsize_y, canvas_w,
-				      picsize_y, CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y, canvas_w,
+				picsize_y, CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			canvas_config(ENC_CANVAS_OFFSET + 2,
-				      input + canvas_w * picsize_y * 2,
-				      canvas_w, picsize_y, CANVAS_ADDR_NOWRAP,
-				      CANVAS_BLKMODE_LINEAR);
+				input + canvas_w * picsize_y * 2,
+				canvas_w, picsize_y, CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_LINEAR);
 			input = ((ENC_CANVAS_OFFSET + 2) << 16) |
 				((ENC_CANVAS_OFFSET + 1) << 8) |
 				ENC_CANVAS_OFFSET;
@@ -2504,12 +2546,18 @@ static s32 set_jpeg_input_format(struct jpegenc_wq_s *wq,
 				r2y_en = 1;
 			iformat = 5;
 			input = input & 0xffffff;
+		} else if ((cmd->input_fmt == JPEGENC_FMT_YUV422_12BIT)
+			|| (cmd->input_fmt == JPEGENC_FMT_YUV444_10BIT)
+			|| (cmd->input_fmt == JPEGENC_FMT_YUV422_10BIT)) {
+			iformat = 7;
+			ifmt_extra = cmd->input_fmt - JPEGENC_FMT_YUV422_12BIT;
+			input = input & 0xff;
 		} else
 			ret = -1;
 	}
 	if (ret == 0)
 		mfdin_basic_jpeg(input, iformat, oformat,
-			picsize_x, picsize_y, r2y_en);
+			picsize_x, picsize_y, r2y_en, ifmt_extra);
 	return ret;
 }
 
@@ -3024,7 +3072,14 @@ static long jpegenc_ioctl(struct file *file, u32 cmd, ulong arg)
 		r = copy_to_user((u32 *)arg, addr_info , 7 * sizeof(u32));
 		break;
 	case JPEGENC_IOC_GET_DEVINFO:
-		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) {
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+			/* GXL send same id of GXTVBB to upper*/
+			r = copy_to_user((s8 *)arg, JPEGENC_DEVINFO_GXTVBB,
+				strlen(JPEGENC_DEVINFO_GXTVBB));
+		} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) {
+			r = copy_to_user((s8 *)arg, JPEGENC_DEVINFO_GXTVBB,
+				strlen(JPEGENC_DEVINFO_GXTVBB));
+		} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) {
 			r = copy_to_user((s8 *)arg, JPEGENC_DEVINFO_GXBB,
 				strlen(JPEGENC_DEVINFO_GXBB));
 		} else if (get_cpu_type() == MESON_CPU_MAJOR_ID_MG9TV) {
diff --git a/drivers/amlogic/amports/jpegenc.h b/drivers/amlogic/amports/jpegenc.h
index b3a339a..0d86f7b 100644
--- a/drivers/amlogic/amports/jpegenc.h
+++ b/drivers/amlogic/amports/jpegenc.h
@@ -4,6 +4,8 @@
 #define JPEGENC_DEVINFO_M8 "AML-M8"
 #define JPEGENC_DEVINFO_G9 "AML-G9"
 #define JPEGENC_DEVINFO_GXBB "AML-GXBB"
+#define JPEGENC_DEVINFO_GXTVBB "AML-GXTVBB"
+#define JPEGENC_DEVINFO_GXL "AML-GXL"
 
 /* M8: 2550/10 = 255M GX: 2000/10 = 200M */
 #define JPEGENC_HDEC_L0()   WRITE_HHI_REG(HHI_VDEC_CLK_CNTL, \
@@ -120,6 +122,9 @@ enum jpegenc_frame_fmt_e {
 	JPEGENC_FMT_RGB888_PLANE,
 	JPEGENC_FMT_RGB565,
 	JPEGENC_FMT_RGBA8888,
+	JPEGENC_FMT_YUV422_12BIT,
+	JPEGENC_FMT_YUV444_10BIT,
+	JPEGENC_FMT_YUV422_10BIT,
 	JPEGENC_MAX_FRAME_FMT
 };
 
diff --git a/drivers/amlogic/amports/picdec.c b/drivers/amlogic/amports/picdec.c
index 3e9643d..27dbdb6 100644
--- a/drivers/amlogic/amports/picdec.c
+++ b/drivers/amlogic/amports/picdec.c
@@ -57,6 +57,7 @@
 #include <linux/ctype.h>
 #include <linux/of.h>
 #include <linux/sizes.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
 #include <linux/dma-mapping.h>
 #include <linux/of_fdt.h>
 #include <linux/dma-contiguous.h>
@@ -70,7 +71,8 @@
 /*class property info.*/
 /* #include "picdeccls.h" */
 static int debug_flag;
-
+static int p2p_mode = 2;
+/* #define MM_ALLOC_SIZE 48*SZ_1M */
 #define NO_TASK_MODE
 
 
@@ -124,12 +126,13 @@ static int task_running;
 /*same as tvin pool*/
 static int PICDEC_POOL_SIZE = 2;
 static int VF_POOL_SIZE = 2;
-
+static int ZOOM_WIDTH = 1280;
+static int ZOOM_HEIGHT = 720;
 /*same as tvin pool*/
 
 static struct picdec_device_s picdec_device;
 static struct source_input_s picdec_input;
-
+static int picdec_buffer_status;
 #define INCPTR(p) ptr_atomic_wrap_inc(&p)
 
 #define GE2D_ENDIAN_SHIFT        24
@@ -139,7 +142,7 @@ static struct source_input_s picdec_input;
 
 #define PROVIDER_NAME "decoder.pic"
 static DEFINE_SPINLOCK(lock);
-
+static struct vframe_receiver_op_s *picdec_stop(void);
 static inline void ptr_atomic_wrap_inc(u32 *ptr)
 {
 
@@ -255,16 +258,24 @@ static void picdec_vf_put(struct vframe_s *vf, void *op_arg)
 			pr_info
 			("**********recycle buffer index : %d *************\n",
 			 i);
-
 		}
+	}
+}
 
+static int picdec_event_cb(int type, void *data, void *private_data)
+{
+	if (type & VFRAME_EVENT_RECEIVER_FORCE_UNREG) {
+		picdec_stop();
+		aml_pr_info(0, "picdec device force to quit\n");
 	}
+	return 0;
 }
 
 static const struct vframe_operations_s picdec_vf_provider = {
 	.peek = picdec_vf_peek,
 	.get = picdec_vf_get,
 	.put = picdec_vf_put,
+	.event_cb = picdec_event_cb,
 	.vf_states = picdec_vf_states,
 };
 
@@ -298,6 +309,11 @@ static int render_frame(struct ge2d_context_s *context,
 	struct timeval end;
 
 	unsigned long time_use = 0;
+	int temp;
+	unsigned phase = 0;
+	unsigned h_phase , v_phase;
+	struct picdec_device_s *dev =  &picdec_device;
+	struct source_input_s *input = &picdec_input;
 
 	do_gettimeofday(&start);
 
@@ -311,15 +327,71 @@ static int render_frame(struct ge2d_context_s *context,
 		index = fill_ptr;
 
 	}
-
-	/* pr_info("render buffer index is %d!!!!!\n", index); */
+	dev->origin_width = input->frame_width;
+	dev->origin_height = input->frame_height;
+	if ((picdec_input.rotate == 90) || (picdec_input.rotate == 270)) {
+		temp = input->frame_width;
+		input->frame_width = input->frame_height;
+		input->frame_height = temp;
+	}
+	h_phase = (input->frame_width << 18) / dev->disp_width;
+	v_phase = (input->frame_height << 18) / dev->disp_height;
+	phase = max(h_phase, v_phase);
+	dev->p2p_mode = p2p_mode;
+	switch (dev->p2p_mode) {
+	case 0:
+		if ((input->frame_width < dev->disp_width) &&
+(input->frame_height < dev->disp_height)) {
+			dev->target_width  = input->frame_width;
+			dev->target_height = input->frame_height;
+		} else {
+			dev->target_width  = dev->disp_width;
+			dev->target_height = dev->disp_height;
+		}
+		break;
+	case 1:
+		if ((input->frame_width >=  ZOOM_WIDTH) &&
+			(input->frame_height >= ZOOM_HEIGHT)) {
+			if ((input->frame_width < dev->disp_width) &&
+(input->frame_height < dev->disp_height)) {
+				dev->target_width  = input->frame_width;
+				dev->target_height = input->frame_height;
+			} else {
+				dev->target_width  = dev->disp_width;
+				dev->target_height = dev->disp_height;
+			}
+		} else {
+			dev->target_width  = dev->disp_width;
+			dev->target_height = dev->disp_height;
+		}
+		break;
+	case 2:
+		if ((phase <= (1 << 18)) && (phase >= (1 << 16))) {
+			input->frame_width  =
+			(input->frame_width << 18) / phase;
+			input->frame_height =
+			(input->frame_height << 18) / phase;
+		} else if (phase < (1 << 16)) {
+			input->frame_width  <<= 2;
+			input->frame_height <<= 2;
+		}
+		dev->target_width = dev->disp_width;
+		dev->target_height = dev->disp_height;
+		break;
+	default:
+		dev->target_width  = dev->disp_width;
+		dev->target_height = dev->disp_height;
+		break;
+	}
+	aml_pr_info(1, "p2p_mode :%d ----render buffer index is %d\n",
+dev->p2p_mode, index);
+	aml_pr_info(1, "render target width: %d ; target height: %d\n",
+dev->target_width, dev->target_height);
 	new_vf = &vfpool[fill_ptr];
-
 	new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
 
-	new_vf->width = picdec_device.disp_width;
-
-	new_vf->height = picdec_device.disp_height;
+	new_vf->width =  dev->target_width;
+	new_vf->height = dev->target_height;
 
 	new_vf->type =
 		VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD | VIDTYPE_VIU_NV21
@@ -332,7 +404,8 @@ static int render_frame(struct ge2d_context_s *context,
 	new_vf->pts = 0;
 
 	new_vf->pts_us64 = 0;
-
+	new_vf->ratio_control = DISP_RATIO_FORCECONFIG |
+	DISP_RATIO_FORCE_NORMALWIDE;
 	new_vf->ratio_control = 0;
 
 	vfbuf_use[index]++;
@@ -361,13 +434,16 @@ static int render_frame_block(void)
 	struct timeval start;
 
 	struct timeval end;
-
+	int temp;
+	unsigned phase = 0;
+	unsigned h_phase , v_phase;
 	unsigned long time_use = 0;
 
 	struct config_para_ex_s ge2d_config;
 
 	struct ge2d_context_s *context = picdec_device.context;
-
+	struct picdec_device_s	*dev =  &picdec_device;
+	struct source_input_s	*input = &picdec_input;
 	do_gettimeofday(&start);
 
 	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
@@ -382,15 +458,72 @@ static int render_frame_block(void)
 		index = fill_ptr;
 
 	}
-
-	aml_pr_info(1, "render buffer index is %d$$$$$$$$$$$$$$$\n", index);
+	dev->origin_width = input->frame_width;
+	dev->origin_height = input->frame_height;
+	if ((picdec_input.rotate == 90) || (picdec_input.rotate == 270)) {
+		temp = input->frame_width;
+		input->frame_width = input->frame_height;
+		input->frame_height = temp;
+	}
+	h_phase = (input->frame_width << 18) / dev->disp_width;
+	v_phase = (input->frame_height << 18) / dev->disp_height;
+	phase = max(h_phase, v_phase);
+	dev->p2p_mode = p2p_mode;
+	switch (dev->p2p_mode) {
+	case 0:
+		if ((input->frame_width < dev->disp_width) &&
+(input->frame_height < dev->disp_height)) {
+			dev->target_width  = input->frame_width;
+			dev->target_height = input->frame_height;
+		} else {
+			dev->target_width  = dev->disp_width;
+			dev->target_height = dev->disp_height;
+		}
+		break;
+	case 1:
+		if ((input->frame_width >=  ZOOM_WIDTH) &&
+			(input->frame_height >= ZOOM_HEIGHT)) {
+			if ((input->frame_width < dev->disp_width) &&
+(input->frame_height < dev->disp_height)) {
+				dev->target_width  = input->frame_width;
+				dev->target_height = input->frame_height;
+			} else {
+				dev->target_width  = dev->disp_width;
+				dev->target_height = dev->disp_height;
+			}
+		} else {
+			dev->target_width  = dev->disp_width;
+			dev->target_height = dev->disp_height;
+		}
+		break;
+	case 2:
+		if ((phase <= (1 << 18)) && (phase >= (1 << 16))) {
+			input->frame_width  =
+			(input->frame_width << 18) / phase;
+			input->frame_height =
+			(input->frame_height << 18) / phase;
+		} else if (phase < (1 << 16)) {
+			input->frame_width  <<= 2;
+			input->frame_height <<= 2;
+		}
+		dev->target_width = dev->disp_width;
+		dev->target_height = dev->disp_height;
+		break;
+	default:
+		dev->target_width  = dev->disp_width;
+		dev->target_height = dev->disp_height;
+		break;
+	}
+	aml_pr_info(1, "p2p_mode :%d ----render buffer index is %d\n",
+dev->p2p_mode , index);
+	aml_pr_info(1, "render target width: %d ; target height: %d\n",
+dev->target_width , dev->target_height);
 	new_vf = &vfpool[fill_ptr];
 
 	new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
 
-	new_vf->width = picdec_device.disp_width;
-
-	new_vf->height = picdec_device.disp_height;
+	new_vf->width = picdec_device.target_width;
+	new_vf->height = picdec_device.target_height;
 
 	new_vf->type =
 		VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD | VIDTYPE_VIU_NV21
@@ -404,7 +537,8 @@ static int render_frame_block(void)
 
 	new_vf->pts_us64 = 0;
 
-	new_vf->ratio_control = 0;
+	new_vf->ratio_control = DISP_RATIO_FORCECONFIG |
+	DISP_RATIO_FORCE_NORMALWIDE;
 
 	picdec_device.cur_index = index;
 
@@ -477,6 +611,7 @@ static struct vframe_receiver_op_s *picdec_stop(void)
 
 #endif				/*
 				 */
+	picdec_cma_buf_uninit();
 	set_freerun_mode(0);
 
 	picdec_local_init();
@@ -609,10 +744,10 @@ int picdec_pre_process(void)
 	char *q;
 
 	char *ref;
-
 	int ret = 0;
-
-	int bp = ((picdec_input.frame_width + 0x1f) & ~0x1f) * 3;
+	int frame_width = picdec_device.origin_width;
+	int frame_height = picdec_device.origin_height;
+	int bp = ((frame_width + 0x1f) & ~0x1f) * 3;
 
 	struct timeval start;
 
@@ -641,13 +776,13 @@ int picdec_pre_process(void)
 	}
 
 	aml_pr_info(1, "picdec_input width is %d , height is %d\n",
-		   picdec_input.frame_width, picdec_input.frame_height);
+		   frame_width, frame_height);
 
 	if (picdec_input.input == NULL) {
 
-		for (j = 0; j < picdec_input.frame_height; j++) {
+		for (j = 0; j < frame_height; j++) {
 
-			for (i = 0; i < picdec_input.frame_width * 3; i += 3) {
+			for (i = 0; i < frame_width * 3; i += 3) {
 
 				dst_addr_off = i + bp * j;
 
@@ -675,13 +810,13 @@ int picdec_pre_process(void)
 			("RGB user space address is %x################\n",
 			 (unsigned)q);*/
 
-			for (j = 0; j < picdec_input.frame_height; j++) {
+			for (j = 0; j < frame_height; j++) {
 
 				ret = copy_from_user(p, (void __user *)q,
-						picdec_input.frame_width *
+						frame_width *
 						3);
 
-				q += picdec_input.frame_width * 3;
+				q += frame_width * 3;
 
 				p += bp;
 
@@ -697,11 +832,11 @@ int picdec_pre_process(void)
 			("RGBA user space address is %x################\n",
 			 (unsigned)q);*/
 
-			for (j = 0; j < picdec_input.frame_height; j++) {
+			for (j = 0; j < frame_height; j++) {
 
 				p = ref;
 
-				for (i = 0; i < picdec_input.frame_width; i++) {
+				for (i = 0; i < frame_width; i++) {
 
 					ret = copy_from_user(p,
 							(void __user *)q, 3);
@@ -727,11 +862,11 @@ int picdec_pre_process(void)
 			("ARGB user space address is %x################\n",
 			 (unsigned)q);*/
 
-			for (j = 0; j < picdec_input.frame_height; j++) {
+			for (j = 0; j < frame_height; j++) {
 
 				p = ref;
 
-				for (i = 0; i < picdec_input.frame_width; i++) {
+				for (i = 0; i < frame_width; i++) {
 
 					ret = copy_from_user(p,
 							(void __user *)(q +
@@ -758,13 +893,13 @@ int picdec_pre_process(void)
 			/*pr_info("user space address is %x################\n",
 				   (unsigned)q);*/
 
-			for (j = 0; j < picdec_input.frame_height; j++) {
+			for (j = 0; j < frame_height; j++) {
 
 				ret = copy_from_user(p, (void __user *)q,
-						picdec_input.frame_width *
+						frame_width *
 						3);
 
-				q += picdec_input.frame_width * 3;
+				q += frame_width * 3;
 
 				p += bp;
 
@@ -778,7 +913,7 @@ int picdec_pre_process(void)
 		io_mapping_unmap_atomic(buffer_start);
 	} else {
 		dma_flush(picdec_device.assit_buf_start,
-		bp * picdec_input.frame_height);
+		bp * frame_height);
 	}
 
 	do_gettimeofday(&end);
@@ -943,10 +1078,8 @@ int fill_color(struct vframe_s *vf, struct ge2d_context_s *context,
 	ge2d_config->dst_para.top = 0;
 
 	ge2d_config->dst_para.left = 0;
-
-	ge2d_config->dst_para.width = picdec_device.disp_width;
-
-	ge2d_config->dst_para.height = picdec_device.disp_height;
+	ge2d_config->dst_para.width = picdec_device.target_width;
+	ge2d_config->dst_para.height = picdec_device.target_height;
 
 	if (ge2d_context_config_ex(context, ge2d_config) < 0) {
 
@@ -960,9 +1093,8 @@ int fill_color(struct vframe_s *vf, struct ge2d_context_s *context,
 
 	dst_left = 0;
 
-	dst_width = picdec_device.disp_width;
-
-	dst_height = picdec_device.disp_height;
+	dst_width =  picdec_device.target_width;
+	dst_height = picdec_device.target_height;
 
 	stretchblt_noalpha(context, 0, 0, 640, 480, dst_left, dst_top,
 					   dst_width, dst_height);
@@ -1153,9 +1285,9 @@ static void rotate_adjust(int w_in, int h_in, int *w_out, int *h_out, int angle)
 
 	int w = 0, h = 0, disp_w = 0, disp_h = 0;
 
-	disp_w = picdec_device.disp_width;
+	disp_w = *w_out;
 
-	disp_h = picdec_device.disp_height;
+	disp_h = *h_out;
 
 	if ((angle == 90) || (angle == 270)) {
 
@@ -1222,9 +1354,9 @@ int picdec_fill_buffer(struct vframe_s *vf, struct ge2d_context_s *context,
 
 	int canvas_id = PIC_DEC_SOURCE_CANVAS;
 
-	int canvas_width = (picdec_input.frame_width + 0x1f) & ~0x1f;
+	int canvas_width = (picdec_device.origin_width + 0x1f) & ~0x1f;
 
-	int canvas_height = (picdec_input.frame_height + 0xf) & ~0xf;
+	int canvas_height = (picdec_device.origin_height + 0xf) & ~0xf;
 
 	int frame_width = picdec_input.frame_width;
 
@@ -1400,18 +1532,47 @@ int picdec_fill_buffer(struct vframe_s *vf, struct ge2d_context_s *context,
 
 	dst_left = 0;
 
-	dst_width = picdec_device.disp_width;
-
-	dst_height = picdec_device.disp_height;
-
+	dst_width =  picdec_device.target_width;
+	dst_height = picdec_device.target_height;
+#if 0
 	rotate_adjust(frame_width, frame_height, &dst_width, &dst_height,
 				  picdec_input.rotate);
-
-	dst_left = (picdec_device.disp_width - dst_width) >> 1;
-
-	dst_top = (picdec_device.disp_height - dst_height) >> 1;
-
-	stretchblt_noalpha(context, 0, 0, frame_width, frame_height,
+#else
+	rotate_adjust(frame_width, frame_height, &dst_width, &dst_height,
+				  0);
+#endif
+	dst_width  = (dst_width + 0x1) & ~0x1;
+	dst_height = (dst_height + 0x1) & ~0x1;
+	switch (picdec_device.p2p_mode) {
+	case 0:
+		dst_left = 0;
+		dst_top = 0;
+		vf->width  = dst_width;
+		vf->height = dst_height;
+		break;
+	case 1:
+		if ((picdec_input.frame_width >=  ZOOM_WIDTH) &&
+		(picdec_input.frame_height >= ZOOM_HEIGHT)) {
+			dst_left = 0;
+			dst_top = 0;
+			vf->width  = dst_width;
+			vf->height = dst_height;
+		} else {
+			dst_left = (picdec_device.disp_width - dst_width) >> 1;
+			dst_top = (picdec_device.disp_height - dst_height) >> 1;
+		}
+		break;
+	case 2:
+		dst_left = (picdec_device.disp_width - dst_width) >> 1;
+		dst_top = (picdec_device.disp_height - dst_height) >> 1;
+		break;
+	default:
+		dst_left = (picdec_device.disp_width - dst_width) >> 1;
+		dst_top = (picdec_device.disp_height - dst_height) >> 1;
+		break;
+	}
+	stretchblt_noalpha(context, 0, 0, picdec_device.origin_width,
+	picdec_device.origin_height,
 			dst_left, dst_top, dst_width, dst_height);
 
 	return 0;
@@ -1487,6 +1648,7 @@ static int picdec_task(void *data)
 	}
 picdec_exit:
 	destroy_ge2d_work_queue(context);
+	picdec_cma_buf_uninit();
 	while (!kthread_should_stop()) {
 
 		/*         may not call stop, wait..
@@ -1528,6 +1690,80 @@ static int simulate_task(void *data)
 *   init functions.
 *
 *************************************************/
+int picdec_cma_buf_init(void)
+{
+	int flags;
+	if (!picdec_device.use_reserved) {
+		switch (picdec_buffer_status) {
+		case 0:/* not config */
+			break;
+		case 1:/* config before , return ok */
+			return 0;
+		case 2:/* config fail, won't retry , return failure */
+			return -1;
+		default:
+			return -1;
+		}
+		aml_pr_info(0, "reserved memory config fail , use CMA	.\n");
+		if (picdec_device.cma_mode == 0) {
+			picdec_device.cma_pages = dma_alloc_from_contiguous(
+					&(picdec_device.pdev->dev),
+					(48*SZ_1M) >> PAGE_SHIFT, 0);
+			picdec_device.buffer_start = page_to_phys(
+			picdec_device.cma_pages);
+			picdec_device.buffer_size = (48*SZ_1M);
+		} else{
+			flags = CODEC_MM_FLAGS_DMA_CPU|CODEC_MM_FLAGS_CMA_CLEAR;
+			picdec_device.buffer_start = codec_mm_alloc_for_dma(
+					"picdec",
+					(48*SZ_1M)/PAGE_SIZE, 0, flags);
+			picdec_device.buffer_size = (48*SZ_1M);
+		}
+		aml_pr_info(0, "cma memory is %x , size is  %x\n" ,
+		(unsigned)picdec_device.buffer_start ,
+		(unsigned)picdec_device.buffer_size);
+
+
+		if (picdec_device.buffer_start == 0) {
+			picdec_buffer_status = 2;
+			aml_pr_info(0, "cma memory allocate fail\n");
+			return -1;
+		} else {
+			picdec_buffer_status = 1;
+			aml_pr_info(0, "cma memory allocate succeed\n");
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+int picdec_cma_buf_uninit(void)
+{
+	if (!picdec_device.use_reserved) {
+		if (picdec_device.cma_mode == 0) {
+			if (picdec_device.cma_pages) {
+				dma_release_from_contiguous(
+					&picdec_device.pdev->dev,
+					picdec_device.cma_pages,
+					(48*SZ_1M) >> PAGE_SHIFT);
+				picdec_device.cma_pages = NULL;
+			}
+		} else {
+			if (picdec_device.buffer_start != 0) {
+				codec_mm_free_for_dma(
+				"picdec",
+				picdec_device.buffer_start);
+				picdec_device.buffer_start = 0;
+				picdec_device.buffer_size = 0;
+				aml_pr_info(0, "cma memory release succeed\n");
+			}
+		}
+	}
+	picdec_buffer_status = 0;
+	return 0;
+}
+
 int picdec_buffer_init(void)
 {
 	int i;
@@ -1539,7 +1775,8 @@ int picdec_buffer_init(void)
 	resource_size_t buf_start;
 	unsigned int buf_size;
 	unsigned offset = 0;
-
+	picdec_buffer_status = 0;
+	picdec_cma_buf_init();
 	get_picdec_buf_info(&buf_start, &buf_size, NULL);
 
 	aml_pr_info(1, "picdec buffer size is %x\n", buf_size);
@@ -2147,10 +2384,10 @@ int init_picdec_device(void)
 	dev_set_drvdata(picdec_device.dev, &picdec_device);
 
 	platform_set_drvdata(picdec_device.pdev, &picdec_device);
-
+#if 0
 	if (picdec_buffer_init() < 0)
 		goto unregister_dev;
-
+#endif
 	vf_provider_init(&picdec_vf_prov, PROVIDER_NAME, &picdec_vf_provider,
 					 NULL);
 	return 0;
@@ -2198,20 +2435,10 @@ static int picdec_driver_probe(struct platform_device *pdev)
 	r = of_reserved_mem_device_init(&pdev->dev);
 	if (r == 0)
 		aml_pr_info(0, "picdec_driver_probe done.\n");
-	if (!picdec_device.use_reserved) {
-		aml_pr_info(0, "reserved memory config fail , use CMA	.\n");
-		picdec_device.cma_pages = dma_alloc_from_contiguous(
-					&pdev->dev,
-					(48 * SZ_1M) >> PAGE_SHIFT, 0);
-		picdec_device.buffer_start = page_to_phys(
-		picdec_device.cma_pages);
-		picdec_device.buffer_size = 48 * SZ_1M;
-		aml_pr_info(0, "cma memory is %x , size is  %x\n" ,
-		(unsigned)picdec_device.buffer_start ,
-		(unsigned)picdec_device.buffer_size);
-	}
+	picdec_device.cma_mode = 1;
 	picdec_device.pdev = pdev;
 	init_picdec_device();
+	picdec_device.p2p_mode = 0;
 	return r;
 
 	/* char *buf_start; */
@@ -2259,13 +2486,7 @@ static int picdec_drv_remove(struct platform_device *plat_dev)
 		if (picdec_device.mapping)
 			io_mapping_free(picdec_device.mapping);
 	} else{
-		if (picdec_device.cma_pages) {
-			dma_release_from_contiguous(
-				&plat_dev->dev,
-				picdec_device.cma_pages,
-				(48 * SZ_1M) >> PAGE_SHIFT);
-			picdec_device.cma_pages = NULL;
-		}
+
 	}
 	return 0;
 }
@@ -2324,6 +2545,10 @@ RESERVEDMEM_OF_DECLARE(picdec, "amlogic, picdec_memory", picdec_mem_setup);
 MODULE_PARM_DESC(debug_flag, "\n debug_flag\n");
 module_param(debug_flag, uint, 0664);
 
+module_param(p2p_mode, uint, 0664);
+MODULE_PARM_DESC(p2p_mode, "\n picdec zoom mode\n");
+
+
 MODULE_DESCRIPTION("Amlogic picture decoder driver");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Simon Zheng <simon.zheng@amlogic.com>");
diff --git a/drivers/amlogic/amports/picdec.h b/drivers/amlogic/amports/picdec.h
index 96b063d..bcb05ad 100644
--- a/drivers/amlogic/amports/picdec.h
+++ b/drivers/amlogic/amports/picdec.h
@@ -1,103 +1,112 @@
-/*
- * drivers/amlogic/amports/picdec.h
- *
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
-*/
-
-#ifndef _PICDEC_INCLUDE__
-#define _PICDEC_INCLUDE__
-
-#include <linux/interrupt.h>
-/* #include <mach/am_regs.h> */
-#include <linux/amlogic/canvas/canvas.h>
-#include <linux/fb.h>
-#include <linux/list.h>
-#include <linux/uaccess.h>
-#include <linux/sysfs.h>
-#include  <linux/spinlock.h>
-#include <linux/kthread.h>
-#include <linux/io-mapping.h>
-#include <linux/ctype.h>
-#include <linux/of.h>
-#include <linux/sizes.h>
-#include <linux/dma-mapping.h>
-#include <linux/of_fdt.h>
-#include <linux/dma-contiguous.h>
-/**************************************************************
-**                                                                   **
-**  macro define                                                         **
-**                                                                   **
-***************************************************************/
-
-struct picdec_device_s {
-	char name[20];
-	struct platform_device *pdev;
-	int task_running;
-	int dump;
-	char *dump_path;
-	unsigned int open_count;
-	int major;
-	unsigned int dbg_enable;
-	struct class *cla;
-	struct device *dev;
-	resource_size_t buffer_start;
-	unsigned int buffer_size;
-	resource_size_t assit_buf_start;
-	const struct vinfo_s *vinfo;
-	int disp_width;
-	int disp_height;
-	int frame_render;
-	int frame_post;
-	struct ge2d_context_s *context;
-	int cur_index;
-	int use_reserved;
-	struct page *cma_pages;
-	struct io_mapping *mapping;	
-	void  __iomem *vir_addr;
-};
-
-struct source_input_s {
-	char *input;
-	int frame_width;
-	int frame_height;
-	int format;
-	int rotate;
-};
-
-struct compat_source_input_s {
-	compat_uptr_t input;
-	int frame_width;
-	int frame_height;
-	int format;
-	int rotate;
-};
-
-#define PICDEC_IOC_MAGIC  'P'
-#define PICDEC_IOC_FRAME_RENDER     _IOW(PICDEC_IOC_MAGIC, 0x00, struct source_input_s)
-#define PICDEC_IOC_FRAME_POST     _IOW(PICDEC_IOC_MAGIC, 0X01, unsigned int)
-#define PICDEC_IOC_CONFIG_FRAME  _IOW(PICDEC_IOC_MAGIC, 0X02, unsigned int)
-
-#define PICDEC_IOC_FRAME_RENDER32 _IOW(PICDEC_IOC_MAGIC, 0x00, struct compat_source_input_s)
-
-void stop_picdec_task(void);
-int picdec_buffer_init(void);
-void get_picdec_buf_info(resource_size_t *start, unsigned int *size,
-						 struct io_mapping **mapping);
-int picdec_fill_buffer(struct vframe_s *vf, struct ge2d_context_s *context,
-	struct config_para_ex_s *ge2d_config);
-extern void set_freerun_mode(int mode);
-
-extern int start_picdec_task(void);
-extern int start_picdec_simulate_task(void);
-#endif				/* _PICDEC_INCLUDE__ */
+/*
+ * drivers/amlogic/amports/picdec.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef _PICDEC_INCLUDE__
+#define _PICDEC_INCLUDE__
+
+#include <linux/interrupt.h>
+/* #include <mach/am_regs.h> */
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include <linux/uaccess.h>
+#include <linux/sysfs.h>
+#include  <linux/spinlock.h>
+#include <linux/kthread.h>
+#include <linux/io-mapping.h>
+#include <linux/ctype.h>
+#include <linux/of.h>
+#include <linux/sizes.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_fdt.h>
+#include <linux/dma-contiguous.h>
+/**************************************************************
+**                                                                   **
+**  macro define                                                         **
+**                                                                   **
+***************************************************************/
+
+struct picdec_device_s {
+	char name[20];
+	struct platform_device *pdev;
+	int task_running;
+	int dump;
+	char *dump_path;
+	unsigned int open_count;
+	int major;
+	unsigned int dbg_enable;
+	struct class *cla;
+	struct device *dev;
+	resource_size_t buffer_start;
+	unsigned int buffer_size;
+	resource_size_t assit_buf_start;
+	const struct vinfo_s *vinfo;
+	int disp_width;
+	int disp_height;
+	int origin_width;
+	int origin_height;
+	int frame_render;
+	int frame_post;
+	int target_width;
+	int target_height;
+	int p2p_mode;
+	struct ge2d_context_s *context;
+	int cur_index;
+	int use_reserved;
+	struct page *cma_pages;
+	struct io_mapping *mapping;
+	void  __iomem *vir_addr;
+	int cma_mode;
+};
+
+struct source_input_s {
+	char *input;
+	int frame_width;
+	int frame_height;
+	int format;
+	int rotate;
+};
+
+struct compat_source_input_s {
+	compat_uptr_t input;
+	int frame_width;
+	int frame_height;
+	int format;
+	int rotate;
+};
+
+#define PICDEC_IOC_MAGIC  'P'
+#define PICDEC_IOC_FRAME_RENDER     _IOW(PICDEC_IOC_MAGIC, 0x00, \
+struct source_input_s)
+#define PICDEC_IOC_FRAME_POST     _IOW(PICDEC_IOC_MAGIC, 0X01, unsigned int)
+#define PICDEC_IOC_CONFIG_FRAME  _IOW(PICDEC_IOC_MAGIC, 0X02, unsigned int)
+
+#define PICDEC_IOC_FRAME_RENDER32 _IOW(PICDEC_IOC_MAGIC, 0x00, \
+struct compat_source_input_s)
+
+void stop_picdec_task(void);
+int picdec_buffer_init(void);
+void get_picdec_buf_info(resource_size_t *start, unsigned int *size,
+						 struct io_mapping **mapping);
+int picdec_fill_buffer(struct vframe_s *vf, struct ge2d_context_s *context,
+	struct config_para_ex_s *ge2d_config);
+extern void set_freerun_mode(int mode);
+int picdec_cma_buf_init(void);
+int picdec_cma_buf_uninit(void);
+extern int start_picdec_task(void);
+extern int start_picdec_simulate_task(void);
+#endif				/* _PICDEC_INCLUDE__ */
diff --git a/drivers/amlogic/amports/rdma.c b/drivers/amlogic/amports/rdma.c
index 1123e53..0f4ba18 100644
--- a/drivers/amlogic/amports/rdma.c
+++ b/drivers/amlogic/amports/rdma.c
@@ -50,7 +50,7 @@
 
 
 /*#define CONFIG_RDMA_IN_RDMAIRQ*/
-#define CONFIG_RDMA_IN_TASK
+/*#define CONFIG_RDMA_IN_TASK*/
 
 #define RDMA_TABLE_SIZE                    (2 * (PAGE_SIZE))
 
@@ -102,12 +102,12 @@ static int rdma_task_handle(void *data)
 			}
 		}
 		if (rdma_start_flag) {
-			rdma_start_flag = 0;
-			vsync_rdma_handle =
+			if (vsync_rdma_handle <= 0)
+				vsync_rdma_handle =
 				rdma_register(&vsync_rdma_op,
 				NULL, RDMA_TABLE_SIZE);
+			rdma_start_flag = 0;
 		}
-
 	}
 	return 0;
 }
diff --git a/drivers/amlogic/amports/vavs.c b/drivers/amlogic/amports/vavs.c
index 5b00072..9e7294e 100644
--- a/drivers/amlogic/amports/vavs.c
+++ b/drivers/amlogic/amports/vavs.c
@@ -14,12 +14,12 @@
  * more details.
  *
 */
-
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/timer.h>
+#include <linux/kfifo.h>
 #include <linux/platform_device.h>
 #include <linux/amlogic/amports/amstream.h>
 #include <linux/amlogic/amports/ptsserv.h>
@@ -28,14 +28,15 @@
 #include <linux/amlogic/amports/vframe_provider.h>
 #include <linux/amlogic/amports/vframe_receiver.h>
 #include <linux/amlogic/amports/vformat.h>
-/* #include <mach/am_regs.h> */
-#include <linux/module.h>
 #include "vdec_reg.h"
 #include "streambuf_reg.h"
 #include "amvdec.h"
 #include "arch/register.h"
 #include "amports_priv.h"
-
+#include <linux/dma-mapping.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/slab.h>
+#include "avs.h"
 
 #define DRIVER_NAME "amvdec_avs"
 #define MODULE_NAME "amvdec_avs"
@@ -44,7 +45,7 @@
 #define NV21
 #endif
 
-/* #define USE_AVS_SEQ_INFO_ONLY */
+#define USE_AVS_SEQ_INFO
 #define HANDLE_AVS_IRQ
 #define DEBUG_PTS
 
@@ -72,12 +73,11 @@
 #define AVS_TIME_STAMP      AV_SCRATCH_B
 #define AVS_OFFSET_REG      AV_SCRATCH_C
 #define MEM_OFFSET_REG      AV_SCRATCH_F
+#define AVS_ERROR_RECOVERY_MODE   AV_SCRATCH_G
 
-#define VF_POOL_SIZE        12
+#define VF_POOL_SIZE        32
 #define PUT_INTERVAL        (HZ/100)
 
-#define INCPTR(p) ptr_atomic_wrap_inc(&p)
-
 #if 1 /*MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8*/
 #define INT_AMVENCODER INT_DOS_MAILBOX_1
 #else
@@ -89,26 +89,51 @@
 
 static int debug_flag;
 
+static int firmware_sel; /* 0, normal; 1, old ucode */
+
+int avs_get_debug_flag(void)
+{
+	return debug_flag;
+}
+
 static struct vframe_s *vavs_vf_peek(void *);
 static struct vframe_s *vavs_vf_get(void *);
 static void vavs_vf_put(struct vframe_s *, void *);
+static int vavs_vf_states(struct vframe_states *states, void *);
 
 static const char vavs_dec_id[] = "vavs-dev";
 
 #define PROVIDER_NAME   "decoder.avs"
+static DEFINE_SPINLOCK(lock);
+static DEFINE_MUTEX(vavs_mutex);
 
 static const struct vframe_operations_s vavs_vf_provider = {
 	.peek = vavs_vf_peek,
 	.get = vavs_vf_get,
 	.put = vavs_vf_put,
+	.vf_states = vavs_vf_states,
 };
 
 static struct vframe_provider_s vavs_vf_prov;
 
+#define  VF_BUF_NUM_MAX 16
+
+/*static u32 vf_buf_num = 4*/
+static u32 vf_buf_num = 4;
+static u32 vf_buf_num_used;
+static u32 canvas_base = 128;
+#ifdef NV21
+	int	canvas_num = 2; /*NV21*/
+#else
+	int	canvas_num = 3;
+#endif
+static u32 work_buf_size;
+
 static struct vframe_s vfpool[VF_POOL_SIZE];
-static u32 vfpool_idx[VF_POOL_SIZE];
-static s32 vfbuf_use[4];
-static s32 fill_ptr, get_ptr, putting_ptr, put_ptr;
+/*static struct vframe_s vfpool2[VF_POOL_SIZE];*/
+static struct vframe_s *cur_vfpool;
+static unsigned char recover_flag;
+static s32 vfbuf_use[VF_BUF_NUM_MAX];
 static u32 saved_resolution;
 static u32 frame_width, frame_height, frame_dur, frame_prog;
 static struct timer_list recycle_timer;
@@ -126,31 +151,42 @@ static unsigned char throw_pb_flag;
 static u32 pts_hit, pts_missed, pts_i_hit, pts_i_missed;
 #endif
 
+static u32 radr, rval;
 static struct dec_sysinfo vavs_amstream_dec_info;
 
-static inline u32 index2canvas(u32 index)
-{
-	const u32 canvas_tab[4] = {
-#ifdef NV21
-		0x010100, 0x040403, 0x070706, 0x0a0a09
-#else
-		0x020100, 0x050403, 0x080706, 0x0b0a09
+#ifdef AVSP_LONG_CABAC
+static struct work_struct long_cabac_wd_work;
+void *es_write_addr_virt;
+dma_addr_t es_write_addr_phy;
+
+void *bitstream_read_tmp;
+dma_addr_t bitstream_read_tmp_phy;
+void *avsp_heap_adr;
+
 #endif
-	};
 
-	return canvas_tab[index];
-}
+static DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
+static DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
+static DECLARE_KFIFO(recycle_q, struct vframe_s *, VF_POOL_SIZE);
 
-static inline void ptr_atomic_wrap_inc(u32 *ptr)
+static inline u32 index2canvas(u32 index)
 {
-	u32 i = *ptr;
-
-	i++;
+	const u32 canvas_tab[VF_BUF_NUM_MAX] = {
+		0x010100, 0x030302, 0x050504, 0x070706,
+		0x090908, 0x0b0b0a, 0x0d0d0c, 0x0f0f0e,
+		0x111110, 0x131312, 0x151514, 0x171716,
+		0x191918, 0x1b1b1a, 0x1d1d1c, 0x1f1f1e,
+	};
+	const u32 canvas_tab_3[4] = {
+		0x010100, 0x040403, 0x070706, 0x0a0a09
+	};
 
-	if (i >= VF_POOL_SIZE)
-		i = 0;
+	if (canvas_num == 2)
+		return canvas_tab[index] + (canvas_base << 16)
+		+ (canvas_base << 8) + canvas_base;
 
-	*ptr = i;
+	return canvas_tab_3[index] + (canvas_base << 16)
+		+ (canvas_base << 8) + canvas_base;
 }
 
 static const u32 frame_rate_tab[16] = {
@@ -185,7 +221,7 @@ static void set_frame_info(struct vframe_s *vf, unsigned *duration)
 		vf->height = READ_VREG(AVS_PIC_HEIGHT);
 		frame_width = vf->width;
 		frame_height = vf->height;
-		/* pr_info("%s: (%d,%d)\n", __func__,vf->width, vf->height); */
+		/* pr_info("%s: (%d,%d)\n", __func__,vf->width, vf->height);*/
 	}
 
 #ifndef USE_AVS_SEQ_INFO
@@ -244,23 +280,33 @@ static void vavs_isr(void)
 	u32 repeat_count;
 	u32 picture_type;
 	u32 buffer_index;
+	u32 picture_struct;
 	unsigned int pts, pts_valid = 0, offset;
-	if (debug_flag & 2) {
+	if (debug_flag & AVS_DEBUG_UCODE) {
 		if (READ_VREG(AV_SCRATCH_E) != 0) {
 			pr_info("dbg%x: %x\n", READ_VREG(AV_SCRATCH_E),
 				   READ_VREG(AV_SCRATCH_D));
 			WRITE_VREG(AV_SCRATCH_E, 0);
 		}
 	}
-
+#ifdef AVSP_LONG_CABAC
+	if (firmware_sel == 0 && READ_VREG(LONG_CABAC_REQ)) {
+#ifdef PERFORMANCE_DEBUG
+		pr_info("%s:schedule long_cabac_wd_work\r\n", __func__);
+#endif
+		schedule_work(&long_cabac_wd_work);
+	}
+#endif
 	reg = READ_VREG(AVS_BUFFEROUT);
 
 	if (reg) {
-		if (debug_flag & 1)
-			pr_info("AVS_BUFFEROUT=%x\n", reg);
+		picture_struct = READ_VREG(AV_SCRATCH_5);
+		if (debug_flag & AVS_DEBUG_PRINT)
+			pr_info("AVS_BUFFEROUT=%x, picture_struct is 0x%x\n",
+				reg, picture_struct);
 		if (pts_by_offset) {
 			offset = READ_VREG(AVS_OFFSET_REG);
-			if (debug_flag & 1)
+			if (debug_flag & AVS_DEBUG_PRINT)
 				pr_info("AVS OFFSET=%x\n", offset);
 			if (pts_lookup_offset(PTS_TYPE_VIDEO, offset, &pts, 0)
 				== 0) {
@@ -276,7 +322,14 @@ static void vavs_isr(void)
 		}
 
 		repeat_count = READ_VREG(AVS_REPEAT_COUNT);
-		buffer_index = ((reg & 0x7) - 1) & 3;
+		if (firmware_sel == 0)
+			buffer_index =
+				((reg & 0x7) +
+				(((reg >> 8) & 0x3) << 3) - 1) & 0x1f;
+		else
+			buffer_index =
+				((reg & 0x7) - 1) & 3;
+
 		picture_type = (reg >> 3) & 7;
 #ifdef DEBUG_PTS
 		if (picture_type == I_PICTURE) {
@@ -291,7 +344,7 @@ static void vavs_isr(void)
 
 		if (throw_pb_flag && picture_type != I_PICTURE) {
 
-			if (debug_flag & 1) {
+			if (debug_flag & AVS_DEBUG_PRINT) {
 				pr_info("picture type %d throwed\n",
 					   picture_type);
 			}
@@ -299,13 +352,16 @@ static void vavs_isr(void)
 		} else if (reg & INTERLACE_FLAG) {	/* interlace */
 			throw_pb_flag = 0;
 
-			if (debug_flag & 1) {
+			if (debug_flag & AVS_DEBUG_PRINT) {
 				pr_info("interlace, picture type %d\n",
 					   picture_type);
 			}
 
-			vfpool_idx[fill_ptr] = buffer_index;
-			vf = &vfpool[fill_ptr];
+			if (kfifo_get(&newframe_q, &vf) == 0) {
+				pr_info
+				("fatal error, no available buffer slot.");
+				return IRQ_HANDLED;
+			}
 			set_frame_info(vf, &dur);
 			vf->bufWidth = 1920;
 			pic_type = 2;
@@ -340,7 +396,8 @@ static void vavs_isr(void)
 					next_pts = 0;
 				}
 			}
-
+			vf->signal_type = 0;
+			vf->index = buffer_index;
 			vf->duration_pulldown = 0;
 			vf->type =
 				(reg & TOP_FIELD_FIRST_FLAG)
@@ -351,21 +408,25 @@ static void vavs_isr(void)
 #endif
 			vf->canvas0Addr = vf->canvas1Addr =
 				index2canvas(buffer_index);
+			vf->type_original = vf->type;
 
-			if (debug_flag & 1) {
+			if (debug_flag & AVS_DEBUG_PRINT) {
 				pr_info("buffer_index %d, canvas addr %x\n",
 					   buffer_index, vf->canvas0Addr);
 			}
 
 			vfbuf_use[buffer_index]++;
 
-			INCPTR(fill_ptr);
+			kfifo_put(&display_q,
+					  (const struct vframe_s *)vf);
 			vf_notify_receiver(PROVIDER_NAME,
 					VFRAME_EVENT_PROVIDER_VFRAME_READY,
 					NULL);
 
-			vfpool_idx[fill_ptr] = buffer_index;
-			vf = &vfpool[fill_ptr];
+			if (kfifo_get(&newframe_q, &vf) == 0) {
+				pr_info("fatal error, no available buffer slot.");
+				return IRQ_HANDLED;
+						}
 			set_frame_info(vf, &dur);
 			vf->bufWidth = 1920;
 
@@ -385,7 +446,8 @@ static void vavs_isr(void)
 				vf->duration = dur >> 1;
 				next_pts = 0;
 			}
-
+			vf->signal_type = 0;
+			vf->index = buffer_index;
 			vf->duration_pulldown = 0;
 			vf->type =
 				(reg & TOP_FIELD_FIRST_FLAG) ?
@@ -396,10 +458,11 @@ static void vavs_isr(void)
 #endif
 			vf->canvas0Addr = vf->canvas1Addr =
 				index2canvas(buffer_index);
-
+			vf->type_original = vf->type;
 			vfbuf_use[buffer_index]++;
 
-			INCPTR(fill_ptr);
+			kfifo_put(&display_q,
+					  (const struct vframe_s *)vf);
 			vf_notify_receiver(PROVIDER_NAME,
 					VFRAME_EVENT_PROVIDER_VFRAME_READY,
 					NULL);
@@ -407,13 +470,15 @@ static void vavs_isr(void)
 		} else {	/* progressive */
 			throw_pb_flag = 0;
 
-			if (debug_flag & 1) {
+			if (debug_flag & AVS_DEBUG_PRINT) {
 				pr_info("progressive picture type %d\n",
 					   picture_type);
 			}
-
-			vfpool_idx[fill_ptr] = buffer_index;
-			vf = &vfpool[fill_ptr];
+			if (kfifo_get(&newframe_q, &vf) == 0) {
+				pr_info
+				("fatal error, no available buffer slot.");
+				return IRQ_HANDLED;
+			}
 			set_frame_info(vf, &dur);
 			vf->bufWidth = 1920;
 			pic_type = 1;
@@ -448,7 +513,8 @@ static void vavs_isr(void)
 					next_pts = 0;
 				}
 			}
-
+			vf->signal_type = 0;
+			vf->index = buffer_index;
 			vf->duration_pulldown = 0;
 			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
 #ifdef NV21
@@ -456,15 +522,15 @@ static void vavs_isr(void)
 #endif
 			vf->canvas0Addr = vf->canvas1Addr =
 				index2canvas(buffer_index);
-
-			if (debug_flag & 1) {
+			vf->type_original = vf->type;
+			if (debug_flag & AVS_DEBUG_PRINT) {
 				pr_info("buffer_index %d, canvas addr %x\n",
 					   buffer_index, vf->canvas0Addr);
 			}
 
 			vfbuf_use[buffer_index]++;
-
-			INCPTR(fill_ptr);
+			kfifo_put(&display_q,
+					  (const struct vframe_s *)vf);
 			vf_notify_receiver(PROVIDER_NAME,
 					VFRAME_EVENT_PROVIDER_VFRAME_READY,
 					NULL);
@@ -484,39 +550,59 @@ static void vavs_isr(void)
 	return;
 #endif
 }
-
+/*
 static int run_flag = 1;
 static int step_flag;
+*/
+static int error_recovery_mode;   /*0: blocky  1: mosaic*/
+/*
+static uint error_watchdog_threshold=10;
+static uint error_watchdog_count;
+static uint error_watchdog_buf_threshold = 0x4000000;
+*/
+static uint long_cabac_busy;
+
 static struct vframe_s *vavs_vf_peek(void *op_arg)
 {
-	if (run_flag == 0)
-		return NULL;
-	if (get_ptr == fill_ptr)
+	struct vframe_s *vf;
+
+	if (recover_flag)
 		return NULL;
 
-	return &vfpool[get_ptr];
+	if (kfifo_peek(&display_q, &vf))
+		return vf;
+
+	return NULL;
+
 }
 
 static struct vframe_s *vavs_vf_get(void *op_arg)
 {
 	struct vframe_s *vf;
-	if (run_flag == 0)
-		return NULL;
 
-	if (get_ptr == fill_ptr)
+	if (recover_flag)
 		return NULL;
 
-	vf = &vfpool[get_ptr];
+	if (kfifo_get(&display_q, &vf))
+		return vf;
+
+	return NULL;
 
-	INCPTR(get_ptr);
-	if (step_flag)
-		run_flag = 0;
-	return vf;
 }
 
 static void vavs_vf_put(struct vframe_s *vf, void *op_arg)
 {
-	INCPTR(putting_ptr);
+	int i;
+	if (recover_flag)
+		return;
+
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		if (vf == &cur_vfpool[i])
+			break;
+	}
+	if (i < VF_POOL_SIZE)
+		kfifo_put(&recycle_q, (const struct vframe_s *)vf);
+
 }
 
 int vavs_dec_status(struct vdec_status *vstatus)
@@ -540,8 +626,8 @@ static void vavs_canvas_init(void)
 	u32 canvas_width, canvas_height;
 	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
 	u32 disp_addr = 0xffffffff;
-	int canvas_num = 3;
-
+	int vf_buf_num_avail = 0;
+	vf_buf_num_used = vf_buf_num;
 	if (buf_size <= 0x00400000) {
 		/* SD only */
 		canvas_width = 768;
@@ -549,9 +635,12 @@ static void vavs_canvas_init(void)
 		decbuf_y_size = 0x80000;
 		decbuf_uv_size = 0x20000;
 		decbuf_size = 0x100000;
+		vf_buf_num_avail =
+		((buf_size - work_buf_size) / decbuf_size) - 1;
 		pr_info
-		("avs (SD only): buf_start %p, buf_size %x, buf_offset %x\n",
-		 (void *)buf_start, buf_size, buf_offset);
+		("avs(SD):buf_start %p, size %x, offset %x avail %d\n",
+		 (void *)buf_start, buf_size, buf_offset,
+		 vf_buf_num_avail);
 	} else {
 		/* HD & SD */
 		canvas_width = 1920;
@@ -559,9 +648,17 @@ static void vavs_canvas_init(void)
 		decbuf_y_size = 0x200000;
 		decbuf_uv_size = 0x80000;
 		decbuf_size = 0x300000;
-		pr_info("avs: buf_start %p, buf_size %x, buf_offset %x\n",
-			   (void *)buf_start, buf_size, buf_offset);
+		vf_buf_num_avail =
+		((buf_size - work_buf_size) / decbuf_size) - 1;
+		pr_info("avs: buf_start %p, buf_size %x, buf_offset %x buf avail %d\n",
+			   (void *)buf_start, buf_size, buf_offset,
+			   vf_buf_num_avail);
 	}
+	if (vf_buf_num_used > vf_buf_num_avail)
+		vf_buf_num_used = vf_buf_num_avail;
+
+	if (firmware_sel == 0)
+		buf_offset = buf_offset + ((vf_buf_num_used + 1) * decbuf_size);
 
 	if (READ_MPEG_REG(VPP_MISC) & VPP_VD1_POSTBLEND) {
 		struct canvas_s cur_canvas;
@@ -571,16 +668,18 @@ static void vavs_canvas_init(void)
 		disp_addr = (cur_canvas.addr + 7) >> 3;
 	}
 
-	for (i = 0; i < 4; i++) {
+	for (i = 0; i < vf_buf_num_used; i++) {
 		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
 #ifdef NV21
-			canvas_config(canvas_num * i + 0,
-					buf_start + 4 * decbuf_size,
+			canvas_config(canvas_base + canvas_num * i + 0,
+					buf_start +
+					vf_buf_num_used * decbuf_size,
 					canvas_width, canvas_height,
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
-			canvas_config(canvas_num * i + 1,
-					buf_start + 4 * decbuf_size +
+			canvas_config(canvas_base + canvas_num * i + 1,
+					buf_start +
+					vf_buf_num_used * decbuf_size +
 					decbuf_y_size, canvas_width,
 					canvas_height / 2,
 					CANVAS_ADDR_NOWRAP,
@@ -604,20 +703,21 @@ static void vavs_canvas_init(void)
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
 #endif
-			if (debug_flag & 1) {
-				pr_info("canvas config %d, addr %p\n", 4,
+			if (debug_flag & AVS_DEBUG_PRINT) {
+				pr_info("canvas config %d, addr %p\n",
+					vf_buf_num_used,
 					   (void *)(buf_start +
-					   4 * decbuf_size));
+					   vf_buf_num_used * decbuf_size));
 			}
 
 		} else {
 #ifdef NV21
-			canvas_config(canvas_num * i + 0,
+			canvas_config(canvas_base + canvas_num * i + 0,
 					buf_start + i * decbuf_size,
 					canvas_width, canvas_height,
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
-			canvas_config(canvas_num * i + 1,
+			canvas_config(canvas_base + canvas_num * i + 1,
 					buf_start + i * decbuf_size +
 					decbuf_y_size, canvas_width,
 					canvas_height / 2,
@@ -642,7 +742,7 @@ static void vavs_canvas_init(void)
 					CANVAS_ADDR_NOWRAP,
 					CANVAS_BLKMODE_32X32);
 #endif
-			if (debug_flag & 1) {
+			if (debug_flag & AVS_DEBUG_PRINT) {
 				pr_info("canvas config %d, addr %p\n", i,
 					   (void *)(buf_start +
 					   i * decbuf_size));
@@ -651,6 +751,84 @@ static void vavs_canvas_init(void)
 	}
 }
 
+void vavs_recover(void)
+{
+	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6) | (1 << 4));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+
+	READ_VREG(DOS_SW_RESET0);
+
+	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6) | (1 << 4));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+
+	WRITE_VREG(DOS_SW_RESET0, (1 << 9) | (1 << 8));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+	/*
+	WRITE_VREG(POWER_CTL_VLD, 0x10);
+	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 2, MEM_FIFO_CNT_BIT, 2);
+	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 8, MEM_LEVEL_CNT_BIT, 6);
+	*/
+	if (firmware_sel == 0)
+		WRITE_VREG(AV_SCRATCH_5, 0);
+
+	if (firmware_sel == 0) {
+		/* fixed canvas index */
+		WRITE_VREG(AV_SCRATCH_0, canvas_base);
+		WRITE_VREG(AV_SCRATCH_1, vf_buf_num_used);
+	} else {
+		int ii;
+		for (ii = 0; ii < 4; ii++) {
+			WRITE_VREG(AV_SCRATCH_0 + ii,
+				(canvas_base + canvas_num * ii) |
+				((canvas_base + canvas_num * ii + 1)
+					<< 8) |
+				((canvas_base + canvas_num * ii + 1)
+					<< 16)
+			);
+		}
+	}
+
+	/* notify ucode the buffer offset */
+	WRITE_VREG(AV_SCRATCH_F, buf_offset);
+
+	/* disable PSCALE for hardware sharing */
+	WRITE_VREG(PSCALE_CTRL, 0);
+
+	WRITE_VREG(AVS_SOS_COUNT, 0);
+	WRITE_VREG(AVS_BUFFERIN, 0);
+	WRITE_VREG(AVS_BUFFEROUT, 0);
+	if (error_recovery_mode)
+		WRITE_VREG(AVS_ERROR_RECOVERY_MODE, 0);
+	else
+		WRITE_VREG(AVS_ERROR_RECOVERY_MODE, 1);
+	/* clear mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	/* enable mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
+#if 1				/* def DEBUG_UCODE */
+	WRITE_VREG(AV_SCRATCH_D, 0);
+#endif
+
+#ifdef NV21
+	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
+#endif
+
+#ifdef PIC_DC_NEED_CLEAR
+	CLEAR_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 31);
+#endif
+
+#ifdef AVSP_LONG_CABAC
+	if (firmware_sel == 0) {
+		WRITE_VREG(LONG_CABAC_DES_ADDR, es_write_addr_phy);
+		WRITE_VREG(LONG_CABAC_REQ, 0);
+		WRITE_VREG(LONG_CABAC_PIC_SIZE, 0);
+		WRITE_VREG(LONG_CABAC_SRC_ADDR, 0);
+	}
+#endif
+
+}
+
 static void vavs_prot_init(void)
 {
 #if 1 /* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
@@ -675,17 +853,38 @@ static void vavs_prot_init(void)
 	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
 #endif
 
+	/***************** reset vld   **********************************/
 	WRITE_VREG(POWER_CTL_VLD, 0x10);
 	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 2, MEM_FIFO_CNT_BIT, 2);
-	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 8, MEM_LEVEL_CNT_BIT, 6);
+	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL,	8, MEM_LEVEL_CNT_BIT, 6);
+	/*************************************************************/
 
 	vavs_canvas_init();
-
+	if (firmware_sel == 0)
+		WRITE_VREG(AV_SCRATCH_5, 0);
 #ifdef NV21
-	WRITE_VREG(AV_SCRATCH_0, 0x010100);
-	WRITE_VREG(AV_SCRATCH_1, 0x040403);
-	WRITE_VREG(AV_SCRATCH_2, 0x070706);
-	WRITE_VREG(AV_SCRATCH_3, 0x0a0a09);
+		if (firmware_sel == 0) {
+			/* fixed canvas index */
+			WRITE_VREG(AV_SCRATCH_0, canvas_base);
+			WRITE_VREG(AV_SCRATCH_1, vf_buf_num_used);
+		} else {
+			int ii;
+			for (ii = 0; ii < 4; ii++) {
+				WRITE_VREG(AV_SCRATCH_0 + ii,
+					(canvas_base + canvas_num * ii) |
+					((canvas_base + canvas_num * ii + 1)
+						<< 8) |
+					((canvas_base + canvas_num * ii + 1)
+						<< 16)
+				);
+			}
+			/*
+			WRITE_VREG(AV_SCRATCH_0, 0x010100);
+			WRITE_VREG(AV_SCRATCH_1, 0x040403);
+			WRITE_VREG(AV_SCRATCH_2, 0x070706);
+			WRITE_VREG(AV_SCRATCH_3, 0x0a0a09);
+			*/
+		}
 #else
 	/* index v << 16 | u << 8 | y */
 	WRITE_VREG(AV_SCRATCH_0, 0x020100);
@@ -702,7 +901,10 @@ static void vavs_prot_init(void)
 	WRITE_VREG(AVS_SOS_COUNT, 0);
 	WRITE_VREG(AVS_BUFFERIN, 0);
 	WRITE_VREG(AVS_BUFFEROUT, 0);
-
+	if (error_recovery_mode)
+		WRITE_VREG(AVS_ERROR_RECOVERY_MODE, 0);
+	else
+		WRITE_VREG(AVS_ERROR_RECOVERY_MODE, 1);
 	/* clear mailbox interrupt */
 	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
 
@@ -720,8 +922,19 @@ static void vavs_prot_init(void)
 	CLEAR_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 31);
 #endif
 
+#ifdef AVSP_LONG_CABAC
+	if (firmware_sel == 0) {
+		WRITE_VREG(LONG_CABAC_DES_ADDR, es_write_addr_phy);
+		WRITE_VREG(LONG_CABAC_REQ, 0);
+		WRITE_VREG(LONG_CABAC_PIC_SIZE, 0);
+		WRITE_VREG(LONG_CABAC_SRC_ADDR, 0);
+	}
+#endif
 }
 
+#ifdef AVSP_LONG_CABAC
+static unsigned char es_write_addr[MAX_CODED_FRAME_SIZE]  __aligned(64);
+#endif
 static void vavs_local_init(void)
 {
 	int i;
@@ -730,8 +943,6 @@ static void vavs_local_init(void)
 
 	avi_flag = (unsigned long) vavs_amstream_dec_info.param;
 
-	fill_ptr = get_ptr = put_ptr = putting_ptr = 0;
-
 	frame_width = frame_height = frame_dur = frame_prog = 0;
 
 	throw_pb_flag = 1;
@@ -743,9 +954,67 @@ static void vavs_local_init(void)
 #ifdef DEBUG_PTS
 	pts_hit = pts_missed = pts_i_hit = pts_i_missed = 0;
 #endif
-
-	for (i = 0; i < 4; i++)
+	INIT_KFIFO(display_q);
+	INIT_KFIFO(recycle_q);
+	INIT_KFIFO(newframe_q);
+
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		const struct vframe_s *vf = &vfpool[i];
+		vfpool[i].index = vf_buf_num;
+		vfpool[i].bufWidth = 1920;
+		kfifo_put(&newframe_q, vf);
+	}
+	for (i = 0; i < vf_buf_num; i++)
 		vfbuf_use[i] = 0;
+
+	cur_vfpool = vfpool;
+
+}
+
+static int vavs_vf_states(struct vframe_states *states, void *op_arg)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&lock, flags);
+	states->vf_pool_size = VF_POOL_SIZE;
+	states->buf_free_num = kfifo_len(&newframe_q);
+	states->buf_avail_num = kfifo_len(&display_q);
+	states->buf_recycle_num = kfifo_len(&recycle_q);
+	spin_unlock_irqrestore(&lock, flags);
+	return 0;
+}
+
+#ifdef CONFIG_POST_PROCESS_MANAGER
+static void vavs_ppmgr_reset(void)
+{
+	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_RESET, NULL);
+
+	vavs_local_init();
+
+	pr_info("vavs: vf_ppmgr_reset\n");
+}
+#endif
+
+static void vavs_local_reset(void)
+{
+	mutex_lock(&vavs_mutex);
+	recover_flag = 1;
+	pr_info("error, local reset\n");
+	amvdec_stop();
+	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_RESET, NULL);
+	vavs_local_init();
+	vavs_recover();
+	amvdec_start();
+	recover_flag = 0;
+#if 0
+	error_watchdog_count = 0;
+
+	pr_info("pc %x stream buf wp %x rp %x level %x\n",
+		READ_VREG(MPC_E),
+		READ_VREG(VLD_MEM_VIFIFO_WP),
+		READ_VREG(VLD_MEM_VIFIFO_RP),
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL));
+#endif
+	mutex_unlock(&vavs_mutex);
 }
 
 static void vavs_put_timer_func(unsigned long arg)
@@ -756,31 +1025,84 @@ static void vavs_put_timer_func(unsigned long arg)
 	vavs_isr();
 #endif
 
-#if 0
-	if (READ_VREG(AVS_SOS_COUNT) > 10) {
-		amvdec_stop();
-		vf_light_unreg_provider(&vavs_vf_prov);
-		vavs_local_init();
-		vavs_prot_init();
-		vf_reg_provider(&vavs_vf_prov);
-		amvdec_start();
+	if (READ_VREG(AVS_SOS_COUNT)) {
+		if (!error_recovery_mode) {
+			if (debug_flag & AVS_DEBUG_OLD_ERROR_HANDLE) {
+				mutex_lock(&vavs_mutex);
+				pr_info("vavs fatal error reset !\n");
+				amvdec_stop();
+#ifdef CONFIG_POST_PROCESS_MANAGER
+				vavs_ppmgr_reset();
+#else
+				vf_light_unreg_provider(&vavs_vf_prov);
+				vavs_local_init();
+				vf_reg_provider(&vavs_vf_prov);
+#endif
+				vavs_recover();
+				amvdec_start();
+				mutex_unlock(&vavs_mutex);
+			} else {
+				vavs_local_reset();
+			}
+		}
 	}
+#if 0
+	if (long_cabac_busy == 0 &&
+		error_watchdog_threshold > 0 &&
+		kfifo_len(&display_q) == 0 &&
+		READ_VREG(VLD_MEM_VIFIFO_LEVEL) >
+		error_watchdog_buf_threshold) {
+		pr_info("newq %d dispq %d recyq %d\r\n",
+			kfifo_len(&newframe_q),
+			kfifo_len(&display_q),
+			kfifo_len(&recycle_q));
+		pr_info("pc %x stream buf wp %x rp %x level %x\n",
+			READ_VREG(MPC_E),
+			READ_VREG(VLD_MEM_VIFIFO_WP),
+			READ_VREG(VLD_MEM_VIFIFO_RP),
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL));
+		error_watchdog_count++;
+		if (error_watchdog_count >= error_watchdog_threshold)
+			vavs_local_reset();
+	} else
+		error_watchdog_count = 0;
 #endif
+	if (radr != 0) {
+		if (rval != 0) {
+			WRITE_VREG(radr, rval);
+			pr_info("WRITE_VREG(%x,%x)\n", radr, rval);
+		} else
+			pr_info("READ_VREG(%x)=%x\n", radr, READ_VREG(radr));
+		rval = 0;
+		radr = 0;
+	}
 
-	if ((putting_ptr != put_ptr) && (READ_VREG(AVS_BUFFERIN) == 0)) {
-		u32 index = vfpool_idx[put_ptr];
-
-		if (--vfbuf_use[index] == 0)
-			WRITE_VREG(AVS_BUFFERIN, ~(1 << index));
+	if (!kfifo_is_empty(&recycle_q) && (READ_VREG(AVS_BUFFERIN) == 0)) {
+		struct vframe_s *vf;
+		if (kfifo_get(&recycle_q, &vf)) {
+			if ((vf->index < vf_buf_num) &&
+			 (--vfbuf_use[vf->index] == 0)) {
+				WRITE_VREG(AVS_BUFFERIN, ~(1 << vf->index));
+				vf->index = vf_buf_num;
+			}
+				kfifo_put(&newframe_q,
+						  (const struct vframe_s *)vf);
+		}
 
-		INCPTR(put_ptr);
 	}
 	if (frame_dur > 0 && saved_resolution !=
 		frame_width * frame_height * (96000 / frame_dur)) {
 		int fps = 96000 / frame_dur;
 		saved_resolution = frame_width * frame_height * fps;
-		vdec_source_changed(VFORMAT_H264,
+		if (firmware_sel == 0 &&
+			(debug_flag & AVS_DEBUG_USE_FULL_SPEED)) {
+			vdec_source_changed(VFORMAT_AVS,
+				4096, 2048, 60);
+		} else {
+			vdec_source_changed(VFORMAT_AVS,
 			frame_width, frame_height, fps);
+		}
+
 	}
 
 	timer->expires = jiffies + PUT_INTERVAL;
@@ -788,6 +1110,119 @@ static void vavs_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
+#ifdef AVSP_LONG_CABAC
+
+static void long_cabac_do_work(struct work_struct *work)
+{
+	int status = 0;
+#ifdef PERFORMANCE_DEBUG
+	pr_info("enter %s buf level (new %d, display %d, recycle %d)\r\n",
+		__func__,
+		kfifo_len(&newframe_q),
+		kfifo_len(&display_q),
+		kfifo_len(&recycle_q)
+		);
+#endif
+	mutex_lock(&vavs_mutex);
+	long_cabac_busy = 1;
+	while (READ_VREG(LONG_CABAC_REQ)) {
+		if (process_long_cabac() < 0) {
+			status = -1;
+			break;
+		}
+	}
+	long_cabac_busy = 0;
+	mutex_unlock(&vavs_mutex);
+#ifdef PERFORMANCE_DEBUG
+	pr_info("exit %s buf level (new %d, display %d, recycle %d)\r\n",
+		__func__,
+		kfifo_len(&newframe_q),
+		kfifo_len(&display_q),
+		kfifo_len(&recycle_q)
+		);
+#endif
+	if (status < 0) {
+		pr_info("transcoding error, local reset\r\n");
+		vavs_local_reset();
+	}
+
+}
+#endif
+
+#ifdef AVSP_LONG_CABAC
+static void init_avsp_long_cabac_buf(void)
+{
+#if 0
+	es_write_addr_phy = (unsigned long)codec_mm_alloc_for_dma(
+		"vavs",
+		PAGE_ALIGN(MAX_CODED_FRAME_SIZE)/PAGE_SIZE,
+		0, CODEC_MM_FLAGS_DMA_CPU);
+	es_write_addr_virt = codec_mm_phys_to_virt(es_write_addr_phy);
+
+#elif 0
+	es_write_addr_virt =
+		(void *)dma_alloc_coherent(amports_get_dma_device(),
+		 MAX_CODED_FRAME_SIZE, &es_write_addr_phy,
+		GFP_KERNEL);
+#else
+	/*es_write_addr_virt = kmalloc(MAX_CODED_FRAME_SIZE, GFP_KERNEL);
+		es_write_addr_virt = (void *)__get_free_pages(GFP_KERNEL,
+		get_order(MAX_CODED_FRAME_SIZE));
+	*/
+	es_write_addr_virt = &es_write_addr[0];
+	if (es_write_addr_virt == NULL) {
+		pr_err("%s: failed to alloc es_write_addr_virt buffer\n",
+			__func__);
+		return;
+	}
+
+	es_write_addr_phy = dma_map_single(amports_get_dma_device(),
+			es_write_addr_virt,
+			MAX_CODED_FRAME_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(amports_get_dma_device(),
+			es_write_addr_phy)) {
+		pr_err("%s: failed to map es_write_addr_virt buffer\n",
+			__func__);
+		/*kfree(es_write_addr_virt);*/
+		es_write_addr_virt = NULL;
+		return;
+	}
+#endif
+
+
+#ifdef BITSTREAM_READ_TMP_NO_CACHE
+	bitstream_read_tmp =
+		(void *)dma_alloc_coherent(amports_get_dma_device(),
+			SVA_STREAM_BUF_SIZE, &bitstream_read_tmp_phy,
+			 GFP_KERNEL);
+
+#else
+
+	bitstream_read_tmp = kmalloc(SVA_STREAM_BUF_SIZE, GFP_KERNEL);
+		/*bitstream_read_tmp = (void *)__get_free_pages(GFP_KERNEL,
+		get_order(MAX_CODED_FRAME_SIZE));
+		*/
+	if (bitstream_read_tmp == NULL) {
+		pr_err("%s: failed to alloc bitstream_read_tmp buffer\n",
+			__func__);
+		return;
+	}
+
+	bitstream_read_tmp_phy = dma_map_single(amports_get_dma_device(),
+			bitstream_read_tmp,
+			SVA_STREAM_BUF_SIZE, DMA_FROM_DEVICE);
+	if (dma_mapping_error(amports_get_dma_device(),
+			bitstream_read_tmp_phy)) {
+		pr_err("%s: failed to map rpm buffer\n", __func__);
+		kfree(bitstream_read_tmp);
+		bitstream_read_tmp = NULL;
+		return;
+	}
+#endif
+}
+#endif
+
+
 static s32 vavs_init(void)
 {
 	pr_info("vavs_init\n");
@@ -799,17 +1234,52 @@ static s32 vavs_init(void)
 
 	vavs_local_init();
 
-	if (debug_flag & 2) {
-		if (amvdec_loadmc_ex(VFORMAT_AVS, "vavs_mc_debug", NULL) < 0) {
-			amvdec_disable();
-			pr_info("failed\n");
-			return -EBUSY;
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		if (debug_flag & 2) {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"txl_vavs_mc_debug", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+		} else {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"txl_vavs_mc", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
 		}
 	} else {
-		if (amvdec_loadmc_ex(VFORMAT_AVS, "vavs_mc", NULL) < 0) {
-			amvdec_disable();
-			pr_info("failed\n");
-			return -EBUSY;
+#ifdef AVSP_LONG_CABAC
+		if (firmware_sel == 0)
+			init_avsp_long_cabac_buf();
+#endif
+		if (debug_flag & AVS_DEBUG_UCODE) {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"vavs_mc_debug", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+			pr_info("debug ucode loaded\r\n");
+		} else if (firmware_sel == 1) {
+			/* old ucode */
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"vavs_mc_old", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+			pr_info("old ucode loaded\r\n");
+		} else {
+			if (amvdec_loadmc_ex(VFORMAT_AVS,
+				"vavs_mc", NULL) < 0) {
+				amvdec_disable();
+				pr_info("failed\n");
+				return -EBUSY;
+			}
+			pr_info("ucode loaded\r\n");
 		}
 	}
 
@@ -852,6 +1322,11 @@ static s32 vavs_init(void)
 
 	stat |= STAT_TIMER_ARM;
 
+#ifdef AVSP_LONG_CABAC
+	if (firmware_sel == 0)
+		INIT_WORK(&long_cabac_wd_work, long_cabac_do_work);
+#endif
+
 	amvdec_start();
 
 	stat |= STAT_VDEC_RUN;
@@ -870,9 +1345,33 @@ static int amvdec_avs_probe(struct platform_device *pdev)
 		pr_info("amvdec_avs memory resource undefined.\n");
 		return -EFAULT;
 	}
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		firmware_sel = 1;
+	}
+
+	if (firmware_sel == 1) {
+		vf_buf_num = 4;
+		canvas_base = 0;
+		canvas_num = 3;
+	} else {
+		/*if(vf_buf_num <= 4)
+			canvas_base = 0;
+		else */
+		canvas_base = 128;
+		canvas_num = 2; /*NV21*/
+	}
 
+#ifdef AVSP_LONG_CABAC
+	buf_start = pdata->mem_start;
+	buf_size = pdata->mem_end - pdata->mem_start + 1
+		- (MAX_CODED_FRAME_SIZE * 2)
+		- LOCAL_HEAP_SIZE;
+	avsp_heap_adr = codec_mm_phys_to_virt(
+		pdata->mem_start + buf_size);
+#else
 	buf_start = pdata->mem_start;
 	buf_size = pdata->mem_end - pdata->mem_start + 1;
+#endif
 
 	if (buf_start > ORI_BUFFER_START_ADDR)
 		buf_offset = buf_start - ORI_BUFFER_START_ADDR;
@@ -909,7 +1408,42 @@ static int amvdec_avs_remove(struct platform_device *pdev)
 		del_timer_sync(&recycle_timer);
 		stat &= ~STAT_TIMER_ARM;
 	}
+#ifdef AVSP_LONG_CABAC
+	if (firmware_sel == 0) {
+		mutex_lock(&vavs_mutex);
+		cancel_work_sync(&long_cabac_wd_work);
+		mutex_unlock(&vavs_mutex);
 
+		if (es_write_addr_virt) {
+#if 0
+			codec_mm_free_for_dma("vavs", es_write_addr_phy);
+#else
+			dma_unmap_single(amports_get_dma_device(),
+				es_write_addr_phy,
+				MAX_CODED_FRAME_SIZE, DMA_FROM_DEVICE);
+			/*kfree(es_write_addr_virt);*/
+			es_write_addr_virt = NULL;
+#endif
+		}
+
+#ifdef BITSTREAM_READ_TMP_NO_CACHE
+		if (bitstream_read_tmp) {
+			dma_free_coherent(amports_get_dma_device(),
+				SVA_STREAM_BUF_SIZE, bitstream_read_tmp,
+				bitstream_read_tmp_phy);
+			bitstream_read_tmp = NULL;
+		}
+#else
+		if (bitstream_read_tmp) {
+			dma_unmap_single(amports_get_dma_device(),
+				bitstream_read_tmp_phy,
+				SVA_STREAM_BUF_SIZE, DMA_FROM_DEVICE);
+			kfree(bitstream_read_tmp);
+			bitstream_read_tmp = NULL;
+		}
+#endif
+	}
+#endif
 	if (stat & STAT_VF_HOOK) {
 		vf_notify_receiver(PROVIDER_NAME,
 				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
@@ -948,7 +1482,7 @@ static struct codec_profile_t amvdec_avs_profile = {
 
 static int __init amvdec_avs_driver_init_module(void)
 {
-	pr_info("amvdec_avs module init\n");
+	pr_debug("amvdec_avs module init\n");
 
 	if (platform_driver_register(&amvdec_avs_driver)) {
 		pr_info("failed to register amvdec_avs driver\n");
@@ -965,7 +1499,7 @@ static int __init amvdec_avs_driver_init_module(void)
 
 static void __exit amvdec_avs_driver_remove_module(void)
 {
-	pr_info("amvdec_avs module remove.\n");
+	pr_debug("amvdec_avs module remove.\n");
 
 	platform_driver_unregister(&amvdec_avs_driver);
 }
@@ -975,18 +1509,54 @@ static void __exit amvdec_avs_driver_remove_module(void)
 module_param(stat, uint, 0664);
 MODULE_PARM_DESC(stat, "\n amvdec_avs stat\n");
 
+/******************************************
 module_param(run_flag, uint, 0664);
 MODULE_PARM_DESC(run_flag, "\n run_flag\n");
 
 module_param(step_flag, uint, 0664);
 MODULE_PARM_DESC(step_flag, "\n step_flag\n");
+*******************************************/
 
 module_param(debug_flag, uint, 0664);
 MODULE_PARM_DESC(debug_flag, "\n debug_flag\n");
 
+module_param(error_recovery_mode, uint, 0664);
+MODULE_PARM_DESC(error_recovery_mode, "\n error_recovery_mode\n");
+
+/******************************************
+module_param(error_watchdog_threshold, uint, 0664);
+MODULE_PARM_DESC(error_watchdog_threshold, "\n error_watchdog_threshold\n");
+
+module_param(error_watchdog_buf_threshold, uint, 0664);
+MODULE_PARM_DESC(error_watchdog_buf_threshold,
+			"\n error_watchdog_buf_threshold\n");
+*******************************************/
+
 module_param(pic_type, uint, 0444);
 MODULE_PARM_DESC(pic_type, "\n amdec_vas picture type\n");
 
+module_param(radr, uint, 0664);
+MODULE_PARM_DESC(radr, "\nradr\n");
+
+module_param(rval, uint, 0664);
+MODULE_PARM_DESC(rval, "\nrval\n");
+
+module_param(vf_buf_num, uint, 0664);
+MODULE_PARM_DESC(vf_buf_num, "\nvf_buf_num\n");
+
+module_param(vf_buf_num_used, uint, 0664);
+MODULE_PARM_DESC(vf_buf_num_used, "\nvf_buf_num_used\n");
+
+module_param(canvas_base, uint, 0664);
+MODULE_PARM_DESC(canvas_base, "\ncanvas_base\n");
+
+module_param(work_buf_size, uint, 0664);
+MODULE_PARM_DESC(work_buf_size, "\nwork_buf_size\n");
+
+module_param(firmware_sel, uint, 0664);
+MODULE_PARM_DESC(firmware_sel, "\firmware_sel\n");
+
+
 module_init(amvdec_avs_driver_init_module);
 module_exit(amvdec_avs_driver_remove_module);
 
diff --git a/drivers/amlogic/amports/vh264mvc.c b/drivers/amlogic/amports/vh264mvc.c
index a8572c7..098ce1d 100644
--- a/drivers/amlogic/amports/vh264mvc.c
+++ b/drivers/amlogic/amports/vh264mvc.c
@@ -417,7 +417,7 @@ static struct vframe_s *vh264mvc_vf_get(void *op_arg)
 				spec2canvas(&buffer_spec1[view1_buf_id]);
 		} else {
 			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_MVC;
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+
 			vf->left_eye.start_x = 0;
 			vf->left_eye.start_y = 0;
 			vf->left_eye.width = vf->width;
@@ -427,12 +427,8 @@ static struct vframe_s *vh264mvc_vf_get(void *op_arg)
 			vf->right_eye.width = vf->width;
 			vf->right_eye.height = vf->height;
 			vf->trans_fmt = TVIN_TFMT_3D_TB;
-#endif
 
 			if (view_mode == 2) {
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-				/* vf->trans_fmt = TVIN_TFMT_3D_LRH_OLER; */
-#endif
 				vf->canvas0Addr =
 					spec2canvas(&buffer_spec1[
 							view1_buf_id]);
@@ -440,9 +436,6 @@ static struct vframe_s *vh264mvc_vf_get(void *op_arg)
 					spec2canvas(&buffer_spec0[
 							view0_buf_id]);
 			} else {
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-				/* vf->trans_fmt = TVIN_TFMT_3D_LRH_ELOR */
-#endif
 				vf->canvas0Addr =
 					spec2canvas(&buffer_spec0[
 							view0_buf_id]);
@@ -452,7 +445,7 @@ static struct vframe_s *vh264mvc_vf_get(void *op_arg)
 			}
 		}
 	}
-
+	vf->type_original = vf->type;
 	if (((vfpool_idx[get_ptr].view0_drop != 0)
 		 || (vfpool_idx[get_ptr].view1_drop != 0))
 		&& ((no_dropping_cnt >= DROPPING_FIRST_WAIT)))
@@ -1555,10 +1548,10 @@ static struct codec_profile_t amvdec_hmvc_profile = {
 
 static int __init amvdec_h264mvc_driver_init_module(void)
 {
-	pr_info("amvdec_h264mvc module init\n");
+	pr_debug("amvdec_h264mvc module init\n");
 
 	if (platform_driver_register(&amvdec_h264mvc_driver)) {
-		pr_info("failed to register amvdec_h264mvc driver\n");
+		pr_err("failed to register amvdec_h264mvc driver\n");
 		return -ENODEV;
 	}
 
@@ -1569,7 +1562,7 @@ static int __init amvdec_h264mvc_driver_init_module(void)
 
 static void __exit amvdec_h264mvc_driver_remove_module(void)
 {
-	pr_info("amvdec_h264mvc module remove.\n");
+	pr_debug("amvdec_h264mvc module remove.\n");
 
 	platform_driver_unregister(&amvdec_h264mvc_driver);
 }
diff --git a/drivers/amlogic/amports/video.h b/drivers/amlogic/amports/video.h
index 78bbbff..e7cd7cf 100644
--- a/drivers/amlogic/amports/video.h
+++ b/drivers/amlogic/amports/video.h
@@ -37,7 +37,7 @@ enum {
 	VIDEO_WIDEOPTION_MAX = 14
 };
 
-
+extern bool pre_scaler_en;
 #define VIDEO_NOTIFY_TRICK_WAIT   0x01
 #define VIDEO_NOTIFY_PROVIDER_GET 0x02
 #define VIDEO_NOTIFY_PROVIDER_PUT 0x04
@@ -166,6 +166,10 @@ enum {
 #define VPP_PHASECTL_INIRPTNUMT_BIT 5
 #define VPP_PHASECTL_INIRCVNUMT_BIT 0
 
+#define VPP_LINE_BUFFER_EN_BIT          21
+#define VPP_SC_PREHORZ_EN_BIT           20
+#define VPP_SC_PREVERT_EN_BIT           19
+#define VPP_LINE_BUFFER_EN          (1 << 21)
 #define VPP_SC_PREHORZ_EN           (1 << 20)
 #define VPP_SC_PREVERT_EN           (1 << 19)
 #define VPP_SC_VERT_EN              (1 << 18)
@@ -173,6 +177,8 @@ enum {
 #define VPP_SC_TOP_EN               (1 << 16)
 #define VPP_SC_V1OUT_EN             (1 << 15)
 #define VPP_SC_RGN14_HNOLINEAR      (1 << 12)
+#define VPP_SC_TOP_EN_WID	    1
+#define VPP_SC_TOP_EN_BIT	    16
 #define VPP_SC_BANK_LENGTH_WID      3
 #define VPP_SC_BANK_LENGTH_MASK     0x7
 #define VPP_SC_HBANK_LENGTH_BIT     8
@@ -206,9 +212,11 @@ enum {
 
 #define VPP_COEF_IDXINC         (1 << 15)
 #define VPP_COEF_RD_CBUS        (1 << 14)
+#define VPP_COEF_SEP_EN	        (1 << 13)
 #define VPP_COEF_9BIT           (1 << 9)
 #define VPP_COEF_TYPE           (1 << 8)
 #define VPP_COEF_VERT           (0 << 8)
+#define VPP_COEF_VERT_CHROMA    (1 << 7)
 #define VPP_COEF_HORZ           (1 << 8)
 #define VPP_COEF_INDEX_MASK     0x7f
 #define VPP_COEF_INDEX_BIT      0
diff --git a/drivers/amlogic/amports/vmjpeg.c b/drivers/amlogic/amports/vmjpeg.c
index 9158c9e..83b833d 100644
--- a/drivers/amlogic/amports/vmjpeg.c
+++ b/drivers/amlogic/amports/vmjpeg.c
@@ -187,7 +187,7 @@ static irqreturn_t vmjpeg_isr(int irq, void *dev_id)
 			}
 
 			set_frame_info(vf);
-
+			vf->signal_type = 0;
 			vf->index = index;
 #ifdef NV21
 			vf->type =
@@ -201,6 +201,7 @@ static irqreturn_t vmjpeg_isr(int irq, void *dev_id)
 			vf->pts = (pts_valid) ? pts : 0;
 			vf->pts_us64 = (pts_valid) ? pts_us64 : 0;
 			vf->orientation = 0;
+			vf->type_original = vf->type;
 			vfbuf_use[index]++;
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
@@ -224,7 +225,7 @@ static irqreturn_t vmjpeg_isr(int irq, void *dev_id)
 			}
 
 			set_frame_info(vf);
-
+			vf->signal_type = 0;
 			vf->index = index;
 #if 0
 			if (reg & PICINFO_AVI1) {
@@ -278,7 +279,7 @@ static irqreturn_t vmjpeg_isr(int irq, void *dev_id)
 				vf->pts = 0;
 				vf->pts_us64 = 0;
 			}
-
+			vf->type_original = vf->type;
 			vfbuf_use[index]++;
 
 			kfifo_put(&display_q, (const struct vframe_s *)vf);
@@ -363,10 +364,11 @@ static void vmjpeg_put_timer_func(unsigned long arg)
 			(READ_VREG(MREG_TO_AMRISC) == 0)) {
 		struct vframe_s *vf;
 		if (kfifo_get(&recycle_q, &vf)) {
-			if ((vf->index >= 0) &&
-				(--vfbuf_use[vf->index] == 0)) {
+			if ((vf->index >= 0)
+				&& (vf->index < DECODE_BUFFER_NUM_MAX)
+				&& (--vfbuf_use[vf->index] == 0)) {
 				WRITE_VREG(MREG_TO_AMRISC, vf->index + 1);
-				vf->index = -1;
+				vf->index = DECODE_BUFFER_NUM_MAX;
 			}
 
 			kfifo_put(&newframe_q, (const struct vframe_s *)vf);
@@ -703,7 +705,7 @@ static void vmjpeg_local_init(void)
 
 	for (i = 0; i < VF_POOL_SIZE; i++) {
 		const struct vframe_s *vf = &vfpool[i];
-		vfpool[i].index = -1;
+		vfpool[i].index = DECODE_BUFFER_NUM_MAX;
 		kfifo_put(&newframe_q, vf);
 	}
 }
diff --git a/drivers/amlogic/amports/vmpeg12.c b/drivers/amlogic/amports/vmpeg12.c
index 835194c..8296e01 100644
--- a/drivers/amlogic/amports/vmpeg12.c
+++ b/drivers/amlogic/amports/vmpeg12.c
@@ -199,13 +199,23 @@ static inline u32 index2canvas(u32 index)
 static void set_frame_info(struct vframe_s *vf)
 {
 	unsigned ar_bits;
+	u32 temp;
 
 #ifdef CONFIG_AM_VDEC_MPEG12_LOG
 	bool first = (frame_width == 0) && (frame_height == 0);
 #endif
+	temp = READ_VREG(MREG_PIC_WIDTH);
+	if (temp > 1920)
+		vf->width = frame_width = 1920;
+	else
+		vf->width = frame_width = temp;
+
+	temp = READ_VREG(MREG_PIC_HEIGHT);
+	if (temp > 1088)
+		vf->height = frame_height = 1088;
+	else
+		vf->height = frame_height = temp;
 
-	vf->width = frame_width = READ_VREG(MREG_PIC_WIDTH);
-	vf->height = frame_height = READ_VREG(MREG_PIC_HEIGHT);
 	vf->flag = 0;
 
 	if (frame_dur > 0)
@@ -303,7 +313,8 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 
 		if ((dec_control &
 			 DEC_CONTROL_FLAG_FORCE_2500_720_576_INTERLACE)
-			&& (frame_width == 720) && (frame_height == 576)
+			&& (frame_width == 720 || frame_width == 480)
+			&& (frame_height == 576)
 			&& (frame_dur == 3840))
 			frame_prog = 0;
 		else if ((dec_control &
@@ -328,7 +339,6 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 			frame_prog = 0;
 		else if (dec_control & DEC_CONTROL_FLAG_FORCE_SEQ_INTERLACE)
 			frame_prog = 0;
-
 		if (frame_prog & PICINFO_PROG) {
 			u32 index = ((reg & 0xf) - 1) & 7;
 
@@ -341,7 +351,7 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 			}
 
 			set_frame_info(vf);
-
+			vf->signal_type = 0;
 			vf->index = index;
 #ifdef NV21
 			vf->type =
@@ -378,6 +388,7 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 			vf->orientation = 0;
 			vf->pts = (pts_valid) ? pts : 0;
 			vf->pts_us64 = (pts_valid) ? pts_us64 : 0;
+			vf->type_original = vf->type;
 
 			vfbuf_use[index] = 1;
 
@@ -433,7 +444,7 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 			vfbuf_use[index] = 2;
 
 			set_frame_info(vf);
-
+			vf->signal_type = 0;
 			vf->index = index;
 			vf->type =
 				(first_field_type == VIDTYPE_INTERLACE_TOP) ?
@@ -451,6 +462,7 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 						index2canvas(index);
 			vf->pts = (pts_valid) ? pts : 0;
 			vf->pts_us64 = (pts_valid) ? pts_us64 : 0;
+			vf->type_original = vf->type;
 
 			if ((error_skip(info, vf)) ||
 				((first_i_frame_ready == 0)
@@ -473,7 +485,7 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 			}
 
 			set_frame_info(vf);
-
+			vf->signal_type = 0;
 			vf->index = index;
 			vf->type = (first_field_type ==
 				VIDTYPE_INTERLACE_TOP) ?
@@ -491,6 +503,7 @@ static irqreturn_t vmpeg12_isr(int irq, void *dev_id)
 					index2canvas(index);
 			vf->pts = 0;
 			vf->pts_us64 = 0;
+			vf->type_original = vf->type;
 
 			if ((error_skip(info, vf)) ||
 				((first_i_frame_ready == 0)
@@ -788,6 +801,21 @@ static void vmpeg12_prot_init(void)
 		WRITE_VREG(DOS_SW_RESET0, 0);
 
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
+
+			READ_VREG(DOS_SW_RESET0);
+			READ_VREG(DOS_SW_RESET0);
+			READ_VREG(DOS_SW_RESET0);
+
+			WRITE_VREG(DOS_SW_RESET0, (1<<7) | (1<<6) | (1<<4));
+			WRITE_VREG(DOS_SW_RESET0, 0);
+
+			WRITE_VREG(DOS_SW_RESET0, (1<<9) | (1<<8));
+			WRITE_VREG(DOS_SW_RESET0, 0);
+
+			READ_VREG(DOS_SW_RESET0);
+			READ_VREG(DOS_SW_RESET0);
+			READ_VREG(DOS_SW_RESET0);
+
 			WRITE_VREG(MDEC_SW_RESET, (1 << 7));
 			WRITE_VREG(MDEC_SW_RESET, 0);
 		}
diff --git a/drivers/amlogic/amports/vmpeg4.c b/drivers/amlogic/amports/vmpeg4.c
index 6c8f8ba..fa3535d 100644
--- a/drivers/amlogic/amports/vmpeg4.c
+++ b/drivers/amlogic/amports/vmpeg4.c
@@ -306,9 +306,10 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 				   READ_VREG(MP4_PIC_WH) & 0xffff);
 		}
 #endif
-		if (vmpeg4_amstream_dec_info.rate == 0) {
+		if (vmpeg4_amstream_dec_info.rate == 0
+		|| vmpeg4_amstream_dec_info.rate > 96000) {
 			/* if ((rate >> 16) != 0) { */
-			if ((rate & 0xffff) != 0) {
+			if ((rate & 0xffff) != 0 && (rate >> 16) != 0) {
 				vmpeg4_amstream_dec_info.rate =
 					(rate >> 16) * DURATION_UNIT /
 					(rate & 0xffff);
@@ -435,7 +436,7 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 				("fatal error, no available buffer slot.");
 				return IRQ_HANDLED;
 			}
-
+			vf->signal_type = 0;
 			vf->index = buffer_index;
 			vf->width = vmpeg4_amstream_dec_info.width;
 			vf->height = vmpeg4_amstream_dec_info.height;
@@ -454,6 +455,7 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 #endif
 			vf->canvas0Addr = vf->canvas1Addr =
 				index2canvas(buffer_index);
+			vf->type_original = vf->type;
 
 			set_aspect_ratio(vf, READ_VREG(MP4_PIC_RATIO));
 
@@ -470,7 +472,7 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 				"fatal error, no available buffer slot.");
 				return IRQ_HANDLED;
 			}
-
+			vf->signal_type = 0;
 			vf->index = buffer_index;
 			vf->width = vmpeg4_amstream_dec_info.width;
 			vf->height = vmpeg4_amstream_dec_info.height;
@@ -490,6 +492,7 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 #endif
 			vf->canvas0Addr = vf->canvas1Addr =
 					index2canvas(buffer_index);
+			vf->type_original = vf->type;
 
 			set_aspect_ratio(vf, READ_VREG(MP4_PIC_RATIO));
 
@@ -512,7 +515,7 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 				("fatal error, no available buffer slot.");
 				return IRQ_HANDLED;
 			}
-
+			vf->signal_type = 0;
 			vf->index = buffer_index;
 			vf->width = vmpeg4_amstream_dec_info.width;
 			vf->height = vmpeg4_amstream_dec_info.height;
@@ -532,6 +535,7 @@ static irqreturn_t vmpeg4_isr(int irq, void *dev_id)
 #endif
 			vf->canvas0Addr = vf->canvas1Addr =
 					index2canvas(buffer_index);
+			vf->type_original = vf->type;
 
 			set_aspect_ratio(vf, READ_VREG(MP4_PIC_RATIO));
 
@@ -628,11 +632,12 @@ static void vmpeg_put_timer_func(unsigned long arg)
 	while (!kfifo_is_empty(&recycle_q) && (READ_VREG(MREG_BUFFERIN) == 0)) {
 		struct vframe_s *vf;
 		if (kfifo_get(&recycle_q, &vf)) {
-			if ((vf->index >= 0) && (--vfbuf_use[vf->index] == 0)) {
+			if ((vf->index >= 0)
+				&& (vf->index < DECODE_BUFFER_NUM_MAX)
+				&& (--vfbuf_use[vf->index] == 0)) {
 				WRITE_VREG(MREG_BUFFERIN, ~(1 << vf->index));
-				vf->index = -1;
-			}
-
+				vf->index = DECODE_BUFFER_NUM_MAX;
+		     }
 			kfifo_put(&newframe_q, (const struct vframe_s *)vf);
 		}
 	}
@@ -643,6 +648,23 @@ static void vmpeg_put_timer_func(unsigned long arg)
 		vdec_source_changed(VFORMAT_MPEG4,
 			frame_width, frame_height, fps);
 	}
+	if (READ_VREG(AV_SCRATCH_L)) {
+		unsigned long flags;
+		pr_info("mpeg4 fatal error happened,need reset    !!\n");
+		amvdec_stop();
+#ifndef CONFIG_POST_PROCESS_MANAGER
+		vf_light_unreg_provider(&vmpeg_vf_prov);
+#endif
+		spin_lock_irqsave(&lock, flags);
+		vmpeg4_local_init();
+		vmpeg4_prot_init();
+		spin_unlock_irqrestore(&lock, flags);
+#ifndef CONFIG_POST_PROCESS_MANAGER
+		vf_reg_provider(&vmpeg_vf_prov);
+#endif
+		amvdec_start();
+	}
+
 
 	timer->expires = jiffies + PUT_INTERVAL;
 
@@ -670,6 +692,7 @@ static void vmpeg4_canvas_init(void)
 	u32 canvas_width, canvas_height;
 	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
 	u32 disp_addr = 0xffffffff;
+	u32 buff_off = 0;
 
 	if (buf_size <= 0x00400000) {
 		/* SD only */
@@ -679,18 +702,40 @@ static void vmpeg4_canvas_init(void)
 		decbuf_uv_size = 0x20000;
 		decbuf_size = 0x100000;
 	} else {
-		/* HD & SD */
-		if (vmpeg4_amstream_dec_info.height >
-			vmpeg4_amstream_dec_info.width) {
-			canvas_width = 1088;
-			canvas_height = 1920;
+		int w = vmpeg4_amstream_dec_info.width;
+		int h = vmpeg4_amstream_dec_info.height;
+		int align_w, align_h;
+		int max, min;
+		align_w = ALIGN(w, 64);
+		align_h = ALIGN(h, 64);
+		if (align_w > align_h) {
+			max = align_w;
+			min = align_h;
 		} else {
-			canvas_width = 1920;
-			canvas_height = 1088;
+			max = align_h;
+			min = align_w;
+		}
+		/* HD & SD */
+		if ((max > 1920 || min > 1088) &&
+			ALIGN(align_w * align_h * 3/2, SZ_64K) * 9 <=
+			buf_size) {
+			canvas_width = align_w;
+			canvas_height = align_h;
+			decbuf_y_size = ALIGN(align_w * align_h, SZ_64K);
+			decbuf_uv_size = ALIGN(align_w * align_h/4, SZ_64K);
+			decbuf_size = ALIGN(align_w * align_h * 3/2, SZ_64K);
+		} else { /*1080p*/
+			if (h > w) {
+				canvas_width = 1088;
+				canvas_height = 1920;
+			} else {
+				canvas_width = 1920;
+				canvas_height = 1088;
+			}
+			decbuf_y_size = 0x200000;
+			decbuf_uv_size = 0x80000;
+			decbuf_size = 0x300000;
 		}
-		decbuf_y_size = 0x200000;
-		decbuf_uv_size = 0x80000;
-		decbuf_size = 0x300000;
 	}
 
 	if (is_vpp_postblend()) {
@@ -702,61 +747,57 @@ static void vmpeg4_canvas_init(void)
 	}
 
 	for (i = 0; i < 8; i++) {
-		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
-#ifdef NV21
-			canvas_config(2 * i + 0,
-				buf_start + 8 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(2 * i + 1,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size, canvas_width,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-#else
-			canvas_config(3 * i + 0,
-				buf_start + 8 * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 1,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size, canvas_width / 2,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 2,
-				buf_start + 8 * decbuf_size +
-				decbuf_y_size + decbuf_uv_size,
-				canvas_width / 2, canvas_height / 2,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-#endif
-		} else {
+		u32 one_buf_start = buf_start + buff_off;
+		if (((one_buf_start + 7) >> 3) == disp_addr) {
+			/*last disp buffer, to next..*/
+			buff_off += decbuf_size;
+			one_buf_start = buf_start + buff_off;
+			pr_info("one_buf_start %d,=== %x disp_addr %x",
+				i, one_buf_start, disp_addr);
+		}
+		if (buff_off < 0x02000000 &&
+			buff_off + decbuf_size > 0x01b00000){
+			/*0x01b00000 is references buffer.
+			to next 32M;*/
+			buff_off = 32 * SZ_1M;/*next 32M*/
+			one_buf_start = buf_start + buff_off;
+		}
+		if (buff_off + decbuf_size > buf_size) {
+			pr_err("ERROR::too small buffer for buf%d %d x%d ,size =%d\n",
+				i,
+				canvas_width,
+				canvas_height,
+				buf_size);
+		}
+		pr_debug("alloced buffer %d at %x,%d\n",
+				i, one_buf_start, decbuf_size);
 #ifdef NV21
-			canvas_config(2 * i + 0,
-				buf_start + i * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(2 * i + 1,
-				buf_start + i * decbuf_size +
-				decbuf_y_size, canvas_width,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
+		canvas_config(2 * i + 0,
+			one_buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(2 * i + 1,
+			one_buf_start +
+			decbuf_y_size, canvas_width,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
 #else
-			canvas_config(3 * i + 0,
-				buf_start + i * decbuf_size,
-				canvas_width, canvas_height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 1,
-				buf_start + i * decbuf_size +
-				decbuf_y_size, canvas_width / 2,
-				canvas_height / 2, CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_32X32);
-			canvas_config(3 * i + 2,
-				buf_start + i * decbuf_size +
-				decbuf_y_size + decbuf_uv_size,
-				canvas_width / 2, canvas_height / 2,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 0,
+			one_buf_start,
+			canvas_width, canvas_height,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 1,
+			one_buf_start +
+			decbuf_y_size, canvas_width / 2,
+			canvas_height / 2, CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
+		canvas_config(3 * i + 2,
+			one_buf_start +
+			decbuf_y_size + decbuf_uv_size,
+			canvas_width / 2, canvas_height / 2,
+			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 #endif
-		}
+		buff_off = buff_off + decbuf_size;
 	}
 }
 
@@ -791,6 +832,7 @@ static void vmpeg4_prot_init(void)
 	WRITE_VREG(AV_SCRATCH_I, 0x141312);
 	WRITE_VREG(AV_SCRATCH_J, 0x171615);
 #endif
+	WRITE_VREG(AV_SCRATCH_L, 0);/*clearfatal error flag*/
 
 	/* notify ucode the buffer offset */
 	WRITE_VREG(AV_SCRATCH_F, buf_offset);
@@ -863,7 +905,7 @@ static void vmpeg4_local_init(void)
 
 	for (i = 0; i < VF_POOL_SIZE; i++) {
 		const struct vframe_s *vf = &vfpool[i];
-		vfpool[i].index = -1;
+		vfpool[i].index = DECODE_BUFFER_NUM_MAX;
 		kfifo_put(&newframe_q, (const struct vframe_s *)vf);
 	}
 }
diff --git a/drivers/amlogic/amports/vp9_mm.c b/drivers/amlogic/amports/vp9_mm.c
new file mode 100644
index 0000000..8cc0fee
--- /dev/null
+++ b/drivers/amlogic/amports/vp9_mm.c
@@ -0,0 +1,205 @@
+ /*
+ * drivers/amlogic/amports/vp9_mm.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/vformat.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+#include <linux/slab.h>
+#include "amports_priv.h"
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
+/*#define VP9_10B_MMU*/
+#include "vvp9.h"
+
+
+
+#ifdef VP9_10B_MMU
+  /* to change ... */
+#define MC_BUFFER_START_4K      (0)
+
+#if 0
+enum vpx_bit_depth {
+	VPX_BITS_8  =  8,  /**<  8 bits */
+	VPX_BITS_10 = 10,  /**< 10 bits */
+	VPX_BITS_12 = 12,  /**< 12 bits */
+};
+#endif
+#define REF_FRAMES_LOG2 3
+#define REF_FRAMES (1 << REF_FRAMES_LOG2)
+#define FRAME_BUFFERS (REF_FRAMES + 7)
+
+#define TOTAL_4K_NUM 0x8000
+/* compute_losless_comp_body_size(4096, 2304, 1) = 18874368(0x1200000)*/
+#define MAX_FRAME_4K_NUM 0x1200
+int mmu_offset_seed;
+int mmu_4k_status[TOTAL_4K_NUM];
+struct MMU_BUFF_CONFIG {
+	long mmu_4k_number;
+	unsigned int  mmu_4k_index[MAX_FRAME_4K_NUM];
+};
+
+struct MMU_BUFF_CONFIG mmu_buf[FRAME_BUFFERS];
+int mmu_pic_count;
+unsigned long cur_mem_usage;
+unsigned long max_mem_usage;
+
+void init_mmu_spec(void)
+{
+	int i, j;
+	for (i = 0; i < TOTAL_4K_NUM; i++)
+		mmu_4k_status[i] = 0;
+	for (i = 0; i < FRAME_BUFFERS; i++) {
+		mmu_buf[i].mmu_4k_number = 0;
+		for (j = 0; j < FRAME_BUFFERS; j++)
+			mmu_buf[i].mmu_4k_index[j] = 0;
+	};
+	mmu_offset_seed = 0;
+	cur_mem_usage = 0;
+	max_mem_usage = 0;
+	mmu_pic_count = -1;
+}
+
+void alloc_mmu(int cur_buf_idx, int pic_width, int pic_height,
+		unsigned short bit_depth, unsigned int *mmu_index_adr) {
+	/*int cur_buf_idx = cm->new_fb_idx;*/
+	int bit_depth_10 = (bit_depth == VPX_BITS_10);
+	int picture_size;
+	int cur_mmu_4k_number;
+	int prefer_4k_position;
+	int i;
+	pr_info
+	("MMU alloc new_fb_idx : %d (width: %d, height: %d, bit_depth: %d)\r\n",
+	cur_buf_idx, pic_width, pic_height, bit_depth);
+
+	picture_size =
+	compute_losless_comp_body_size(pic_width, pic_height, bit_depth_10);
+	cur_mmu_4k_number = ((picture_size+(1<<12)-1) >> 12);
+	pr_info("MMU allo picture_size : %d(0x%x) mmu_4k_number: %d(0x%x) \r\n",
+	picture_size, picture_size, cur_mmu_4k_number, cur_mmu_4k_number);
+
+	mmu_buf[cur_buf_idx].mmu_4k_number = cur_mmu_4k_number;
+	for (i = 0; i < cur_mmu_4k_number; i++) {
+		prefer_4k_position = (mmu_offset_seed & 0xff) +
+			(
+			((i & 0xf) << 11) |  /* bit[14:11]*/
+			(((i >> 4) & 0xf) << 7) |  /*bit[10:7]*/
+			(((i >> 8) & 0xf) << 3) |  /* bit[6:3]*/
+			(((i >> 12) & 0x7) << 0)    /* bit[2:0]*/
+			);
+		if ((prefer_4k_position >= TOTAL_4K_NUM)
+			| (mmu_4k_status[prefer_4k_position] != 0)) {
+			for (prefer_4k_position = 0;
+				prefer_4k_position < TOTAL_4K_NUM;
+				prefer_4k_position++) {
+				if (mmu_4k_status[prefer_4k_position] == 0)
+					break;
+				}
+			if (prefer_4k_position == TOTAL_4K_NUM)
+				pr_err
+				("ERROR : NOT Enough 4K MMU Memory !!!!\r\n");
+		}
+		mmu_4k_status[prefer_4k_position] = 1;
+		mmu_buf[cur_buf_idx].mmu_4k_index[i] =
+				MC_BUFFER_START_4K + prefer_4k_position;
+		pr_info("MMU alloc  mmu_4k_index[%d] : 0x%x\r\n", i,
+				mmu_buf[cur_buf_idx].mmu_4k_index[i]);
+	}
+
+	mmu_offset_seed++;
+	/*copyToDDR_32bits(FRAME_MMU_MAP_ADDR,
+		mmu_buf[cur_buf_idx].mmu_4k_index, cur_mmu_4k_number*4, 0);*/
+	for (i = 0; i < cur_mmu_4k_number; i++)
+		mmu_index_adr[i] = mmu_buf[cur_buf_idx].mmu_4k_index[i];
+
+	mmu_pic_count++;
+	cur_mem_usage += cur_mmu_4k_number*4096;
+	if (max_mem_usage < cur_mem_usage)
+		max_mem_usage = cur_mem_usage;
+	pr_info("MMU USAGE current : %ld, max : %ld (P%0d)\r\n",
+			cur_mem_usage, max_mem_usage, mmu_pic_count);
+
+}
+
+void release_unused_4k(long used_4k_num, int cur_buf_idx)
+{
+	long release_4k_position;
+	int i;
+	if (mmu_pic_count < 0)
+		return;
+
+	mmu_offset_seed = used_4k_num & 0xff;
+	if (used_4k_num > mmu_buf[cur_buf_idx].mmu_4k_number) {
+		pr_err
+		("MMU ERROR:Use more 4K Page than allocated %ld>([%d]=%ld)\r\n",
+		used_4k_num, cur_buf_idx, mmu_buf[cur_buf_idx].mmu_4k_number);
+	} else
+		pr_info
+		("MMU RELEASE: P%d(buffer%d)used %ld of %ld 4k buff(%ld%c)\r\n",
+		mmu_pic_count, cur_buf_idx, used_4k_num,
+		mmu_buf[cur_buf_idx].mmu_4k_number,
+		used_4k_num*100/mmu_buf[cur_buf_idx].mmu_4k_number, '%');
+
+	for (i = used_4k_num; i < mmu_buf[cur_buf_idx].mmu_4k_number; i++) {
+		release_4k_position =
+		mmu_buf[cur_buf_idx].mmu_4k_index[i] - MC_BUFFER_START_4K;
+		mmu_4k_status[release_4k_position] = 0;
+	}
+	cur_mem_usage -=
+		(mmu_buf[cur_buf_idx].mmu_4k_number - used_4k_num)*4096;
+	mmu_buf[cur_buf_idx].mmu_4k_number = used_4k_num;
+
+}
+
+void release_buffer_4k(int cur_buf_idx)
+{
+	/*long used_4k_num;*/
+	long release_4k_position;
+	int i;
+
+	if (mmu_buf[cur_buf_idx].mmu_4k_number == 0)
+		return;
+	pr_info("[MMU MEM RECYCLE] : buffer %d (%ld 4K Buffer)\r\n",
+		cur_buf_idx, mmu_buf[cur_buf_idx].mmu_4k_number);
+
+	for (i = 0; i < mmu_buf[cur_buf_idx].mmu_4k_number; i++) {
+		release_4k_position = mmu_buf[cur_buf_idx].mmu_4k_index[i]
+			- MC_BUFFER_START_4K;
+		mmu_4k_status[release_4k_position] = 0;
+	}
+	cur_mem_usage -= mmu_buf[cur_buf_idx].mmu_4k_number * 4096;
+	mmu_buf[cur_buf_idx].mmu_4k_number = 0;
+
+}
+
+#endif
diff --git a/drivers/amlogic/amports/vpp.c b/drivers/amlogic/amports/vpp.c
index 60b6288c..f6a4514 100644
--- a/drivers/amlogic/amports/vpp.c
+++ b/drivers/amlogic/amports/vpp.c
@@ -32,9 +32,6 @@
 #include <linux/amlogic/gpio-amlogic.h>
 
 #include <linux/amlogic/iomap.h>
-#ifdef CONFIG_AM_DEINTERLACE
-#include "deinterlace.h"
-#endif
 
 #include "videolog.h"
 /* #define CONFIG_VIDEO_LOG */
@@ -46,24 +43,24 @@
 #include "arch/register.h"
 #include "amports_priv.h"
 
-
 /* vpp filter coefficients */
 #define COEF_BICUBIC         0
 #define COEF_3POINT_TRIANGLE 1
 #define COEF_4POINT_TRIANGLE 2
 #define COEF_BILINEAR        3
-#if 1	/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 #define COEF_2POINT_BILINEAR 4
-#endif
+#define COEF_BICUBIC_SHARP   5
+#define COEF_3POINT_TRIANGLE_SHARP   6
+#define COEF_3POINT_BSPLINE  7
+#define COEF_4POINT_BSPLINE  8
+#define COEF_3D_FILTER       9
+#define COEF_NULL            0xff
+#define TOTAL_FILTERS        10
 
 #define MAX_NONLINEAR_FACTOR    0x40
 
-#if 1	/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 #define VPP_SPEED_FACTOR 0x110ULL
-#endif
-#ifdef TV_REVERSE
-/*extern bool reverse;*/
-#endif
+#define SUPER_SCALER_V_FACTOR  100
 
 const u32 vpp_filter_coefs_bicubic_sharp[] = {
 	3,
@@ -136,6 +133,7 @@ const u32 vpp_filter_coefs_3point_triangle[] = {
 	0x1a4c1a00
 };
 
+/* point_num =4, filt_len =4, group_num = 64, [1 2 1] */
 const u32 vpp_filter_coefs_4point_triangle[] = {
 	4,
 	33,
@@ -149,8 +147,51 @@ const u32 vpp_filter_coefs_4point_triangle[] = {
 	0x12322e0e, 0x12322e0e, 0x11312f0f, 0x11312f0f,
 	0x10303010
 };
+/*4th order (cubic) b-spline
+filt_cubic point_num =4, filt_len =4, group_num = 64, [1 5 1] */
+const u32 vpp_filter_coefs_4point_bspline[] = {
+	4,
+	33,
+	0x15561500, 0x14561600, 0x13561700, 0x12561800,
+	0x11551a00, 0x11541b00, 0x10541c00, 0x0f541d00,
+	0x0f531e00, 0x0e531f00, 0x0d522100, 0x0c522200,
+	0x0b522300, 0x0b512400, 0x0a502600, 0x0a4f2700,
+	0x094e2900, 0x084e2a00, 0x084d2b00, 0x074c2c01,
+	0x074b2d01, 0x064a2f01, 0x06493001, 0x05483201,
+	0x05473301, 0x05463401, 0x04453601, 0x04433702,
+	0x04423802, 0x03413a02, 0x03403b02, 0x033f3c02,
+	0x033d3d03
+};
+/*3rd order (quadratic) b-spline
+filt_quadratic, point_num =3, filt_len =3, group_num = 64, [1 6 1] */
+const u32 vpp_filter_coefs_3point_bspline[] = {
+	3,
+	33,
+	0x40400000, 0x3e420000, 0x3c440000, 0x3a460000,
+	0x38480000, 0x364a0000, 0x344b0100, 0x334c0100,
+	0x314e0100, 0x304f0100, 0x2e500200, 0x2c520200,
+	0x2a540200, 0x29540300, 0x27560300, 0x26570300,
+	0x24580400, 0x23590400, 0x215a0500, 0x205b0500,
+	0x1e5c0600, 0x1d5c0700, 0x1c5d0700, 0x1a5e0800,
+	0x195e0900, 0x185e0a00, 0x175f0a00, 0x15600b00,
+	0x14600c00, 0x13600d00, 0x12600e00, 0x11600f00,
+	0x10601000
+};
+/*filt_triangle, point_num =3, filt_len =2.6, group_num = 64, [1 7 1] */
+const u32 vpp_filter_coefs_3point_triangle_sharp[] = {
+	3,
+	33,
+	0x40400000, 0x3e420000, 0x3d430000, 0x3b450000,
+	0x3a460000, 0x38480000, 0x37490000, 0x354b0000,
+	0x344c0000, 0x324e0000, 0x314f0000, 0x2f510000,
+	0x2e520000, 0x2c540000, 0x2b550000, 0x29570000,
+	0x28580000, 0x265a0000, 0x245c0000, 0x235d0000,
+	0x215f0000, 0x20600000, 0x1e620000, 0x1d620100,
+	0x1b620300, 0x19630400, 0x17630600, 0x15640700,
+	0x14640800, 0x12640a00, 0x11640b00, 0x0f650c00,
+	0x0d660d00
+};
 
-#if 1	/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 const u32 vpp_filter_coefs_2point_binilear[] = {
 	2,
 	33,
@@ -164,18 +205,158 @@ const u32 vpp_filter_coefs_2point_binilear[] = {
 	0x48380000, 0x463a0000, 0x443c0000, 0x423e0000,
 	0x40400000
 };
-#endif
 
 static const u32 *filter_table[] = {
 	vpp_filter_coefs_bicubic,
 	vpp_filter_coefs_3point_triangle,
 	vpp_filter_coefs_4point_triangle,
 	vpp_filter_coefs_bilinear,
-#if 1	/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
-	vpp_filter_coefs_2point_binilear
-#endif
+	vpp_filter_coefs_2point_binilear,
+	vpp_filter_coefs_bicubic_sharp,
+	vpp_filter_coefs_3point_triangle_sharp,
+	vpp_filter_coefs_3point_bspline,
+	vpp_filter_coefs_4point_bspline,
+	vpp_3d_filter_coefs_bilinear
+};
+
+static int chroma_filter_table[] = {
+	COEF_4POINT_TRIANGLE, /* bicubic */
+	COEF_3POINT_TRIANGLE,
+	COEF_4POINT_TRIANGLE,
+	COEF_4POINT_TRIANGLE, /* bilinear */
+	COEF_2POINT_BILINEAR,
+	COEF_3POINT_TRIANGLE, /* bicubic_sharp */
+	COEF_3POINT_TRIANGLE, /* 3point_triangle_sharp */
+	COEF_3POINT_TRIANGLE, /* 3point_bspline */
+	COEF_4POINT_TRIANGLE, /* 4point_bspline */
+	COEF_3D_FILTER		  /* can not change */
+};
+
+static unsigned int sharpness1_sr2_ctrl_32d7 = 0x00181008;
+MODULE_PARM_DESC(sharpness1_sr2_ctrl_32d7, "sharpness1_sr2_ctrl_32d7");
+module_param(sharpness1_sr2_ctrl_32d7, uint, 0664);
+/*0x3280 default val: 1920x1080*/
+static unsigned int sharpness1_sr2_ctrl_3280 = 0xffffffff;
+MODULE_PARM_DESC(sharpness1_sr2_ctrl_3280, "sharpness1_sr2_ctrl_3280");
+module_param(sharpness1_sr2_ctrl_3280, uint, 0664);
+
+#define MAX_COEFF_LEVEL 5
+uint num_coeff_level = MAX_COEFF_LEVEL;
+uint vert_coeff_settings[MAX_COEFF_LEVEL] = {
+	/* in:out */
+	COEF_BICUBIC,
+	/* ratio < 1 */
+	COEF_BICUBIC_SHARP,
+	/* ratio = 1 and phase = 0, */
+	/* use for MBX without sharpness HW module, */
+	/* TV use COEF_BICUBIC in function coeff */
+	COEF_BICUBIC,
+	/* ratio in (1~0.5) */
+	COEF_3POINT_BSPLINE,
+	/* ratio in [0.5~0.333) with pre-scaler on */
+	/* this setting is sharpness/smooth balanced */
+	/* if need more smooth(less sharp, could use */
+	/* COEF_4POINT_BSPLINE or COEF_4POINT_TRIANGLE */
+	COEF_4POINT_TRIANGLE,
+	/* ratio <= 0.333 with pre-scaler on */
+	/* this setting is most smooth */
+};
+
+uint horz_coeff_settings[MAX_COEFF_LEVEL] = {
+	/* in:out */
+	COEF_BICUBIC,
+	/* ratio < 1 */
+	COEF_BICUBIC_SHARP,
+	/* ratio = 1 and phase = 0, */
+	/* use for MBX without sharpness HW module, */
+	/* TV use COEF_BICUBIC in function coeff */
+	COEF_BICUBIC,
+	/* ratio in (1~0.5) */
+	COEF_3POINT_BSPLINE,
+	/* ratio in [0.5~0.333) with pre-scaler on */
+	/* this setting is sharpness/smooth balanced */
+	/* if need more smooth(less sharp, could use */
+	/* COEF_4POINT_BSPLINE or COEF_4POINT_TRIANGLE */
+	COEF_4POINT_TRIANGLE,
+	/* ratio <= 0.333 with pre-scaler on */
+	/* this setting is most smooth */
 };
 
+static uint coeff(uint *settings, uint ratio, uint phase, bool interlace)
+{
+	uint coeff_select = 0;
+	uint coeff_type = 0;
+	if (ratio >= (3 << 24))
+		coeff_select = 4;
+	else if (ratio >= (2 << 24))
+		coeff_select = 3;
+	else if (ratio > (1 << 24))
+		coeff_select = 2;
+	else if (ratio == (1 << 24)) {
+		if (phase == 0)
+			coeff_select = 1;
+		else
+			coeff_select = 2;
+	}
+	coeff_type = settings[coeff_select];
+	/* TODO: add future TV chips */
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+		(get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)) {
+		if (coeff_type == COEF_BICUBIC_SHARP)
+			coeff_type = COEF_BICUBIC;
+	} else {
+		/* gxtvbb use dejaggy in SR0 to reduce intelace combing
+		   other chip no dejaggy, need swtich to more blur filter */
+		if (interlace && (coeff_select < 3))
+			coeff_type = COEF_4POINT_BSPLINE;
+	}
+	return coeff_type;
+}
+
+/* vertical and horizontal coeff settings */
+module_param_array(vert_coeff_settings, uint, &num_coeff_level, 0664);
+MODULE_PARM_DESC(vert_coeff_settings, "\n vert_coeff_settings\n");
+
+module_param_array(horz_coeff_settings, uint, &num_coeff_level, 0664);
+MODULE_PARM_DESC(horz_coeff_settings, "\n horz_coeff_settings\n");
+
+bool vert_chroma_filter_en = true;
+module_param(vert_chroma_filter_en, bool, 0664);
+MODULE_PARM_DESC(vert_chroma_filter_en, "enable vertical chromafilter\n");
+
+bool vert_chroma_filter_force_en;
+module_param(vert_chroma_filter_force_en, bool, 0664);
+MODULE_PARM_DESC(vert_chroma_filter_force_en,
+	"force enable vertical chromafilter\n");
+
+uint num_chroma_filter = TOTAL_FILTERS;
+module_param_array(chroma_filter_table, uint, &num_chroma_filter, 0664);
+MODULE_PARM_DESC(chroma_filter_table, "\n chroma_filter_table\n");
+
+uint cur_vert_chroma_filter;
+MODULE_PARM_DESC(cur_vert_chroma_filter, "cur_vert_chroma_filter");
+module_param(cur_vert_chroma_filter, int, 0444);
+
+uint cur_vert_filter;
+MODULE_PARM_DESC(cur_vert_filter, "cur_vert_filter");
+module_param(cur_vert_filter, int, 0444);
+uint cur_horz_filter;
+
+MODULE_PARM_DESC(cur_horz_filter, "cur_horz_filter");
+module_param(cur_horz_filter, int, 0444);
+uint cur_skip_line;
+
+MODULE_PARM_DESC(cur_skip_line, "cur_skip_line");
+module_param(cur_skip_line, int, 0444);
+
+unsigned int super_scaler_v_ratio = 133;
+MODULE_PARM_DESC(super_scaler_v_ratio, "super_scaler_v_ratio");
+module_param(super_scaler_v_ratio, uint, 0664);
+
+static u32 skip_policy = 0x81;
+module_param(skip_policy, uint, 0664);
+MODULE_PARM_DESC(skip_policy, "\n skip_policy\n");
+
 static u32 vpp_wide_mode;
 static u32 vpp_zoom_ratio = 100;
 static s32 vpp_zoom_center_x, vpp_zoom_center_y;
@@ -185,6 +366,8 @@ static s32 video_layer_top, video_layer_left, video_layer_width,
 	   video_layer_height;
 static u32 video_source_crop_top, video_source_crop_left,
 	   video_source_crop_bottom, video_source_crop_right;
+static u32 video_crop_top_resv, video_crop_left_resv,
+	   video_crop_bottom_resv, video_crop_right_resv;
 static s32 video_layer_global_offset_x, video_layer_global_offset_y;
 static s32 osd_layer_top, osd_layer_left, osd_layer_width, osd_layer_height;
 static u32 video_speed_check_width = 1800, video_speed_check_height = 1400;
@@ -194,20 +377,17 @@ static bool vpp_3d_scale;
 static int force_filter_mode = 1;
 MODULE_PARM_DESC(force_filter_mode, "force_filter_mode");
 module_param(force_filter_mode, int, 0664);
-
 #endif
 
 static unsigned int super_debug;
 module_param(super_debug, uint, 0664);
 MODULE_PARM_DESC(super_debug, "super_debug");
 
-#ifdef SUPER_SCALER_OPEN
-
 static unsigned int super_scaler = 1;
 module_param(super_scaler, uint, 0664);
 MODULE_PARM_DESC(super_scaler, "super_scaler");
 
-static unsigned int scaler_path_sel = 1;
+static unsigned int scaler_path_sel;
 module_param(scaler_path_sel, uint, 0664);
 MODULE_PARM_DESC(scaler_path_sel, "scaler_path_sel");
 
@@ -218,15 +398,31 @@ MODULE_PARM_DESC(bypass_spscl0, "bypass_spscl0");
 static unsigned int bypass_spscl1;
 module_param(bypass_spscl1, uint, 0664);
 MODULE_PARM_DESC(bypass_spscl1, "bypass_spscl1");
-#endif
-#if 0	/* (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV) */
-static unsigned int bypass_ratio = 150;
-#else
-static unsigned int bypass_ratio = 196;
-#endif
+
+static unsigned int vert_scaler_filter = 0xff;
+module_param(vert_scaler_filter, uint, 0664);
+MODULE_PARM_DESC(vert_scaler_filter, "vert_scaler_filter");
+
+static unsigned int horz_scaler_filter = 0xff;
+module_param(horz_scaler_filter, uint, 0664);
+MODULE_PARM_DESC(horz_scaler_filter, "horz_scaler_filter");
+
+static unsigned int bypass_ratio = 205;
 module_param(bypass_ratio, uint, 0664);
 MODULE_PARM_DESC(bypass_ratio, "bypass_ratio");
 
+static unsigned int sr0_sr1_refresh = 1;
+module_param(sr0_sr1_refresh, uint, 0664);
+MODULE_PARM_DESC(sr0_sr1_refresh, "sr0_sr1_refresh");
+
+bool pre_scaler_en = true;
+module_param(pre_scaler_en, bool, 0664);
+MODULE_PARM_DESC(pre_scaler_en, "pre_scaler_en");
+
+unsigned int force_vskip_cnt;
+MODULE_PARM_DESC(force_vskip_cnt, "force_vskip_cnt");
+module_param(force_vskip_cnt, uint, 0664);
+
 #if 0
 #define DECL_PARM(name)\
 static int name;\
@@ -339,6 +535,24 @@ calculate_non_linear_ratio(unsigned middle_ratio,
 	return;
 }
 
+/* We find that the minimum line the video can be scaled
+ * down without skip line for different modes as below:
+ * 4k2k mode:
+ * video source		minimus line		ratio(height_in/height_out)
+ * 3840 * 2160		1690			1.278
+ * 1920 * 1080		860			1.256
+ * 1280 * 720		390			1.846
+ * 720 * 480		160			3.000
+ * 1080p mode:
+ * video source		minimus line		ratio(height_in/height_out)
+ * 3840 * 2160		840			2.571
+ * 1920 * 1080		430			2.511
+ * 1280 * 720		200			3.600
+ * 720 * 480		80			6.000
+ * So the safe scal ratio is 1.25 for 4K2K mode and 2.5
+ * (1.25 * 3840 / 1920) for 1080p mode.
+ */
+#define MIN_RATIO_1000	1250
 static int
 vpp_process_speed_check(s32 width_in,
 		s32 height_in,
@@ -347,6 +561,11 @@ vpp_process_speed_check(s32 width_in,
 		struct vpp_frame_par_s *next_frame_par,
 		const struct vinfo_s *vinfo, struct vframe_s *vf)
 {
+	u32 cur_ratio;
+
+	if (next_frame_par->vscale_skip_count < force_vskip_cnt)
+		return SPEED_CHECK_VSKIP;
+
 	/* #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8) */
 	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) && !is_meson_mtvd_cpu()) {
 		if ((width_in <= 0) || (height_in <= 0) || (height_out <= 0)
@@ -354,18 +573,27 @@ vpp_process_speed_check(s32 width_in,
 			return SPEED_CHECK_DONE;
 
 		if (height_in > height_out) {
-
+			if (get_cpu_type() >=
+				MESON_CPU_MAJOR_ID_GXBB) {
+				cur_ratio = div_u64((u64)height_in *
+						(u64)vinfo->height *
+						1000,
+						height_out * 2160);
+				if ((cur_ratio > MIN_RATIO_1000) &&
+				(vf->source_type != VFRAME_SOURCE_TYPE_TUNER) &&
+				(vf->source_type != VFRAME_SOURCE_TYPE_CVBS))
+					return SPEED_CHECK_VSKIP;
+			}
 			if (vf->type & VIDTYPE_VIU_422) {
 				/*TODO vpu */
-				if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) {
+				if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB)
 					bypass_ratio = 125;
-				}
 				if (height_out == 0
-					|| div_u64(
-						VPP_SPEED_FACTOR * width_in *
-						height_in *
-						vinfo->sync_duration_num *
-						height_screen,
+					|| div_u64((u64)VPP_SPEED_FACTOR *
+						(u64)width_in *
+						(u64)height_in *
+						(u64)vinfo->sync_duration_num *
+						(u64)height_screen,
 						height_out *
 						vinfo->sync_duration_den *
 						bypass_ratio) > get_vpu_clk())
@@ -375,27 +603,30 @@ vpp_process_speed_check(s32 width_in,
 			} else {
 				/*TODO vpu */
 				if (height_out == 0
-					|| div_u64(VPP_SPEED_FACTOR * width_in *
-					height_in *
-					vinfo->sync_duration_num *
-					height_screen,
+					|| div_u64((u64)VPP_SPEED_FACTOR *
+					(u64)width_in *
+					(u64)height_in *
+					(u64)vinfo->sync_duration_num *
+					(u64)height_screen,
 					height_out *
 					vinfo->sync_duration_den * 256)
 					> get_vpu_clk())
 					return SPEED_CHECK_VSKIP;
 				/* 4K down scaling to non 4K > 30hz,
 				   skip lines for memory bandwidth */
-				else if (((vf->type & VIDTYPE_COMPRESS)
-					   == 0) &&
+				else if ((((vf->type & VIDTYPE_COMPRESS)
+					   == 0) || (next_frame_par->nocomp))
+					&&
 					 (height_in > 2048) &&
 					 (height_out < 2048) &&
 					 (vinfo->sync_duration_num >
-					  (30 * vinfo->sync_duration_den)))
+					  (30 * vinfo->sync_duration_den)) &&
+					 (get_cpu_type() !=
+						MESON_CPU_MAJOR_ID_GXTVBB))
 					return SPEED_CHECK_VSKIP;
 				else
 					return SPEED_CHECK_DONE;
 			}
-
 		} else if (next_frame_par->hscale_skip_count == 0) {
 			/*TODO vpu */
 			if (div_u64(VPP_SPEED_FACTOR * width_in *
@@ -406,7 +637,6 @@ vpp_process_speed_check(s32 width_in,
 			else
 				return SPEED_CHECK_DONE;
 		}
-
 		return SPEED_CHECK_DONE;
 	}
 	/* #else */
@@ -429,13 +659,11 @@ vpp_process_speed_check(s32 width_in,
 	/* #endif */
 
 	amlog_mask(LOG_MASK_VPP, "vpp_process_speed_check failed\n");
-
 	return SPEED_CHECK_VSKIP;
-	/* #endif */
 }
 
 static void
-vpp_set_filters2(u32 width_in,
+vpp_set_filters2(u32 process_3d_type, u32 width_in,
 	u32 height_in,
 	u32 wid_out,
 	u32 hei_out,
@@ -450,6 +678,8 @@ vpp_set_filters2(u32 width_in,
 	u32 ratio_x = 0;
 	u32 ratio_y = 0;
 	u32 tmp_ratio_y = 0;
+	int temp_width;
+	int temp_height;
 	struct vppfilter_mode_s *filter = &next_frame_par->vpp_filter;
 	u32 wide_mode;
 	s32 height_shift = 0;
@@ -466,39 +696,45 @@ vpp_set_filters2(u32 width_in,
 	bool fill_match = true;
 	u32 orig_aspect = 0;
 	u32 screen_aspect = 0;
+	bool skip_policy_check = true;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+		if ((likely(w_in >
+			(video_source_crop_left + video_source_crop_right)))
+			&& (super_scaler == 0)) {
+			w_in -= video_source_crop_left;
+			w_in -= video_source_crop_right;
+			h_crop_enable = true;
+		}
 
-#ifdef SUPER_SCALER_OPEN
-	if ((likely(w_in > (video_source_crop_left + video_source_crop_right)))
-		&& (super_scaler == 0)) {
-		w_in -= video_source_crop_left + video_source_crop_right;
-		h_crop_enable = true;
-	}
+		if ((likely(h_in >
+			(video_source_crop_top + video_source_crop_bottom)))
+			&& (super_scaler == 0)) {
+			h_in -= video_source_crop_top;
+			h_in -= video_source_crop_bottom;
+			v_crop_enable = true;
+		}
+	} else {
+		if (likely(w_in >
+			(video_source_crop_left + video_source_crop_right))) {
+			w_in -= video_source_crop_left;
+			w_in -= video_source_crop_right;
+			h_crop_enable = true;
+		}
 
-	if ((likely(h_in > (video_source_crop_top + video_source_crop_bottom)))
-		&& (super_scaler == 0)) {
-		h_in -= video_source_crop_top + video_source_crop_bottom;
-		v_crop_enable = true;
-	}
-#else
-	if (likely(w_in >
-		(video_source_crop_left + video_source_crop_right))) {
-		w_in -= video_source_crop_left + video_source_crop_right;
-		h_crop_enable = true;
+		if (likely(h_in >
+			(video_source_crop_top + video_source_crop_bottom))) {
+			h_in -= video_source_crop_top;
+			h_in -= video_source_crop_bottom;
+			v_crop_enable = true;
+		}
 	}
 
-	if (likely(h_in >
-		(video_source_crop_top + video_source_crop_bottom))) {
-		h_in -= video_source_crop_top + video_source_crop_bottom;
-		v_crop_enable = true;
-	}
-#endif
-#ifdef CONFIG_AM_DEINTERLACE
-	int deinterlace_mode = get_deinterlace_mode();
-#endif
 #ifndef TV_3D_FUNCTION_OPEN
 	next_frame_par->vscale_skip_count = 0;
 	next_frame_par->hscale_skip_count = 0;
 #endif
+	next_frame_par->nocomp = false;
 	if (vpp_flags & VPP_FLAG_INTERLACE_IN)
 		next_frame_par->vscale_skip_count++;
 	if (vpp_flags & VPP_FLAG_INTERLACE_OUT)
@@ -573,8 +809,8 @@ RESTART:
 			video_height = osd_layer_height;
 		}
 	} else {
-#ifdef SUPER_SCALER_OPEN
-		if (next_frame_par->supscl_path) {
+		if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) &&
+			next_frame_par->supscl_path == sup0_pp_sp1_scpath) {
 			video_top = (video_layer_top >> next_frame_par->
 				 supsc1_vert_ratio);
 			video_height = (video_layer_height >> next_frame_par->
@@ -583,9 +819,7 @@ RESTART:
 				 supsc1_hori_ratio);
 			video_width = (video_layer_width >> next_frame_par->
 				 supsc1_hori_ratio);
-		} else
-#endif
-		{
+		} else {
 			video_top = video_layer_top;
 			video_left = video_layer_left;
 			video_width = video_layer_width;
@@ -729,11 +963,19 @@ RESTART:
 				(vpp_zoom_center_y << 10) +
 				(ratio_y >> 1)) / ratio_y;
 	end = ((h_in << 18) + (ratio_y >> 1)) / ratio_y + start - 1;
+	if (super_debug)
+		pr_info("top:start =%d,%d,%d,%d  %d,%d,%d\n",
+			start, end, video_top,
+			video_height, h_in, ratio_y, vpp_zoom_center_y);
 #else
 	start =
 		video_top + video_height / 2 - ((h_in << 17) +
 		(vpp_zoom_center_y << 10)) / ratio_y;
 	end = (h_in << 18) / ratio_y + start - 1;
+	if (super_debug)
+		pr_info("top:start =%d,%d,%d,%d  %d,%d,%d\n",
+			start, end, video_top,
+			video_height, h_in, ratio_y, vpp_zoom_center_y);
 #endif
 
 #ifdef TV_REVERSE
@@ -770,7 +1012,8 @@ RESTART:
 
 			} else
 				next_frame_par->VPP_vd_start_lines_ = 0;
-
+			temp_height = min((video_top + video_height - 1),
+			(vinfo->height - 1));
 		} else {
 			if (start < video_top) {
 				temp = ((video_top - start) * ratio_y) >> 18;
@@ -778,11 +1021,13 @@ RESTART:
 
 			} else
 				next_frame_par->VPP_vd_start_lines_ = 0;
+			temp_height = min((video_top + video_height - 1),
+			(vinfo->height - 1)) - video_top + 1;
 		}
 
 		temp =
 			next_frame_par->VPP_vd_start_lines_ +
-			(video_height * ratio_y >> 18);
+			(temp_height * ratio_y >> 18);
 		next_frame_par->VPP_vd_end_lines_ =
 			(temp <= (h_in - 1)) ? temp : (h_in - 1);
 	}
@@ -800,7 +1045,7 @@ RESTART:
 	[video_top, video_top+video_height-1]
 	*/
 	start = max(start, max(0, video_top));
-	end = min(end, min((s32) height_out - 1,
+	end = min(end, min((s32)(vinfo->height - 1),
 		(s32)(video_top + video_height - 1)));
 
 	if (start >= end) {
@@ -822,19 +1067,6 @@ RESTART:
 	ratio_y <<= height_shift;
 	ratio_y = ratio_y / (next_frame_par->vscale_skip_count + 1);
 
-	if (vpp_flags & VPP_FLAG_INTERLACE_OUT)
-		filter->vpp_vert_coeff = filter_table[COEF_BILINEAR];
-	else
-		filter->vpp_vert_coeff = filter_table[COEF_BICUBIC];
-#ifdef	TV_3D_FUNCTION_OPEN
-	if ((next_frame_par->vpp_3d_scale) && force_filter_mode)
-		filter->vpp_vert_coeff = vpp_3d_filter_coefs_bilinear;
-#endif
-
-#ifdef CONFIG_AM_DEINTERLACE
-	if (deinterlace_mode)
-		filter->vpp_vert_coeff = filter_table[COEF_3POINT_TRIANGLE];
-#endif
 	filter->vpp_vsc_start_phase_step = ratio_y << 6;
 
 	f2v_get_vertical_phase(ratio_y, ini_vphase,
@@ -849,16 +1081,9 @@ RESTART:
 	next_frame_par->VPP_hsc_linear_startp = next_frame_par->VPP_hsc_startp;
 	next_frame_par->VPP_hsc_linear_endp = next_frame_par->VPP_hsc_endp;
 
-	filter->vpp_horz_coeff = filter_table[COEF_BICUBIC];
-
 	filter->vpp_hsc_start_phase_step = ratio_x << 6;
 	next_frame_par->VPP_hf_ini_phase_ = vpp_zoom_center_x & 0xff;
 
-	if ((ratio_x == (1 << 18)) && (next_frame_par->VPP_hf_ini_phase_ == 0))
-		filter->vpp_horz_coeff = vpp_filter_coefs_bicubic_sharp;
-	else
-		filter->vpp_horz_coeff = filter_table[COEF_BICUBIC];
-
 	/* screen position for source */
 #ifdef TV_REVERSE
 	start =
@@ -867,7 +1092,7 @@ RESTART:
 				(ratio_x >> 1)) / ratio_x;
 	end = ((w_in << 18) + (ratio_x >> 1)) / ratio_x + start - 1;
 	if (super_debug)
-		pr_info("start =%d,%d,%d,%d  %d,%d,%d\n",
+		pr_info("left:start =%d,%d,%d,%d  %d,%d,%d\n",
 			start, end, video_left,
 			video_width, w_in, ratio_x, vpp_zoom_center_x);
 #else
@@ -876,6 +1101,9 @@ RESTART:
 		(vpp_zoom_center_x << 10)) /
 		ratio_x;
 	end = (w_in << 18) / ratio_x + start - 1;
+	pr_info("left:start =%d,%d,%d,%d  %d,%d,%d\n",
+			start, end, video_left,
+			video_width, w_in, ratio_x, vpp_zoom_center_x);
 #endif
 	/* calculate source horizontal clip */
 #ifdef TV_REVERSE
@@ -908,7 +1136,8 @@ RESTART:
 
 			} else
 				next_frame_par->VPP_hd_start_lines_ = 0;
-
+			temp_width = min((video_left + video_width - 1),
+			(vinfo->width - 1));
 		} else {
 			if (start < video_left) {
 				temp = ((video_left - start) * ratio_x) >> 18;
@@ -916,11 +1145,12 @@ RESTART:
 
 			} else
 				next_frame_par->VPP_hd_start_lines_ = 0;
+			temp_width = min((video_left + video_width - 1),
+			(vinfo->width - 1)) - video_left + 1;
 		}
-
 		temp =
 			next_frame_par->VPP_hd_start_lines_ +
-			(video_width * ratio_x >> 18);
+			(temp_width * ratio_x >> 18);
 		next_frame_par->VPP_hd_end_lines_ =
 			(temp <= (w_in - 1)) ? temp : (w_in - 1);
 	}
@@ -939,29 +1169,22 @@ RESTART:
 	 */
 	start = max(start, max(0, video_left));
 	end = min(end,
-		min((s32) width_out - 1, (s32)(video_left + video_width - 1)));
+		min((s32)(vinfo->width - 1),
+		(s32)(video_left + video_width - 1)));
 
 	if (start >= end) {
 		/* nothing to display */
 		next_frame_par->VPP_hsc_startp = 0;
-
 		next_frame_par->VPP_hsc_endp = 0;
-
+		/* avoid mif set wrong or di out size overflow */
+		next_frame_par->VPP_hd_start_lines_ = 0;
+		next_frame_par->VPP_hd_end_lines_ = 0;
 	} else {
 		next_frame_par->VPP_hsc_startp = start;
 
 		next_frame_par->VPP_hsc_endp = end;
 	}
 
-	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
-	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) && !is_meson_mtvd_cpu()) {
-		if (next_frame_par->VPP_line_in_length_ >= 2048) {
-			filter->vpp_vert_coeff =
-				filter_table[COEF_2POINT_BILINEAR];
-		}
-	}
-	/* #endif */
-
 	if ((wide_mode == VIDEO_WIDEOPTION_NONLINEAR) && (end > start)) {
 		calculate_non_linear_ratio(ratio_x, end - start,
 				next_frame_par);
@@ -996,8 +1219,9 @@ RESTART:
 				next_frame_par->vscale_skip_count += 2;
 			else {
 #ifdef TV_3D_FUNCTION_OPEN
-				if (next_frame_par->vpp_3d_mode ==
+				if ((next_frame_par->vpp_3d_mode ==
 					VPP_3D_MODE_LA)
+					&& (process_3d_type & MODE_3D_ENABLE))
 					next_frame_par->vscale_skip_count += 2;
 				else
 #endif
@@ -1009,14 +1233,158 @@ RESTART:
 			next_frame_par->hscale_skip_count = 1;
 	}
 
+	if ((vf->type & VIDTYPE_COMPRESS) &&
+		(vf->canvas0Addr != 0) &&
+		(next_frame_par->vscale_skip_count > 1) &&
+		(!next_frame_par->nocomp)) {
+		pr_info("Try DW buffer for compressed frame scaling.\n");
+
+		/* for VIDTYPE_COMPRESS, check if we can use double write
+		 * buffer when primary frame can not be scaled.
+		 */
+		next_frame_par->nocomp = true;
+		w_in = width_in = vf->width;
+		h_in = height_in = vf->height;
+		next_frame_par->hscale_skip_count = 0;
+		next_frame_par->vscale_skip_count = 0;
+
+		goto RESTART;
+	}
+
+	if ((skip_policy & 0xf0) && (skip_policy_check == true)) {
+		skip_policy_check = false;
+		if (skip_policy & 0x40) {
+			next_frame_par->vscale_skip_count = skip_policy & 0xf;
+			goto RESTART;
+		} else if (skip_policy & 0x80) {
+			if ((vf->width >= 4096) &&
+			(!(vf->type & VIDTYPE_COMPRESS))
+			&& (next_frame_par->vscale_skip_count == 0)) {
+				next_frame_par->vscale_skip_count =
+				skip_policy & 0xf;
+				goto RESTART;
+			}
+		}
+	}
+
 	filter->vpp_hsc_start_phase_step = ratio_x << 6;
 
+	/* coeff selection before skip and apply pre_scaler */
+	filter->vpp_vert_filter =
+		coeff(vert_coeff_settings,
+			filter->vpp_vsc_start_phase_step *
+				(next_frame_par->vscale_skip_count + 1),
+			1,
+			((vf->type_original & VIDTYPE_TYPEMASK)
+				!= VIDTYPE_PROGRESSIVE));
+	filter->vpp_vert_coeff =
+		filter_table[filter->vpp_vert_filter];
+
+	/* when local interlace or AV or ATV */
+	/* TODO: add 420 check for local */
+	if (vert_chroma_filter_force_en || (vert_chroma_filter_en
+	&& (((vf->source_type == VFRAME_SOURCE_TYPE_OTHERS)
+	 && ((vf->type_original & VIDTYPE_TYPEMASK) != VIDTYPE_PROGRESSIVE))
+	|| (vf->source_type == VFRAME_SOURCE_TYPE_CVBS)
+	|| (vf->source_type == VFRAME_SOURCE_TYPE_TUNER)))) {
+		cur_vert_chroma_filter
+			= chroma_filter_table[filter->vpp_vert_filter];
+		filter->vpp_vert_chroma_coeff
+			= filter_table[cur_vert_chroma_filter];
+		filter->vpp_vert_chroma_filter_en = true;
+	} else {
+		cur_vert_chroma_filter = COEF_NULL;
+		filter->vpp_vert_chroma_filter_en = false;
+	}
+
+	filter->vpp_horz_filter =
+		coeff(horz_coeff_settings,
+			filter->vpp_hf_start_phase_step,
+			next_frame_par->VPP_hf_ini_phase_,
+			((vf->type_original & VIDTYPE_TYPEMASK)
+				!= VIDTYPE_PROGRESSIVE));
+	/*for gxl cvbs out index*/
+	if ((vinfo->mode == VMODE_576CVBS) &&
+		(filter->vpp_hf_start_phase_step == (1 << 24)))
+		filter->vpp_horz_filter = COEF_BICUBIC_SHARP;
+	filter->vpp_horz_coeff =
+		filter_table[filter->vpp_horz_filter];
+
+	/* apply line skip */
 	if (next_frame_par->hscale_skip_count) {
 		filter->vpp_hf_start_phase_step >>= 1;
+		filter->vpp_hsc_start_phase_step >>= 1;
 		next_frame_par->VPP_line_in_length_ >>= 1;
 	}
 
+	/*pre hsc&vsc in pps for scaler down*/
+	if ((filter->vpp_hf_start_phase_step >= 0x2000000) &&
+		(filter->vpp_vsc_start_phase_step >= 0x2000000) &&
+		(get_cpu_type() != MESON_CPU_MAJOR_ID_GXBB) &&
+		pre_scaler_en) {
+		filter->vpp_pre_vsc_en = 1;
+		filter->vpp_vsc_start_phase_step >>= 1;
+		ratio_y >>= 1;
+		f2v_get_vertical_phase(ratio_y, ini_vphase,
+		next_frame_par->VPP_vf_ini_phase_,
+		vpp_flags & VPP_FLAG_INTERLACE_OUT);
+
+	} else
+		filter->vpp_pre_vsc_en = 0;
+
+	if ((filter->vpp_hf_start_phase_step >= 0x2000000) &&
+		(get_cpu_type() != MESON_CPU_MAJOR_ID_GXBB) &&
+		pre_scaler_en) {
+		filter->vpp_pre_hsc_en = 1;
+		filter->vpp_hf_start_phase_step >>= 1;
+		filter->vpp_hsc_start_phase_step >>= 1;
+	} else
+		filter->vpp_pre_hsc_en = 0;
+
 	next_frame_par->VPP_hf_ini_phase_ = vpp_zoom_center_x & 0xff;
+
+	/* overwrite filter setting for interlace output*/
+	/* TODO: not reasonable when 4K input to 480i output */
+	if (vpp_flags & VPP_FLAG_INTERLACE_OUT) {
+		filter->vpp_vert_coeff = filter_table[COEF_BILINEAR];
+		filter->vpp_vert_filter = COEF_BILINEAR;
+	}
+
+	/* force overwrite filter setting */
+	if ((vert_scaler_filter >= COEF_BICUBIC) &&
+		(vert_scaler_filter <= COEF_3D_FILTER)) {
+		filter->vpp_vert_coeff = filter_table[vert_scaler_filter];
+		filter->vpp_vert_filter = vert_scaler_filter;
+		if (vert_chroma_filter_force_en) {
+			cur_vert_chroma_filter
+				= chroma_filter_table[vert_scaler_filter];
+			filter->vpp_vert_chroma_coeff
+				= filter_table[cur_vert_chroma_filter];
+			filter->vpp_vert_chroma_filter_en = true;
+		} else {
+			cur_vert_chroma_filter = COEF_NULL;
+			filter->vpp_vert_chroma_filter_en = false;
+		}
+	}
+
+	if ((horz_scaler_filter >= COEF_BICUBIC) &&
+		(horz_scaler_filter <= COEF_3D_FILTER)) {
+		filter->vpp_horz_coeff = filter_table[horz_scaler_filter];
+		filter->vpp_horz_filter = horz_scaler_filter;
+	}
+
+#ifdef	TV_3D_FUNCTION_OPEN
+	/* final stage for 3D filter overwrite */
+	if ((next_frame_par->vpp_3d_scale) && force_filter_mode) {
+		filter->vpp_vert_coeff = filter_table[COEF_3D_FILTER];
+		filter->vpp_vert_filter = COEF_3D_FILTER;
+	}
+#endif
+
+	cur_vert_filter = filter->vpp_vert_filter;
+	cur_horz_filter = filter->vpp_horz_filter;
+	cur_skip_line = next_frame_par->vscale_skip_count;
+
 #if HAS_VPU_PROT
 	if (has_vpu_prot()) {
 		if (get_prot_status()) {
@@ -1077,10 +1445,13 @@ RESTART:
 	}
 #endif
 }
-
-#ifdef SUPER_SCALER_OPEN
-
-static int vpp_set_super_sclaer_regs(int scaler_path_sel,
+/*
+VPP_SRSHARP0_CTRL:0x1d91
+[0]srsharp0 enable for sharpness module reg r/w
+[1]if sharpness is enable or vscaler is enable,must set to 1,
+sharpness1;reg can only to be w
+*/
+int vpp_set_super_scaler_regs(int scaler_path_sel,
 		int reg_srscl0_enable,
 		int reg_srscl0_hsize,
 		int reg_srscl0_vsize,
@@ -1094,52 +1465,138 @@ static int vpp_set_super_sclaer_regs(int scaler_path_sel,
 {
 
 	int tmp_data = 0;
+	int tmp_data2 = 0;
+
+	/* top config */
+	tmp_data = READ_VCBUS_REG(VPP_SRSHARP0_CTRL);
+	if (sr0_sr1_refresh) {
+		if (reg_srscl0_hsize > SUPER_CORE0_WIDTH_MAX) {
+			if (((tmp_data >> 1)&0x1) != 0)
+				VSYNC_WR_MPEG_REG_BITS(VPP_SRSHARP0_CTRL,
+					0, 1, 1);
+		} else {
+			if (((tmp_data >> 1)&0x1) != 1)
+				VSYNC_WR_MPEG_REG_BITS(VPP_SRSHARP0_CTRL,
+					1, 1, 1);
+		}
+		if ((tmp_data&0x1) != 1)
+			VSYNC_WR_MPEG_REG_BITS(VPP_SRSHARP0_CTRL, 1, 0, 1);
+	}
+	tmp_data = READ_VCBUS_REG(VPP_SRSHARP1_CTRL);
+	if (sr0_sr1_refresh) {
+		if (((tmp_data >> 1)&0x1) != 1)
+			VSYNC_WR_MPEG_REG_BITS(VPP_SRSHARP1_CTRL, 1, 1, 1);
+		if ((tmp_data&0x1) != 1)
+			VSYNC_WR_MPEG_REG_BITS(VPP_SRSHARP1_CTRL, 1, 0, 1);
+	}
+	/* core0 config */
+	tmp_data = READ_VCBUS_REG(SRSHARP0_SHARP_SR2_CTRL);
+	if (sr0_sr1_refresh) {
+		if (((tmp_data >> 5)&0x1) != (reg_srscl0_vert_ratio&0x1))
+			VSYNC_WR_MPEG_REG_BITS(SRSHARP0_SHARP_SR2_CTRL,
+				reg_srscl0_vert_ratio&0x1, 5, 1);
+		if (((tmp_data >> 4)&0x1) != (reg_srscl0_hori_ratio&0x1))
+			VSYNC_WR_MPEG_REG_BITS(SRSHARP0_SHARP_SR2_CTRL,
+				reg_srscl0_hori_ratio&0x1, 4, 1);
+
+		if (reg_srscl0_hsize > SUPER_CORE0_WIDTH_MAX) {
+			if (((tmp_data >> 2)&0x1) != 0)
+				VSYNC_WR_MPEG_REG_BITS(SRSHARP0_SHARP_SR2_CTRL,
+					0, 2, 1);
+		} else {
+			if (((tmp_data >> 2)&0x1) != 1)
+				VSYNC_WR_MPEG_REG_BITS(SRSHARP0_SHARP_SR2_CTRL,
+					1, 2, 1);
+		}
 
-	tmp_data = (0xf << 4) |	/* enable y/c bic */
-		((reg_srscl0_vert_ratio & 0x1) << 2) |
-		((reg_srscl0_hori_ratio & 0x1) << 1) |
-		(reg_srscl0_enable & 0x1);
-	VSYNC_WR_MPEG_REG(SRSCL0_CTRL_MODE, tmp_data);
-
-	tmp_data = (0xf << 4) |	/* enable y/c bic */
-		((reg_srscl1_vert_ratio & 0x1) << 2) |
-		((reg_srscl1_hori_ratio & 0x1) << 1) |
-		(reg_srscl1_enable & 0x1);
-	VSYNC_WR_MPEG_REG(SRSCL1_CTRL_MODE, tmp_data);
+		if ((tmp_data & 0x1) == (reg_srscl0_hori_ratio&0x1))
+			VSYNC_WR_MPEG_REG_BITS(SRSHARP0_SHARP_SR2_CTRL,
+				((~(reg_srscl0_hori_ratio&0x1))&0x1), 0, 1);
+	}
+	/* core1 config */
+	tmp_data = sharpness1_sr2_ctrl_32d7;
+	/*if ((((tmp_data >> 5)&0x1) != (reg_srscl1_vert_ratio&0x1)) ||
+		(((tmp_data >> 4)&0x1) != (reg_srscl1_hori_ratio&0x1)) ||
+		((tmp_data & 0x1) == (reg_srscl1_hori_ratio&0x1)) ||
+		(((tmp_data >> 2)&0x1) != 1)) {*/
+	if (1) {/* modify for avoid reg not be write@20160505 */
+		tmp_data = tmp_data & (~(1 << 5));
+		tmp_data = tmp_data & (~(1 << 4));
+		tmp_data = tmp_data & (~(1 << 2));
+		tmp_data = tmp_data & (~(1 << 0));
+		tmp_data |= ((reg_srscl1_vert_ratio&0x1) << 5);
+		tmp_data |= ((reg_srscl1_hori_ratio&0x1) << 4);
+		tmp_data |= (1 << 2);
+		tmp_data |= (((~(reg_srscl1_hori_ratio&0x1))&0x1) << 0);
+		if (sr0_sr1_refresh) {
+			VSYNC_WR_MPEG_REG(SRSHARP1_SHARP_SR2_CTRL, tmp_data);
+			sharpness1_sr2_ctrl_32d7 = tmp_data;
+		}
+	}
 
+	/* size config */
 	tmp_data = ((reg_srscl0_hsize & 0x1fff) << 16) |
 			   (reg_srscl0_vsize & 0x1fff);
-	VSYNC_WR_MPEG_REG(SRSCL0_HV_SIZEIN, tmp_data);
+	tmp_data2 = READ_VCBUS_REG(SRSHARP0_SHARP_SR2_CTRL);
+	if (tmp_data != tmp_data2)
+		VSYNC_WR_MPEG_REG(SRSHARP0_SHARP_HVSIZE, tmp_data);
 
 	tmp_data = ((reg_srscl1_hsize & 0x1fff) << 16) |
 			   (reg_srscl1_vsize & 0x1fff);
-	VSYNC_WR_MPEG_REG(SRSCL1_HV_SIZEIN, tmp_data);
+	if (1) {/*(sharpness1_sr2_ctrl_3280 != tmp_data) {*/
+		VSYNC_WR_MPEG_REG(SRSHARP1_SHARP_HVSIZE, tmp_data);
+		sharpness1_sr2_ctrl_3280 = tmp_data;
+	}
+
+	if (scaler_path_sel == sup0_pp_sp1_scpath) {
+		tmp_data = ((reg_srscl1_hsize & 0x1fff) << 16) |
+				   (reg_srscl1_vsize & 0x1fff);
+		tmp_data2 = READ_VCBUS_REG(VPP_VE_H_V_SIZE);
+		if (tmp_data != tmp_data2)
+			VSYNC_WR_MPEG_REG(VPP_VE_H_V_SIZE, tmp_data);
+	} else if (scaler_path_sel == sup0_pp_post_blender) {
+		tmp_data = ((reg_srscl1_hsize & 0x1fff) << 16) |
+				   (reg_srscl1_vsize & 0x1fff);
+		tmp_data2 = READ_VCBUS_REG(VPP_PSR_H_V_SIZE);
+		if (tmp_data != tmp_data2)
+			VSYNC_WR_MPEG_REG(VPP_PSR_H_V_SIZE, tmp_data);
+	}
 
-	VSYNC_WR_MPEG_REG_BITS(VPP_VE_ENABLE_CTRL, scaler_path_sel, 5, 1);
+	/* path config */
+	tmp_data2 = (READ_VCBUS_REG(VPP_VE_ENABLE_CTRL) >> 5)&0x1;
+	if (tmp_data2 != scaler_path_sel)
+		VSYNC_WR_MPEG_REG_BITS(VPP_VE_ENABLE_CTRL,
+			scaler_path_sel, 5, 1);
 
 	return 0;
 }
 
-static void vpp_set_scaler(u32 src_width,
+static void vpp_set_scaler(u32 process_3d_type, u32 src_width,
 			u32 src_height,
 			const struct vinfo_s *vinfo,
 			u32 vpp_flags,
 			struct vpp_frame_par_s *next_frame_par,
 			struct vframe_s *vf)
 {
-
-	unsigned int spsc0_h_in, spsc0_w_in, spsc1_h_in, spsc1_w_in;
-	unsigned int spsc0_h_out, spsc0_w_out, spsc1_h_out, spsc1_w_out;
+	unsigned int spsc1_h_out, spsc1_w_out;
 	unsigned int ppsc_h_in, ppsc_w_in;
 	unsigned int ppsc_h_out, ppsc_w_out;
 	unsigned int hor_sc_multiple_num, ver_sc_multiple_num;
 	bool h_crop_enable = false, v_crop_enable = false;
 	u32 width_out = vinfo->width;
 	u32 height_out = vinfo->height;
+
+	if (video_layer_width > 0 && video_layer_width <= vinfo->width
+	&& ((video_layer_width + video_layer_left) <= vinfo->width))
+		width_out = video_layer_width;
+	if (video_layer_height > 0 && video_layer_height <= vinfo->height
+	&& ((video_layer_height + video_layer_top) <= vinfo->height))
+		height_out = video_layer_height;
+
 	if ((likely(src_width >
 		(video_source_crop_left + video_source_crop_right)))
 		&& (super_scaler == 1)) {
-		src_widh -= video_source_crop_left + video_source_crop_right;
+		src_width -= video_source_crop_left + video_source_crop_right;
 		h_crop_enable = true;
 	}
 
@@ -1151,17 +1608,28 @@ static void vpp_set_scaler(u32 src_width,
 		v_crop_enable = true;
 	}
 	hor_sc_multiple_num = width_out / src_width;
-	ver_sc_multiple_num = height_out / src_height;
+	ver_sc_multiple_num = height_out*SUPER_SCALER_V_FACTOR / src_height;
 
 	/* just calcuate the enable sclaer module */
-	if ((hor_sc_multiple_num >= 4) || (ver_sc_multiple_num >= 4)) {
-		next_frame_par->supsc0_enable = 1;
-		next_frame_par->supsc1_enable = 1;
-	} else if ((hor_sc_multiple_num >= 2) || (ver_sc_multiple_num >= 2)) {
-		if (src_width > SUPER_CORE0_WIDTH_MAX
-			&& src_width <= SUPER_CORE1_WIDTH_MAX) {
+	if ((hor_sc_multiple_num >= 4) || (ver_sc_multiple_num >=
+				(4*SUPER_SCALER_V_FACTOR))) {
+		if (bypass_spscl0 == 0)
+			next_frame_par->supsc0_enable = 1;
+		if (bypass_spscl1 == 0)
+			next_frame_par->supsc1_enable = 1;
+	} else if ((hor_sc_multiple_num >= 2) || (ver_sc_multiple_num >=
+				(2*SUPER_SCALER_V_FACTOR))) {
+		if (((src_width > SUPER_CORE0_WIDTH_MAX/2)
+			&& (src_width <= SUPER_CORE0_WIDTH_MAX)
+			&& (bypass_spscl1 == 0))
+			|| (bypass_spscl0 == 1)) {
 			next_frame_par->supsc0_enable = 0;
 			next_frame_par->supsc1_enable = 1;
+		} else if ((src_width > SUPER_CORE0_WIDTH_MAX/2)
+			&& (src_width <= SUPER_CORE0_WIDTH_MAX)
+			&& (bypass_spscl1 == 1)) {
+			next_frame_par->supsc0_enable = 0;
+			next_frame_par->supsc1_enable = 0;
 		} else {
 			next_frame_par->supsc0_enable = 1;
 			next_frame_par->supsc1_enable = 0;
@@ -1170,10 +1638,27 @@ static void vpp_set_scaler(u32 src_width,
 		next_frame_par->supsc0_enable = 0;
 		next_frame_par->supsc1_enable = 0;
 	}
-	if (hor_sc_multiple_num >= 4) {
-		next_frame_par->supsc0_hori_ratio = 1;
-		next_frame_par->supsc1_hori_ratio = 1;
-	} else if (hor_sc_multiple_num >= 2) {
+	if (src_width > SUPER_CORE0_WIDTH_MAX)
+		next_frame_par->supsc0_enable = 0;
+	if (width_out > SUPER_CORE1_WIDTH_MAX*2)
+		next_frame_par->supsc1_enable = 0;
+
+	if (ver_sc_multiple_num >= (2*SUPER_SCALER_V_FACTOR)) {
+		if (src_width > SUPER_CORE0_WIDTH_MAX/2)
+			next_frame_par->supsc0_vert_ratio = 0;
+		else
+			next_frame_par->supsc0_vert_ratio =
+				next_frame_par->supsc0_enable ? 1 : 0;
+		if (width_out > SUPER_CORE1_WIDTH_MAX*2)
+			next_frame_par->supsc1_vert_ratio = 0;
+		else
+			next_frame_par->supsc1_vert_ratio =
+				next_frame_par->supsc1_enable ? 1 : 0;
+	} else {
+		next_frame_par->supsc0_vert_ratio = 0;
+		next_frame_par->supsc1_vert_ratio = 0;
+	}
+	if (hor_sc_multiple_num >= 2) {
 		next_frame_par->supsc0_hori_ratio =
 			next_frame_par->supsc0_enable ? 1 : 0;
 		next_frame_par->supsc1_hori_ratio =
@@ -1181,20 +1666,21 @@ static void vpp_set_scaler(u32 src_width,
 	} else {
 		next_frame_par->supsc0_hori_ratio = 0;
 		next_frame_par->supsc1_hori_ratio = 0;
-	}
-
-	if (ver_sc_multiple_num >= 4) {
-		next_frame_par->supsc0_vert_ratio = 1;
-		next_frame_par->supsc1_vert_ratio = 1;
-	} else if (ver_sc_multiple_num >= 2) {
-		next_frame_par->supsc0_vert_ratio =
-			next_frame_par->supsc0_enable ? 1 : 0;
-		next_frame_par->supsc1_vert_ratio =
-			next_frame_par->supsc1_enable ? 1 : 0;
-	} else {
 		next_frame_par->supsc0_vert_ratio = 0;
 		next_frame_par->supsc1_vert_ratio = 0;
 	}
+	if ((ver_sc_multiple_num <= super_scaler_v_ratio) &&
+		(src_height >= SUPER_CORE0_WIDTH_MAX/2) &&
+		(src_height <= 1088) &&
+		(ver_sc_multiple_num > SUPER_SCALER_V_FACTOR) &&
+		(vinfo->height >= 2000)) {
+		next_frame_par->supsc0_enable = 0;
+		next_frame_par->supsc1_enable = 1;
+		next_frame_par->supsc0_hori_ratio = 0;
+		next_frame_par->supsc1_hori_ratio = 1;
+		next_frame_par->supsc0_vert_ratio = 0;
+		next_frame_par->supsc1_vert_ratio = 1;
+	}
 	if (bypass_spscl0) {
 		next_frame_par->supsc0_enable = 0;
 		next_frame_par->supsc0_hori_ratio = 0;
@@ -1205,8 +1691,8 @@ static void vpp_set_scaler(u32 src_width,
 		next_frame_par->supsc1_hori_ratio = 0;
 		next_frame_par->supsc1_vert_ratio = 0;
 	}
-	spsc0_h_in = src_height;
-	spsc0_w_in = src_width;
+	next_frame_par->spsc0_h_in = src_height;
+	next_frame_par->spsc0_w_in = src_width;
 	if (super_debug)
 		pr_info(
 		"supsc0_hori=%d,supsc1_hori=%d,supsc0_v=%d,supsc1_v=%d\n",
@@ -1214,77 +1700,59 @@ static void vpp_set_scaler(u32 src_width,
 		 next_frame_par->supsc1_hori_ratio,
 		 next_frame_par->supsc0_vert_ratio,
 		 next_frame_par->supsc1_vert_ratio);
-	/* select the scaler path:[super 1   =>>
-	ppscaler  =>>  super 2 ]  or
-	[super 1   =>>   super 2  =>>  ppsaler] */
-	if (next_frame_par->supscl_path == sup0_sp1_pp_scpath) {
-		ppsc_h_out = height_out;
-		ppsc_w_out = width_out;
-		spsc1_h_in = spsc0_h_out =
-			(spsc0_h_in << next_frame_par->supsc0_vert_ratio);
-		spsc1_w_in = spsc0_w_out =
-			(spsc0_w_in << next_frame_par->supsc0_hori_ratio);
-		ppsc_h_in = spsc1_h_out =
-			(spsc1_h_in << next_frame_par->supsc1_vert_ratio);
-		ppsc_w_in = spsc1_w_out =
-			(spsc1_w_in << next_frame_par->supsc1_hori_ratio);
-
-	} else if (next_frame_par->supscl_path == sup0_pp_sp1_scpath) {
-		ppsc_h_in = (spsc0_h_in << next_frame_par->supsc0_vert_ratio);
-		ppsc_w_in = (spsc0_w_in << next_frame_par->supsc0_hori_ratio);
-		spsc1_h_out = height_out;
-		spsc1_w_out = width_out;
-		ppsc_h_out =
-			(spsc1_h_out >> next_frame_par->supsc1_vert_ratio);
-		ppsc_w_out =
-			(spsc1_w_out >> next_frame_par->supsc1_hori_ratio);
-		spsc1_h_in = ppsc_h_out;
-		spsc1_w_in = ppsc_w_out;
-
-	} else {
-		next_frame_par->supsc0_enable = 0;
-		next_frame_par->supsc1_enable = 0;
-		ppsc_h_in = src_height;
-		ppsc_w_in = src_width;
-		ppsc_h_out = height_out;
-		ppsc_w_out = width_out;
-		spsc1_h_in = 0;
-		spsc1_w_in = 0;
-		/* spsc1_h_in  spsc1_w_in are just iinitialized */
-	}
-	vpp_set_filters2(ppsc_w_in, ppsc_h_in, ppsc_w_out, ppsc_h_out, vinfo,
-					 vpp_flags, next_frame_par, vf);
+	/* select the scaler path:[core0 =>>
+	ppscaler =>> core1]  or
+	[core0  =>> ppscaler =>> postblender =>> core1]*/
+	ppsc_h_in = (next_frame_par->spsc0_h_in <<
+		next_frame_par->supsc0_vert_ratio);
+	ppsc_w_in = (next_frame_par->spsc0_w_in <<
+		next_frame_par->supsc0_hori_ratio);
+	spsc1_h_out = height_out;
+	spsc1_w_out = width_out;
+	ppsc_h_out =
+		(spsc1_h_out >> next_frame_par->supsc1_vert_ratio);
+	ppsc_w_out =
+		(spsc1_w_out >> next_frame_par->supsc1_hori_ratio);
+	next_frame_par->spsc1_h_in = ppsc_h_out;
+	next_frame_par->spsc1_w_in = ppsc_w_out;
+
+	vpp_set_filters2(process_3d_type, ppsc_w_in,
+	ppsc_h_in, ppsc_w_out, ppsc_h_out, vinfo,
+	vpp_flags, next_frame_par, vf);
 	if (next_frame_par->supscl_path == sup0_pp_sp1_scpath) {
-		spsc1_h_in = next_frame_par->VPP_vsc_endp -
+		next_frame_par->spsc1_h_in = next_frame_par->VPP_vsc_endp -
 			next_frame_par->VPP_vsc_startp + 1;
 		/* (ppsc_h_in<<18)/
 		(next_frame_par->vpp_filter.vpp_vsc_start_phase_step>>6); */
-		spsc1_w_in = next_frame_par->VPP_hsc_endp -
+		next_frame_par->spsc1_w_in = next_frame_par->VPP_hsc_endp -
 			next_frame_par->VPP_hsc_startp + 1;
 		/* (ppsc_w_in<<18)/
 		(next_frame_par->vpp_filter.vpp_hsc_start_phase_step>>6); */
 	}
-	vpp_set_super_sclaer_regs(next_frame_par->supscl_path,
+	/*vpp_set_super_sclaer_regs(next_frame_par->supscl_path,
 		next_frame_par->supsc0_enable,
-		spsc0_w_in,
-		spsc0_h_in,
+		next_frame_par->spsc0_w_in,
+		next_frame_par->spsc0_h_in,
 		next_frame_par->supsc0_hori_ratio,
 		next_frame_par->supsc0_vert_ratio,
 		next_frame_par->supsc1_enable,
-		spsc1_w_in,
-		spsc1_h_in,
+		next_frame_par->spsc1_w_in,
+		next_frame_par->spsc1_h_in,
 		next_frame_par->supsc1_hori_ratio,
-		next_frame_par->supsc1_vert_ratio);
-	if (super_debug)
+		next_frame_par->supsc1_vert_ratio);*/
+	if (super_debug) {
 		pr_info
 		("ppsc_w_in=%u, ppsc_h_in=%u, ppsc_w_out=%u, ppsc_h_out=%u.\n",
 		 ppsc_w_in, ppsc_h_in, ppsc_w_out, ppsc_h_out);
-
+		pr_info("spsc0_w_in=%u, spsc0_h_in=%u, spsc1_w_in=%u, spsc1_h_in=%u.\n",
+		 next_frame_par->spsc0_w_in, next_frame_par->spsc0_h_in,
+		 next_frame_par->spsc1_w_in, next_frame_par->spsc1_h_in);
+	}
 	/* vpp_set_ppsclaer(src_width,src_height,ppsc_w_in,
 	* ppsc_h_in,vinfo,vpp_flags,next_frame_par); */
 	/* cause the next_frame_par amlost were set at ppsclaer,
 	and new supper scaler maybe need to change the param . */
-	if ((next_frame_par->supscl_path == sup0_sp1_pp_scpath)
+	if ((next_frame_par->supscl_path == sup0_pp_post_blender)
 		&& (next_frame_par->supsc1_enable)) {
 		next_frame_par->VPP_hd_start_lines_ >>=
 			next_frame_par->supsc1_hori_ratio;
@@ -1310,8 +1778,8 @@ static void vpp_set_scaler(u32 src_width,
 	}
 	if (next_frame_par->supscl_path == sup0_pp_sp1_scpath) {
 		/* zoom in the under parm because super scaler1 is open */
-		next_frame_par->VPP_hsc_startp <<= next_frame_par->
-			supsc1_hori_ratio;
+		next_frame_par->VPP_hsc_startp <<=
+			next_frame_par->supsc1_hori_ratio;
 		next_frame_par->VPP_hsc_endp = (next_frame_par->VPP_hsc_endp <<
 			next_frame_par->supsc1_hori_ratio) +
 			next_frame_par->supsc1_hori_ratio;
@@ -1325,8 +1793,9 @@ static void vpp_set_scaler(u32 src_width,
 		next_frame_par->VPP_vsc_startp <<=
 			next_frame_par->supsc1_vert_ratio;
 		next_frame_par->VPP_vsc_endp =
-			(next_frame_par->VPP_vsc_endp << next_frame_par->
-			supsc1_vert_ratio) + next_frame_par->supsc1_vert_ratio;
+			(next_frame_par->VPP_vsc_endp <<
+			next_frame_par->supsc1_vert_ratio) +
+			next_frame_par->supsc1_vert_ratio;
 	}
 
 	if (h_crop_enable) {
@@ -1341,17 +1810,46 @@ static void vpp_set_scaler(u32 src_width,
 
 }
 
-#endif
 #ifdef TV_3D_FUNCTION_OPEN
-
+void get_vpp_3d_mode(u32 trans_fmt, u32 *vpp_3d_mode)
+{
+	switch (trans_fmt) {
+	case TVIN_TFMT_3D_LRH_OLOR:
+	case TVIN_TFMT_3D_LRH_OLER:
+	case TVIN_TFMT_3D_LRH_ELOR:
+	case TVIN_TFMT_3D_LRH_ELER:
+	case TVIN_TFMT_3D_DET_LR:
+		*vpp_3d_mode = VPP_3D_MODE_LR;
+		break;
+	case TVIN_TFMT_3D_FP:
+	case TVIN_TFMT_3D_TB:
+	case TVIN_TFMT_3D_DET_TB:
+	case TVIN_TFMT_3D_FA:
+		*vpp_3d_mode = VPP_3D_MODE_TB;
+		break;
+	case TVIN_TFMT_3D_LA:
+	case TVIN_TFMT_3D_DET_INTERLACE:
+		*vpp_3d_mode = VPP_3D_MODE_LA;
+		break;
+	case TVIN_TFMT_3D_DET_CHESSBOARD:
+	default:
+		*vpp_3d_mode = VPP_3D_MODE_NULL;
+		break;
+	}
+}
 static void
 vpp_get_video_source_size(u32 *src_width, u32 *src_height,
 	u32 process_3d_type, struct vframe_s *vf,
 	struct vpp_frame_par_s *next_frame_par)
 {
 
-	if (process_3d_type & MODE_3D_AUTO) {
-
+	if ((process_3d_type & MODE_3D_AUTO) ||
+	(((process_3d_type & MODE_3D_TO_2D_R) ||
+	(process_3d_type & MODE_3D_TO_2D_L) ||
+	(process_3d_type & MODE_3D_LR_SWITCH) ||
+	(process_3d_type & MODE_FORCE_3D_TO_2D_TB) ||
+	(process_3d_type & MODE_FORCE_3D_TO_2D_LR)) &&
+	(process_3d_type & MODE_3D_ENABLE))) {
 		if (vf->trans_fmt) {
 			if (process_3d_type & MODE_3D_TO_2D_MASK)
 				*src_height = vf->left_eye.height;
@@ -1391,7 +1889,7 @@ vpp_get_video_source_size(u32 *src_width, u32 *src_height,
 			*src_width = vf->width;
 			*src_height = vf->height;
 			next_frame_par->vpp_3d_mode = VPP_3D_MODE_NULL;
-			next_frame_par->vpp_3d_scale = 1;
+			next_frame_par->vpp_3d_scale = 0;
 			next_frame_par->vpp_2pic_mode = 0;
 			break;
 		}
@@ -1466,13 +1964,17 @@ vpp_get_video_source_size(u32 *src_width, u32 *src_height,
 	}
 	/*process 3d->2d or l/r switch case */
 	if ((VPP_3D_MODE_NULL != next_frame_par->vpp_3d_mode) &&
-		(VPP_3D_MODE_LA != next_frame_par->vpp_3d_mode)) {
+		(VPP_3D_MODE_LA != next_frame_par->vpp_3d_mode)
+		&& (process_3d_type & MODE_3D_ENABLE)) {
 		if (process_3d_type & MODE_3D_TO_2D_R)
 			next_frame_par->vpp_2pic_mode = VPP_SELECT_PIC1;
 		else if (process_3d_type & MODE_3D_TO_2D_L)
 			next_frame_par->vpp_2pic_mode = VPP_SELECT_PIC0;
 		else if (process_3d_type & MODE_3D_LR_SWITCH)
 			next_frame_par->vpp_2pic_mode |= VPP_PIC1_FIRST;
+		if ((process_3d_type & MODE_FORCE_3D_TO_2D_LR) ||
+		(process_3d_type & MODE_FORCE_3D_TO_2D_TB))
+			next_frame_par->vpp_2pic_mode = VPP_SELECT_PIC0;
 
 		/*only display one pic */
 		if ((next_frame_par->vpp_2pic_mode & 0x3) == 0)
@@ -1515,13 +2017,20 @@ vpp_set_filters(u32 process_3d_type, u32 wide_mode,
 		vpp_get_video_source_size(&src_width, &src_height,
 			process_3d_type, vf, next_frame_par);
 	} else {
-		src_width = vf->width;
-	src_height = vf->height;
+		if (vf->type & VIDTYPE_COMPRESS) {
+			src_width = vf->compWidth;
+			src_height = vf->compHeight;
+		} else {
+			src_width = vf->width;
+			src_height = vf->height;
+		}
 		next_frame_par->vpp_3d_mode = VPP_3D_MODE_NULL;
 		next_frame_par->vpp_2pic_mode = 0;
 		next_frame_par->vpp_3d_scale = 0;
 	}
-
+	next_frame_par->trans_fmt = vf->trans_fmt;
+	get_vpp_3d_mode(next_frame_par->trans_fmt,
+		&next_frame_par->vpp_3d_mode);
 	if (vpp_3d_scale)
 		next_frame_par->vpp_3d_scale = 1;
 	amlog_mask(LOG_MASK_VPP, "%s: src_width %u,src_height %u.\n", __func__,
@@ -1557,9 +2066,25 @@ vpp_set_filters(u32 process_3d_type, u32 wide_mode,
 	if (vf->type & VIDTYPE_VSCALE_DISABLE)
 		vpp_flags |= VPP_FLAG_VSCALE_DISABLE;
 #ifndef TV_3D_FUNCTION_OPEN
-	src_width = vf->width;
-	src_height = vf->height;
+	if (vf->type & VIDTYPE_COMPRESS) {
+		src_width = vf->compWidth;
+		src_height = vf->compHeight;
+	} else {
+		src_width = vf->width;
+		src_height = vf->height;
+	}
 #endif
+	if (vf->type & VIDTYPE_MVC) {
+		video_source_crop_top = 0;
+		video_source_crop_left = 0;
+		video_source_crop_bottom = 0;
+		video_source_crop_right = 0;
+	} else {
+		video_source_crop_top = video_crop_top_resv;
+		video_source_crop_left = video_crop_left_resv;
+		video_source_crop_bottom = video_crop_bottom_resv;
+		video_source_crop_right = video_crop_right_resv;
+	}
 	vpp_wide_mode = wide_mode;
 	vpp_flags |= wide_mode | (aspect_ratio << VPP_FLAG_AR_BITS);
 
@@ -1570,42 +2095,50 @@ vpp_set_filters(u32 process_3d_type, u32 wide_mode,
 	next_frame_par->VPP_post_blend_vd_h_end_ = vinfo->width - 1;
 	next_frame_par->VPP_post_blend_h_size_ = vinfo->width;
 
-#ifdef SUPER_SCALER_OPEN
-	if (super_scaler
-		&& (vpp_wide_mode != VIDEO_WIDEOPTION_NORMAL_NOSCALEUP)) {
-		next_frame_par->supscl_path = scaler_path_sel;
-		vpp_set_scaler(src_width, src_height,
-			vinfo, vpp_flags, next_frame_par, vf);
-	} else {
-		next_frame_par->supsc0_enable = 0;
-		next_frame_par->supsc0_hori_ratio = 0;
-		next_frame_par->supsc0_vert_ratio = 0;
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
+		if (super_scaler &&
+		(vpp_wide_mode != VIDEO_WIDEOPTION_NORMAL_NOSCALEUP)
+		&& (!(vf->type & VIDTYPE_PIC))
+		&& ((video_layer_width + video_layer_left) <= vinfo->width)) {
+			next_frame_par->supscl_path = scaler_path_sel;
+			vpp_set_scaler(process_3d_type, src_width, src_height,
+				vinfo, vpp_flags, next_frame_par, vf);
+		} else {
+			next_frame_par->supsc0_enable = 0;
+			next_frame_par->supsc0_hori_ratio = 0;
+			next_frame_par->supsc0_vert_ratio = 0;
 
 		next_frame_par->supsc1_enable = 0;
 		next_frame_par->supsc1_hori_ratio = 0;
 		next_frame_par->supsc1_vert_ratio = 0;
-		vpp_set_super_sclaer_regs(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-				0);	/* disable super scaler */
-		vpp_set_filters2(src_width, src_height, vinfo->width,
-				vinfo->height, vinfo, vpp_flags,
-				next_frame_par, vf);
-	}
-	if (super_debug)
-		pr_info("VPP_hd_start_lines= %d,%d,%d,%d, %d,%d,%d,%d, %d,%d\n",
-		 next_frame_par->VPP_hd_start_lines_,
-		 next_frame_par->VPP_hd_end_lines_,
-		 next_frame_par->VPP_vd_start_lines_,
-		 next_frame_par->VPP_vd_end_lines_,
-		 next_frame_par->VPP_hsc_startp,
-		 next_frame_par->VPP_hsc_endp,
-		 next_frame_par->VPP_hsc_linear_startp,
-		 next_frame_par->VPP_hsc_linear_endp,
-		 next_frame_par->VPP_vsc_startp,
-		 next_frame_par->VPP_vsc_endp);
-#else
-	vpp_set_filters2(src_width, src_height, vinfo->width, vinfo->height,
+
+		next_frame_par->spsc0_w_in = src_width;
+		next_frame_par->spsc0_h_in = src_height;
+		next_frame_par->spsc1_w_in = vinfo->width;
+		next_frame_par->spsc1_h_in = vinfo->height;
+
+		vpp_set_filters2(process_3d_type, src_width,
+		src_height, vinfo->width,
+		vinfo->height, vinfo, vpp_flags,
+		next_frame_par, vf);
+		}
+		if (super_debug)
+			pr_info("VPP_hd_start_lines= %d,%d,%d,%d, %d,%d,%d,%d, %d,%d\n",
+			 next_frame_par->VPP_hd_start_lines_,
+			 next_frame_par->VPP_hd_end_lines_,
+			 next_frame_par->VPP_vd_start_lines_,
+			 next_frame_par->VPP_vd_end_lines_,
+			 next_frame_par->VPP_hsc_startp,
+			 next_frame_par->VPP_hsc_endp,
+			 next_frame_par->VPP_hsc_linear_startp,
+			 next_frame_par->VPP_hsc_linear_endp,
+			 next_frame_par->VPP_vsc_startp,
+			 next_frame_par->VPP_vsc_endp);
+	} else {
+		vpp_set_filters2(process_3d_type, src_width, src_height,
+			vinfo->width, vinfo->height,
 			vinfo, vpp_flags, next_frame_par, vf);
-#endif
+	}
 }
 
 void prot_get_parameter(u32 wide_mode,
@@ -1617,6 +2150,7 @@ void prot_get_parameter(u32 wide_mode,
 	u32 src_height = 0;
 	u32 vpp_flags = 0;
 	u32 aspect_ratio = 0;
+	u32 process_3d_type = VPP_3D_MODE_NULL;
 
 	BUG_ON(vinfo == NULL);
 
@@ -1664,12 +2198,15 @@ void prot_get_parameter(u32 wide_mode,
 	if (vinfo->field_height != vinfo->height)
 		vpp_flags |= VPP_FLAG_INTERLACE_OUT;
 
-	next_frame_par->VPP_post_blend_vd_v_end_ = vinfo->field_height - 1;
-	next_frame_par->VPP_post_blend_vd_h_end_ = vinfo->width - 1;
+	next_frame_par->VPP_post_blend_vd_v_end_ =
+	vinfo->field_height - 1;
+	next_frame_par->VPP_post_blend_vd_h_end_ =
+	vinfo->width - 1;
 	next_frame_par->VPP_post_blend_h_size_ = vinfo->width;
 
-	vpp_set_filters2(src_width, src_height, vinfo->width, vinfo->height,
-					 vinfo, vpp_flags, next_frame_par, vf);
+	vpp_set_filters2(process_3d_type, src_width, src_height,
+	vinfo->width, vinfo->height,
+	vinfo, vpp_flags, next_frame_par, vf);
 }
 
 void vpp_set_osd_layer_preblend(u32 *enable)
@@ -1694,18 +2231,18 @@ void vpp_set_osd_layer_position(s32 *para)
 
 void vpp_set_video_source_crop(u32 t, u32 l, u32 b, u32 r)
 {
-	video_source_crop_top = t;
-	video_source_crop_left = l;
-	video_source_crop_bottom = b;
-	video_source_crop_right = r;
+	video_crop_top_resv = t;
+	video_crop_left_resv = l;
+	video_crop_bottom_resv = b;
+	video_crop_right_resv = r;
 }
 
 void vpp_get_video_source_crop(u32 *t, u32 *l, u32 *b, u32 *r)
 {
-	*t = video_source_crop_top;
-	*l = video_source_crop_left;
-	*b = video_source_crop_bottom;
-	*r = video_source_crop_right;
+	*t = video_crop_top_resv;
+	*l = video_crop_left_resv;
+	*b = video_crop_bottom_resv;
+	*r = video_crop_right_resv;
 }
 
 void vpp_set_video_layer_position(s32 x, s32 y, s32 w, s32 h)
@@ -1781,3 +2318,15 @@ void vpp_set_3d_scale(bool enable)
 	vpp_3d_scale = enable;
 }
 #endif
+
+void vpp_super_scaler_support(void)
+{
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+		(get_cpu_type() == MESON_CPU_MAJOR_ID_TXL))
+		super_scaler = 1;
+	else
+		super_scaler = 0;
+}
+
+
+
diff --git a/drivers/amlogic/amports/vpp.h b/drivers/amlogic/amports/vpp.h
index 47b42cb..3e35c16 100644
--- a/drivers/amlogic/amports/vpp.h
+++ b/drivers/amlogic/amports/vpp.h
@@ -68,6 +68,12 @@ struct vppfilter_mode_s {
 	u32 vpp_sc_misc_;
 	u32 vpp_vsc_start_phase_step;
 	u32 vpp_hsc_start_phase_step;
+	bool vpp_pre_vsc_en;
+	bool vpp_pre_hsc_en;
+	u32 vpp_vert_filter;
+	u32 vpp_horz_filter;
+	const u32 *vpp_vert_chroma_coeff;
+	u32 vpp_vert_chroma_filter_en;
 };
 
 struct vpp_filters_s {
@@ -107,6 +113,7 @@ struct vpp_frame_par_s {
 	u32 vscale_skip_count;
 	u32 hscale_skip_count;
 	u32 vpp_3d_mode;
+	u32 trans_fmt;
 	u32 vpp_2pic_mode;
 	/* bit[1:0] 0: 1 pic,1:two pic one buf,2:tow pic two buf */
 	/* bit[2]0:select pic0,1:select pic1 */
@@ -120,24 +127,34 @@ struct vpp_frame_par_s {
 	u32 supsc1_hori_ratio;
 	u32 supsc0_vert_ratio;
 	u32 supsc1_vert_ratio;
+	u32 spsc0_w_in;
+	u32 spsc0_h_in;
+	u32 spsc1_w_in;
+	u32 spsc1_h_in;
+
+	bool nocomp;
+
 };
 
-#if 0
+#if 1
 /* (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||
 (MESON_CPU_TYPE==MESON_CPU_TYPE_MESONG9TV) */
 #define TV_3D_FUNCTION_OPEN
-#define TV_REVERSE
 #endif
 
-#if 0	/* (MESON_CPU_TYPE==MESON_CPU_TYPE_MESONG9TV) */
-#define SUPER_SCALER_OPEN
+#define TV_REVERSE
+
+#ifdef TV_REVERSE
+extern bool reverse;
+#endif
+extern bool platform_type;
 enum select_scaler_path_e {
-	sup0_sp1_pp_scpath,
-	sup0_pp_sp1_scpath
+	sup0_pp_sp1_scpath,
+	sup0_pp_post_blender,
 };
-#define SUPER_CORE0_WIDTH_MAX  1024
-#define SUPER_CORE1_WIDTH_MAX  2048
-#endif
+#define SUPER_CORE0_WIDTH_MAX  2048
+#define SUPER_CORE1_WIDTH_MAX  4096
+
 
 #ifdef TV_3D_FUNCTION_OPEN
 
@@ -155,6 +172,8 @@ enum select_scaler_path_e {
 #define MODE_3D_MVC	    0x00000800
 #define MODE_3D_OUT_TB	0x00010000
 #define MODE_3D_OUT_LR	0x00020000
+#define MODE_FORCE_3D_TO_2D_LR	0x00100000
+#define MODE_FORCE_3D_TO_2D_TB	0x00200000
 
 /*when the output mode is field alterlative*/
 /* LRLRLRLRL mode */
@@ -169,7 +188,8 @@ enum select_scaler_path_e {
 	MODE_3D_OUT_FA_R_FIRST|MODE_3D_OUT_FA_LB_FIRST|MODE_3D_OUT_FA_RB_FIRST)
 
 #define MODE_3D_TO_2D_MASK  \
-	(MODE_3D_TO_2D_L|MODE_3D_TO_2D_R|MODE_3D_OUT_FA_MASK)
+	(MODE_3D_TO_2D_L|MODE_3D_TO_2D_R|MODE_3D_OUT_FA_MASK | \
+	MODE_FORCE_3D_TO_2D_LR | MODE_FORCE_3D_TO_2D_TB)
 
 #define VPP_3D_MODE_NULL 0x0
 #define VPP_3D_MODE_LR   0x1
@@ -185,7 +205,8 @@ enum select_scaler_path_e {
 
 extern
 void vpp_set_3d_scale(bool enable);
-
+extern
+void get_vpp_3d_mode(u32 trans_fmt, u32 *vpp_3d_mode);
 #endif
 
 extern void
@@ -225,6 +246,8 @@ void vpp_set_video_speed_check(u32 h, u32 w);
 extern
 void vpp_get_video_speed_check(u32 *h, u32 *w);
 
+extern
+void vpp_super_scaler_support(void);
 
 #ifdef CONFIG_AM_VIDEO2
 extern void
@@ -241,4 +264,16 @@ extern void vpp2_set_zoom_ratio(u32 r);
 extern u32 vpp2_get_zoom_ratio(void);
 #endif
 
+extern int vpp_set_super_scaler_regs(int scaler_path_sel,
+		int reg_srscl0_enable,
+		int reg_srscl0_hsize,
+		int reg_srscl0_vsize,
+		int reg_srscl0_hori_ratio,
+		int reg_srscl0_vert_ratio,
+		int reg_srscl1_enable,
+		int reg_srscl1_hsize,
+		int reg_srscl1_vsize,
+		int reg_srscl1_hori_ratio,
+		int reg_srscl1_vert_ratio);
+
 #endif				/* VPP_H */
diff --git a/drivers/amlogic/amports/vreal.c b/drivers/amlogic/amports/vreal.c
index 5f1a4c8..822d3ee 100644
--- a/drivers/amlogic/amports/vreal.c
+++ b/drivers/amlogic/amports/vreal.c
@@ -317,6 +317,7 @@ static irqreturn_t vreal_isr(int irq, void *dev_id)
 		/* pr_info("pts %d, picture type %d\n", vf->pts, pictype); */
 
 		info = READ_VREG(RV_PIC_INFO);
+		vf->signal_type = 0;
 		vf->index = buffer_index;
 		vf->width = info >> 16;
 		vf->height = (info >> 4) & 0xfff;
@@ -333,6 +334,7 @@ static irqreturn_t vreal_isr(int irq, void *dev_id)
 #endif
 		vf->canvas0Addr = vf->canvas1Addr = index2canvas(buffer_index);
 		vf->orientation = 0;
+		vf->type_original = vf->type;
 
 		vfbuf_use[buffer_index] = 1;
 
@@ -464,9 +466,10 @@ static void vreal_put_timer_func(unsigned long arg)
 	while (!kfifo_is_empty(&recycle_q) && (READ_VREG(TO_AMRISC) == 0)) {
 		struct vframe_s *vf;
 		if (kfifo_get(&recycle_q, &vf)) {
-			if ((vf->index >= 0) && (--vfbuf_use[vf->index] == 0)) {
+			if ((vf->index >= 0) && (vf->index < VF_BUF_NUM)
+				&& (--vfbuf_use[vf->index] == 0)) {
 				WRITE_VREG(TO_AMRISC, ~(1 << vf->index));
-				vf->index = -1;
+				vf->index = VF_BUF_NUM;
 			}
 
 			kfifo_put(&newframe_q, (const struct vframe_s *)vf);
@@ -678,7 +681,7 @@ static void vreal_local_init(void)
 
 	for (i = 0; i < VF_POOL_SIZE; i++) {
 		const struct vframe_s *vf = &vfpool[i];
-		vfpool[i].index = -1;
+		vfpool[i].index = VF_BUF_NUM;
 		kfifo_put(&newframe_q, vf);
 	}
 
@@ -954,10 +957,10 @@ static struct codec_profile_t amvdec_real_profile = {
 
 static int __init amvdec_real_driver_init_module(void)
 {
-	pr_info("amvdec_real module init\n");
+	pr_debug("amvdec_real module init\n");
 
 	if (platform_driver_register(&amvdec_real_driver)) {
-		pr_info("failed to register amvdec_real driver\n");
+		pr_err("failed to register amvdec_real driver\n");
 		return -ENODEV;
 	}
 	vcodec_profile_register(&amvdec_real_profile);
@@ -966,7 +969,7 @@ static int __init amvdec_real_driver_init_module(void)
 
 static void __exit amvdec_real_driver_remove_module(void)
 {
-	pr_info("amvdec_real module remove.\n");
+	pr_debug("amvdec_real module remove.\n");
 
 	platform_driver_unregister(&amvdec_real_driver);
 }
diff --git a/drivers/amlogic/amports/vvc1.c b/drivers/amlogic/amports/vvc1.c
index af91496..689b19c 100644
--- a/drivers/amlogic/amports/vvc1.c
+++ b/drivers/amlogic/amports/vvc1.c
@@ -389,6 +389,8 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 
 		if (frm.state != RATE_MEASURE_DONE)
 			frm.num += (repeat_count > 1) ? repeat_count : 1;
+		if (0 == vvc1_amstream_dec_info.rate)
+			vvc1_amstream_dec_info.rate = PTS2DUR(frm.rate);
 
 		if (reg & INTERLACE_FLAG) {	/* interlace */
 			if (kfifo_get(&newframe_q, &vf) == 0) {
@@ -396,7 +398,7 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 				("fatal error, no available buffer slot.");
 				return IRQ_HANDLED;
 			}
-
+			vf->signal_type = 0;
 			vf->index = buffer_index;
 			vf->width = vvc1_amstream_dec_info.width;
 			vf->height = vvc1_amstream_dec_info.height;
@@ -457,6 +459,7 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 			vf->canvas0Addr = vf->canvas1Addr =
 						index2canvas(buffer_index);
 			vf->orientation = 0;
+			vf->type_original = vf->type;
 			set_aspect_ratio(vf, READ_VREG(VC1_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
@@ -473,7 +476,7 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 				("fatal error, no available buffer slot.");
 				return IRQ_HANDLED;
 			}
-
+			vf->signal_type = 0;
 			vf->index = buffer_index;
 			vf->width = vvc1_amstream_dec_info.width;
 			vf->height = vvc1_amstream_dec_info.height;
@@ -504,13 +507,14 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 
 			vf->duration_pulldown = 0;
 			vf->type = (reg & BOTTOM_FIELD_FIRST_FLAG) ?
-			VIDTYPE_INTERLACE_BOTTOM : VIDTYPE_INTERLACE_TOP;
+			VIDTYPE_INTERLACE_TOP : VIDTYPE_INTERLACE_BOTTOM;
 #ifdef NV21
 			vf->type |= VIDTYPE_VIU_NV21;
 #endif
 			vf->canvas0Addr = vf->canvas1Addr =
 					index2canvas(buffer_index);
 			vf->orientation = 0;
+			vf->type_original = vf->type;
 			set_aspect_ratio(vf, READ_VREG(VC1_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
@@ -527,7 +531,7 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 				("fatal error, no available buffer slot.");
 				return IRQ_HANDLED;
 			}
-
+			vf->signal_type = 0;
 			vf->index = buffer_index;
 			vf->width = vvc1_amstream_dec_info.width;
 			vf->height = vvc1_amstream_dec_info.height;
@@ -591,6 +595,7 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 			vf->canvas0Addr = vf->canvas1Addr =
 						index2canvas(buffer_index);
 			vf->orientation = 0;
+			vf->type_original = vf->type;
 			set_aspect_ratio(vf, READ_VREG(VC1_PIC_RATIO));
 
 			vfbuf_use[buffer_index]++;
@@ -1114,10 +1119,10 @@ static struct codec_profile_t amvdec_vc1_profile = {
 
 static int __init amvdec_vc1_driver_init_module(void)
 {
-	pr_info("amvdec_vc1 module init\n");
+	pr_debug("amvdec_vc1 module init\n");
 
 	if (platform_driver_register(&amvdec_vc1_driver)) {
-		pr_info("failed to register amvdec_vc1 driver\n");
+		pr_err("failed to register amvdec_vc1 driver\n");
 		return -ENODEV;
 	}
 	vcodec_profile_register(&amvdec_vc1_profile);
@@ -1126,7 +1131,7 @@ static int __init amvdec_vc1_driver_init_module(void)
 
 static void __exit amvdec_vc1_driver_remove_module(void)
 {
-	pr_info("amvdec_vc1 module remove.\n");
+	pr_debug("amvdec_vc1 module remove.\n");
 
 	platform_driver_unregister(&amvdec_vc1_driver);
 }
diff --git a/drivers/amlogic/amports/vvp9.c b/drivers/amlogic/amports/vvp9.c
new file mode 100644
index 0000000..d129327
--- /dev/null
+++ b/drivers/amlogic/amports/vvp9.c
@@ -0,0 +1,5987 @@
+ /*
+ * drivers/amlogic/amports/vvp9.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/vformat.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+#include <linux/slab.h>
+#include "amports_priv.h"
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
+#define MEM_NAME "codec_vp9"
+/* #include <mach/am_regs.h> */
+#include "vdec_reg.h"
+
+#include "vdec.h"
+#include "amvdec.h"
+
+#define MIX_STREAM_SUPPORT
+#define SUPPORT_4K2K
+/*#define VP9_10B_MMU*/
+
+#include "vvp9.h"
+#define VP9D_MPP_REFINFO_TBL_ACCCONFIG             0x3442
+#define VP9D_MPP_REFINFO_DATA                      0x3443
+#define VP9D_MPP_REF_SCALE_ENBL                    0x3441
+#define HEVC_MPRED_CTRL4                           0x324c
+#define HEVC_CM_HEADER_START_ADDR                  0x3628
+#define HEVC_DBLK_CFGB                             0x350b
+#define HEVCD_MPP_ANC2AXI_TBL_DATA                 0x3464
+#define HEVC_SAO_MMU_VH1_ADDR                      0x363b
+#define HEVC_SAO_MMU_VH0_ADDR                      0x363a
+#define HEVC_SAO_MMU_STATUS                        0x3639
+
+
+#define VP9_10B_DEC_IDLE                           0
+#define VP9_10B_DEC_FRAME_HEADER                   1
+#define VP9_10B_DEC_SLICE_SEGMENT                  2
+#define VP9_10B_DECODE_SLICE                     5
+#define VP9_10B_DISCARD_NAL                  6
+#define VP9_DUMP_LMEM                7
+#define VP9_HEAD_PARSER_DONE            0xf0
+#define VP9_HEAD_SEARCH_DONE          0xf1
+#define VP9_EOS                        0xf2
+#define HEVC_ACTION_DONE                0xff
+
+#define MAX_BUF_NUM 24
+#define MAX_REF_ACTIVE  16
+#define VF_POOL_SIZE        32
+
+#undef pr_info
+#define pr_info printk
+
+/*---------------------------------------------------
+ Include "parser_cmd.h"
+---------------------------------------------------*/
+#define PARSER_CMD_SKIP_CFG_0 0x0000090b
+
+#define PARSER_CMD_SKIP_CFG_1 0x1b14140f
+
+#define PARSER_CMD_SKIP_CFG_2 0x001b1910
+
+#define PARSER_CMD_NUMBER 37
+
+unsigned short parser_cmd[PARSER_CMD_NUMBER] = {
+0x0401,
+0x8401,
+0x0800,
+0x0402,
+0x9002,
+0x1423,
+0x8CC3,
+0x1423,
+0x8804,
+0x9825,
+0x0800,
+0x04FE,
+0x8406,
+0x8411,
+0x1800,
+0x8408,
+0x8409,
+0x8C2A,
+0x9C2B,
+0x1C00,
+0x840F,
+0x8407,
+0x8000,
+0x8408,
+0x2000,
+0xA800,
+0x8410,
+0x04DE,
+0x840C,
+0x840D,
+0xAC00,
+0xA000,
+0x08C0,
+0x08E0,
+0xA40E,
+0xFC00,
+0x7C00
+};
+/*#define HEVC_PIC_STRUCT_SUPPORT*/
+/* to remove, fix build error */
+
+/*#define CODEC_MM_FLAGS_FOR_VDECODER  0*/
+
+
+#define SUPPORT_10BIT
+/* #define ERROR_HANDLE_DEBUG */
+#if 0 /* MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B*/
+#undef SUPPORT_4K2K
+#else
+#define SUPPORT_4K2K
+#endif
+
+#ifndef STAT_KTHREAD
+#define STAT_KTHREAD 0x40
+#endif
+
+#define DRIVER_NAME "amvdec_vp9"
+#define MODULE_NAME "amvdec_vp9"
+
+#define PUT_INTERVAL        (HZ/100)
+#define ERROR_SYSTEM_RESET_COUNT   200
+
+#define PTS_NORMAL                0
+#define PTS_NONE_REF_USE_DURATION 1
+
+#define PTS_MODE_SWITCHING_THRESHOLD           3
+#define PTS_MODE_SWITCHING_RECOVERY_THREASHOLD 3
+
+#define DUR2PTS(x) ((x)*90/96)
+
+struct VP9Decoder_s;
+static int vvp9_vf_states(struct vframe_states *states, void *);
+static struct vframe_s *vvp9_vf_peek(void *);
+static struct vframe_s *vvp9_vf_get(void *);
+static void vvp9_vf_put(struct vframe_s *, void *);
+static int vvp9_event_cb(int type, void *data, void *private_data);
+
+static int vvp9_stop(struct VP9Decoder_s *pbi);
+static s32 vvp9_init(struct VP9Decoder_s *pbi);
+static void vvp9_prot_init(struct VP9Decoder_s *pbi);
+static int vvp9_local_init(struct VP9Decoder_s *pbi);
+static void vvp9_put_timer_func(unsigned long arg);
+
+
+static const char vvp9_dec_id[] = "vvp9-dev";
+
+#define PROVIDER_NAME   "decoder.vp9"
+
+static const struct vframe_operations_s vvp9_vf_provider = {
+	.peek = vvp9_vf_peek,
+	.get = vvp9_vf_get,
+	.put = vvp9_vf_put,
+	.event_cb = vvp9_event_cb,
+	.vf_states = vvp9_vf_states,
+};
+
+static struct vframe_provider_s vvp9_vf_prov;
+
+static u32 bit_depth_luma;
+static u32 bit_depth_chroma;
+static u32 frame_width;
+static u32 frame_height;
+static u32 video_signal_type;
+static u32 pts_unstable;
+
+
+#define PROB_SIZE    (496 * 2 * 4)
+#define PROB_BUF_SIZE    (0x5000)
+#define COUNT_BUF_SIZE   (0x300 * 4 * 4)
+/*compute_losless_comp_body_size(4096, 2304, 1) = 18874368(0x1200000)*/
+#define MAX_FRAME_4K_NUM 0x1200
+#define FRAME_MMU_MAP_SIZE  (MAX_FRAME_4K_NUM * 4)
+
+static inline int div_r32(int64_t m, int n)
+{
+/*
+return (int)(m/n)
+*/
+#ifndef CONFIG_ARM64
+	do_div(m, n);
+	return (int)m;
+#else
+	return (int)(m/n);
+#endif
+}
+
+
+/*USE_BUF_BLOCK*/
+struct BUF_s {
+	int index;
+	unsigned int alloc_flag;
+	/*buffer */
+	unsigned int cma_page_count;
+	unsigned long alloc_addr;
+	unsigned long start_adr;
+	unsigned int size;
+
+	unsigned int free_start_adr;
+} /*BUF_t */;
+
+
+	/* #undef BUFMGR_ONLY to enable hardware configuration */
+
+/*#define TEST_WR_PTR_INC*/
+#define WR_PTR_INC_NUM 128
+
+#define SIMULATION
+#define DOS_PROJECT
+#undef MEMORY_MAP_IN_REAL_CHIP
+
+/*#undef DOS_PROJECT*/
+/*#define MEMORY_MAP_IN_REAL_CHIP*/
+
+/*#define BUFFER_MGR_ONLY*/
+/*#define CONFIG_HEVC_CLK_FORCED_ON*/
+/*#define ENABLE_SWAP_TEST*/
+#define   MCRCC_ENABLE
+
+#ifdef VP9_10B_NV21
+#define MEM_MAP_MODE 2  /* 0:linear 1:32x32 2:64x32*/
+#else
+#define MEM_MAP_MODE 0  /* 0:linear 1:32x32 2:64x32*/
+#endif
+
+#define VP9_LPF_LVL_UPDATE
+/*#define DBG_LF_PRINT*/
+
+#ifdef VP9_10B_NV21
+#else
+#define LOSLESS_COMPRESS_MODE
+#endif
+
+#define DOUBLE_WRITE_YSTART_TEMP 0x02000000
+#define DOUBLE_WRITE_CSTART_TEMP 0x02900000
+
+
+
+typedef unsigned int u32;
+typedef unsigned short u16;
+
+#define VP9_DEBUG_BUFMGR                   0x01
+#define VP9_DEBUG_BUFMGR_MORE              0x02
+#define VP9_DEBUG_UCODE                    0x04
+#define VP9_DEBUG_REG                      0x08
+#define VP9_DEBUG_MERGE			0x10
+#define VP9_DEBUG_BASIC				        0x40
+#define VP9_DEBUG_SEND_PARAM_WITH_REG      0x100
+#define VP9_DEBUG_NO_DISPLAY               0x200
+#define VP9_DEBUG_DBG_LF_PRINT             0x400
+#define VP9_DEBUG_OUT_PTS                  0x800
+#define VP9_DEBUG_VF_REF				   0x1000
+#define VP9_DEBUG_DIS_LOC_ERROR_PROC       0x10000
+#define VP9_DEBUG_DIS_SYS_ERROR_PROC   0x20000
+#define VP9_DEBUG_DUMP_PIC_LIST       0x40000
+#define VP9_DEBUG_TRIG_SLICE_SEGMENT_PROC 0x80000
+#define VP9_DEBUG_HW_RESET               0x100000
+#define VP9_DEBUG_LOAD_UCODE_FROM_FILE   0x200000
+#define VP9_DEBUG_ERROR_TRIG             0x400000
+#define VP9_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP   0x4000000
+
+
+static u32 debug;
+
+#define DEBUG_REG
+#ifdef DEBUG_REG
+void WRITE_VREG_DBG2(unsigned adr, unsigned val)
+{
+	if (debug & VP9_DEBUG_REG)
+		pr_info("%s(%x, %x)\n", __func__, adr, val);
+	if (adr != 0)
+		WRITE_VREG(adr, val);
+}
+
+#undef WRITE_VREG
+#define WRITE_VREG WRITE_VREG_DBG2
+#endif
+
+/**************************************************
+
+VP9 buffer management start
+
+***************************************************/
+#ifdef VP9_10B_MMU
+#define MMU_COMPRESS_HEADER_SIZE  0x48000
+#endif
+static DEFINE_SPINLOCK(lock);
+#define   lock_buffer_pool(pool)
+#define   unlock_buffer_pool(pool)
+#define INVALID_IDX -1  /* Invalid buffer index.*/
+
+#define RPM_BEGIN                                              0x200
+#define RPM_END                                                0x280
+
+union param_u {
+	struct {
+		unsigned short data[RPM_END - RPM_BEGIN];
+	} l;
+	struct {
+		/* from ucode lmem, do not change this struct */
+		unsigned short profile;
+		unsigned short show_existing_frame;
+		unsigned short frame_to_show_idx;
+		unsigned short frame_type; /*1 bit*/
+		unsigned short show_frame; /*1 bit*/
+		unsigned short error_resilient_mode; /*1 bit*/
+		unsigned short intra_only; /*1 bit*/
+		unsigned short display_size_present; /*1 bit*/
+		unsigned short reset_frame_context;
+		unsigned short refresh_frame_flags;
+		unsigned short width;
+		unsigned short height;
+		unsigned short display_width;
+		unsigned short display_height;
+	/*
+	bit[11:8] - ref_frame_info_0 (ref(3-bits), ref_frame_sign_bias(1-bit))
+	bit[7:4]  - ref_frame_info_1 (ref(3-bits), ref_frame_sign_bias(1-bit))
+	bit[3:0]  - ref_frame_info_2 (ref(3-bits), ref_frame_sign_bias(1-bit))
+	*/
+		unsigned short ref_info;
+		/*
+		bit[2]: same_frame_size0
+		bit[1]: same_frame_size1
+		bit[0]: same_frame_size2
+		*/
+		unsigned short same_frame_size;
+
+		unsigned short mode_ref_delta_enabled;
+		unsigned short ref_deltas[4];
+		unsigned short mode_deltas[2];
+		unsigned short filter_level;
+		unsigned short sharpness_level;
+		unsigned short bit_depth;
+		unsigned short seg_quant_info[8];
+		unsigned short seg_enabled;
+		unsigned short seg_abs_delta;
+		/* bit 15: feature enabled; bit 8, sign; bit[5:0], data */
+		unsigned short seg_lf_info[8];
+	} p;
+};
+
+
+struct vpx_codec_frame_buffer_s {
+	uint8_t *data;  /**< Pointer to the data buffer */
+	size_t size;  /**< Size of data in bytes */
+	void *priv;  /**< Frame's private data */
+};
+
+enum vpx_color_space_t {
+	VPX_CS_UNKNOWN    = 0,  /**< Unknown */
+	VPX_CS_BT_601     = 1,  /**< BT.601 */
+	VPX_CS_BT_709     = 2,  /**< BT.709 */
+	VPX_CS_SMPTE_170  = 3,  /**< SMPTE.170 */
+	VPX_CS_SMPTE_240  = 4,  /**< SMPTE.240 */
+	VPX_CS_BT_2020    = 5,  /**< BT.2020 */
+	VPX_CS_RESERVED   = 6,  /**< Reserved */
+	VPX_CS_SRGB       = 7   /**< sRGB */
+}; /**< alias for enum vpx_color_space */
+
+enum vpx_bit_depth_t {
+	VPX_BITS_8  =  8,  /**<  8 bits */
+	VPX_BITS_10 = 10,  /**< 10 bits */
+	VPX_BITS_12 = 12,  /**< 12 bits */
+};
+
+#define MAX_SLICE_NUM 1024
+struct PIC_BUFFER_CONFIG_s {
+	int index;
+	int BUF_index;
+	int comp_body_size;
+	int buf_size;
+	int vf_ref;
+	int y_canvas_index;
+	int uv_canvas_index;
+
+	int decode_idx;
+	int slice_type;
+	int num_reorder_pic;
+	int stream_offset;
+	uint8_t used_by_display;
+	uint8_t referenced;
+	uint8_t output_mark;
+	uint8_t recon_mark;
+	uint8_t output_ready;
+	uint8_t error_mark;
+	/**/
+	int slice_idx;
+	/*buffer*/
+#ifdef VP9_10B_MMU
+	unsigned long header_adr;
+#endif
+	unsigned long mpred_mv_wr_start_addr;
+	unsigned long mc_y_adr;
+	unsigned long mc_u_v_adr;
+	unsigned int dw_y_adr;
+	unsigned int dw_u_v_adr;
+	int mc_canvas_y;
+	int mc_canvas_u_v;
+
+	int lcu_total;
+	/**/
+	int   y_width;
+	int   y_height;
+	int   y_crop_width;
+	int   y_crop_height;
+	int   y_stride;
+
+	int   uv_width;
+	int   uv_height;
+	int   uv_crop_width;
+	int   uv_crop_height;
+	int   uv_stride;
+
+	int   alpha_width;
+	int   alpha_height;
+	int   alpha_stride;
+
+	uint8_t *y_buffer;
+	uint8_t *u_buffer;
+	uint8_t *v_buffer;
+	uint8_t *alpha_buffer;
+
+	uint8_t *buffer_alloc;
+	int buffer_alloc_sz;
+	int border;
+	int frame_size;
+	int subsampling_x;
+	int subsampling_y;
+	unsigned int bit_depth;
+	enum vpx_color_space_t color_space;
+
+	int corrupted;
+	int flags;
+} PIC_BUFFER_CONFIG;
+
+enum BITSTREAM_PROFILE {
+	PROFILE_0,
+	PROFILE_1,
+	PROFILE_2,
+	PROFILE_3,
+	MAX_PROFILES
+};
+
+enum FRAME_TYPE {
+	KEY_FRAME = 0,
+	INTER_FRAME = 1,
+	FRAME_TYPES,
+};
+
+enum REFERENCE_MODE {
+	SINGLE_REFERENCE      = 0,
+	COMPOUND_REFERENCE    = 1,
+	REFERENCE_MODE_SELECT = 2,
+	REFERENCE_MODES       = 3,
+};
+
+#define NONE           -1
+#define INTRA_FRAME     0
+#define LAST_FRAME      1
+#define GOLDEN_FRAME    2
+#define ALTREF_FRAME    3
+#define MAX_REF_FRAMES  4
+
+#define REFS_PER_FRAME 3
+
+#define REF_FRAMES_LOG2 3
+#define REF_FRAMES (1 << REF_FRAMES_LOG2)
+
+/*4 scratch frames for the new frames to support a maximum of 4 cores decoding
+in parallel, 3 for scaled references on the encoder.
+TODO(hkuang): Add ondemand frame buffers instead of hardcoding the number
+// of framebuffers.
+TODO(jkoleszar): These 3 extra references could probably come from the
+normal reference pool.*/
+#define FRAME_BUFFERS (REF_FRAMES + 7)
+
+#define FRAME_CONTEXTS_LOG2 2
+#define FRAME_CONTEXTS (1 << FRAME_CONTEXTS_LOG2)
+
+
+struct RefCntBuffer_s {
+	int ref_count;
+	/*MV_REF *mvs;*/
+	int mi_rows;
+	int mi_cols;
+	struct vpx_codec_frame_buffer_s raw_frame_buffer;
+	struct PIC_BUFFER_CONFIG_s buf;
+
+/*The Following variables will only be used in frame parallel decode.
+
+frame_worker_owner indicates which FrameWorker owns this buffer. NULL means
+that no FrameWorker owns, or is decoding, this buffer.
+VP9Worker *frame_worker_owner;
+
+row and col indicate which position frame has been decoded to in real
+pixel unit. They are reset to -1 when decoding begins and set to INT_MAX
+when the frame is fully decoded.*/
+	int row;
+	int col;
+} RefCntBuffer;
+
+struct RefBuffer_s {
+/*TODO(dkovalev): idx is not really required and should be removed, now it
+is used in vp9_onyxd_if.c*/
+	int idx;
+	struct PIC_BUFFER_CONFIG_s *buf;
+	/*struct scale_factors sf;*/
+} RefBuffer;
+
+struct InternalFrameBuffer_s {
+	uint8_t *data;
+	size_t size;
+	int in_use;
+} InternalFrameBuffer;
+
+struct InternalFrameBufferList_s {
+	int num_internal_frame_buffers;
+	struct InternalFrameBuffer_s *int_fb;
+} InternalFrameBufferList;
+
+struct BufferPool_s {
+/*Protect BufferPool from being accessed by several FrameWorkers at
+the same time during frame parallel decode.
+TODO(hkuang): Try to use atomic variable instead of locking the whole pool.
+
+Private data associated with the frame buffer callbacks.
+void *cb_priv;
+
+vpx_get_frame_buffer_cb_fn_t get_fb_cb;
+vpx_release_frame_buffer_cb_fn_t release_fb_cb;*/
+
+	struct RefCntBuffer_s frame_bufs[FRAME_BUFFERS];
+
+/*Frame buffers allocated internally by the codec.*/
+	struct InternalFrameBufferList_s int_frame_buffers;
+} BufferPool;
+
+struct VP9_Common_s {
+	enum vpx_color_space_t color_space;
+	int width;
+	int height;
+	int display_width;
+	int display_height;
+	int last_width;
+	int last_height;
+
+	int subsampling_x;
+	int subsampling_y;
+
+	int use_highbitdepth;/*Marks if we need to use 16bit frame buffers.*/
+
+	struct PIC_BUFFER_CONFIG_s *frame_to_show;
+	struct RefCntBuffer_s *prev_frame;
+
+	/*TODO(hkuang): Combine this with cur_buf in macroblockd.*/
+	struct RefCntBuffer_s *cur_frame;
+
+	int ref_frame_map[REF_FRAMES]; /* maps fb_idx to reference slot */
+
+	/*Prepare ref_frame_map for the next frame.
+	Only used in frame parallel decode.*/
+	int next_ref_frame_map[REF_FRAMES];
+
+	/* TODO(jkoleszar): could expand active_ref_idx to 4,
+	with 0 as intra, and roll new_fb_idx into it.*/
+
+	/*Each frame can reference REFS_PER_FRAME buffers*/
+	struct RefBuffer_s frame_refs[REFS_PER_FRAME];
+
+	int prev_fb_idx;
+	int new_fb_idx;
+
+	/*last frame's frame type for motion search*/
+	enum FRAME_TYPE last_frame_type;
+	enum FRAME_TYPE frame_type;
+
+	int show_frame;
+	int last_show_frame;
+	int show_existing_frame;
+
+	/*Flag signaling that the frame is encoded using only INTRA modes.*/
+	uint8_t intra_only;
+	uint8_t last_intra_only;
+
+	int allow_high_precision_mv;
+
+	/*Flag signaling that the frame context should be reset to default
+	values. 0 or 1 implies don't reset, 2 reset just the context
+	specified in the  frame header, 3 reset all contexts.*/
+	int reset_frame_context;
+
+	/*MBs, mb_rows/cols is in 16-pixel units; mi_rows/cols is in
+		MODE_INFO (8-pixel) units.*/
+	int MBs;
+	int mb_rows, mi_rows;
+	int mb_cols, mi_cols;
+	int mi_stride;
+
+	/*Whether to use previous frame's motion vectors for prediction.*/
+	int use_prev_frame_mvs;
+
+	int refresh_frame_context;    /* Two state 0 = NO, 1 = YES */
+
+	int ref_frame_sign_bias[MAX_REF_FRAMES];    /* Two state 0, 1 */
+
+	/*struct loopfilter lf;*/
+	/*struct segmentation seg;*/
+
+	/*TODO(hkuang):Remove this as it is the same as frame_parallel_decode*/
+	/* in pbi.*/
+	int frame_parallel_decode;  /* frame-based threading.*/
+
+	/*Context probabilities for reference frame prediction*/
+	/*MV_REFERENCE_FRAME comp_fixed_ref;*/
+	/*MV_REFERENCE_FRAME comp_var_ref[2];*/
+	enum REFERENCE_MODE reference_mode;
+
+	/*FRAME_CONTEXT *fc; */ /* this frame entropy */
+	/*FRAME_CONTEXT *frame_contexts; */  /*FRAME_CONTEXTS*/
+	/*unsigned int  frame_context_idx; *//* Context to use/update */
+	/*FRAME_COUNTS counts;*/
+
+	unsigned int current_video_frame;
+	enum BITSTREAM_PROFILE profile;
+
+	enum vpx_bit_depth_t bit_depth;
+
+	int error_resilient_mode;
+	int frame_parallel_decoding_mode;
+
+	int byte_alignment;
+	int skip_loop_filter;
+
+	/*External BufferPool passed from outside.*/
+	struct BufferPool_s *buffer_pool;
+
+	int above_context_alloc_cols;
+
+} VP9_COMMON;
+
+static void set_canvas(struct PIC_BUFFER_CONFIG_s *pic_config);
+static int prepare_display_buf(struct VP9Decoder_s *pbi,
+					struct PIC_BUFFER_CONFIG_s *pic_config);
+static int get_free_fb(struct VP9_Common_s *cm)
+{
+	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+	int i;
+
+	lock_buffer_pool(cm->buffer_pool);
+	for (i = 0; i < FRAME_BUFFERS; ++i) {
+		if (debug & VP9_DEBUG_BUFMGR_MORE)
+			pr_info("%s:%d, ref_count %d vf_ref %d used_by_d %d index %d\r\n",
+			__func__, i, frame_bufs[i].ref_count,
+			frame_bufs[i].buf.vf_ref,
+			frame_bufs[i].buf.used_by_display,
+			frame_bufs[i].buf.index);
+		if ((frame_bufs[i].ref_count == 0) &&
+			(frame_bufs[i].buf.vf_ref == 0) &&
+			(frame_bufs[i].buf.used_by_display == 0) &&
+			(frame_bufs[i].buf.index != -1)
+			)
+			break;
+	}
+	if (i != FRAME_BUFFERS) {
+		frame_bufs[i].ref_count = 1;
+		/*pr_info("[MMU DEBUG 1] set ref_count[%d] : %d\r\n",
+					i, frame_bufs[i].ref_count);*/
+	} else {
+		/* Reset i to be INVALID_IDX to indicate
+			no free buffer found*/
+		i = INVALID_IDX;
+	}
+
+	unlock_buffer_pool(cm->buffer_pool);
+	return i;
+}
+
+static unsigned char is_buffer_empty(struct VP9_Common_s *cm)
+{
+	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+	int i;
+
+	for (i = 0; i < FRAME_BUFFERS; ++i)
+		if ((frame_bufs[i].ref_count == 0) &&
+			(frame_bufs[i].buf.vf_ref == 0) &&
+			(frame_bufs[i].buf.used_by_display == 0) &&
+			(frame_bufs[i].buf.index != -1)
+			)
+			break;
+	if (i != FRAME_BUFFERS)
+		return 0;
+
+	return 1;
+}
+
+static struct PIC_BUFFER_CONFIG_s *get_frame_new_buffer(struct VP9_Common_s *cm)
+{
+	return &cm->buffer_pool->frame_bufs[cm->new_fb_idx].buf;
+}
+
+static void ref_cnt_fb(struct RefCntBuffer_s *bufs, int *idx, int new_idx)
+{
+	const int ref_index = *idx;
+
+	if (ref_index >= 0 && bufs[ref_index].ref_count > 0) {
+		bufs[ref_index].ref_count--;
+		/*pr_info("[MMU DEBUG 2] dec ref_count[%d] : %d\r\n",
+				ref_index, bufs[ref_index].ref_count);*/
+	}
+
+	*idx = new_idx;
+
+	bufs[new_idx].ref_count++;
+	/*pr_info("[MMU DEBUG 3] inc ref_count[%d] : %d\r\n",
+				new_idx, bufs[new_idx].ref_count);*/
+}
+
+int vp9_release_frame_buffer(struct vpx_codec_frame_buffer_s *fb)
+{
+	struct InternalFrameBuffer_s *const int_fb =
+				(struct InternalFrameBuffer_s *)fb->priv;
+	if (int_fb)
+		int_fb->in_use = 0;
+	return 0;
+}
+
+static void setup_display_size(struct VP9_Common_s *cm, union param_u *params,
+						int print_header_info)
+{
+	cm->display_width = cm->width;
+	cm->display_height = cm->height;
+	if (params->p.display_size_present) {
+		if (print_header_info)
+			pr_info(" * 1-bit display_size_present read : 1\n");
+		cm->display_width = params->p.display_width;
+		cm->display_height = params->p.display_height;
+		/*vp9_read_frame_size(rb, &cm->display_width,
+							&cm->display_height);*/
+	} else {
+		if (print_header_info)
+			pr_info(" * 1-bit display_size_present read : 0\n");
+	}
+}
+
+static void resize_context_buffers(struct VP9_Common_s *cm, int width,
+								int height)
+{
+	if (cm->width != width || cm->height != height) {
+		/* to do ..*/
+		cm->width = width;
+		cm->height = height;
+		pr_info("%s (%d,%d)=>(%d,%d)\r\n", __func__, cm->width,
+			cm->height, width, height);
+	}
+	/*
+	if (cm->cur_frame->mvs == NULL ||
+		cm->mi_rows > cm->cur_frame->mi_rows ||
+		cm->mi_cols > cm->cur_frame->mi_cols) {
+		resize_mv_buffer(cm);
+	}
+	*/
+}
+
+static int valid_ref_frame_size(int ref_width, int ref_height,
+				int this_width, int this_height) {
+	return 2 * this_width >= ref_width &&
+		2 * this_height >= ref_height &&
+		this_width <= 16 * ref_width &&
+		this_height <= 16 * ref_height;
+}
+
+/*
+static int valid_ref_frame_img_fmt(enum vpx_bit_depth_t ref_bit_depth,
+					int ref_xss, int ref_yss,
+					enum vpx_bit_depth_t this_bit_depth,
+					int this_xss, int this_yss) {
+	return ref_bit_depth == this_bit_depth && ref_xss == this_xss &&
+		ref_yss == this_yss;
+}
+*/
+
+static void setup_frame_size(struct VP9_Common_s *cm, union param_u *params,
+				unsigned int *mmu_index_adr,
+				int print_header_info) {
+	int width, height;
+	struct BufferPool_s * const pool = cm->buffer_pool;
+	struct PIC_BUFFER_CONFIG_s *ybf;
+	width = params->p.width;
+	height = params->p.height;
+	/*vp9_read_frame_size(rb, &width, &height);*/
+	if (print_header_info)
+		pr_info(" * 16-bits w read : %d (width : %d)\n", width, height);
+	if (print_header_info)
+		pr_info
+		(" * 16-bits h read : %d (height : %d)\n", width, height);
+
+	WRITE_VREG(HEVC_PARSER_PICTURE_SIZE, (height << 16) | width);
+
+#ifdef VP9_10B_MMU
+	/* if(cm->prev_fb_idx >= 0) release_unused_4k(cm->prev_fb_idx);*/
+	/* cm->prev_fb_idx = cm->new_fb_idx;*/
+	pr_info
+	("[DEBUG DEBUG]Before alloc_mmu, prev_fb_idx : %d, new_fb_idx : %d\r\n",
+	cm->prev_fb_idx, cm->new_fb_idx);
+	alloc_mmu(cm->new_fb_idx, params->p.width, params->p.height,
+	params->p.bit_depth, mmu_index_adr);
+#endif
+
+	resize_context_buffers(cm, width, height);
+	setup_display_size(cm, params, print_header_info);
+#if 0
+	lock_buffer_pool(pool);
+	if (vp9_realloc_frame_buffer(
+		get_frame_new_buffer(cm), cm->width, cm->height,
+		cm->subsampling_x, cm->subsampling_y,
+#if CONFIG_VP9_HIGHBITDEPTH
+		cm->use_highbitdepth,
+#endif
+		VP9_DEC_BORDER_IN_PIXELS,
+		cm->byte_alignment,
+		&pool->frame_bufs[cm->new_fb_idx].raw_frame_buffer,
+		pool->get_fb_cb, pool->cb_priv)) {
+		unlock_buffer_pool(pool);
+		vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,
+			"Failed to allocate frame buffer");
+	}
+	unlock_buffer_pool(pool);
+#else
+	/* porting */
+	ybf = get_frame_new_buffer(cm);
+	ybf->y_crop_width = width;
+	ybf->y_crop_height = height;
+	ybf->bit_depth = params->p.bit_depth;
+#endif
+	pool->frame_bufs[cm->new_fb_idx].buf.subsampling_x = cm->subsampling_x;
+	pool->frame_bufs[cm->new_fb_idx].buf.subsampling_y = cm->subsampling_y;
+	pool->frame_bufs[cm->new_fb_idx].buf.bit_depth =
+						(unsigned int)cm->bit_depth;
+	pool->frame_bufs[cm->new_fb_idx].buf.color_space = cm->color_space;
+}
+
+static int setup_frame_size_with_refs(struct VP9_Common_s *cm,
+					union param_u *params,
+					unsigned int *mmu_index_adr,
+					int print_header_info) {
+	int width, height;
+	int found = 0, i;
+	int has_valid_ref_frame = 0;
+	struct PIC_BUFFER_CONFIG_s *ybf;
+	struct BufferPool_s * const pool = cm->buffer_pool;
+	for (i = 0; i < REFS_PER_FRAME; ++i) {
+		if ((params->p.same_frame_size >>
+				(REFS_PER_FRAME - i - 1)) & 0x1) {
+			struct PIC_BUFFER_CONFIG_s *const buf =
+							cm->frame_refs[i].buf;
+			/*if (print_header_info)
+				pr_info
+				("1-bit same_frame_size[%d] read : 1\n", i);*/
+				width = buf->y_crop_width;
+				height = buf->y_crop_height;
+			/*if (print_header_info)
+				pr_info
+				(" - same_frame_size width : %d\n", width);*/
+			/*if (print_header_info)
+				pr_info
+				(" - same_frame_size height : %d\n", height);*/
+			found = 1;
+			break;
+		} else {
+			/*if (print_header_info)
+				pr_info
+				("1-bit same_frame_size[%d] read : 0\n", i);*/
+		}
+	}
+
+	if (!found) {
+		/*vp9_read_frame_size(rb, &width, &height);*/
+		width = params->p.width;
+		height = params->p.height;
+		/*if (print_header_info)
+			pr_info
+			(" * 16-bits w read : %d (width : %d)\n",
+				width, height);
+		if (print_header_info)
+			pr_info
+			(" * 16-bits h read : %d (height : %d)\n",
+				width, height);*/
+	}
+
+	if (width <= 0 || height <= 0) {
+		pr_err("Error: Invalid frame size\r\n");
+		return -1;
+	}
+
+	params->p.width = width;
+	params->p.height = height;
+
+	WRITE_VREG(HEVC_PARSER_PICTURE_SIZE, (height << 16) | width);
+#ifdef VP9_10B_MMU
+	/*if(cm->prev_fb_idx >= 0) release_unused_4k(cm->prev_fb_idx);
+	cm->prev_fb_idx = cm->new_fb_idx;*/
+	pr_info
+	("[DEBUG DEBUG]Before alloc_mmu, prev_fb_idx : %d, new_fb_idx : %d\r\n",
+	cm->prev_fb_idx, cm->new_fb_idx);
+	alloc_mmu(cm->new_fb_idx, params->p.width, params->p.height,
+	params->p.bit_depth, mmu_index_adr);
+#endif
+
+	/*Check to make sure at least one of frames that this frame references
+	has valid dimensions.*/
+	for (i = 0; i < REFS_PER_FRAME; ++i) {
+		struct RefBuffer_s * const ref_frame = &cm->frame_refs[i];
+		has_valid_ref_frame |=
+			valid_ref_frame_size(ref_frame->buf->y_crop_width,
+			ref_frame->buf->y_crop_height,
+			width, height);
+	}
+	if (!has_valid_ref_frame) {
+		pr_err("Error: Referenced frame has invalid size\r\n");
+		return -1;
+	}
+#if 0
+	for (i = 0; i < REFS_PER_FRAME; ++i) {
+			struct RefBuffer_s * const ref_frame =
+							&cm->frame_refs[i];
+			if (!valid_ref_frame_img_fmt(
+				ref_frame->buf->bit_depth,
+				ref_frame->buf->subsampling_x,
+				ref_frame->buf->subsampling_y,
+				cm->bit_depth,
+				cm->subsampling_x,
+				cm->subsampling_y))
+				pr_err
+				("Referenced frame incompatible color fmt\r\n");
+				return -1;
+	}
+#endif
+	resize_context_buffers(cm, width, height);
+	setup_display_size(cm, params, print_header_info);
+
+#if 0
+	lock_buffer_pool(pool);
+	if (vp9_realloc_frame_buffer(
+		get_frame_new_buffer(cm), cm->width, cm->height,
+		cm->subsampling_x, cm->subsampling_y,
+#if CONFIG_VP9_HIGHBITDEPTH
+		cm->use_highbitdepth,
+#endif
+		VP9_DEC_BORDER_IN_PIXELS,
+		cm->byte_alignment,
+		&pool->frame_bufs[cm->new_fb_idx].raw_frame_buffer,
+		pool->get_fb_cb,
+		pool->cb_priv)) {
+			unlock_buffer_pool(pool);
+			vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,
+			"Failed to allocate frame buffer");
+	}
+	unlock_buffer_pool(pool);
+#else
+	/* porting */
+	ybf = get_frame_new_buffer(cm);
+	ybf->y_crop_width = width;
+	ybf->y_crop_height = height;
+	ybf->bit_depth = params->p.bit_depth;
+#endif
+	pool->frame_bufs[cm->new_fb_idx].buf.subsampling_x = cm->subsampling_x;
+	pool->frame_bufs[cm->new_fb_idx].buf.subsampling_y = cm->subsampling_y;
+	pool->frame_bufs[cm->new_fb_idx].buf.bit_depth =
+						(unsigned int)cm->bit_depth;
+	pool->frame_bufs[cm->new_fb_idx].buf.color_space = cm->color_space;
+	return 0;
+}
+
+uint8_t print_header_info = 0;
+
+struct buff_s {
+	u32 buf_start;
+	u32 buf_size;
+	u32 buf_end;
+} buff_t;
+
+struct BuffInfo_s {
+	u32 max_width;
+	u32 max_height;
+	u32 start_adr;
+	u32 end_adr;
+	struct buff_s ipp;
+	struct buff_s sao_abv;
+	struct buff_s sao_vb;
+	struct buff_s short_term_rps;
+	struct buff_s vps;
+	struct buff_s sps;
+	struct buff_s pps;
+	struct buff_s sao_up;
+	struct buff_s swap_buf;
+	struct buff_s swap_buf2;
+	struct buff_s scalelut;
+	struct buff_s dblk_para;
+	struct buff_s dblk_data;
+	struct buff_s seg_map;
+#ifdef VP9_10B_MMU
+	struct buff_s mmu_vbh;
+	struct buff_s cm_header;
+#endif
+	struct buff_s mpred_above;
+	struct buff_s mpred_mv;
+	struct buff_s rpm;
+	struct buff_s lmem;
+} BuffInfo_t;
+
+struct VP9Decoder_s {
+	union param_u param;
+	int frame_count;
+	int pic_count;
+	u32 stat;
+	struct timer_list timer;
+	u32 frame_dur;
+	u32 frame_ar;
+	int fatal_error;
+	uint8_t init_flag;
+	uint8_t process_busy;
+	int show_frame_num;
+	struct buff_s mc_buf_spec;
+	struct dec_sysinfo vvp9_amstream_dec_info;
+	void *rpm_addr;
+	void *lmem_addr;
+	dma_addr_t rpm_phy_addr;
+	dma_addr_t lmem_phy_addr;
+	unsigned short *lmem_ptr;
+	unsigned short *debug_ptr;
+
+	void *prob_buffer_addr;
+	void *count_buffer_addr;
+	dma_addr_t prob_buffer_phy_addr;
+	dma_addr_t count_buffer_phy_addr;
+
+#if 1
+	/*VP9_10B_MMU*/
+	void *frame_mmu_map_addr;
+	dma_addr_t frame_mmu_map_phy_addr;
+#endif
+	unsigned int use_cma_flag;
+
+	unsigned long pre_last_frame_alloc_addr;
+	unsigned long pre_last_frame_alloc_size;
+	u32 predisp_addr;
+	u32 predisp_size;
+
+	struct BUF_s m_BUF[MAX_BUF_NUM];
+	u32 used_buf_num;
+	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
+	DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
+	DECLARE_KFIFO(pending_q, struct vframe_s *, VF_POOL_SIZE);
+	struct vframe_s vfpool[VF_POOL_SIZE];
+	int buf_num;
+	int pic_num;
+	int lcu_size_log2;
+	unsigned int losless_comp_body_size;
+
+	u32 video_signal_type;
+
+	int pts_mode;
+	int last_lookup_pts;
+	int last_pts;
+	u64 last_lookup_pts_us64;
+	u64 last_pts_us64;
+	u64 shift_byte_count;
+	u32 shift_byte_count_lo;
+	u32 shift_byte_count_hi;
+	int pts_mode_switching_count;
+	int pts_mode_recovery_count;
+
+	bool get_frame_dur;
+	u32 saved_resolution;
+
+	/**/
+	struct VP9_Common_s common;
+	struct RefCntBuffer_s *cur_buf;
+	int refresh_frame_flags;
+	uint8_t need_resync;
+	uint8_t hold_ref_buf;
+	uint8_t ready_for_new_data;
+	struct BufferPool_s vp9_buffer_pool;
+
+	struct BuffInfo_s *work_space_buf;
+	struct buff_s *mc_buf;
+
+	unsigned int frame_width;
+	unsigned int frame_height;
+
+	unsigned short *rpm_ptr;
+	int     init_pic_w;
+	int     init_pic_h;
+	int     lcu_total;
+	int     lcu_size;
+
+	int     slice_type;
+
+	int skip_flag;
+	int decode_idx;
+	int slice_idx;
+	uint8_t has_keyframe;
+	uint8_t wait_buf;
+	uint8_t error_flag;
+
+	/* bit 0, for decoding; bit 1, for displaying */
+	uint8_t ignore_bufmgr_error;
+	int PB_skip_mode;
+	int PB_skip_count_after_decoding;
+	/*hw*/
+
+	u32 pre_stream_offset;
+} VP9Decoder;
+
+
+int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct BufferPool_s *pool = cm->buffer_pool;
+	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
+	int i, mask, ref_index = 0;
+
+	pbi->ready_for_new_data = 0;
+
+	if (pbi->has_keyframe == 0 &&
+		params->p.frame_type != KEY_FRAME){
+		return -2;
+	}
+	pbi->has_keyframe = 1;
+
+#ifdef VP9_10B_MMU
+	if (cm->prev_fb_idx >= 0) {
+		long used_4k_num = (READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
+		release_unused_4k(used_4k_num, cm->prev_fb_idx);
+	}
+#endif
+	if (cm->new_fb_idx >= 0
+		&& frame_bufs[cm->new_fb_idx].ref_count == 0){
+		vp9_release_frame_buffer
+			(&frame_bufs[cm->new_fb_idx].raw_frame_buffer);
+#ifdef VP9_10B_MMU
+		release_buffer_4k(cm->new_fb_idx);
+#endif
+	}
+	/*pr_info("Before get_free_fb, prev_fb_idx : %d, new_fb_idx : %d\r\n",
+		cm->prev_fb_idx, cm->new_fb_idx);*/
+	cm->new_fb_idx = get_free_fb(cm);
+	cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];
+	/*if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("[VP9 DEBUG]%s(get_free_fb): %d\r\n", __func__,
+				cm->new_fb_idx);*/
+	if (cm->new_fb_idx == INVALID_IDX) {
+		pr_info("get_free_fb error\r\n");
+		return -1;
+	}
+	pbi->cur_buf = &frame_bufs[cm->new_fb_idx];
+#ifdef VP9_10B_MMU
+	/* moved to after picture size ready
+	alloc_mmu(cm, params->p.width, params->p.height,
+	params->p.bit_depth, pbi->frame_mmu_map_addr);*/
+	cm->prev_fb_idx = cm->new_fb_idx;
+#endif
+	/*read_uncompressed_header()*/
+	cm->last_frame_type = cm->frame_type;
+	cm->last_intra_only = cm->intra_only;
+	cm->profile = params->p.profile;
+	if (cm->profile >= MAX_PROFILES) {
+		pr_err("Error: Unsupported profile %d\r\n", cm->profile);
+		return -1;
+	}
+	cm->show_existing_frame = params->p.show_existing_frame;
+	if (cm->show_existing_frame) {
+		/* Show an existing frame directly.*/
+		int frame_to_show_idx = params->p.frame_to_show_idx;
+		int frame_to_show;
+		if (frame_to_show_idx >= REF_FRAMES) {
+			pr_info("frame_to_show_idx %d exceed max index\r\n",
+					frame_to_show_idx);
+			return -1;
+		}
+
+		frame_to_show = cm->ref_frame_map[frame_to_show_idx];
+		/*pr_info("frame_to_show %d\r\n", frame_to_show);*/
+		lock_buffer_pool(pool);
+		if (frame_to_show < 0 ||
+			frame_bufs[frame_to_show].ref_count < 1) {
+			unlock_buffer_pool(pool);
+			pr_err
+			("Error:Buffer %d does not contain a decoded frame",
+			frame_to_show);
+			return -1;
+		}
+
+		ref_cnt_fb(frame_bufs, &cm->new_fb_idx, frame_to_show);
+		unlock_buffer_pool(pool);
+		pbi->refresh_frame_flags = 0;
+		/*cm->lf.filter_level = 0;*/
+		cm->show_frame = 1;
+
+		/*
+		if (pbi->frame_parallel_decode) {
+			for (i = 0; i < REF_FRAMES; ++i)
+				cm->next_ref_frame_map[i] =
+				cm->ref_frame_map[i];
+		}
+		*/
+		/* do not decode, search next start code */
+		return 1;
+	}
+	cm->frame_type = params->p.frame_type;
+	cm->show_frame = params->p.show_frame;
+	cm->error_resilient_mode = params->p.error_resilient_mode;
+
+
+	if (cm->frame_type == KEY_FRAME) {
+		pbi->refresh_frame_flags = (1 << REF_FRAMES) - 1;
+
+		for (i = 0; i < REFS_PER_FRAME; ++i) {
+			cm->frame_refs[i].idx = INVALID_IDX;
+			cm->frame_refs[i].buf = NULL;
+		}
+
+		setup_frame_size(cm, params,  pbi->frame_mmu_map_addr,
+					print_header_info);
+		if (pbi->need_resync) {
+			memset(&cm->ref_frame_map, -1,
+				sizeof(cm->ref_frame_map));
+			pbi->need_resync = 0;
+		}
+	} else {
+		cm->intra_only = cm->show_frame ? 0 : params->p.intra_only;
+		/*if (print_header_info) {
+			if (cm->show_frame)
+				pr_info
+				("intra_only set to 0 because of show_frame\n");
+			else
+				pr_info
+				("1-bit intra_only read: %d\n", cm->intra_only);
+		}*/
+
+
+		cm->reset_frame_context = cm->error_resilient_mode ?
+			0 : params->p.reset_frame_context;
+		if (print_header_info) {
+			if (cm->error_resilient_mode)
+				pr_info
+				("reset to 0 error_resilient_mode\n");
+		else
+			pr_info
+				(" * 2-bits reset_frame_context read : %d\n",
+				cm->reset_frame_context);
+		}
+
+		if (cm->intra_only) {
+			if (cm->profile > PROFILE_0) {
+				/*read_bitdepth_colorspace_sampling(cm,
+					rb, print_header_info);*/
+			} else {
+				/*NOTE: The intra-only frame header
+				does not include the specification
+				of either the color format or color sub-sampling
+				in profile 0. VP9 specifies that the default
+				color format should be YUV 4:2:0 in this
+				case (normative).*/
+				cm->color_space = VPX_CS_BT_601;
+				cm->subsampling_y = cm->subsampling_x = 1;
+				cm->bit_depth = VPX_BITS_8;
+				cm->use_highbitdepth = 0;
+			}
+
+			pbi->refresh_frame_flags =
+				params->p.refresh_frame_flags;
+			/*if (print_header_info)
+				pr_info("*%d-bits refresh_frame read:0x%x\n",
+				REF_FRAMES, pbi->refresh_frame_flags);*/
+			setup_frame_size(cm, params,  pbi->frame_mmu_map_addr,
+				print_header_info);
+			if (pbi->need_resync) {
+				memset(&cm->ref_frame_map, -1,
+					sizeof(cm->ref_frame_map));
+				pbi->need_resync = 0;
+			}
+		} else if (pbi->need_resync != 1) {  /* Skip if need resync */
+				pbi->refresh_frame_flags =
+						params->p.refresh_frame_flags;
+				if (print_header_info)
+					pr_info
+					("*%d-bits refresh_frame read:0x%x\n",
+					REF_FRAMES, pbi->refresh_frame_flags);
+				for (i = 0; i < REFS_PER_FRAME; ++i) {
+					const int ref =
+						(params->p.ref_info >>
+						(((REFS_PER_FRAME-i-1)*4)+1))
+						& 0x7;
+					const int idx =
+						cm->ref_frame_map[ref];
+					struct RefBuffer_s * const ref_frame =
+						&cm->frame_refs[i];
+					if (print_header_info)
+						pr_info
+						("*%d-bits ref[%d]read:%d\n",
+						REF_FRAMES_LOG2, i, ref);
+					ref_frame->idx = idx;
+					ref_frame->buf = &frame_bufs[idx].buf;
+					cm->ref_frame_sign_bias[LAST_FRAME + i]
+					= (params->p.ref_info >>
+					((REFS_PER_FRAME-i-1)*4)) & 0x1;
+					if (print_header_info)
+						pr_info
+						("1bit ref_frame_sign_bias");
+						/*pr_info
+						("%dread: %d\n",
+						LAST_FRAME+i,
+						cm->ref_frame_sign_bias
+						[LAST_FRAME + i]);*/
+					/*pr_info
+					("[VP9 DEBUG]%s(get ref):%d\r\n",
+					__func__, ref_frame->idx);*/
+
+				}
+
+				setup_frame_size_with_refs(cm, params,
+					pbi->frame_mmu_map_addr,
+					print_header_info);
+				for (i = 0; i < REFS_PER_FRAME; ++i) {
+					/*struct RefBuffer_s *const ref_buf =
+					&cm->frame_refs[i];*/
+					/* to do:
+					vp9_setup_scale_factors_for_frame*/
+				}
+		}
+	}
+
+	get_frame_new_buffer(cm)->bit_depth = cm->bit_depth;
+	get_frame_new_buffer(cm)->color_space = cm->color_space;
+	get_frame_new_buffer(cm)->slice_type = cm->frame_type;
+
+	if (pbi->need_resync)
+		pr_err
+		("Error: Keyframe/intra-only frame required to reset\r\n");
+	/* Generate next_ref_frame_map.*/
+	lock_buffer_pool(pool);
+	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
+		if (mask & 1) {
+			cm->next_ref_frame_map[ref_index] = cm->new_fb_idx;
+			++frame_bufs[cm->new_fb_idx].ref_count;
+			/*pr_info("[MMU DEBUG 4] inc ref_count[%d] : %d\r\n",
+			cm->new_fb_idx, frame_bufs[cm->new_fb_idx].ref_count);*/
+		} else
+			cm->next_ref_frame_map[ref_index] =
+				cm->ref_frame_map[ref_index];
+		/* Current thread holds the reference frame.*/
+		if (cm->ref_frame_map[ref_index] >= 0) {
+			++frame_bufs[cm->ref_frame_map[ref_index]].ref_count;
+			/*pr_info
+			("[MMU DEBUG 5] inc ref_count[%d] : %d\r\n",
+			cm->ref_frame_map[ref_index],
+			frame_bufs[cm->ref_frame_map[ref_index]].ref_count);*/
+		}
+		++ref_index;
+	}
+
+	for (; ref_index < REF_FRAMES; ++ref_index) {
+		cm->next_ref_frame_map[ref_index] =
+			cm->ref_frame_map[ref_index];
+		/* Current thread holds the reference frame.*/
+		if (cm->ref_frame_map[ref_index] >= 0) {
+			++frame_bufs[cm->ref_frame_map[ref_index]].ref_count;
+			/*pr_info("[MMU DEBUG 6] inc ref_count[%d] : %d\r\n",
+			cm->ref_frame_map[ref_index],
+			frame_bufs[cm->ref_frame_map[ref_index]].ref_count);*/
+		}
+	}
+	unlock_buffer_pool(pool);
+	pbi->hold_ref_buf = 1;
+
+#if 0
+	if (frame_is_intra_only(cm) || cm->error_resilient_mode)
+		vp9_setup_past_independence(cm);
+	setup_loopfilter(&cm->lf, rb, print_header_info);
+	setup_quantization(cm, &pbi->mb, rb, print_header_info);
+	setup_segmentation(&cm->seg, rb, print_header_info);
+	setup_segmentation_dequant(cm, print_header_info);
+
+	setup_tile_info(cm, rb, print_header_info);
+	sz = vp9_rb_read_literal(rb, 16);
+	if (print_header_info)
+		pr_info(" * 16-bits size read : %d (0x%x)\n", sz, sz);
+
+	if (sz == 0)
+		vpx_internal_error(&cm->error, VPX_CODEC_CORRUPT_FRAME,
+		"Invalid header size");
+#endif
+	/*end read_uncompressed_header()*/
+	cm->use_prev_frame_mvs = !cm->error_resilient_mode &&
+			cm->width == cm->last_width &&
+			cm->height == cm->last_height &&
+			!cm->last_intra_only &&
+			cm->last_show_frame &&
+			(cm->last_frame_type != KEY_FRAME);
+
+	/*pr_info
+	("set use_prev_frame_mvs to %d (last_width %d last_height %d",
+	cm->use_prev_frame_mvs, cm->last_width, cm->last_height);
+	pr_info
+	(" last_intra_only %d last_show_frame %d last_frame_type %d)\n",
+	cm->last_intra_only, cm->last_show_frame, cm->last_frame_type);*/
+	return 0;
+}
+
+static void decrease_ref_count(int idx, struct RefCntBuffer_s *const frame_bufs,
+					struct BufferPool_s *const pool)
+{
+	if (idx >= 0) {
+		--frame_bufs[idx].ref_count;
+		/*pr_info("[MMU DEBUG 7] dec ref_count[%d] : %d\r\n", idx,
+			frame_bufs[idx].ref_count);*/
+		/*A worker may only get a free framebuffer index when
+		calling get_free_fb. But the private buffer is not set up
+		until finish decoding header. So any error happens during
+		decoding header, the frame_bufs will not have valid priv
+		buffer.*/
+#ifdef VP9_10B_MMU
+		if (frame_bufs[idx].ref_count == 0)
+			release_buffer_4k(idx);
+#endif
+		if (frame_bufs[idx].ref_count == 0 &&
+			frame_bufs[idx].raw_frame_buffer.priv)
+			vp9_release_frame_buffer
+			(&frame_bufs[idx].raw_frame_buffer);
+	}
+}
+
+void swap_frame_buffers(struct VP9Decoder_s *pbi)
+{
+	int ref_index = 0, mask;
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct BufferPool_s *const pool = cm->buffer_pool;
+	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
+
+	lock_buffer_pool(pool);
+	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
+		const int old_idx = cm->ref_frame_map[ref_index];
+		/*Current thread releases the holding of reference frame.*/
+		decrease_ref_count(old_idx, frame_bufs, pool);
+
+		/*Release the reference frame in reference map.*/
+		if ((mask & 1) && old_idx >= 0)
+			decrease_ref_count(old_idx, frame_bufs, pool);
+		cm->ref_frame_map[ref_index] =
+			cm->next_ref_frame_map[ref_index];
+		++ref_index;
+	}
+
+	/*Current thread releases the holding of reference frame.*/
+	for (; ref_index < REF_FRAMES && !cm->show_existing_frame;
+		++ref_index) {
+		const int old_idx = cm->ref_frame_map[ref_index];
+		decrease_ref_count(old_idx, frame_bufs, pool);
+		cm->ref_frame_map[ref_index] =
+			cm->next_ref_frame_map[ref_index];
+	}
+	unlock_buffer_pool(pool);
+	pbi->hold_ref_buf = 0;
+	cm->frame_to_show = get_frame_new_buffer(cm);
+
+	/*if (!pbi->frame_parallel_decode || !cm->show_frame) {*/
+	lock_buffer_pool(pool);
+	--frame_bufs[cm->new_fb_idx].ref_count;
+	/*pr_info("[MMU DEBUG 8] dec ref_count[%d] : %d\r\n", cm->new_fb_idx,
+		frame_bufs[cm->new_fb_idx].ref_count);*/
+	unlock_buffer_pool(pool);
+	/*}*/
+
+	/*Invalidate these references until the next frame starts.*/
+	for (ref_index = 0; ref_index < 3; ref_index++)
+		cm->frame_refs[ref_index].idx = -1;
+}
+
+#if 0
+static void check_resync(vpx_codec_alg_priv_t *const ctx,
+				const struct VP9Decoder_s *const pbi)
+{
+	/* Clear resync flag if worker got a key frame or intra only frame.*/
+	if (ctx->need_resync == 1 && pbi->need_resync == 0 &&
+		(pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
+		ctx->need_resync = 0;
+}
+#endif
+
+int vp9_get_raw_frame(struct VP9Decoder_s *pbi, struct PIC_BUFFER_CONFIG_s *sd)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	int ret = -1;
+
+	if (pbi->ready_for_new_data == 1)
+		return ret;
+
+	pbi->ready_for_new_data = 1;
+
+	/* no raw frame to show!!! */
+	if (!cm->show_frame)
+		return ret;
+
+	pbi->ready_for_new_data = 1;
+
+	*sd = *cm->frame_to_show;
+	ret = 0;
+
+	return ret;
+}
+
+int vp9_bufmgr_init(struct VP9Decoder_s *pbi, struct BuffInfo_s *buf_spec_i,
+		struct buff_s *mc_buf_i) {
+	struct VP9_Common_s *cm = &pbi->common;
+
+	/*memset(pbi, 0, sizeof(struct VP9Decoder));*/
+	pbi->frame_count = 0;
+	pbi->pic_count = 0;
+	pbi->pre_stream_offset = 0;
+	cm->buffer_pool = &pbi->vp9_buffer_pool;
+	cm->prev_fb_idx = INVALID_IDX;
+	cm->new_fb_idx = INVALID_IDX;
+	pr_info
+	("After vp9_bufmgr_init, prev_fb_idx : %d, new_fb_idx : %d\r\n",
+		cm->prev_fb_idx, cm->new_fb_idx);
+	pbi->need_resync = 1;
+	/* Initialize the references to not point to any frame buffers.*/
+	memset(&cm->ref_frame_map, -1, sizeof(cm->ref_frame_map));
+	memset(&cm->next_ref_frame_map, -1, sizeof(cm->next_ref_frame_map));
+	cm->current_video_frame = 0;
+	pbi->ready_for_new_data = 1;
+
+	/* private init */
+	pbi->work_space_buf = buf_spec_i;
+	pbi->mc_buf = mc_buf_i;
+	pbi->rpm_addr = NULL;
+	pbi->lmem_addr = NULL;
+
+	pbi->use_cma_flag = 0;
+	pbi->decode_idx = 0;
+	pbi->slice_idx = 0;
+	/*int m_uiMaxCUWidth = 1<<7;*/
+	/*int m_uiMaxCUHeight = 1<<7;*/
+	pbi->has_keyframe = 0;
+	pbi->skip_flag = 0;
+	pbi->wait_buf = 0;
+	pbi->error_flag = 0;
+
+	pbi->pts_mode = PTS_NORMAL;
+	pbi->last_pts = 0;
+	pbi->last_lookup_pts = 0;
+	pbi->last_pts_us64 = 0;
+	pbi->last_lookup_pts_us64 = 0;
+	pbi->shift_byte_count = 0;
+	pbi->shift_byte_count_lo = 0;
+	pbi->shift_byte_count_hi = 0;
+	pbi->pts_mode_switching_count = 0;
+	pbi->pts_mode_recovery_count = 0;
+
+	pbi->buf_num = 0;
+	pbi->pic_num = 0;
+
+	return 0;
+}
+
+
+int vp9_bufmgr_postproc(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s sd;
+	swap_frame_buffers(pbi);
+	if (!cm->show_existing_frame) {
+		cm->last_show_frame = cm->show_frame;
+		cm->prev_frame = cm->cur_frame;
+#if 0
+	if (cm->seg.enabled && !pbi->frame_parallel_decode)
+		vp9_swap_current_and_last_seg_map(cm);
+#endif
+	}
+	cm->last_width = cm->width;
+	cm->last_height = cm->height;
+	if (cm->show_frame)
+		cm->current_video_frame++;
+
+	if (vp9_get_raw_frame(pbi, &sd) == 0) {
+		/*pr_info("Display frame index %d\r\n", sd.index);*/
+		sd.stream_offset = pbi->pre_stream_offset;
+		prepare_display_buf(pbi, &sd);
+		pbi->pre_stream_offset = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+	} /*else
+		pr_info
+		("Not display this frame,ready_for_new_data%d show_frame%d\r\n",
+		pbi->ready_for_new_data, cm->show_frame);*/
+	return 0;
+}
+
+struct VP9Decoder_s vp9_decoder;
+union param_u vp9_param;
+
+/**************************************************
+
+VP9 buffer management end
+
+***************************************************/
+
+
+#define HEVC_CM_BODY_START_ADDR                    0x3626
+#define HEVC_CM_BODY_LENGTH                        0x3627
+#define HEVC_CM_HEADER_LENGTH                      0x3629
+#define HEVC_CM_HEADER_OFFSET                      0x362b
+
+#define LOSLESS_COMPRESS_MODE
+/* DOUBLE_WRITE_MODE is enabled only when NV21 8 bit output is needed */
+/* double_write_mode: 0, no double write; 1, 1:1 ratio; 2, (1/4):(1/4) ratio
+	0x10, double write only
+*/
+static u32 double_write_mode;
+
+/*#define DECOMP_HEADR_SURGENT*/
+
+static u32 mem_map_mode; /* 0:linear 1:32x32 2:64x32 ; m8baby test1902 */
+static u32 enable_mem_saving = 1;
+static u32 force_w_h;
+
+static u32 force_fps;
+
+
+const u32 vp9_version = 201602101;
+static u32 debug;
+static u32 radr;
+static u32 rval;
+static u32 dbg_cmd;
+static u32 dbg_skip_decode_index;
+static u32 endian = 0xff0;
+#ifdef ERROR_HANDLE_DEBUG
+static u32 dbg_nal_skip_flag;
+		/* bit[0], skip vps; bit[1], skip sps; bit[2], skip pps */
+static u32 dbg_nal_skip_count;
+#endif
+/*for debug*/
+static u32 decode_stop_pos;
+static u32 decode_stop_pos_pre;
+static u32 decode_pic_begin;
+static uint slice_parse_begin;
+static u32 step;
+#ifdef MIX_STREAM_SUPPORT
+#ifdef SUPPORT_4K2K
+static u32 buf_alloc_width = 4096;
+static u32 buf_alloc_height = 2304;
+#else
+static u32 buf_alloc_width = 1920;
+static u32 buf_alloc_height = 1088;
+#endif
+static u32 dynamic_buf_num_margin;
+#else
+static u32 buf_alloc_width;
+static u32 buf_alloc_height;
+static u32 dynamic_buf_num_margin = 7;
+#endif
+static u32 buf_alloc_depth = 10;
+static u32 buf_alloc_size;
+/*
+bit[0]: 0,
+    bit[1]: 0, always release cma buffer when stop
+    bit[1]: 1, never release cma buffer when stop
+bit[0]: 1, when stop, release cma buffer if blackout is 1;
+do not release cma buffer is blackout is not 1
+
+bit[2]: 0, when start decoding, check current displayed buffer
+	 (only for buffer decoded by vp9) if blackout is 0
+	 1, do not check current displayed buffer
+
+bit[3]: 1, if blackout is not 1, do not release current
+			displayed cma buffer always.
+*/
+/* set to 1 for fast play;
+	set to 8 for other case of "keep last frame"
+*/
+static u32 buffer_mode = 1;
+/* buffer_mode_dbg: debug only*/
+static u32 buffer_mode_dbg = 0xffff0000;
+/**/
+
+/*
+bit 0, 1: only display I picture;
+bit 1, 1: only decode I picture;
+*/
+static u32 i_only_flag;
+
+/*
+use_cma: 1, use both reserver memory and cma for buffers
+2, only use cma for buffers
+*/
+static u32 use_cma = 2;
+
+static u32 max_decoding_time;
+/*
+error handling
+*/
+/*error_handle_policy:
+bit 0: 0, auto skip error_skip_nal_count nals before error recovery;
+1, skip error_skip_nal_count nals before error recovery;
+bit 1 (valid only when bit0 == 1):
+1, wait vps/sps/pps after error recovery;
+bit 2 (valid only when bit0 == 0):
+0, auto search after error recovery (vp9_recover() called);
+1, manual search after error recovery
+(change to auto search after get IDR: WRITE_VREG(NAL_SEARCH_CTL, 0x2))
+
+bit 4: 0, set error_mark after reset/recover
+    1, do not set error_mark after reset/recover
+bit 5: 0, check total lcu for every picture
+    1, do not check total lcu
+
+*/
+
+static u32 error_handle_policy;
+/*static u32 parser_sei_enable = 1;*/
+
+static u32 max_buf_num = 12;
+
+
+static DEFINE_MUTEX(vvp9_mutex);
+
+static struct device *cma_dev;
+
+
+#define HEVC_DEC_STATUS_REG       HEVC_ASSIST_SCRATCH_0
+#define HEVC_RPM_BUFFER           HEVC_ASSIST_SCRATCH_1
+#define HEVC_SHORT_TERM_RPS       HEVC_ASSIST_SCRATCH_2
+#define VP9_ADAPT_PROB_REG        HEVC_ASSIST_SCRATCH_3
+#define VP9_MMU_MAP_BUFFER        HEVC_ASSIST_SCRATCH_4
+#define HEVC_PPS_BUFFER           HEVC_ASSIST_SCRATCH_5
+#define HEVC_SAO_UP               HEVC_ASSIST_SCRATCH_6
+#define HEVC_STREAM_SWAP_BUFFER   HEVC_ASSIST_SCRATCH_7
+#define HEVC_STREAM_SWAP_BUFFER2  HEVC_ASSIST_SCRATCH_8
+#define VP9_PROB_SWAP_BUFFER      HEVC_ASSIST_SCRATCH_9
+#define VP9_COUNT_SWAP_BUFFER     HEVC_ASSIST_SCRATCH_A
+#define VP9_SEG_MAP_BUFFER        HEVC_ASSIST_SCRATCH_B
+#define HEVC_SCALELUT             HEVC_ASSIST_SCRATCH_D
+#define HEVC_WAIT_FLAG            HEVC_ASSIST_SCRATCH_E
+#define RPM_CMD_REG               HEVC_ASSIST_SCRATCH_F
+#define LMEM_DUMP_ADR                 HEVC_ASSIST_SCRATCH_F
+#define HEVC_STREAM_SWAP_TEST     HEVC_ASSIST_SCRATCH_L
+#define HEVC_DECODE_PIC_BEGIN_REG HEVC_ASSIST_SCRATCH_M
+#define HEVC_DECODE_PIC_NUM_REG   HEVC_ASSIST_SCRATCH_N
+
+#define DEBUG_REG1              HEVC_ASSIST_SCRATCH_G
+#define DEBUG_REG2              HEVC_ASSIST_SCRATCH_H
+
+
+/*
+ucode parser/search control
+bit 0:  0, header auto parse; 1, header manual parse
+bit 1:  0, auto skip for noneseamless stream; 1, no skip
+bit [3:2]: valid when bit1==0;
+0, auto skip nal before first vps/sps/pps/idr;
+1, auto skip nal before first vps/sps/pps
+2, auto skip nal before first  vps/sps/pps,
+	and not decode until the first I slice (with slice address of 0)
+
+3, auto skip before first I slice (nal_type >=16 && nal_type<=21)
+bit [15:4] nal skip count (valid when bit0 == 1 (manual mode) )
+bit [16]: for NAL_UNIT_EOS when bit0 is 0:
+	0, send SEARCH_DONE to arm ;  1, do not send SEARCH_DONE to arm
+bit [17]: for NAL_SEI when bit0 is 0:
+	0, do not parse SEI in ucode; 1, parse SEI in ucode
+bit [31:20]: used by ucode for debug purpose
+*/
+#define NAL_SEARCH_CTL            HEVC_ASSIST_SCRATCH_I
+#define CUR_NAL_UNIT_TYPE       HEVC_ASSIST_SCRATCH_J
+#define DECODE_STOP_POS         HEVC_ASSIST_SCRATCH_K
+
+#define RPM_BUF_SIZE (0x80*2)
+#define LMEM_BUF_SIZE (0x400 * 2)
+
+#define WORK_BUF_SPEC_NUM 2
+static struct BuffInfo_s amvvp9_workbuff_spec[WORK_BUF_SPEC_NUM] = {
+	{
+		/* 8M bytes */
+		.max_width = 1920,
+		.max_height = 1088,
+		.ipp = {
+			/* IPP work space calculation :
+			   4096 * (Y+CbCr+Flags) = 12k, round to 16k */
+			.buf_size = 0x4000,
+		},
+		.sao_abv = {
+			.buf_size = 0x30000,
+		},
+		.sao_vb = {
+			.buf_size = 0x30000,
+		},
+		.short_term_rps = {
+			/* SHORT_TERM_RPS - Max 64 set, 16 entry every set,
+			   total 64x16x2 = 2048 bytes (0x800) */
+			.buf_size = 0x800,
+		},
+		.vps = {
+			/* VPS STORE AREA - Max 16 VPS, each has 0x80 bytes,
+			   total 0x0800 bytes */
+			.buf_size = 0x800,
+		},
+		.sps = {
+			/* SPS STORE AREA - Max 16 SPS, each has 0x80 bytes,
+			   total 0x0800 bytes */
+			.buf_size = 0x800,
+		},
+		.pps = {
+			/* PPS STORE AREA - Max 64 PPS, each has 0x80 bytes,
+			   total 0x2000 bytes */
+			.buf_size = 0x2000,
+		},
+		.sao_up = {
+			/* SAO UP STORE AREA - Max 640(10240/16) LCU,
+			   each has 16 bytes total 0x2800 bytes */
+			.buf_size = 0x2800,
+		},
+		.swap_buf = {
+			/* 256cyclex64bit = 2K bytes 0x800
+			   (only 144 cycles valid) */
+			.buf_size = 0x800,
+		},
+		.swap_buf2 = {
+			.buf_size = 0x800,
+		},
+		.scalelut = {
+			/* support up to 32 SCALELUT 1024x32 =
+			   32Kbytes (0x8000) */
+			.buf_size = 0x8000,
+		},
+		.dblk_para = {
+			/* DBLK -> Max 256(4096/16) LCU,
+			each para 1024bytes(total:0x40000),
+			data 1024bytes(total:0x40000)*/
+			.buf_size = 0x80000,
+		},
+		.dblk_data = {
+			.buf_size = 0x80000,
+		},
+		.seg_map = {
+		/*4096x2304/64/64 *24 = 0xd800 Bytes*/
+			.buf_size = 0xd800,
+		},
+#ifdef VP9_10B_MMU
+		.mmu_vbh = {
+			.buf_size = 0x5000, /*2*16*(more than 2304)/4, 4K*/
+		},
+		.cm_header = {
+			.buf_size = MMU_COMPRESS_HEADER_SIZE*8,
+			/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8) */
+		},
+#endif
+		.mpred_above = {
+			.buf_size = 0x10000, /* 2 * size of hevc*/
+		},
+		.mpred_mv = {/* 1080p, 0x40000 per buffer */
+			.buf_size = 0x40000 * FRAME_BUFFERS,
+		},
+		.rpm = {
+			.buf_size = RPM_BUF_SIZE,
+		},
+		.lmem = {
+			.buf_size = 0x400 * 2,
+		}
+	},
+	{
+		.max_width = 4096,
+		.max_height = 2304,
+		.ipp = {
+			/* IPP work space calculation :
+			   4096 * (Y+CbCr+Flags) = 12k, round to 16k */
+			.buf_size = 0x4000,
+		},
+		.sao_abv = {
+			.buf_size = 0x30000,
+		},
+		.sao_vb = {
+			.buf_size = 0x30000,
+		},
+		.short_term_rps = {
+			/* SHORT_TERM_RPS - Max 64 set, 16 entry every set,
+			   total 64x16x2 = 2048 bytes (0x800) */
+			.buf_size = 0x800,
+		},
+		.vps = {
+			/* VPS STORE AREA - Max 16 VPS, each has 0x80 bytes,
+			   total 0x0800 bytes */
+			.buf_size = 0x800,
+		},
+		.sps = {
+			/* SPS STORE AREA - Max 16 SPS, each has 0x80 bytes,
+			   total 0x0800 bytes */
+			.buf_size = 0x800,
+		},
+		.pps = {
+			/* PPS STORE AREA - Max 64 PPS, each has 0x80 bytes,
+			   total 0x2000 bytes */
+			.buf_size = 0x2000,
+		},
+		.sao_up = {
+			/* SAO UP STORE AREA - Max 640(10240/16) LCU,
+			   each has 16 bytes total 0x2800 bytes */
+			.buf_size = 0x2800,
+		},
+		.swap_buf = {
+			/* 256cyclex64bit = 2K bytes 0x800
+			   (only 144 cycles valid) */
+			.buf_size = 0x800,
+		},
+		.swap_buf2 = {
+			.buf_size = 0x800,
+		},
+		.scalelut = {
+			/* support up to 32 SCALELUT 1024x32 = 32Kbytes
+			   (0x8000) */
+			.buf_size = 0x8000,
+		},
+		.dblk_para = {
+			/* DBLK -> Max 256(4096/16) LCU,
+			each para 1024bytes(total:0x40000),
+			data 1024bytes(total:0x40000)*/
+			.buf_size = 0x80000,
+		},
+		.dblk_data = {
+			.buf_size = 0x80000,
+		},
+		.seg_map = {
+			/*4096x2304/64/64 *24 = 0xd800 Bytes*/
+			.buf_size = 0xd800,
+		},
+#ifdef VP9_10B_MMU
+		.mmu_vbh = {
+			.buf_size = 0x5000,/*2*16*(more than 2304)/4, 4K*/
+		},
+		.cm_header = {
+			.buf_size = MMU_COMPRESS_HEADER_SIZE*8,
+			/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8) */
+		},
+#endif
+		.mpred_above = {
+			.buf_size = 0x10000, /* 2 * size of hevc*/
+		},
+		.mpred_mv = {
+			/* .buf_size = 0x100000*16,
+			//4k2k , 0x100000 per buffer */
+			/* 4096x2304 , 0x120000 per buffer */
+			.buf_size = 0x120000 * FRAME_BUFFERS,
+		},
+		.rpm = {
+			.buf_size = RPM_BUF_SIZE,
+		},
+		.lmem = {
+			.buf_size = 0x400 * 2,
+		}
+	}
+};
+
+
+/*Losless compression body buffer size 4K per 64x32 (jt)*/
+int  compute_losless_comp_body_size(int width, int height,
+				uint8_t is_bit_depth_10)
+{
+	int     width_x64;
+	int     height_x32;
+	int     bsize;
+	width_x64 = width + 63;
+	width_x64 >>= 6;
+	height_x32 = height + 31;
+	height_x32 >>= 5;
+#ifdef VP9_10B_MMU
+	 bsize = (is_bit_depth_10?4096:3200)*width_x64*height_x32;
+#else
+	 bsize = (is_bit_depth_10?4096:3072)*width_x64*height_x32;
+#endif
+	if (debug & VP9_DEBUG_BUFMGR_MORE)
+		pr_info("%s(%d,%d,%d)=>%d\n",
+			__func__, width, height,
+			is_bit_depth_10, bsize);
+
+	return  bsize;
+}
+
+/* Losless compression header buffer size 32bytes per 128x64 (jt)*/
+static  int  compute_losless_comp_header_size(int width, int height)
+{
+	int     width_x128;
+	int     height_x64;
+	int     hsize;
+	width_x128 = width + 127;
+	width_x128 >>= 7;
+	height_x64 = height + 63;
+	height_x64 >>= 6;
+
+	hsize = 32 * width_x128 * height_x64;
+	if (debug & VP9_DEBUG_BUFMGR_MORE)
+		pr_info("%s(%d,%d)=>%d\n",
+			__func__, width, height,
+			hsize);
+
+	return  hsize;
+}
+
+static void init_buff_spec(struct BuffInfo_s *buf_spec)
+{
+	void *mem_start_virt;
+	buf_spec->ipp.buf_start = buf_spec->start_adr;
+	buf_spec->sao_abv.buf_start =
+		buf_spec->ipp.buf_start + buf_spec->ipp.buf_size;
+
+	buf_spec->sao_vb.buf_start =
+		buf_spec->sao_abv.buf_start + buf_spec->sao_abv.buf_size;
+	buf_spec->short_term_rps.buf_start =
+		buf_spec->sao_vb.buf_start + buf_spec->sao_vb.buf_size;
+	buf_spec->vps.buf_start =
+		buf_spec->short_term_rps.buf_start +
+		buf_spec->short_term_rps.buf_size;
+	buf_spec->sps.buf_start =
+		buf_spec->vps.buf_start + buf_spec->vps.buf_size;
+	buf_spec->pps.buf_start =
+		buf_spec->sps.buf_start + buf_spec->sps.buf_size;
+	buf_spec->sao_up.buf_start =
+		buf_spec->pps.buf_start + buf_spec->pps.buf_size;
+	buf_spec->swap_buf.buf_start =
+		buf_spec->sao_up.buf_start + buf_spec->sao_up.buf_size;
+	buf_spec->swap_buf2.buf_start =
+		buf_spec->swap_buf.buf_start + buf_spec->swap_buf.buf_size;
+	buf_spec->scalelut.buf_start =
+		buf_spec->swap_buf2.buf_start + buf_spec->swap_buf2.buf_size;
+	buf_spec->dblk_para.buf_start =
+		buf_spec->scalelut.buf_start + buf_spec->scalelut.buf_size;
+	buf_spec->dblk_data.buf_start =
+		buf_spec->dblk_para.buf_start + buf_spec->dblk_para.buf_size;
+	buf_spec->seg_map.buf_start =
+	buf_spec->dblk_data.buf_start + buf_spec->dblk_data.buf_size;
+#ifdef VP9_10B_MMU
+	buf_spec->mmu_vbh.buf_start  =
+		buf_spec->seg_map.buf_start + buf_spec->seg_map.buf_size;
+	buf_spec->cm_header.buf_start =
+		buf_spec->mmu_vbh.buf_start + buf_spec->mmu_vbh.buf_size;
+	buf_spec->mpred_above.buf_start =
+		buf_spec->cm_header.buf_start + buf_spec->cm_header.buf_size;
+#else
+	buf_spec->mpred_above.buf_start =
+		buf_spec->seg_map.buf_start + buf_spec->seg_map.buf_size;
+#endif
+	buf_spec->mpred_mv.buf_start =
+		buf_spec->mpred_above.buf_start +
+		buf_spec->mpred_above.buf_size;
+	if (debug & VP9_DEBUG_SEND_PARAM_WITH_REG) {
+		buf_spec->end_adr =
+			buf_spec->mpred_mv.buf_start +
+			buf_spec->mpred_mv.buf_size;
+	} else {
+		buf_spec->rpm.buf_start =
+			buf_spec->mpred_mv.buf_start +
+			buf_spec->mpred_mv.buf_size;
+		if (debug & VP9_DEBUG_UCODE) {
+			buf_spec->lmem.buf_start =
+				buf_spec->rpm.buf_start +
+				buf_spec->rpm.buf_size;
+			buf_spec->end_adr =
+				buf_spec->lmem.buf_start +
+				buf_spec->lmem.buf_size;
+		} else {
+			buf_spec->end_adr =
+				buf_spec->rpm.buf_start +
+				buf_spec->rpm.buf_size;
+		}
+	}
+	mem_start_virt = codec_mm_phys_to_virt(buf_spec->dblk_para.buf_start);
+	if (mem_start_virt)
+		memset(mem_start_virt, 0, buf_spec->dblk_para.buf_size);
+	else
+		pr_err("mem_start_virt failed\n");
+
+	if (debug) {
+		pr_info("%s workspace (%x %x) size = %x\n", __func__,
+			   buf_spec->start_adr, buf_spec->end_adr,
+			   buf_spec->end_adr - buf_spec->start_adr);
+	}
+	if (debug) {
+		pr_info("ipp.buf_start             :%x\n",
+			   buf_spec->ipp.buf_start);
+		pr_info("sao_abv.buf_start          :%x\n",
+			   buf_spec->sao_abv.buf_start);
+		pr_info("sao_vb.buf_start          :%x\n",
+			   buf_spec->sao_vb.buf_start);
+		pr_info("short_term_rps.buf_start  :%x\n",
+			   buf_spec->short_term_rps.buf_start);
+		pr_info("vps.buf_start             :%x\n",
+			   buf_spec->vps.buf_start);
+		pr_info("sps.buf_start             :%x\n",
+			   buf_spec->sps.buf_start);
+		pr_info("pps.buf_start             :%x\n",
+			   buf_spec->pps.buf_start);
+		pr_info("sao_up.buf_start          :%x\n",
+			   buf_spec->sao_up.buf_start);
+		pr_info("swap_buf.buf_start        :%x\n",
+			   buf_spec->swap_buf.buf_start);
+		pr_info("swap_buf2.buf_start       :%x\n",
+			   buf_spec->swap_buf2.buf_start);
+		pr_info("scalelut.buf_start        :%x\n",
+			   buf_spec->scalelut.buf_start);
+		pr_info("dblk_para.buf_start       :%x\n",
+			   buf_spec->dblk_para.buf_start);
+		pr_info("dblk_data.buf_start       :%x\n",
+			   buf_spec->dblk_data.buf_start);
+		pr_info("seg_map.buf_start       :%x\n",
+			buf_spec->seg_map.buf_start);
+#ifdef VP9_10B_MMU
+		pr_info("mmu_vbh.buf_start     :%x\n",
+			buf_spec->mmu_vbh.buf_start);
+		pr_info("cm_header.buf_start     :%x\n",
+			buf_spec->cm_header.buf_start);
+#endif
+		pr_info("mpred_above.buf_start     :%x\n",
+			   buf_spec->mpred_above.buf_start);
+		pr_info("mpred_mv.buf_start        :%x\n",
+			   buf_spec->mpred_mv.buf_start);
+		if ((debug & VP9_DEBUG_SEND_PARAM_WITH_REG) == 0) {
+			pr_info("rpm.buf_start             :%x\n",
+				   buf_spec->rpm.buf_start);
+		}
+	}
+
+}
+
+/*====================================================
+========================================================================
+vp9_prob define
+========================================================================*/
+#define VP9_PARTITION_START      0
+#define VP9_PARTITION_SIZE_STEP  (3 * 4)
+#define VP9_PARTITION_ONE_SIZE   (4 * VP9_PARTITION_SIZE_STEP)
+#define VP9_PARTITION_KEY_START  0
+#define VP9_PARTITION_P_START    VP9_PARTITION_ONE_SIZE
+#define VP9_PARTITION_SIZE       (2 * VP9_PARTITION_ONE_SIZE)
+#define VP9_SKIP_START           (VP9_PARTITION_START + VP9_PARTITION_SIZE)
+#define VP9_SKIP_SIZE            4 /* only use 3*/
+#define VP9_TX_MODE_START        (VP9_SKIP_START+VP9_SKIP_SIZE)
+#define VP9_TX_MODE_8_0_OFFSET   0
+#define VP9_TX_MODE_8_1_OFFSET   1
+#define VP9_TX_MODE_16_0_OFFSET  2
+#define VP9_TX_MODE_16_1_OFFSET  4
+#define VP9_TX_MODE_32_0_OFFSET  6
+#define VP9_TX_MODE_32_1_OFFSET  9
+#define VP9_TX_MODE_SIZE         12
+#define VP9_COEF_START           (VP9_TX_MODE_START+VP9_TX_MODE_SIZE)
+#define VP9_COEF_BAND_0_OFFSET   0
+#define VP9_COEF_BAND_1_OFFSET   (VP9_COEF_BAND_0_OFFSET + 3 * 3 + 1)
+#define VP9_COEF_BAND_2_OFFSET   (VP9_COEF_BAND_1_OFFSET + 6 * 3)
+#define VP9_COEF_BAND_3_OFFSET   (VP9_COEF_BAND_2_OFFSET + 6 * 3)
+#define VP9_COEF_BAND_4_OFFSET   (VP9_COEF_BAND_3_OFFSET + 6 * 3)
+#define VP9_COEF_BAND_5_OFFSET   (VP9_COEF_BAND_4_OFFSET + 6 * 3)
+#define VP9_COEF_SIZE_ONE_SET    100 /* ((3 +5*6)*3 + 1 padding)*/
+#define VP9_COEF_4X4_START       (VP9_COEF_START + 0 * VP9_COEF_SIZE_ONE_SET)
+#define VP9_COEF_8X8_START       (VP9_COEF_START + 4 * VP9_COEF_SIZE_ONE_SET)
+#define VP9_COEF_16X16_START     (VP9_COEF_START + 8 * VP9_COEF_SIZE_ONE_SET)
+#define VP9_COEF_32X32_START     (VP9_COEF_START + 12 * VP9_COEF_SIZE_ONE_SET)
+#define VP9_COEF_SIZE_PLANE      (2 * VP9_COEF_SIZE_ONE_SET)
+#define VP9_COEF_SIZE            (4 * 2 * 2 * VP9_COEF_SIZE_ONE_SET)
+#define VP9_INTER_MODE_START     (VP9_COEF_START+VP9_COEF_SIZE)
+#define VP9_INTER_MODE_SIZE      24 /* only use 21 ( #*7)*/
+#define VP9_INTERP_START         (VP9_INTER_MODE_START+VP9_INTER_MODE_SIZE)
+#define VP9_INTERP_SIZE          8
+#define VP9_INTRA_INTER_START    (VP9_INTERP_START+VP9_INTERP_SIZE)
+#define VP9_INTRA_INTER_SIZE     4
+#define VP9_INTERP_INTRA_INTER_START  VP9_INTERP_START
+#define VP9_INTERP_INTRA_INTER_SIZE   (VP9_INTERP_SIZE + VP9_INTRA_INTER_SIZE)
+#define VP9_COMP_INTER_START     \
+		(VP9_INTERP_INTRA_INTER_START+VP9_INTERP_INTRA_INTER_SIZE)
+#define VP9_COMP_INTER_SIZE      5
+#define VP9_COMP_REF_START       (VP9_COMP_INTER_START+VP9_COMP_INTER_SIZE)
+#define VP9_COMP_REF_SIZE        5
+#define VP9_SINGLE_REF_START     (VP9_COMP_REF_START+VP9_COMP_REF_SIZE)
+#define VP9_SINGLE_REF_SIZE      10
+#define VP9_REF_MODE_START       VP9_COMP_INTER_START
+#define VP9_REF_MODE_SIZE        \
+		(VP9_COMP_INTER_SIZE+VP9_COMP_REF_SIZE+VP9_SINGLE_REF_SIZE)
+#define VP9_IF_Y_MODE_START      (VP9_REF_MODE_START+VP9_REF_MODE_SIZE)
+#define VP9_IF_Y_MODE_SIZE       36
+#define VP9_IF_UV_MODE_START     (VP9_IF_Y_MODE_START+VP9_IF_Y_MODE_SIZE)
+#define VP9_IF_UV_MODE_SIZE      92 /* only use 90*/
+#define VP9_MV_JOINTS_START      (VP9_IF_UV_MODE_START+VP9_IF_UV_MODE_SIZE)
+#define VP9_MV_JOINTS_SIZE       3
+#define VP9_MV_SIGN_0_START      (VP9_MV_JOINTS_START+VP9_MV_JOINTS_SIZE)
+#define VP9_MV_SIGN_0_SIZE       1
+#define VP9_MV_CLASSES_0_START   (VP9_MV_SIGN_0_START+VP9_MV_SIGN_0_SIZE)
+#define VP9_MV_CLASSES_0_SIZE    10
+#define VP9_MV_CLASS0_0_START    (VP9_MV_CLASSES_0_START+VP9_MV_CLASSES_0_SIZE)
+#define VP9_MV_CLASS0_0_SIZE     1
+#define VP9_MV_BITS_0_START      (VP9_MV_CLASS0_0_START+VP9_MV_CLASS0_0_SIZE)
+#define VP9_MV_BITS_0_SIZE       10
+#define VP9_MV_SIGN_1_START      (VP9_MV_BITS_0_START+VP9_MV_BITS_0_SIZE)
+#define VP9_MV_SIGN_1_SIZE       1
+#define VP9_MV_CLASSES_1_START   \
+			(VP9_MV_SIGN_1_START+VP9_MV_SIGN_1_SIZE)
+#define VP9_MV_CLASSES_1_SIZE    10
+#define VP9_MV_CLASS0_1_START    \
+			(VP9_MV_CLASSES_1_START+VP9_MV_CLASSES_1_SIZE)
+#define VP9_MV_CLASS0_1_SIZE     1
+#define VP9_MV_BITS_1_START      \
+			(VP9_MV_CLASS0_1_START+VP9_MV_CLASS0_1_SIZE)
+#define VP9_MV_BITS_1_SIZE       10
+#define VP9_MV_CLASS0_FP_0_START \
+			(VP9_MV_BITS_1_START+VP9_MV_BITS_1_SIZE)
+#define VP9_MV_CLASS0_FP_0_SIZE  9
+#define VP9_MV_CLASS0_FP_1_START \
+			(VP9_MV_CLASS0_FP_0_START+VP9_MV_CLASS0_FP_0_SIZE)
+#define VP9_MV_CLASS0_FP_1_SIZE  9
+#define VP9_MV_CLASS0_HP_0_START \
+			(VP9_MV_CLASS0_FP_1_START+VP9_MV_CLASS0_FP_1_SIZE)
+#define VP9_MV_CLASS0_HP_0_SIZE  2
+#define VP9_MV_CLASS0_HP_1_START \
+			(VP9_MV_CLASS0_HP_0_START+VP9_MV_CLASS0_HP_0_SIZE)
+#define VP9_MV_CLASS0_HP_1_SIZE  2
+#define VP9_MV_START             VP9_MV_JOINTS_START
+#define VP9_MV_SIZE              72 /*only use 69*/
+
+#define VP9_TOTAL_SIZE           (VP9_MV_START + VP9_MV_SIZE)
+
+
+/*========================================================================
+	vp9_count_mem define
+========================================================================*/
+#define VP9_COEF_COUNT_START           0
+#define VP9_COEF_COUNT_BAND_0_OFFSET   0
+#define VP9_COEF_COUNT_BAND_1_OFFSET   \
+			(VP9_COEF_COUNT_BAND_0_OFFSET + 3*5)
+#define VP9_COEF_COUNT_BAND_2_OFFSET   \
+			(VP9_COEF_COUNT_BAND_1_OFFSET + 6*5)
+#define VP9_COEF_COUNT_BAND_3_OFFSET   \
+			(VP9_COEF_COUNT_BAND_2_OFFSET + 6*5)
+#define VP9_COEF_COUNT_BAND_4_OFFSET   \
+			(VP9_COEF_COUNT_BAND_3_OFFSET + 6*5)
+#define VP9_COEF_COUNT_BAND_5_OFFSET   \
+			(VP9_COEF_COUNT_BAND_4_OFFSET + 6*5)
+#define VP9_COEF_COUNT_SIZE_ONE_SET    165 /* ((3 +5*6)*5 */
+#define VP9_COEF_COUNT_4X4_START       \
+	(VP9_COEF_COUNT_START + 0*VP9_COEF_COUNT_SIZE_ONE_SET)
+#define VP9_COEF_COUNT_8X8_START       \
+	(VP9_COEF_COUNT_START + 4*VP9_COEF_COUNT_SIZE_ONE_SET)
+#define VP9_COEF_COUNT_16X16_START     \
+	(VP9_COEF_COUNT_START + 8*VP9_COEF_COUNT_SIZE_ONE_SET)
+#define VP9_COEF_COUNT_32X32_START     \
+	(VP9_COEF_COUNT_START + 12*VP9_COEF_COUNT_SIZE_ONE_SET)
+#define VP9_COEF_COUNT_SIZE_PLANE      (2 * VP9_COEF_COUNT_SIZE_ONE_SET)
+#define VP9_COEF_COUNT_SIZE            (4 * 2 * 2 * VP9_COEF_COUNT_SIZE_ONE_SET)
+
+#define VP9_INTRA_INTER_COUNT_START    \
+	(VP9_COEF_COUNT_START+VP9_COEF_COUNT_SIZE)
+#define VP9_INTRA_INTER_COUNT_SIZE     (4*2)
+#define VP9_COMP_INTER_COUNT_START     \
+	(VP9_INTRA_INTER_COUNT_START+VP9_INTRA_INTER_COUNT_SIZE)
+#define VP9_COMP_INTER_COUNT_SIZE      (5*2)
+#define VP9_COMP_REF_COUNT_START       \
+	(VP9_COMP_INTER_COUNT_START+VP9_COMP_INTER_COUNT_SIZE)
+#define VP9_COMP_REF_COUNT_SIZE        (5*2)
+#define VP9_SINGLE_REF_COUNT_START     \
+	(VP9_COMP_REF_COUNT_START+VP9_COMP_REF_COUNT_SIZE)
+#define VP9_SINGLE_REF_COUNT_SIZE      (10*2)
+#define VP9_TX_MODE_COUNT_START        \
+	(VP9_SINGLE_REF_COUNT_START+VP9_SINGLE_REF_COUNT_SIZE)
+#define VP9_TX_MODE_COUNT_SIZE         (12*2)
+#define VP9_SKIP_COUNT_START           \
+	(VP9_TX_MODE_COUNT_START+VP9_TX_MODE_COUNT_SIZE)
+#define VP9_SKIP_COUNT_SIZE            (3*2)
+#define VP9_MV_SIGN_0_COUNT_START      \
+	(VP9_SKIP_COUNT_START+VP9_SKIP_COUNT_SIZE)
+#define VP9_MV_SIGN_0_COUNT_SIZE       (1*2)
+#define VP9_MV_SIGN_1_COUNT_START      \
+	(VP9_MV_SIGN_0_COUNT_START+VP9_MV_SIGN_0_COUNT_SIZE)
+#define VP9_MV_SIGN_1_COUNT_SIZE       (1*2)
+#define VP9_MV_BITS_0_COUNT_START      \
+	(VP9_MV_SIGN_1_COUNT_START+VP9_MV_SIGN_1_COUNT_SIZE)
+#define VP9_MV_BITS_0_COUNT_SIZE       (10*2)
+#define VP9_MV_BITS_1_COUNT_START      \
+	(VP9_MV_BITS_0_COUNT_START+VP9_MV_BITS_0_COUNT_SIZE)
+#define VP9_MV_BITS_1_COUNT_SIZE       (10*2)
+#define VP9_MV_CLASS0_HP_0_COUNT_START \
+	(VP9_MV_BITS_1_COUNT_START+VP9_MV_BITS_1_COUNT_SIZE)
+#define VP9_MV_CLASS0_HP_0_COUNT_SIZE  (2*2)
+#define VP9_MV_CLASS0_HP_1_COUNT_START \
+	(VP9_MV_CLASS0_HP_0_COUNT_START+VP9_MV_CLASS0_HP_0_COUNT_SIZE)
+#define VP9_MV_CLASS0_HP_1_COUNT_SIZE  (2*2)
+/* Start merge_tree*/
+#define VP9_INTER_MODE_COUNT_START     \
+	(VP9_MV_CLASS0_HP_1_COUNT_START+VP9_MV_CLASS0_HP_1_COUNT_SIZE)
+#define VP9_INTER_MODE_COUNT_SIZE      (7*4)
+#define VP9_IF_Y_MODE_COUNT_START      \
+	(VP9_INTER_MODE_COUNT_START+VP9_INTER_MODE_COUNT_SIZE)
+#define VP9_IF_Y_MODE_COUNT_SIZE       (10*4)
+#define VP9_IF_UV_MODE_COUNT_START     \
+	(VP9_IF_Y_MODE_COUNT_START+VP9_IF_Y_MODE_COUNT_SIZE)
+#define VP9_IF_UV_MODE_COUNT_SIZE      (10*10)
+#define VP9_PARTITION_P_COUNT_START    \
+	(VP9_IF_UV_MODE_COUNT_START+VP9_IF_UV_MODE_COUNT_SIZE)
+#define VP9_PARTITION_P_COUNT_SIZE     (4*4*4)
+#define VP9_INTERP_COUNT_START         \
+	(VP9_PARTITION_P_COUNT_START+VP9_PARTITION_P_COUNT_SIZE)
+#define VP9_INTERP_COUNT_SIZE          (4*3)
+#define VP9_MV_JOINTS_COUNT_START      \
+	(VP9_INTERP_COUNT_START+VP9_INTERP_COUNT_SIZE)
+#define VP9_MV_JOINTS_COUNT_SIZE       (1 * 4)
+#define VP9_MV_CLASSES_0_COUNT_START   \
+	(VP9_MV_JOINTS_COUNT_START+VP9_MV_JOINTS_COUNT_SIZE)
+#define VP9_MV_CLASSES_0_COUNT_SIZE    (1*11)
+#define VP9_MV_CLASS0_0_COUNT_START    \
+	(VP9_MV_CLASSES_0_COUNT_START+VP9_MV_CLASSES_0_COUNT_SIZE)
+#define VP9_MV_CLASS0_0_COUNT_SIZE     (1*2)
+#define VP9_MV_CLASSES_1_COUNT_START   \
+	(VP9_MV_CLASS0_0_COUNT_START+VP9_MV_CLASS0_0_COUNT_SIZE)
+#define VP9_MV_CLASSES_1_COUNT_SIZE    (1*11)
+#define VP9_MV_CLASS0_1_COUNT_START    \
+	(VP9_MV_CLASSES_1_COUNT_START+VP9_MV_CLASSES_1_COUNT_SIZE)
+#define VP9_MV_CLASS0_1_COUNT_SIZE     (1*2)
+#define VP9_MV_CLASS0_FP_0_COUNT_START \
+	(VP9_MV_CLASS0_1_COUNT_START+VP9_MV_CLASS0_1_COUNT_SIZE)
+#define VP9_MV_CLASS0_FP_0_COUNT_SIZE  (3*4)
+#define VP9_MV_CLASS0_FP_1_COUNT_START \
+	(VP9_MV_CLASS0_FP_0_COUNT_START+VP9_MV_CLASS0_FP_0_COUNT_SIZE)
+#define VP9_MV_CLASS0_FP_1_COUNT_SIZE  (3*4)
+
+
+#define DC_PRED    0       /* Average of above and left pixels*/
+#define V_PRED     1       /* Vertical*/
+#define H_PRED     2       /* Horizontal*/
+#define D45_PRED   3       /*Directional 45 deg = round(arctan(1/1) * 180/pi)*/
+#define D135_PRED  4       /* Directional 135 deg = 180 - 45*/
+#define D117_PRED  5       /* Directional 117 deg = 180 - 63*/
+#define D153_PRED  6       /* Directional 153 deg = 180 - 27*/
+#define D207_PRED  7       /* Directional 207 deg = 180 + 27*/
+#define D63_PRED   8       /*Directional 63 deg = round(arctan(2/1) * 180/pi)*/
+#define TM_PRED    9       /*True-motion*/
+
+int clip_prob(int p)
+{
+	return (p > 255) ? 255 : (p < 1) ? 1 : p;
+}
+
+#define ROUND_POWER_OF_TWO(value, n) \
+	(((value) + (1 << ((n) - 1))) >> (n))
+
+#define MODE_MV_COUNT_SAT 20
+static const int count_to_update_factor[MODE_MV_COUNT_SAT + 1] = {
+	0, 6, 12, 19, 25, 32, 38, 44, 51, 57, 64,
+	70, 76, 83, 89, 96, 102, 108, 115, 121, 128
+};
+
+void   vp9_tree_merge_probs(unsigned int *prev_prob, unsigned int *cur_prob,
+	int coef_node_start, int tree_left, int tree_right, int tree_i,
+	int node) {
+
+	int prob_32, prob_res, prob_shift;
+	int pre_prob, new_prob;
+	int den, m_count, get_prob, factor;
+	prob_32 = prev_prob[coef_node_start / 4 * 2];
+	prob_res = coef_node_start & 3;
+	prob_shift = prob_res * 8;
+	pre_prob = (prob_32 >> prob_shift) & 0xff;
+
+	den = tree_left + tree_right;
+
+	if (den == 0)
+		new_prob = pre_prob;
+	else {
+		m_count = (den < MODE_MV_COUNT_SAT) ?
+			den : MODE_MV_COUNT_SAT;
+		get_prob = clip_prob(
+				div_r32(((int64_t)tree_left * 256 + (den >> 1)),
+				den));
+		/*weighted_prob*/
+		factor = count_to_update_factor[m_count];
+		new_prob = ROUND_POWER_OF_TWO(pre_prob * (256 - factor)
+				+ get_prob * factor, 8);
+	}
+	cur_prob[coef_node_start / 4 * 2] = (cur_prob[coef_node_start / 4 * 2]
+			& (~(0xff << prob_shift))) | (new_prob << prob_shift);
+
+	/*pr_info(" - [%d][%d] 0x%02X --> 0x%02X (0x%X 0x%X) (%X)\n",
+	tree_i, node, pre_prob, new_prob, tree_left, tree_right,
+	cur_prob[coef_node_start/4*2]);*/
+}
+
+
+/*void adapt_coef_probs(void)*/
+void adapt_coef_probs(int pic_count, int prev_kf, int cur_kf, int pre_fc,
+	unsigned int *prev_prob, unsigned int *cur_prob, unsigned int *count)
+{
+	/* 80 * 64bits = 0xF00 ( use 0x1000 4K bytes)
+	unsigned int prev_prob[496*2];
+	unsigned int cur_prob[496*2];
+	0x300 * 128bits = 0x3000 (32K Bytes)
+	unsigned int count[0x300*4];*/
+
+	int tx_size, coef_tx_size_start, coef_count_tx_size_start;
+	int plane, coef_plane_start, coef_count_plane_start;
+	int type, coef_type_start, coef_count_type_start;
+	int band, coef_band_start, coef_count_band_start;
+	int cxt_num;
+	int cxt, coef_cxt_start, coef_count_cxt_start;
+	int node, coef_node_start, coef_count_node_start;
+
+	int tree_i, tree_left, tree_right;
+	int mvd_i;
+
+	int count_sat = 24;
+	/*int update_factor = 112;*/ /*If COEF_MAX_UPDATE_FACTOR_AFTER_KEY,
+	use 128*/
+	/* If COEF_MAX_UPDATE_FACTOR_AFTER_KEY, use 128*/
+	/*int update_factor = (pic_count == 1) ? 128 : 112;*/
+	int update_factor =   cur_kf ? 112 :
+			prev_kf ? 128 : 112;
+
+	int prob_32;
+	int prob_res;
+	int prob_shift;
+	int pre_prob;
+
+	int num, den;
+	int get_prob;
+	int m_count;
+	int factor;
+
+	int new_prob;
+
+	if (debug & VP9_DEBUG_MERGE)
+		pr_info
+	("\n ##adapt_coef_probs (pre_fc : %d ,prev_kf : %d,cur_kf : %d)##\n\n",
+	pre_fc, prev_kf, cur_kf);
+
+	/*adapt_coef_probs*/
+	for (tx_size = 0; tx_size < 4; tx_size++) {
+		coef_tx_size_start = VP9_COEF_START
+			+ tx_size * 4 * VP9_COEF_SIZE_ONE_SET;
+		coef_count_tx_size_start = VP9_COEF_COUNT_START
+			+ tx_size * 4 * VP9_COEF_COUNT_SIZE_ONE_SET;
+		coef_plane_start = coef_tx_size_start;
+		coef_count_plane_start = coef_count_tx_size_start;
+		for (plane = 0; plane < 2; plane++) {
+			coef_type_start = coef_plane_start;
+			coef_count_type_start = coef_count_plane_start;
+			for (type = 0; type < 2; type++) {
+				coef_band_start = coef_type_start;
+				coef_count_band_start = coef_count_type_start;
+				for (band = 0; band < 6; band++) {
+					if (band == 0)
+						cxt_num = 3;
+					else
+						cxt_num = 6;
+					coef_cxt_start = coef_band_start;
+					coef_count_cxt_start =
+						coef_count_band_start;
+					for (cxt = 0; cxt < cxt_num; cxt++) {
+						const int n0 =
+						count[coef_count_cxt_start];
+						const int n1 =
+						count[coef_count_cxt_start + 1];
+						const int n2 =
+						count[coef_count_cxt_start + 2];
+						const int neob =
+						count[coef_count_cxt_start + 3];
+						const int nneob =
+						count[coef_count_cxt_start + 4];
+						const unsigned int
+						branch_ct[3][2] = {
+						{ neob, nneob },
+						{ n0, n1 + n2 },
+						{ n1, n2 }
+						};
+						coef_node_start =
+							coef_cxt_start;
+						for
+						(node = 0; node < 3; node++) {
+							prob_32 =
+							prev_prob[
+							coef_node_start
+							/ 4 * 2];
+							prob_res =
+							coef_node_start & 3;
+							prob_shift =
+							prob_res * 8;
+							pre_prob =
+							(prob_32 >> prob_shift)
+							& 0xff;
+
+							/*get_binary_prob*/
+							num =
+							branch_ct[node][0];
+							den =
+							branch_ct[node][0] +
+							 branch_ct[node][1];
+							m_count = (den <
+							count_sat)
+							? den : count_sat;
+
+							get_prob =
+							(den == 0) ? 128u :
+							clip_prob(
+							div_r32(((int64_t)
+							num * 256
+							+ (den >> 1)),
+							den));
+
+							factor =
+							update_factor * m_count
+							/ count_sat;
+							new_prob =
+							ROUND_POWER_OF_TWO
+							(pre_prob *
+							(256 - factor) +
+							get_prob * factor, 8);
+
+							cur_prob[coef_node_start
+							/ 4 * 2] =
+							(cur_prob
+							[coef_node_start
+							/ 4 * 2] & (~(0xff <<
+							prob_shift))) |
+							(new_prob <<
+							prob_shift);
+
+							coef_node_start += 1;
+						}
+
+						coef_cxt_start =
+							coef_cxt_start + 3;
+						coef_count_cxt_start =
+							coef_count_cxt_start
+							+ 5;
+					}
+					if (band == 0) {
+						coef_band_start += 10;
+						coef_count_band_start += 15;
+					} else {
+						coef_band_start += 18;
+						coef_count_band_start += 30;
+					}
+				}
+				coef_type_start += VP9_COEF_SIZE_ONE_SET;
+				coef_count_type_start +=
+					VP9_COEF_COUNT_SIZE_ONE_SET;
+			}
+			coef_plane_start += 2 * VP9_COEF_SIZE_ONE_SET;
+			coef_count_plane_start +=
+					2 * VP9_COEF_COUNT_SIZE_ONE_SET;
+		}
+	}
+
+if (cur_kf == 0) {
+		/*mode_mv_merge_probs - merge_intra_inter_prob*/
+		for (coef_count_node_start = VP9_INTRA_INTER_COUNT_START;
+		coef_count_node_start < (VP9_MV_CLASS0_HP_1_COUNT_START +
+		VP9_MV_CLASS0_HP_1_COUNT_SIZE);	coef_count_node_start += 2) {
+
+			if (coef_count_node_start ==
+				VP9_INTRA_INTER_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_intra_inter_prob\n");
+				coef_node_start = VP9_INTRA_INTER_START;
+			} else if (coef_count_node_start ==
+				VP9_COMP_INTER_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_comp_inter_prob\n");
+				coef_node_start = VP9_COMP_INTER_START;
+			}
+			/*
+			else if (coef_count_node_start ==
+				VP9_COMP_REF_COUNT_START) {
+				pr_info(" # merge_comp_inter_prob\n");
+				coef_node_start = VP9_COMP_REF_START;
+			}
+			else if (coef_count_node_start ==
+				VP9_SINGLE_REF_COUNT_START) {
+				pr_info(" # merge_comp_inter_prob\n");
+				coef_node_start = VP9_SINGLE_REF_START;
+			}
+			*/
+			else if (coef_count_node_start ==
+				VP9_TX_MODE_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_tx_mode_probs\n");
+				coef_node_start = VP9_TX_MODE_START;
+			} else if (coef_count_node_start ==
+				VP9_SKIP_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_skip_probs\n");
+				coef_node_start = VP9_SKIP_START;
+			} else if (coef_count_node_start ==
+				VP9_MV_SIGN_0_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_sign_0\n");
+				coef_node_start = VP9_MV_SIGN_0_START;
+			} else if (coef_count_node_start ==
+				VP9_MV_SIGN_1_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_sign_1\n");
+				coef_node_start = VP9_MV_SIGN_1_START;
+			} else if (coef_count_node_start ==
+				VP9_MV_BITS_0_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_bits_0\n");
+				coef_node_start = VP9_MV_BITS_0_START;
+			} else if (coef_count_node_start ==
+				VP9_MV_BITS_1_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_bits_1\n");
+				coef_node_start = VP9_MV_BITS_1_START;
+			} else if (coef_count_node_start ==
+					VP9_MV_CLASS0_HP_0_COUNT_START) {
+				if (debug & VP9_DEBUG_MERGE)
+					pr_info(" # merge_class0_hp\n");
+				coef_node_start = VP9_MV_CLASS0_HP_0_START;
+			}
+
+
+		den = count[coef_count_node_start] +
+			count[coef_count_node_start + 1];
+
+		prob_32 = prev_prob[coef_node_start / 4 * 2];
+		prob_res = coef_node_start & 3;
+		prob_shift = prob_res * 8;
+		pre_prob = (prob_32 >> prob_shift) & 0xff;
+
+		if (den == 0)
+			new_prob = pre_prob;
+		else {
+			m_count = (den < MODE_MV_COUNT_SAT) ?
+				den : MODE_MV_COUNT_SAT;
+			get_prob =
+				clip_prob(
+				div_r32(((int64_t)count[coef_count_node_start]
+				* 256 + (den >> 1)),
+				den));
+			/*weighted_prob*/
+			factor = count_to_update_factor[m_count];
+			new_prob =
+				ROUND_POWER_OF_TWO(pre_prob * (256 - factor)
+				+ get_prob * factor, 8);
+		}
+		cur_prob[coef_node_start / 4 * 2] =
+			(cur_prob[coef_node_start / 4 * 2] &
+			(~(0xff << prob_shift)))
+			| (new_prob << prob_shift);
+
+		coef_node_start = coef_node_start + 1;
+	}
+	if (debug & VP9_DEBUG_MERGE)
+		pr_info(" # merge_vp9_inter_mode_tree\n");
+	coef_node_start = VP9_INTER_MODE_START;
+	coef_count_node_start = VP9_INTER_MODE_COUNT_START;
+	for (tree_i = 0; tree_i < 7; tree_i++) {
+		for (node = 0; node < 3; node++) {
+			switch (node) {
+			case 2:
+				tree_left =
+				count[coef_count_node_start + 1];
+				tree_right =
+				count[coef_count_node_start + 3];
+				break;
+			case 1:
+				tree_left =
+				count[coef_count_node_start + 0];
+				tree_right =
+				count[coef_count_node_start + 1]
+				+ count[coef_count_node_start + 3];
+				break;
+			default:
+				tree_left =
+				count[coef_count_node_start + 2];
+				tree_right =
+				count[coef_count_node_start + 0]
+				+ count[coef_count_node_start + 1]
+				+ count[coef_count_node_start + 3];
+				break;
+
+			}
+
+			vp9_tree_merge_probs(prev_prob, cur_prob,
+				coef_node_start, tree_left, tree_right,
+				tree_i, node);
+
+			coef_node_start = coef_node_start + 1;
+		}
+		coef_count_node_start = coef_count_node_start + 4;
+	}
+	if (debug & VP9_DEBUG_MERGE)
+		pr_info(" # merge_vp9_intra_mode_tree\n");
+	coef_node_start = VP9_IF_Y_MODE_START;
+	coef_count_node_start = VP9_IF_Y_MODE_COUNT_START;
+	for (tree_i = 0; tree_i < 14; tree_i++) {
+		for (node = 0; node < 9; node++) {
+			switch (node) {
+			case 8:
+				tree_left =
+				count[coef_count_node_start+D153_PRED];
+				tree_right =
+				count[coef_count_node_start+D207_PRED];
+				break;
+			case 7:
+				tree_left =
+				count[coef_count_node_start+D63_PRED];
+				tree_right =
+				count[coef_count_node_start+D207_PRED] +
+				count[coef_count_node_start+D153_PRED];
+				break;
+			case 6:
+				tree_left =
+				count[coef_count_node_start + D45_PRED];
+				tree_right =
+				count[coef_count_node_start+D207_PRED] +
+				count[coef_count_node_start+D153_PRED] +
+				count[coef_count_node_start+D63_PRED];
+				break;
+			case 5:
+				tree_left =
+				count[coef_count_node_start+D135_PRED];
+				tree_right =
+				count[coef_count_node_start+D117_PRED];
+				break;
+			case 4:
+				tree_left =
+				count[coef_count_node_start+H_PRED];
+				tree_right =
+				count[coef_count_node_start+D117_PRED] +
+				count[coef_count_node_start+D135_PRED];
+				break;
+			case 3:
+				tree_left =
+				count[coef_count_node_start+H_PRED] +
+				count[coef_count_node_start+D117_PRED] +
+				count[coef_count_node_start+D135_PRED];
+				tree_right =
+				count[coef_count_node_start+D45_PRED] +
+				count[coef_count_node_start+D207_PRED] +
+				count[coef_count_node_start+D153_PRED] +
+				count[coef_count_node_start+D63_PRED];
+				break;
+			case 2:
+				tree_left =
+				count[coef_count_node_start+V_PRED];
+				tree_right =
+				count[coef_count_node_start+H_PRED] +
+				count[coef_count_node_start+D117_PRED] +
+				count[coef_count_node_start+D135_PRED] +
+				count[coef_count_node_start+D45_PRED] +
+				count[coef_count_node_start+D207_PRED] +
+				count[coef_count_node_start+D153_PRED] +
+				count[coef_count_node_start+D63_PRED];
+				break;
+			case 1:
+				tree_left =
+				count[coef_count_node_start+TM_PRED];
+				tree_right =
+				count[coef_count_node_start+V_PRED] +
+				count[coef_count_node_start+H_PRED] +
+				count[coef_count_node_start+D117_PRED] +
+				count[coef_count_node_start+D135_PRED] +
+				count[coef_count_node_start+D45_PRED] +
+				count[coef_count_node_start+D207_PRED] +
+				count[coef_count_node_start+D153_PRED] +
+				count[coef_count_node_start+D63_PRED];
+				break;
+			default:
+				tree_left =
+				count[coef_count_node_start+DC_PRED];
+				tree_right =
+				count[coef_count_node_start+TM_PRED] +
+				count[coef_count_node_start+V_PRED] +
+				count[coef_count_node_start+H_PRED] +
+				count[coef_count_node_start+D117_PRED] +
+				count[coef_count_node_start+D135_PRED] +
+				count[coef_count_node_start+D45_PRED] +
+				count[coef_count_node_start+D207_PRED] +
+				count[coef_count_node_start+D153_PRED] +
+				count[coef_count_node_start+D63_PRED];
+				break;
+
+				}
+
+			vp9_tree_merge_probs(prev_prob, cur_prob,
+				coef_node_start, tree_left, tree_right,
+				tree_i, node);
+
+			coef_node_start = coef_node_start + 1;
+		}
+		coef_count_node_start = coef_count_node_start + 10;
+	}
+
+	if (debug & VP9_DEBUG_MERGE)
+		pr_info(" # merge_vp9_partition_tree\n");
+	coef_node_start = VP9_PARTITION_P_START;
+	coef_count_node_start = VP9_PARTITION_P_COUNT_START;
+	for (tree_i = 0; tree_i < 16; tree_i++) {
+		for (node = 0; node < 3; node++) {
+			switch (node) {
+			case 2:
+				tree_left =
+				count[coef_count_node_start + 2];
+				tree_right =
+				count[coef_count_node_start + 3];
+				break;
+			case 1:
+				tree_left =
+				count[coef_count_node_start + 1];
+				tree_right =
+				count[coef_count_node_start + 2] +
+				count[coef_count_node_start + 3];
+				break;
+			default:
+				tree_left =
+				count[coef_count_node_start + 0];
+				tree_right =
+				count[coef_count_node_start + 1] +
+				count[coef_count_node_start + 2] +
+				count[coef_count_node_start + 3];
+				break;
+
+			}
+
+			vp9_tree_merge_probs(prev_prob, cur_prob,
+				coef_node_start,
+				tree_left, tree_right, tree_i, node);
+
+			coef_node_start = coef_node_start + 1;
+		}
+		coef_count_node_start = coef_count_node_start + 4;
+	}
+
+	if (debug & VP9_DEBUG_MERGE)
+		pr_info(" # merge_vp9_switchable_interp_tree\n");
+	coef_node_start = VP9_INTERP_START;
+	coef_count_node_start = VP9_INTERP_COUNT_START;
+	for (tree_i = 0; tree_i < 4; tree_i++) {
+		for (node = 0; node < 2; node++) {
+			switch (node) {
+			case 1:
+				tree_left =
+				count[coef_count_node_start + 1];
+				tree_right =
+				count[coef_count_node_start + 2];
+				break;
+			default:
+				tree_left =
+				count[coef_count_node_start + 0];
+				tree_right =
+				count[coef_count_node_start + 1] +
+				count[coef_count_node_start + 2];
+				break;
+
+			}
+
+			vp9_tree_merge_probs(prev_prob, cur_prob,
+				coef_node_start,
+				tree_left, tree_right, tree_i, node);
+
+			coef_node_start = coef_node_start + 1;
+		}
+		coef_count_node_start = coef_count_node_start + 3;
+	}
+
+	if (debug & VP9_DEBUG_MERGE)
+		pr_info("# merge_vp9_mv_joint_tree\n");
+	coef_node_start = VP9_MV_JOINTS_START;
+	coef_count_node_start = VP9_MV_JOINTS_COUNT_START;
+	for (tree_i = 0; tree_i < 1; tree_i++) {
+		for (node = 0; node < 3; node++) {
+			switch (node) {
+			case 2:
+				tree_left =
+				count[coef_count_node_start + 2];
+				tree_right =
+				count[coef_count_node_start + 3];
+				break;
+			case 1:
+				tree_left =
+				count[coef_count_node_start + 1];
+				tree_right =
+				count[coef_count_node_start + 2] +
+				count[coef_count_node_start + 3];
+				break;
+			default:
+				tree_left =
+				count[coef_count_node_start + 0];
+				tree_right =
+				count[coef_count_node_start + 1] +
+				count[coef_count_node_start + 2] +
+				count[coef_count_node_start + 3];
+				break;
+			}
+
+			vp9_tree_merge_probs(prev_prob, cur_prob,
+				coef_node_start,
+				tree_left, tree_right, tree_i, node);
+
+			coef_node_start = coef_node_start + 1;
+		}
+		coef_count_node_start = coef_count_node_start + 4;
+	}
+
+	for (mvd_i = 0; mvd_i < 2; mvd_i++) {
+		if (debug & VP9_DEBUG_MERGE)
+			pr_info(" # merge_vp9_mv_class_tree [%d]  -\n", mvd_i);
+		coef_node_start =
+			mvd_i ? VP9_MV_CLASSES_1_START : VP9_MV_CLASSES_0_START;
+		coef_count_node_start =
+			mvd_i ? VP9_MV_CLASSES_1_COUNT_START
+			: VP9_MV_CLASSES_0_COUNT_START;
+		tree_i = 0;
+		for (node = 0; node < 10; node++) {
+			switch (node) {
+			case 9:
+				tree_left =
+				count[coef_count_node_start + 9];
+				tree_right =
+				count[coef_count_node_start + 10];
+				break;
+			case 8:
+				tree_left =
+				count[coef_count_node_start + 7];
+				tree_right =
+				count[coef_count_node_start + 8];
+				break;
+			case 7:
+				tree_left =
+				count[coef_count_node_start + 7] +
+				count[coef_count_node_start + 8];
+				tree_right =
+				count[coef_count_node_start + 9] +
+				count[coef_count_node_start + 10];
+				break;
+			case 6:
+				tree_left =
+				count[coef_count_node_start + 6];
+				tree_right =
+				count[coef_count_node_start + 7] +
+				count[coef_count_node_start + 8] +
+				count[coef_count_node_start + 9] +
+				count[coef_count_node_start + 10];
+				break;
+			case 5:
+				tree_left =
+				count[coef_count_node_start + 4];
+				tree_right =
+				count[coef_count_node_start + 5];
+				break;
+			case 4:
+				tree_left =
+				count[coef_count_node_start + 4] +
+				count[coef_count_node_start + 5];
+				tree_right =
+				count[coef_count_node_start + 6] +
+				count[coef_count_node_start + 7] +
+				count[coef_count_node_start + 8] +
+				count[coef_count_node_start + 9] +
+				count[coef_count_node_start + 10];
+				break;
+			case 3:
+				tree_left =
+				count[coef_count_node_start + 2];
+				tree_right =
+				count[coef_count_node_start + 3];
+				break;
+			case 2:
+				tree_left =
+				count[coef_count_node_start + 2] +
+				count[coef_count_node_start + 3];
+				tree_right =
+				count[coef_count_node_start + 4] +
+				count[coef_count_node_start + 5] +
+				count[coef_count_node_start + 6] +
+				count[coef_count_node_start + 7] +
+				count[coef_count_node_start + 8] +
+				count[coef_count_node_start + 9] +
+				count[coef_count_node_start + 10];
+				break;
+			case 1:
+				tree_left =
+				count[coef_count_node_start + 1];
+				tree_right =
+				count[coef_count_node_start + 2] +
+				count[coef_count_node_start + 3] +
+				count[coef_count_node_start + 4] +
+				count[coef_count_node_start + 5] +
+				count[coef_count_node_start + 6] +
+				count[coef_count_node_start + 7] +
+				count[coef_count_node_start + 8] +
+				count[coef_count_node_start + 9] +
+				count[coef_count_node_start + 10];
+				break;
+			default:
+				tree_left =
+				count[coef_count_node_start + 0];
+				tree_right =
+				count[coef_count_node_start + 1] +
+				count[coef_count_node_start + 2] +
+				count[coef_count_node_start + 3] +
+				count[coef_count_node_start + 4] +
+				count[coef_count_node_start + 5] +
+				count[coef_count_node_start + 6] +
+				count[coef_count_node_start + 7] +
+				count[coef_count_node_start + 8] +
+				count[coef_count_node_start + 9] +
+				count[coef_count_node_start + 10];
+				break;
+
+			}
+
+			vp9_tree_merge_probs(prev_prob, cur_prob,
+				coef_node_start, tree_left, tree_right,
+				tree_i, node);
+
+			coef_node_start = coef_node_start + 1;
+		}
+
+		if (debug & VP9_DEBUG_MERGE)
+			pr_info(" # merge_vp9_mv_class0_tree [%d]  -\n", mvd_i);
+		coef_node_start =
+			mvd_i ? VP9_MV_CLASS0_1_START : VP9_MV_CLASS0_0_START;
+		coef_count_node_start =
+			mvd_i ? VP9_MV_CLASS0_1_COUNT_START :
+			VP9_MV_CLASS0_0_COUNT_START;
+		tree_i = 0;
+		node = 0;
+		tree_left = count[coef_count_node_start + 0];
+		tree_right = count[coef_count_node_start + 1];
+
+		vp9_tree_merge_probs(prev_prob, cur_prob, coef_node_start,
+			tree_left, tree_right, tree_i, node);
+		if (debug & VP9_DEBUG_MERGE)
+			pr_info(" # merge_vp9_mv_fp_tree_class0_fp [%d]  -\n",
+				mvd_i);
+		coef_node_start =
+			mvd_i ? VP9_MV_CLASS0_FP_1_START :
+			VP9_MV_CLASS0_FP_0_START;
+		coef_count_node_start =
+			mvd_i ? VP9_MV_CLASS0_FP_1_COUNT_START :
+			VP9_MV_CLASS0_FP_0_COUNT_START;
+		for (tree_i = 0; tree_i < 3; tree_i++) {
+			for (node = 0; node < 3; node++) {
+				switch (node) {
+				case 2:
+					tree_left =
+					count[coef_count_node_start + 2];
+					tree_right =
+					count[coef_count_node_start + 3];
+					break;
+				case 1:
+					tree_left =
+					count[coef_count_node_start + 1];
+					tree_right =
+					count[coef_count_node_start + 2]
+					+ count[coef_count_node_start + 3];
+					break;
+				default:
+					tree_left =
+					count[coef_count_node_start + 0];
+					tree_right =
+					count[coef_count_node_start + 1]
+					+ count[coef_count_node_start + 2]
+					+ count[coef_count_node_start + 3];
+					break;
+
+				}
+
+				vp9_tree_merge_probs(prev_prob, cur_prob,
+					coef_node_start, tree_left, tree_right,
+					tree_i, node);
+
+				coef_node_start = coef_node_start + 1;
+			}
+			coef_count_node_start = coef_count_node_start + 4;
+		}
+
+	} /* for mvd_i (mvd_y or mvd_x)*/
+}
+
+}
+
+
+
+/*USE_BUF_BLOCK*/
+static void uninit_buf_list(struct VP9Decoder_s *pbi)
+{
+	int i;
+	struct VP9_Common_s *cm = &pbi->common;
+	uint8_t release_cma_flag = 0;
+	uint8_t blackout = get_blackout_policy();
+	u32 buffer_mode_real =
+		(buffer_mode & ((buffer_mode_dbg >> 16) & 0xfff)) |
+		(buffer_mode_dbg & 0xfff);
+	blackout &= ((buffer_mode_dbg >> 28) & 0xf);
+	blackout |=  ((buffer_mode_dbg >> 12) & 0xf);
+
+	pbi->predisp_addr = 0;
+
+	if (buffer_mode_real & 1) {
+		if (blackout == 1)
+			release_cma_flag = 1;
+	} else {
+		if (buffer_mode_real & 2)
+			;
+		else
+			release_cma_flag = 1;
+	}
+
+	if (blackout != 1) {
+		struct PIC_BUFFER_CONFIG_s *pic_config;
+		if ((release_cma_flag == 1) &&
+				(buffer_mode_real & 8)) {
+			release_cma_flag = 2;
+		}
+
+		msleep(50); /* ensure RDMA for display is done */
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB &&
+			double_write_mode == 0) {
+			pbi->predisp_addr =
+			READ_VCBUS_REG(AFBC_BODY_BADDR) << 4;
+		} else {
+			struct canvas_s cur_canvas;
+			canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
+				 &cur_canvas);
+			pbi->predisp_addr = cur_canvas.addr;
+		}
+
+		for (i = 0; i < FRAME_BUFFERS; i++) {
+			pic_config = &cm->buffer_pool->frame_bufs[i].buf;
+			if (pic_config->index == -1)
+				continue;
+			if (pbi->predisp_addr == pic_config->mc_y_adr) {
+				pbi->predisp_size = pic_config->buf_size;
+				pr_info("%s, set  pbi->predisp_size = %d\n",
+					__func__, pic_config->buf_size);
+				break;
+			}
+		}
+	}
+
+	if (pbi->pre_last_frame_alloc_addr) {
+		if (blackout == 1 || pbi->predisp_addr == 0
+			|| pbi->predisp_addr < pbi->pre_last_frame_alloc_addr
+			|| pbi->predisp_addr >=
+			(pbi->pre_last_frame_alloc_addr
+				+ pbi->pre_last_frame_alloc_size)
+			) {
+			codec_mm_free_for_dma(MEM_NAME,
+				pbi->pre_last_frame_alloc_addr);
+			pr_info("release pre_last_frame cma buffer %ld\n",
+				pbi->pre_last_frame_alloc_addr);
+			pbi->pre_last_frame_alloc_addr = 0;
+			pbi->pre_last_frame_alloc_size = 0;
+		}
+	}
+
+	if (release_cma_flag) {
+		for (i = 0; i < pbi->used_buf_num; i++) {
+			if (pbi->m_BUF[i].alloc_addr != 0
+				&& pbi->m_BUF[i].cma_page_count > 0) {
+				if ((release_cma_flag == 2)
+					&& (pbi->predisp_addr >=
+						pbi->m_BUF[i].start_adr)
+					&& (pbi->predisp_addr <
+					(pbi->m_BUF[i].start_adr +
+						pbi->m_BUF[i].size))) {
+					if (pbi->pre_last_frame_alloc_addr)
+						pr_info("last buf not free\n");
+					else {
+						pbi->pre_last_frame_alloc_addr
+						=
+						pbi->m_BUF[i].alloc_addr;
+						pbi->pre_last_frame_alloc_size
+						    = pbi->m_BUF[i].size;
+						pbi->m_BUF[i].alloc_addr = 0;
+						pbi->m_BUF[i].
+						cma_page_count = 0;
+						continue;
+					}
+				}
+
+				pr_info("release cma buffer[%d] (%d %ld)\n", i,
+					pbi->m_BUF[i].cma_page_count,
+					pbi->m_BUF[i].alloc_addr);
+				codec_mm_free_for_dma(MEM_NAME,
+					pbi->m_BUF[i].alloc_addr);
+				pbi->m_BUF[i].alloc_addr = 0;
+				pbi->m_BUF[i].cma_page_count = 0;
+
+			}
+		}
+	}
+	pr_info("%s, blackout %x r%x buf_mode %x r%x rel_cma_flag %x pbi->predisp_addr %d pre_alloc_addr(%ld, %ld)\n",
+		__func__, get_blackout_policy(), blackout,
+		buffer_mode, buffer_mode_real, release_cma_flag,
+		pbi->predisp_addr, pbi->pre_last_frame_alloc_addr,
+		pbi->pre_last_frame_alloc_size);
+	pbi->buf_num = 0;
+}
+
+static void init_buf_list(struct VP9Decoder_s *pbi)
+{
+	int i;
+	int buf_size;
+	int mc_buffer_end = pbi->mc_buf->buf_start + pbi->mc_buf->buf_size;
+
+	pbi->used_buf_num = max_buf_num;
+
+	if (pbi->used_buf_num > MAX_BUF_NUM)
+		pbi->used_buf_num = MAX_BUF_NUM;
+	if (buf_alloc_size > 0) {
+		buf_size = buf_alloc_size;
+		if (debug)
+			pr_info("[Buffer Management] init_buf_list:\n");
+	} else {
+		int pic_width = pbi->init_pic_w;
+		int pic_height = pbi->init_pic_h;
+
+	/*SUPPORT_10BIT*/
+	int losless_comp_header_size = compute_losless_comp_header_size
+			(pic_width, pic_height);
+	int losless_comp_body_size = compute_losless_comp_body_size
+			(pic_width, pic_height, buf_alloc_depth == 10);
+	int mc_buffer_size = losless_comp_header_size
+		+ losless_comp_body_size;
+	int mc_buffer_size_h = (mc_buffer_size + 0xffff)>>16;
+	if (double_write_mode) {
+		int pic_width_dw = (double_write_mode == 2) ?
+			pic_width / 2 : pic_width;
+		int pic_height_dw = (double_write_mode == 2) ?
+			pic_height / 2 : pic_height;
+		int lcu_size = 64; /*fixed 64*/
+		int pic_width_64 = (pic_width_dw + 63) & (~0x3f);
+		int pic_height_32 = (pic_height_dw + 31) & (~0x1f);
+		int pic_width_lcu  =
+			(pic_width_64 % lcu_size) ? pic_width_64 / lcu_size
+			+ 1 : pic_width_64 / lcu_size;
+		int pic_height_lcu =
+			(pic_height_32 % lcu_size) ? pic_height_32 / lcu_size
+			+ 1 : pic_height_32 / lcu_size;
+		int lcu_total       = pic_width_lcu * pic_height_lcu;
+		int mc_buffer_size_u_v = lcu_total * lcu_size * lcu_size / 2;
+		int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff) >> 16;
+			/*64k alignment*/
+		buf_size = ((mc_buffer_size_u_v_h << 16) * 3);
+	} else
+		buf_size = 0;
+
+	if (mc_buffer_size & 0xffff) { /*64k alignment*/
+		mc_buffer_size_h += 1;
+	}
+	if ((double_write_mode & 0x10) == 0)
+		buf_size += (mc_buffer_size_h << 16);
+
+	if (debug) {
+			pr_info
+			("init_buf_list num %d (width %d height %d):\n",
+			 pbi->used_buf_num, pic_width, pic_height);
+		}
+	}
+
+	for (i = 0; i < pbi->used_buf_num; i++) {
+		if (((i + 1) * buf_size) > pbi->mc_buf->buf_size) {
+			if (use_cma)
+				pbi->use_cma_flag = 1;
+			else {
+				if (debug) {
+					pr_info("%s maximum buf size is used\n",
+						   __func__);
+				}
+				break;
+			}
+		}
+		pbi->m_BUF[i].alloc_flag = 0;
+		pbi->m_BUF[i].index = i;
+
+		if (use_cma == 2)
+			pbi->use_cma_flag = 1;
+		if (pbi->use_cma_flag) {
+			if ((pbi->m_BUF[i].cma_page_count != 0)
+				&& (pbi->m_BUF[i].alloc_addr != 0)
+				&& (pbi->m_BUF[i].size != buf_size)) {
+				if ((pbi->predisp_addr >=
+						pbi->m_BUF[i].alloc_addr)
+					&& (pbi->predisp_addr <
+					(pbi->m_BUF[i].alloc_addr +
+						pbi->m_BUF[i].size))) {
+					pbi->pre_last_frame_alloc_addr =
+						pbi->m_BUF[i].alloc_addr;
+					pbi->pre_last_frame_alloc_size =
+						pbi->m_BUF[i].size;
+				} else {
+					codec_mm_free_for_dma(MEM_NAME,
+						pbi->m_BUF[i].alloc_addr);
+					pr_info("release cma buffer[%d] (%d %ld)\n",
+					i, pbi->m_BUF[i].cma_page_count,
+						pbi->m_BUF[i].alloc_addr);
+				}
+				pbi->m_BUF[i].alloc_addr = 0;
+				pbi->m_BUF[i].cma_page_count = 0;
+			}
+			if (pbi->m_BUF[i].alloc_addr == 0) {
+				if (!codec_mm_enough_for_size(buf_size)) {
+					/*
+					not enough mem for buffer.
+					*/
+					pr_info("not enought buffer for [%d],%d\n",
+						i, buf_size);
+					pbi->m_BUF[i].cma_page_count = 0;
+					if (i <= 8) {
+						/*if alloced (i+1)>=9
+						don't send errors.*/
+						/*pbi->fatal_error |=
+						DECODER_FATAL_ERROR_NO_MEM;*/
+					}
+					break;
+				}
+				pbi->m_BUF[i].cma_page_count =
+					PAGE_ALIGN(buf_size) / PAGE_SIZE;
+				pbi->m_BUF[i].alloc_addr =
+				    codec_mm_alloc_for_dma(
+					MEM_NAME, pbi->m_BUF[i].cma_page_count,
+					4 + PAGE_SHIFT,
+					CODEC_MM_FLAGS_FOR_VDECODER);
+				if (pbi->m_BUF[i].alloc_addr == 0) {
+					pr_info("alloc cma buffer[%d] fail\n",
+					i);
+					pbi->m_BUF[i].cma_page_count = 0;
+					break;
+				}
+				pr_info("allocate cma buffer[%d] (%d,%ld,%ld)\n",
+						i,
+						pbi->m_BUF[i].cma_page_count,
+						pbi->m_BUF[i].alloc_addr,
+						pbi->m_BUF[i].start_adr);
+			} else {
+				pr_info("reuse cma buffer[%d] (%d,%ld,%ld)\n",
+						i,
+						pbi->m_BUF[i].cma_page_count,
+						pbi->m_BUF[i].alloc_addr,
+						pbi->m_BUF[i].start_adr);
+			}
+			pbi->m_BUF[i].start_adr =  pbi->m_BUF[i].alloc_addr;
+		} else {
+			pbi->m_BUF[i].cma_page_count = 0;
+			pbi->m_BUF[i].alloc_addr = 0;
+			pbi->m_BUF[i].start_adr =
+				pbi->mc_buf->buf_start + i * buf_size;
+		}
+		pbi->m_BUF[i].size = buf_size;
+		pbi->m_BUF[i].free_start_adr = pbi->m_BUF[i].start_adr;
+
+		if (((pbi->m_BUF[i].start_adr + buf_size) > mc_buffer_end)
+			&& (pbi->m_BUF[i].alloc_addr == 0)) {
+			if (debug) {
+				pr_info
+				("Max mc buffer or mpred_mv buffer is used\n");
+			}
+			break;
+		}
+
+		if (debug) {
+			pr_info("Buffer %d: start_adr %p size %x\n", i,
+				   (void *)pbi->m_BUF[i].start_adr,
+				   pbi->m_BUF[i].size);
+		}
+	}
+
+	pbi->buf_num = i;
+
+}
+
+static int config_pic(struct VP9Decoder_s *pbi,
+				struct PIC_BUFFER_CONFIG_s *pic_config)
+{
+	int ret = -1;
+	int i;
+	int pic_width = pbi->init_pic_w;
+	int pic_height = pbi->init_pic_h;
+	int MV_MEM_UNIT = 0x240;
+	int lcu_size = 64; /*fixed 64*/
+	int pic_width_64 = (pic_width + 63) & (~0x3f);
+	int pic_height_32 = (pic_height + 31) & (~0x1f);
+	int pic_width_lcu  = (pic_width_64 % lcu_size) ?
+				pic_width_64 / lcu_size  + 1
+				: pic_width_64 / lcu_size;
+	int pic_height_lcu = (pic_height_32 % lcu_size) ?
+				pic_height_32 / lcu_size + 1
+				: pic_height_32 / lcu_size;
+	int lcu_total       = pic_width_lcu * pic_height_lcu;
+
+	int mpred_mv_end = pbi->work_space_buf->mpred_mv.buf_start +
+			pbi->work_space_buf->mpred_mv.buf_size;
+	int y_adr = 0;
+	int buf_size = 0;
+
+	int losless_comp_header_size =
+			compute_losless_comp_header_size(pic_width ,
+			pic_height);
+	int losless_comp_body_size = compute_losless_comp_body_size(pic_width ,
+			pic_height, buf_alloc_depth == 10);
+	int mc_buffer_size = losless_comp_header_size + losless_comp_body_size;
+	int mc_buffer_size_h = (mc_buffer_size + 0xffff) >> 16;
+	int mc_buffer_size_u_v = 0;
+	int mc_buffer_size_u_v_h = 0;
+	if (double_write_mode) {
+		int pic_width_dw = (double_write_mode == 2) ?
+			pic_width / 2 : pic_width;
+		int pic_height_dw = (double_write_mode == 2) ?
+			pic_height / 2 : pic_height;
+		int pic_width_64_dw = (pic_width_dw + 63) & (~0x3f);
+		int pic_height_32_dw = (pic_height_dw + 31) & (~0x1f);
+		int pic_width_lcu_dw  = (pic_width_64_dw % lcu_size) ?
+					pic_width_64_dw / lcu_size  + 1
+					: pic_width_64_dw / lcu_size;
+		int pic_height_lcu_dw = (pic_height_32_dw % lcu_size) ?
+					pic_height_32_dw / lcu_size + 1
+					: pic_height_32_dw / lcu_size;
+		int lcu_total_dw       = pic_width_lcu_dw * pic_height_lcu_dw;
+
+		mc_buffer_size_u_v = lcu_total_dw * lcu_size * lcu_size / 2;
+		mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff) >> 16;
+		/*64k alignment*/
+		buf_size = ((mc_buffer_size_u_v_h << 16) * 3);
+	}
+	if (mc_buffer_size & 0xffff) /*64k alignment*/
+		mc_buffer_size_h += 1;
+	if ((double_write_mode & 0x10) == 0)
+		buf_size += (mc_buffer_size_h << 16);
+
+#ifdef VP9_10B_MMU
+	if ((pbi->work_space_buf->cm_header.buf_start + ((pic_config->index + 1)
+		* MMU_COMPRESS_HEADER_SIZE))
+		> (pbi->work_space_buf->cm_header.buf_start +
+		pbi->work_space_buf->cm_header.buf_size)) {
+		pr_info("MMU header_adr allocate fail\n");
+		return -1;
+	}
+
+	pic_config->header_adr = pbi->work_space_buf->cm_header.buf_start
+		+ (pic_config->index * MMU_COMPRESS_HEADER_SIZE);
+	if (debug & VP9_DEBUG_BUFMGR) {
+		pr_info("MMU header_adr %d: %ld\n",
+			pic_config->index, pic_config->header_adr);
+	}
+#endif
+
+	if ((pbi->work_space_buf->mpred_mv.buf_start +
+		(((pic_config->index + 1) * lcu_total) * MV_MEM_UNIT))
+		<= mpred_mv_end) {
+		for (i = 0; i < pbi->buf_num; i++) {
+			y_adr = ((pbi->m_BUF[i].free_start_adr
+				+ 0xffff) >> 16) << 16;
+			/*64k alignment*/
+			if ((y_adr+buf_size) <=	(pbi->m_BUF[i].start_adr+
+				pbi->m_BUF[i].size)) {
+				pbi->m_BUF[i].free_start_adr =
+					y_adr + buf_size;
+				break;
+			}
+		}
+		if (i < pbi->buf_num) {
+			/*ensure get_pic_by_POC()
+			not get the buffer not decoded*/
+			pic_config->BUF_index = i;
+			pic_config->lcu_total = lcu_total;
+
+			pic_config->comp_body_size = losless_comp_body_size;
+			pic_config->buf_size = buf_size;
+			pic_config->mc_y_adr = y_adr;
+
+			pic_config->mc_canvas_y = pic_config->index;
+			pic_config->mc_canvas_u_v = pic_config->index;
+			if (double_write_mode & 0x10) {
+				pic_config->mc_u_v_adr = y_adr +
+				((mc_buffer_size_u_v_h << 16) << 1);
+
+				pic_config->mc_canvas_y =
+					(pic_config->index << 1);
+				pic_config->mc_canvas_u_v =
+					(pic_config->index << 1) + 1;
+
+				pic_config->dw_y_adr = y_adr;
+				pic_config->dw_u_v_adr = pic_config->mc_u_v_adr;
+			} else if (double_write_mode) {
+				pic_config->dw_y_adr = y_adr +
+					(mc_buffer_size_h << 16);
+				pic_config->dw_u_v_adr = pic_config->dw_y_adr +
+					((mc_buffer_size_u_v_h << 16) << 1);
+			}
+
+			pic_config->mpred_mv_wr_start_addr =
+			pbi->work_space_buf->mpred_mv.buf_start +
+					((pic_config->index * lcu_total)
+					* MV_MEM_UNIT);
+
+			if ((pbi->predisp_addr != 0) &&
+				(pbi->predisp_size != 0) &&
+				(buffer_mode & 0x4) == 0) {
+				if ((pic_config->mc_y_adr >=
+					(pbi->predisp_addr +
+					pbi->predisp_size)) ||
+					((pic_config->mc_y_adr
+					+ pic_config->buf_size)
+					<= pbi->predisp_addr)) {
+					pic_config->used_by_display = 0;
+				} else {
+					pic_config->used_by_display = 1;
+					pr_info
+					("%s,pic_config%d is displayed\n",
+						__func__, i);
+				}
+			} else
+				pic_config->used_by_display = 0;
+
+			if (debug) {
+				pr_info
+				("%s index %d BUF_index %d mc_y_adr %lx ",
+				__func__, pic_config->index,
+				pic_config->BUF_index,
+				pic_config->mc_y_adr);
+				pr_info
+				("comp_body_size %x comp_buf_size %x ",
+				pic_config->comp_body_size,
+				pic_config->buf_size);
+				pr_info
+				("mpred_mv_wr_start_adr %ld\n",
+				pic_config->mpred_mv_wr_start_addr);
+			}
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static void init_pic_list(struct VP9Decoder_s *pbi)
+{
+	int i;
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *pic_config;
+
+	for (i = 0; i < FRAME_BUFFERS; i++) {
+		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
+		pic_config->index = i;
+		pic_config->BUF_index = -1;
+		if (config_pic(pbi, pic_config) < 0) {
+			if (debug)
+				pr_info("Config_pic %d fail\n",
+					pic_config->index);
+			pic_config->index = -1;
+			break;
+		}
+		pic_config->y_crop_width = pbi->init_pic_w;
+		pic_config->y_crop_height = pbi->init_pic_h;
+		/*set_canvas(pic_config);*/
+	}
+	for (; i < FRAME_BUFFERS; i++) {
+		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
+		pic_config->index = -1;
+		pic_config->BUF_index = -1;
+	}
+
+}
+
+
+static void init_pic_list_hw(struct VP9Decoder_s *pbi)
+{
+	int i;
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *pic_config;
+	/*WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x0);*/
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR,
+		(0x1 << 1) | (0x1 << 2));
+
+
+	for (i = 0; i < FRAME_BUFFERS; i++) {
+		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
+		if (pic_config->index < 0)
+			break;
+
+#ifdef VP9_10B_MMU
+	/*WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
+		pic_config->header_adr
+		| (pic_config->mc_canvas_y << 8)|0x1);*/
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA, pic_config->header_adr >> 5);
+#else
+	/*WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
+		pic_config->mc_y_adr
+		| (pic_config->mc_canvas_y << 8) | 0x1);*/
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA, pic_config->mc_y_adr >> 5);
+#endif
+#ifndef LOSLESS_COMPRESS_MODE
+	/*WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
+		pic_config->mc_u_v_adr
+		| (pic_config->mc_canvas_u_v << 8)| 0x1);*/
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA, pic_config->mc_u_v_adr >> 5);
+#endif
+	}
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x1);
+
+	/*Zero out canvas registers in IPP -- avoid simulation X*/
+	WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+			(0 << 8) | (0 << 1) | 1);
+	for (i = 0; i < 32; i++)
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
+}
+
+
+static void dump_pic_list(struct VP9Decoder_s *pbi)
+{
+	return;
+}
+
+static int config_pic_size(struct VP9Decoder_s *pbi, unsigned short bit_depth)
+{
+#ifdef LOSLESS_COMPRESS_MODE
+	unsigned int data32;
+#endif
+	int losless_comp_header_size, losless_comp_body_size;
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *cur_pic_config = &cm->cur_frame->buf;
+	frame_width = cur_pic_config->y_crop_width;
+	frame_height = cur_pic_config->y_crop_height;
+	cur_pic_config->bit_depth = bit_depth;
+	losless_comp_header_size =
+		compute_losless_comp_header_size(cur_pic_config->y_crop_width,
+		cur_pic_config->y_crop_height);
+	losless_comp_body_size =
+		compute_losless_comp_body_size(cur_pic_config->y_crop_width,
+		cur_pic_config->y_crop_height, (bit_depth == VPX_BITS_10));
+	cur_pic_config->comp_body_size = losless_comp_body_size;
+#ifdef LOSLESS_COMPRESS_MODE
+	data32 = READ_VREG(HEVC_SAO_CTRL5);
+	if (bit_depth == VPX_BITS_10)
+		data32 &= ~(1 << 9);
+	else
+		data32 |= (1 << 9);
+
+	WRITE_VREG(HEVC_SAO_CTRL5, data32);
+
+#ifdef VP9_10B_MMU
+	/*bit[4] : paged_mem_mode*/
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, (0x1 << 4));
+#else
+	/*bit[3] smem mdoe*/
+	if (bit_depth == VPX_BITS_10)
+		WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, (0 << 3));
+	else
+		WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, (1 << 3));
+#endif
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL2, (losless_comp_body_size >> 5));
+	/*WRITE_VREG(HEVCD_MPP_DECOMP_CTL3,(0xff<<20) | (0xff<<10) | 0xff);*/
+	WRITE_VREG(HEVC_CM_BODY_LENGTH, losless_comp_body_size);
+	WRITE_VREG(HEVC_CM_HEADER_OFFSET, losless_comp_body_size);
+	WRITE_VREG(HEVC_CM_HEADER_LENGTH, losless_comp_header_size);
+#else
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, 0x1 << 31);
+#endif
+	return 0;
+}
+
+static int config_mc_buffer(struct VP9Decoder_s *pbi, unsigned short bit_depth)
+{
+	int i;
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *cur_pic_config = &cm->cur_frame->buf;
+	uint8_t scale_enable = 0;
+
+	if (debug&VP9_DEBUG_BUFMGR)
+		pr_info("config_mc_buffer entered .....\n");
+
+	WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+			(0 << 8) | (0 << 1) | 1);
+	for (i = 0; i < REFS_PER_FRAME; ++i) {
+		struct PIC_BUFFER_CONFIG_s *pic_config = cm->frame_refs[i].buf;
+
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR,
+		(pic_config->mc_canvas_u_v << 16)
+		| (pic_config->mc_canvas_u_v << 8)
+		| pic_config->mc_canvas_y);
+		if (debug & VP9_DEBUG_BUFMGR_MORE)
+			pr_info("refid %x mc_canvas_u_v %x mc_canvas_y %x\n",
+				i, pic_config->mc_canvas_u_v,
+				pic_config->mc_canvas_y);
+	}
+	WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+			(16 << 8) | (0 << 1) | 1);
+	for (i = 0; i < REFS_PER_FRAME; ++i) {
+		struct PIC_BUFFER_CONFIG_s *pic_config = cm->frame_refs[i].buf;
+
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR,
+			(pic_config->mc_canvas_u_v << 16)
+			| (pic_config->mc_canvas_u_v << 8)
+			| pic_config->mc_canvas_y);
+	}
+
+	/*auto_inc start index:0 field:0*/
+	WRITE_VREG(VP9D_MPP_REFINFO_TBL_ACCCONFIG, 0x1 << 2);
+	/*index 0:last 1:golden 2:altref*/
+	for (i = 0; i < REFS_PER_FRAME; i++) {
+		int ref_pic_body_size;
+		struct PIC_BUFFER_CONFIG_s *pic_config = cm->frame_refs[i].buf;
+
+		WRITE_VREG(VP9D_MPP_REFINFO_DATA, pic_config->y_crop_width);
+		WRITE_VREG(VP9D_MPP_REFINFO_DATA, pic_config->y_crop_height);
+
+	if (pic_config->y_crop_width != cur_pic_config->y_crop_width ||
+		pic_config->y_crop_height != cur_pic_config->y_crop_height) {
+		scale_enable |= (1 << i);
+	}
+	ref_pic_body_size =
+		compute_losless_comp_body_size(pic_config->y_crop_width,
+		pic_config->y_crop_height, (bit_depth == VPX_BITS_10));
+	WRITE_VREG(VP9D_MPP_REFINFO_DATA,
+		(pic_config->y_crop_width << 14)
+		/ cur_pic_config->y_crop_width);
+	WRITE_VREG(VP9D_MPP_REFINFO_DATA,
+		(pic_config->y_crop_height << 14)
+		/ cur_pic_config->y_crop_height);
+#ifdef VP9_10B_MMU
+	WRITE_VREG(VP9D_MPP_REFINFO_DATA, 0);
+#else
+	WRITE_VREG(VP9D_MPP_REFINFO_DATA, ref_pic_body_size >> 5);
+#endif
+	}
+	WRITE_VREG(VP9D_MPP_REF_SCALE_ENBL, scale_enable);
+	return 0;
+}
+
+static void clear_mpred_hw(struct VP9Decoder_s *pbi)
+{
+	unsigned int data32;
+	data32 = READ_VREG(HEVC_MPRED_CTRL4);
+	data32 &=  (~(1 << 6));
+	WRITE_VREG(HEVC_MPRED_CTRL4, data32);
+}
+
+static void config_mpred_hw(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *cur_pic_config = &cm->cur_frame->buf;
+	struct PIC_BUFFER_CONFIG_s *last_frame_pic_config =
+						&cm->prev_frame->buf;
+
+	unsigned int data32;
+	int     mpred_curr_lcu_x;
+	int     mpred_curr_lcu_y;
+	int     mpred_mv_rd_end_addr;
+	int     MV_MEM_UNIT = 0x240;
+
+
+	mpred_mv_rd_end_addr = last_frame_pic_config->mpred_mv_wr_start_addr
+			+ (last_frame_pic_config->lcu_total * MV_MEM_UNIT);
+
+	data32 = READ_VREG(HEVC_MPRED_CURR_LCU);
+	mpred_curr_lcu_x   = data32 & 0xffff;
+	mpred_curr_lcu_y   = (data32 >> 16) & 0xffff;
+
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("cur pic_config index %d  col pic_config index %d\n",
+			cur_pic_config->index, last_frame_pic_config->index);
+	WRITE_VREG(HEVC_MPRED_CTRL3, 0x24122412);
+	WRITE_VREG(HEVC_MPRED_ABV_START_ADDR,
+			pbi->work_space_buf->mpred_above.buf_start);
+
+	data32 = READ_VREG(HEVC_MPRED_CTRL4);
+
+	data32 &=  (~(1 << 6));
+	data32 |= (cm->use_prev_frame_mvs << 6);
+	WRITE_VREG(HEVC_MPRED_CTRL4, data32);
+
+	WRITE_VREG(HEVC_MPRED_MV_WR_START_ADDR,
+			cur_pic_config->mpred_mv_wr_start_addr);
+	WRITE_VREG(HEVC_MPRED_MV_WPTR, cur_pic_config->mpred_mv_wr_start_addr);
+
+	WRITE_VREG(HEVC_MPRED_MV_RD_START_ADDR,
+			last_frame_pic_config->mpred_mv_wr_start_addr);
+	WRITE_VREG(HEVC_MPRED_MV_RPTR,
+			last_frame_pic_config->mpred_mv_wr_start_addr);
+	/*data32 = ((pbi->lcu_x_num - pbi->tile_width_lcu)*MV_MEM_UNIT);*/
+	/*WRITE_VREG(HEVC_MPRED_MV_WR_ROW_JUMP,data32);*/
+	/*WRITE_VREG(HEVC_MPRED_MV_RD_ROW_JUMP,data32);*/
+	WRITE_VREG(HEVC_MPRED_MV_RD_END_ADDR, mpred_mv_rd_end_addr);
+
+}
+
+static void config_sao_hw(struct VP9Decoder_s *pbi, union param_u *params)
+{
+	struct VP9_Common_s *cm = &pbi->common;
+	struct PIC_BUFFER_CONFIG_s *pic_config = &cm->cur_frame->buf;
+
+	unsigned int data32;
+	int lcu_size = 64;
+	int mc_buffer_size_u_v =
+		pic_config->lcu_total * lcu_size*lcu_size/2;
+	int mc_buffer_size_u_v_h =
+		(mc_buffer_size_u_v + 0xffff) >> 16;/*64k alignment*/
+
+
+	if ((double_write_mode & 0x10) == 0)
+		WRITE_VREG(HEVC_CM_BODY_START_ADDR, pic_config->mc_y_adr);
+
+	if (double_write_mode) {
+		WRITE_VREG(HEVC_SAO_Y_START_ADDR, pic_config->dw_y_adr);
+		WRITE_VREG(HEVC_SAO_C_START_ADDR, pic_config->dw_u_v_adr);
+		WRITE_VREG(HEVC_SAO_Y_WPTR, pic_config->dw_y_adr);
+		WRITE_VREG(HEVC_SAO_C_WPTR, pic_config->dw_u_v_adr);
+	} else {
+		WRITE_VREG(HEVC_SAO_Y_START_ADDR, 0xffffffff);
+		WRITE_VREG(HEVC_SAO_C_START_ADDR, 0xffffffff);
+	}
+#ifdef VP9_10B_MMU
+	WRITE_VREG(HEVC_CM_HEADER_START_ADDR, pic_config->header_adr);
+#endif
+	data32 = (mc_buffer_size_u_v_h << 16) << 1;
+	/*pr_info("data32=%x,mc_buffer_size_u_v_h=%x,lcu_total=%x\n",
+		data32, mc_buffer_size_u_v_h, pic_config->lcu_total);*/
+	WRITE_VREG(HEVC_SAO_Y_LENGTH, data32);
+
+	data32 = (mc_buffer_size_u_v_h << 16);
+	WRITE_VREG(HEVC_SAO_C_LENGTH, data32);
+
+#ifdef VP9_10B_NV21
+#ifdef DOS_PROJECT
+	data32 = READ_VREG(HEVC_SAO_CTRL1);
+	data32 &= (~0x3000);
+	/*[13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32*/
+	data32 |= (MEM_MAP_MODE << 12);
+	data32 &= (~0x3);
+	data32 |= 0x1; /* [1]:dw_disable [0]:cm_disable*/
+	WRITE_VREG(HEVC_SAO_CTRL1, data32);
+	/*[23:22] dw_v1_ctrl [21:20] dw_v0_ctrl [19:18] dw_h1_ctrl
+		[17:16] dw_h0_ctrl*/
+	data32 = READ_VREG(HEVC_SAO_CTRL5);
+	/*set them all 0 for H265_NV21 (no down-scale)*/
+	data32 &= ~(0xff << 16);
+	WRITE_VREG(HEVC_SAO_CTRL5, data32);
+	ata32 = READ_VREG(HEVCD_IPP_AXIIF_CONFIG);
+	data32 &= (~0x30);
+	/*[5:4] address_format 00:linear 01:32x32 10:64x32*/
+	data32 |= (MEM_MAP_MODE << 4);
+	WRITE_VREG(HEVCD_IPP_AXIIF_CONFIG, data32);
+#else
+	/*m8baby test1902*/
+	data32 = READ_VREG(HEVC_SAO_CTRL1);
+	data32 &= (~0x3000);
+	/*[13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32*/
+	data32 |= (MEM_MAP_MODE << 12);
+	data32 &= (~0xff0);
+	/*data32 |= 0x670;*/ /*Big-Endian per 64-bit*/
+	data32 |= 0x880;  /*.Big-Endian per 64-bit */
+	data32 &= (~0x3);
+	data32 |= 0x1; /*[1]:dw_disable [0]:cm_disable*/
+	WRITE_VREG(HEVC_SAO_CTRL1, data32);
+	/* [23:22] dw_v1_ctrl [21:20] dw_v0_ctrl
+	[19:18] dw_h1_ctrl [17:16] dw_h0_ctrl*/
+	data32 = READ_VREG(HEVC_SAO_CTRL5);
+	/* set them all 0 for H265_NV21 (no down-scale)*/
+	data32 &= ~(0xff << 16);
+	WRITE_VREG(HEVC_SAO_CTRL5, data32);
+
+	data32 = READ_VREG(HEVCD_IPP_AXIIF_CONFIG);
+	data32 &= (~0x30);
+	/*[5:4] address_format 00:linear 01:32x32 10:64x32*/
+	data32 |= (MEM_MAP_MODE << 4);
+	data32 &= (~0xF);
+	data32 |= 0x8; /*Big-Endian per 64-bit*/
+	WRITE_VREG(HEVCD_IPP_AXIIF_CONFIG, data32);
+#endif
+#else
+	data32 = READ_VREG(HEVC_SAO_CTRL1);
+	data32 &= (~0x3000);
+	data32 |= (MEM_MAP_MODE <<
+			   12);	/* [13:12] axi_aformat, 0-Linear,
+				   1-32x32, 2-64x32 */
+	data32 &= (~0xff0);
+	/* data32 |= 0x670;  // Big-Endian per 64-bit */
+	data32 |= endian;	/* Big-Endian per 64-bit */
+	data32 &= (~0x3); /*[1]:dw_disable [0]:cm_disable*/
+	if (double_write_mode == 0)
+		data32 |= 0x2; /*disable double write*/
+	else if (double_write_mode & 0x10)
+		data32 |= 0x1; /*disable cm*/
+	WRITE_VREG(HEVC_SAO_CTRL1, data32);
+
+	if (double_write_mode & 0x10) {
+		/* [23:22] dw_v1_ctrl
+		[21:20] dw_v0_ctrl
+		[19:18] dw_h1_ctrl
+		[17:16] dw_h0_ctrl
+		*/
+		data32 = READ_VREG(HEVC_SAO_CTRL5);
+		/*set them all 0 for H265_NV21 (no down-scale)*/
+		data32 &= ~(0xff << 16);
+		WRITE_VREG(HEVC_SAO_CTRL5, data32);
+	} else {
+		data32 = READ_VREG(HEVC_SAO_CTRL5);
+		data32 &= (~(0xff << 16));
+		if (double_write_mode != 1)
+			data32 |= (0xff<<16);
+		WRITE_VREG(HEVC_SAO_CTRL5, data32);
+	}
+
+	data32 = READ_VREG(HEVCD_IPP_AXIIF_CONFIG);
+	data32 &= (~0x30);
+	/* [5:4]    -- address_format 00:linear 01:32x32 10:64x32 */
+	data32 |= (mem_map_mode <<
+			   4);
+	data32 &= (~0xF);
+	data32 |= 0xf;  /* valid only when double write only */
+		/*data32 |= 0x8;*/		/* Big-Endian per 64-bit */
+	WRITE_VREG(HEVCD_IPP_AXIIF_CONFIG, data32);
+#endif
+}
+
+static void vp9_config_work_space_hw(struct VP9Decoder_s *pbi)
+{
+	struct BuffInfo_s *buf_spec = pbi->work_space_buf;
+#ifdef LOSLESS_COMPRESS_MODE
+	int losless_comp_header_size =
+		compute_losless_comp_header_size(pbi->init_pic_w,
+		pbi->init_pic_h);
+	int losless_comp_body_size =
+		compute_losless_comp_body_size(pbi->init_pic_w,
+		pbi->init_pic_h, buf_alloc_depth == 10);
+#endif
+#ifdef VP9_10B_MMU
+	unsigned int data32;
+#endif
+	if (debug)
+		pr_info("%s %x %x %x %x %x %x %x %x %x %x %x %x\n",
+			__func__,
+			buf_spec->ipp.buf_start,
+			buf_spec->start_adr,
+			buf_spec->short_term_rps.buf_start,
+			buf_spec->vps.buf_start,
+			buf_spec->sps.buf_start,
+			buf_spec->pps.buf_start,
+			buf_spec->sao_up.buf_start,
+			buf_spec->swap_buf.buf_start,
+			buf_spec->swap_buf2.buf_start,
+			buf_spec->scalelut.buf_start,
+			buf_spec->dblk_para.buf_start,
+			buf_spec->dblk_data.buf_start);
+	WRITE_VREG(HEVCD_IPP_LINEBUFF_BASE, buf_spec->ipp.buf_start);
+	if ((debug & VP9_DEBUG_SEND_PARAM_WITH_REG) == 0)
+		WRITE_VREG(HEVC_RPM_BUFFER, (u32)pbi->rpm_phy_addr);
+	WRITE_VREG(HEVC_SHORT_TERM_RPS, buf_spec->short_term_rps.buf_start);
+	/*WRITE_VREG(HEVC_VPS_BUFFER, buf_spec->vps.buf_start);*/
+	/*WRITE_VREG(HEVC_SPS_BUFFER, buf_spec->sps.buf_start);*/
+	WRITE_VREG(HEVC_PPS_BUFFER, buf_spec->pps.buf_start);
+	WRITE_VREG(HEVC_SAO_UP, buf_spec->sao_up.buf_start);
+	WRITE_VREG(HEVC_STREAM_SWAP_BUFFER, buf_spec->swap_buf.buf_start);
+	WRITE_VREG(HEVC_STREAM_SWAP_BUFFER2, buf_spec->swap_buf2.buf_start);
+	WRITE_VREG(HEVC_SCALELUT, buf_spec->scalelut.buf_start);
+
+	/* cfg_p_addr */
+	WRITE_VREG(HEVC_DBLK_CFG4, buf_spec->dblk_para.buf_start);
+	/* cfg_d_addr */
+	WRITE_VREG(HEVC_DBLK_CFG5, buf_spec->dblk_data.buf_start);
+
+#ifdef LOSLESS_COMPRESS_MODE
+#ifdef VP9_10B_MMU
+	/*bit[4] : paged_mem_mode*/
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, (0x1 << 4));
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL2, 0);
+#else
+	/*if(cur_pic_config->bit_depth == VPX_BITS_10)
+		WRITE_VREG(P_HEVCD_MPP_DECOMP_CTL1, (0<<3));*/
+	/*bit[3] smem mdoe*/
+	/*else WRITE_VREG(P_HEVCD_MPP_DECOMP_CTL1, (1<<3));*/
+	/*bit[3] smem mdoe*/
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL2, (losless_comp_body_size >> 5));
+#endif
+	/*WRITE_VREG(P_HEVCD_MPP_DECOMP_CTL2,(losless_comp_body_size >> 5));*/
+	/*WRITE_VREG(P_HEVCD_MPP_DECOMP_CTL3,(0xff<<20) | (0xff<<10) | 0xff);*/
+/*8-bit mode */
+	WRITE_VREG(HEVC_CM_BODY_LENGTH, losless_comp_body_size);
+	WRITE_VREG(HEVC_CM_HEADER_OFFSET, losless_comp_body_size);
+	WRITE_VREG(HEVC_CM_HEADER_LENGTH, losless_comp_header_size);
+#else
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, 0x1 << 31);
+#endif
+
+#ifdef VP9_10B_MMU
+	WRITE_VREG(HEVC_SAO_MMU_VH0_ADDR, buf_spec->mmu_vbh.buf_start);
+	WRITE_VREG(HEVC_SAO_MMU_VH1_ADDR, buf_spec->mmu_vbh.buf_start
+			+ buf_spec->mmu_vbh.buf_size/2);
+	/*data32 = READ_VREG(P_HEVC_SAO_CTRL9);*/
+	/*data32 |= 0x1;*/
+	/*WRITE_VREG(P_HEVC_SAO_CTRL9, data32);*/
+
+	/* use HEVC_CM_HEADER_START_ADDR */
+	data32 = READ_VREG(HEVC_SAO_CTRL5);
+	data32 |= (1<<10);
+	WRITE_VREG(HEVC_SAO_CTRL5, data32);
+
+#endif
+
+	WRITE_VREG(VP9_SEG_MAP_BUFFER, buf_spec->seg_map.buf_start);
+
+	if (debug & VP9_DEBUG_UCODE)
+		WRITE_VREG(LMEM_DUMP_ADR, (u32)pbi->lmem_phy_addr);
+
+	 /**/
+	WRITE_VREG(VP9_PROB_SWAP_BUFFER, pbi->prob_buffer_phy_addr);
+	WRITE_VREG(VP9_COUNT_SWAP_BUFFER, pbi->count_buffer_phy_addr);
+#ifdef VP9_10B_MMU
+	WRITE_VREG(VP9_MMU_MAP_BUFFER, pbi->frame_mmu_map_phy_addr);
+#endif
+
+}
+
+
+#ifdef VP9_LPF_LVL_UPDATE
+/*
+ * Defines, declarations, sub-functions for vp9 de-block loop
+	filter Thr/Lvl table update
+ * - struct segmentation is for loop filter only (removed something)
+ * - function "vp9_loop_filter_init" and "vp9_loop_filter_frame_init" will
+	be instantiated in C_Entry
+ * - vp9_loop_filter_init run once before decoding start
+ * - vp9_loop_filter_frame_init run before every frame decoding start
+ * - set video format to VP9 is in vp9_loop_filter_init
+ */
+#define MAX_LOOP_FILTER 63
+#define MAX_REF_LF_DELTAS 4
+#define MAX_MODE_LF_DELTAS 2
+/*#define INTRA_FRAME 0*/
+/*#define LAST_FRAME 1*/
+/*#define MAX_REF_FRAMES 4*/
+#define SEGMENT_DELTADATA   0
+#define SEGMENT_ABSDATA     1
+#define MAX_SEGMENTS     8
+/*.#define SEG_TREE_PROBS   (MAX_SEGMENTS-1)*/
+/*no use for loop filter, if this struct for common use, pls add it back*/
+/*#define PREDICTION_PROBS 3*/
+/* no use for loop filter, if this struct for common use, pls add it back*/
+
+enum SEG_LVL_FEATURES {
+	SEG_LVL_ALT_Q = 0, /*Use alternate Quantizer ....*/
+	SEG_LVL_ALT_LF = 1, /*Use alternate loop filter value...*/
+	SEG_LVL_REF_FRAME = 2, /*Optional Segment reference frame*/
+	SEG_LVL_SKIP = 3,  /*Optional Segment (0,0) + skip mode*/
+	SEG_LVL_MAX = 4    /*Number of features supported*/
+};
+
+struct segmentation {
+	uint8_t enabled;
+	uint8_t update_map;
+	uint8_t update_data;
+	uint8_t abs_delta;
+	uint8_t temporal_update;
+
+	/*no use for loop filter, if this struct
+	for common use, pls add it back*/
+	/*vp9_prob tree_probs[SEG_TREE_PROBS]; */
+	/* no use for loop filter, if this struct
+		for common use, pls add it back*/
+	/*vp9_prob pred_probs[PREDICTION_PROBS];*/
+
+	int16_t feature_data[MAX_SEGMENTS][SEG_LVL_MAX];
+	unsigned int feature_mask[MAX_SEGMENTS];
+};
+
+struct loop_filter_thresh {
+	uint8_t mblim;
+	uint8_t lim;
+	uint8_t hev_thr;
+};
+
+struct loop_filter_info_n {
+	struct loop_filter_thresh lfthr[MAX_LOOP_FILTER + 1];
+	uint8_t lvl[MAX_SEGMENTS][MAX_REF_FRAMES][MAX_MODE_LF_DELTAS];
+};
+
+struct loopfilter {
+	int filter_level;
+
+	int sharpness_level;
+	int last_sharpness_level;
+
+	uint8_t mode_ref_delta_enabled;
+	uint8_t mode_ref_delta_update;
+
+	/*0 = Intra, Last, GF, ARF*/
+	signed char ref_deltas[MAX_REF_LF_DELTAS];
+	signed char last_ref_deltas[MAX_REF_LF_DELTAS];
+
+	/*0 = ZERO_MV, MV*/
+	signed char mode_deltas[MAX_MODE_LF_DELTAS];
+	signed char last_mode_deltas[MAX_MODE_LF_DELTAS];
+};
+
+static int vp9_clamp(int value, int low, int high)
+{
+	return value < low ? low : (value > high ? high : value);
+}
+
+int segfeature_active(struct segmentation *seg,
+			int segment_id,
+			enum SEG_LVL_FEATURES feature_id) {
+	return seg->enabled &&
+		(seg->feature_mask[segment_id] & (1 << feature_id));
+}
+
+int get_segdata(struct segmentation *seg, int segment_id,
+				enum SEG_LVL_FEATURES feature_id) {
+	return seg->feature_data[segment_id][feature_id];
+}
+
+static void vp9_update_sharpness(struct loop_filter_info_n *lfi,
+					int sharpness_lvl)
+{
+	int lvl;
+	/*For each possible value for the loop filter fill out limits*/
+	for (lvl = 0; lvl <= MAX_LOOP_FILTER; lvl++) {
+		/*Set loop filter parameters that control sharpness.*/
+		int block_inside_limit = lvl >> ((sharpness_lvl > 0) +
+					(sharpness_lvl > 4));
+
+		if (sharpness_lvl > 0) {
+			if (block_inside_limit > (9 - sharpness_lvl))
+				block_inside_limit = (9 - sharpness_lvl);
+		}
+
+		if (block_inside_limit < 1)
+			block_inside_limit = 1;
+
+		lfi->lfthr[lvl].lim = (uint8_t)block_inside_limit;
+		lfi->lfthr[lvl].mblim = (uint8_t)(2 * (lvl + 2) +
+				block_inside_limit);
+	}
+}
+
+int default_filt_lvl;
+struct loop_filter_info_n *lfi;
+struct loopfilter *lf;
+struct segmentation *seg_4lf;
+
+/*instantiate this function once when decode is started*/
+void vp9_loop_filter_init(void)
+{
+	int i;
+	lfi = kmalloc(sizeof(struct loop_filter_info_n), GFP_KERNEL);
+	lf = kmalloc(sizeof(struct loopfilter), GFP_KERNEL);
+	seg_4lf = kmalloc(sizeof(struct segmentation), GFP_KERNEL);
+	if (lfi == NULL || lf == NULL || seg_4lf == NULL) {
+		pr_err("[test.c] vp9_loop_filter init malloc error!!!\n");
+		return;
+	}
+
+	lf->sharpness_level = 0; /*init to 0 */
+	/*init limits for given sharpness*/
+	vp9_update_sharpness(lfi, lf->sharpness_level);
+	lf->last_sharpness_level = lf->sharpness_level;
+	/*init hev threshold const vectors (actually no use)
+	for (i = 0; i <= MAX_LOOP_FILTER; i++)
+		lfi->lfthr[i].hev_thr = (uint8_t)(i >> 4);*/
+
+	/*Write to register*/
+	for (i = 0; i < 32; i++) {
+		unsigned int thr;
+		thr = ((lfi->lfthr[i * 2 + 1].lim & 0x3f)<<8) |
+			(lfi->lfthr[i * 2 + 1].mblim & 0xff);
+		thr = (thr<<16) | ((lfi->lfthr[i*2].lim & 0x3f)<<8) |
+			(lfi->lfthr[i * 2].mblim & 0xff);
+		WRITE_VREG(HEVC_DBLK_CFG9, thr);
+	}
+
+	/*video format is VP9*/
+	WRITE_VREG(HEVC_DBLK_CFGB, 0x40400001);
+}
+	/* perform this function per frame*/
+void vp9_loop_filter_frame_init(struct segmentation *seg,
+		struct loop_filter_info_n *lfi, struct loopfilter *lf,
+		int default_filt_lvl) {
+	int i;
+	int seg_id;
+	/*n_shift is the multiplier for lf_deltas
+	the multiplier is 1 for when filter_lvl is between 0 and 31;
+	2 when filter_lvl is between 32 and 63*/
+	const int scale = 1 << (default_filt_lvl >> 5);
+
+	/*update limits if sharpness has changed*/
+	if (lf->last_sharpness_level != lf->sharpness_level) {
+		vp9_update_sharpness(lfi, lf->sharpness_level);
+		lf->last_sharpness_level = lf->sharpness_level;
+
+	/*Write to register*/
+	for (i = 0; i < 32; i++) {
+		unsigned int thr;
+		thr = ((lfi->lfthr[i * 2 + 1].lim & 0x3f) << 8)
+			| (lfi->lfthr[i * 2 + 1].mblim & 0xff);
+		thr = (thr << 16) | ((lfi->lfthr[i * 2].lim & 0x3f) << 8)
+			| (lfi->lfthr[i * 2].mblim & 0xff);
+		WRITE_VREG(HEVC_DBLK_CFG9, thr);
+		}
+	}
+
+	for (seg_id = 0; seg_id < MAX_SEGMENTS; seg_id++) {/*MAX_SEGMENTS = 8*/
+		int lvl_seg = default_filt_lvl;
+		if (segfeature_active(seg, seg_id, SEG_LVL_ALT_LF)) {
+			const int data = get_segdata(seg, seg_id,
+						SEG_LVL_ALT_LF);
+			lvl_seg = vp9_clamp(seg->abs_delta == SEGMENT_ABSDATA ?
+				data : default_filt_lvl + data,
+				0, MAX_LOOP_FILTER);
+#ifdef DBG_LF_PRINT
+	pr_info("segfeature_active!!!seg_id=%d,lvl_seg=%d\n", seg_id, lvl_seg);
+#endif
+	}
+
+	if (!lf->mode_ref_delta_enabled) {
+		/*we could get rid of this if we assume that deltas are set to
+		zero when not in use; encoder always uses deltas*/
+		memset(lfi->lvl[seg_id], lvl_seg, sizeof(lfi->lvl[seg_id]));
+	} else {
+		int ref, mode;
+		const int intra_lvl = lvl_seg +	lf->ref_deltas[INTRA_FRAME]
+					* scale;
+#ifdef DBG_LF_PRINT
+	pr_info("LF_PRINT:vp9_loop_filter_frame_init,seg_id=%d\n", seg_id);
+	pr_info("ref_deltas[INTRA_FRAME]=%d\n", lf->ref_deltas[INTRA_FRAME]);
+#endif
+		lfi->lvl[seg_id][INTRA_FRAME][0] =
+				vp9_clamp(intra_lvl, 0, MAX_LOOP_FILTER);
+
+		for (ref = LAST_FRAME; ref < MAX_REF_FRAMES; ++ref) {
+			/* LAST_FRAME = 1, MAX_REF_FRAMES = 4*/
+			for (mode = 0; mode < MAX_MODE_LF_DELTAS; ++mode) {
+				/*MAX_MODE_LF_DELTAS = 2*/
+				const int inter_lvl =
+					lvl_seg + lf->ref_deltas[ref] * scale
+					+ lf->mode_deltas[mode] * scale;
+#ifdef DBG_LF_PRINT
+#endif
+				lfi->lvl[seg_id][ref][mode] =
+					vp9_clamp(inter_lvl, 0,
+					MAX_LOOP_FILTER);
+				}
+			}
+		}
+	}
+
+#ifdef DBG_LF_PRINT
+	/*print out thr/lvl table per frame*/
+	for (i = 0; i <= MAX_LOOP_FILTER; i++) {
+		pr_info("LF_PRINT:(%d)thr=%d,blim=%d,lim=%d\n",
+			i, lfi->lfthr[i].hev_thr, lfi->lfthr[i].mblim,
+			lfi->lfthr[i].lim);
+	}
+	for (seg_id = 0; seg_id < MAX_SEGMENTS; seg_id++) {
+		pr_info("LF_PRINT:lvl(seg_id=%d)(mode=0,%d,%d,%d,%d)\n",
+			seg_id, lfi->lvl[seg_id][0][0],
+			lfi->lvl[seg_id][1][0], lfi->lvl[seg_id][2][0],
+			lfi->lvl[seg_id][3][0]);
+		pr_info("i(mode=1,%d,%d,%d,%d)\n", lfi->lvl[seg_id][0][1],
+			lfi->lvl[seg_id][1][1], lfi->lvl[seg_id][2][1],
+			lfi->lvl[seg_id][3][1]);
+	}
+#endif
+
+	/*Write to register */
+	for (i = 0; i < 16; i++) {
+		unsigned int level;
+		level = ((lfi->lvl[i >> 1][3][i & 1] & 0x3f) << 24) |
+			((lfi->lvl[i >> 1][2][i & 1] & 0x3f) << 16) |
+			((lfi->lvl[i >> 1][1][i & 1] & 0x3f) << 8) |
+			(lfi->lvl[i >> 1][0][i & 1] & 0x3f);
+		if (!default_filt_lvl)
+			level = 0;
+		WRITE_VREG(HEVC_DBLK_CFGA, level);
+	}
+}
+/* VP9_LPF_LVL_UPDATE */
+#endif
+
+static void vp9_init_decoder_hw(void)
+{
+	unsigned int data32;
+	int i;
+
+	pr_info("[test.c] Entering vp9_init_decoder_hw\n");
+
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("[test.c] Enable HEVC Parser Interrupt\n");
+		data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+#if 1
+		/* set bit 31~29 to 3 if HEVC_STREAM_FIFO_CTL[29] is 1 */
+		data32 &= ~(7 << 29);
+		data32 |= (3 << 29);
+#endif
+		data32 = data32 |
+		(1 << 24) |/*stream_buffer_empty_int_amrisc_enable*/
+		(1 << 22) |/*stream_fifo_empty_int_amrisc_enable*/
+		(1 << 7) |/*dec_done_int_cpu_enable*/
+		(1 << 4) |/*startcode_found_int_cpu_enable*/
+		(0 << 3) |/*startcode_found_int_amrisc_enable*/
+		(1 << 0)    /*parser_int_enable*/
+		;
+	WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
+
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("[test.c] Enable HEVC Parser Shift\n");
+
+		data32 = READ_VREG(HEVC_SHIFT_STATUS);
+		data32 = data32 |
+		(0 << 1) |/*emulation_check_off VP9
+			do not have emulation*/
+		(1 << 0)/*startcode_check_on*/
+		;
+		WRITE_VREG(HEVC_SHIFT_STATUS, data32);
+		WRITE_VREG(HEVC_SHIFT_CONTROL,
+		(0 << 14) | /*disable_start_code_protect*/
+		(1 << 10) | /*length_zero_startcode_en for VP9*/
+		(1 << 9) | /*length_valid_startcode_en for VP9*/
+		(3 << 6) | /*sft_valid_wr_position*/
+		(2 << 4) | /*emulate_code_length_sub_1*/
+		(3 << 1) | /*start_code_length_sub_1
+		VP9 use 0x00000001 as startcode (4 Bytes)*/
+		(1 << 0)   /*stream_shift_enable*/
+		);
+
+	WRITE_VREG(HEVC_CABAC_CONTROL,
+		(1 << 0)/*cabac_enable*/
+	);
+
+	WRITE_VREG(HEVC_PARSER_CORE_CONTROL,
+		(1 << 0)/* hevc_parser_core_clk_en*/
+	);
+
+
+	WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
+
+	/*Initial IQIT_SCALELUT memory -- just to avoid X in simulation*/
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("Initial IQIT_SCALELUT memory\n");
+	WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0);/*cfg_p_addr*/
+	for (i = 0; i < 1024; i++)
+		WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
+
+
+#ifdef ENABLE_SWAP_TEST
+	WRITE_VREG(HEVC_STREAM_SWAP_TEST, 100);
+#else
+	WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
+#endif
+
+	WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, 0);
+	WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, 0x7fffffff); /*to remove*/
+
+	/*Send parser_cmd*/
+	if (debug)
+		pr_info("[test.c] SEND Parser Command ...\n");
+	WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1 << 16) | (0 << 0));
+	for (i = 0; i < PARSER_CMD_NUMBER; i++)
+		WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
+	WRITE_VREG(HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
+	WRITE_VREG(HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
+	WRITE_VREG(HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
+
+
+	WRITE_VREG(HEVC_PARSER_IF_CONTROL,
+		/*  (1 << 8) |*/ /*sao_sw_pred_enable*/
+		(1 << 5) | /*parser_sao_if_en*/
+		(1 << 2) | /*parser_mpred_if_en*/
+		(1 << 0) /*parser_scaler_if_en*/
+	);
+	/*Changed to Start MPRED in microcode*/
+	/*
+	pr_info("[test.c] Start MPRED\n");
+	WRITE_VREG(HEVC_MPRED_INT_STATUS,
+	(1<<31)
+	);
+	*/
+	if (debug)
+		pr_info("[test.c] Reset IPP\n");
+	WRITE_VREG(HEVCD_IPP_TOP_CNTL,
+		(0 << 1) | /*enable ipp*/
+		(1 << 0)   /*software reset ipp and mpp*/
+	);
+	WRITE_VREG(HEVCD_IPP_TOP_CNTL,
+		(1 << 1) | /*enable ipp*/
+		(0 << 0)   /*software reset ipp and mpp*/
+	);
+#ifdef VP9_10B_NV21
+	/*Enable NV21 reference read mode for MC*/
+	WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, 0x1 << 31);
+#endif
+
+	/*Initialize mcrcc and decomp perf counters
+	mcrcc_perfcount_reset();
+	decomp_perfcount_reset();*/
+	pr_info("[test.c] Leaving vp9_init_decoder_hw\n");
+	return;
+}
+
+
+#ifdef CONFIG_HEVC_CLK_FORCED_ON
+static void config_vp9_clk_forced_on(void)
+{
+	unsigned int rdata32;
+	/*IQIT*/
+	rdata32 = READ_VREG(HEVC_IQIT_CLK_RST_CTRL);
+	WRITE_VREG(HEVC_IQIT_CLK_RST_CTRL, rdata32 | (0x1 << 2));
+
+	/* DBLK*/
+	rdata32 = READ_VREG(HEVC_DBLK_CFG0);
+	WRITE_VREG(HEVC_DBLK_CFG0, rdata32 | (0x1 << 2));
+
+	/* SAO*/
+	rdata32 = READ_VREG(HEVC_SAO_CTRL1);
+	WRITE_VREG(HEVC_SAO_CTRL1, rdata32 | (0x1 << 2));
+
+	/*MPRED*/
+	rdata32 = READ_VREG(HEVC_MPRED_CTRL1);
+	WRITE_VREG(HEVC_MPRED_CTRL1, rdata32 | (0x1 << 24));
+
+	/* PARSER*/
+	rdata32 = READ_VREG(HEVC_STREAM_CONTROL);
+	WRITE_VREG(HEVC_STREAM_CONTROL, rdata32 | (0x1 << 15));
+	rdata32 = READ_VREG(HEVC_SHIFT_CONTROL);
+	WRITE_VREG(HEVC_SHIFT_CONTROL, rdata32 | (0x1 << 15));
+	rdata32 = READ_VREG(HEVC_CABAC_CONTROL);
+	WRITE_VREG(HEVC_CABAC_CONTROL, rdata32 | (0x1 << 13));
+	rdata32 = READ_VREG(HEVC_PARSER_CORE_CONTROL);
+	WRITE_VREG(HEVC_PARSER_CORE_CONTROL, rdata32 | (0x1 << 15));
+	rdata32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+	WRITE_VREG(HEVC_PARSER_INT_CONTROL, rdata32 | (0x1 << 15));
+	rdata32 = READ_VREG(HEVC_PARSER_IF_CONTROL);
+	WRITE_VREG(HEVC_PARSER_IF_CONTROL,
+			rdata32 | (0x1 << 6) | (0x1 << 3) | (0x1 << 1));
+
+	/*IPP*/
+	rdata32 = READ_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG);
+	WRITE_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG, rdata32 | 0xffffffff);
+
+	/* MCRCC*/
+	rdata32 = READ_VREG(HEVCD_MCRCC_CTL1);
+	WRITE_VREG(HEVCD_MCRCC_CTL1, rdata32 | (0x1 << 3));
+}
+#endif
+
+
+#ifdef MCRCC_ENABLE
+static void  config_mcrcc_axi_hw(struct VP9Decoder_s *pbi)
+{
+	unsigned int rdata32;
+	unsigned short is_inter;
+	/*pr_info("Entered config_mcrcc_axi_hw...\n");*/
+	WRITE_VREG(HEVCD_MCRCC_CTL1, 0x2);/* reset mcrcc*/
+	is_inter = ((pbi->common.frame_type != KEY_FRAME) &&
+			(!pbi->common.intra_only)) ? 1 : 0;
+	if (!is_inter) { /* I-PIC*/
+		/*remove reset -- disables clock*/
+		WRITE_VREG(HEVCD_MCRCC_CTL1, 0x0);
+		return;
+	}
+
+#if 0
+	pr_info("before call mcrcc_get_hitrate\r\n");
+	mcrcc_get_hitrate();
+	decomp_get_hitrate();
+	decomp_get_comprate();
+#endif
+
+	WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+			(0 << 8) | (1 << 1) | 0);
+	rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+	rdata32 = rdata32 & 0xffff;
+	rdata32 = rdata32 | (rdata32 << 16);
+	WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
+	/*Programme canvas1 */
+	rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+	rdata32 = rdata32 & 0xffff;
+	rdata32 = rdata32 | (rdata32 << 16);
+	WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32);
+	/*enable mcrcc progressive-mode*/
+	WRITE_VREG(HEVCD_MCRCC_CTL1, 0xff0);
+	return;
+}
+#endif
+
+
+static struct VP9Decoder_s gHevc;
+
+static void vp9_local_uninit(struct VP9Decoder_s *pbi)
+{
+	pbi->rpm_ptr = NULL;
+	pbi->lmem_ptr = NULL;
+
+	if (pbi->rpm_addr) {
+		dma_unmap_single(amports_get_dma_device(),
+			pbi->rpm_phy_addr, RPM_BUF_SIZE,
+				DMA_FROM_DEVICE);
+		kfree(pbi->rpm_addr);
+		pbi->rpm_addr = NULL;
+	}
+	if (pbi->lmem_addr) {
+			if (pbi->lmem_phy_addr)
+				dma_free_coherent(amports_get_dma_device(),
+						LMEM_BUF_SIZE, pbi->lmem_addr,
+						pbi->lmem_phy_addr);
+		pbi->lmem_addr = NULL;
+	}
+	if (pbi->prob_buffer_addr) {
+		if (pbi->prob_buffer_phy_addr)
+			dma_free_coherent(amports_get_dma_device(),
+				PROB_BUF_SIZE, pbi->prob_buffer_addr,
+				pbi->prob_buffer_phy_addr);
+			pbi->prob_buffer_addr = NULL;
+	}
+	if (pbi->count_buffer_addr) {
+		if (pbi->count_buffer_phy_addr)
+			dma_free_coherent(amports_get_dma_device(),
+				COUNT_BUF_SIZE, pbi->count_buffer_addr,
+				pbi->count_buffer_phy_addr);
+			pbi->count_buffer_addr = NULL;
+	}
+#ifdef VP9_10B_MMU
+	if (pbi->frame_mmu_map_addr) {
+		if (pbi->frame_mmu_map_phy_addr)
+			dma_free_coherent(amports_get_dma_device(),
+				FRAME_MMU_MAP_SIZE, pbi->frame_mmu_map_addr,
+					pbi->frame_mmu_map_phy_addr);
+			pbi->frame_mmu_map_addr = NULL;
+	}
+#endif
+}
+
+static int vp9_local_init(struct VP9Decoder_s *pbi)
+{
+	int ret = -1;
+	/*int losless_comp_header_size, losless_comp_body_size;*/
+
+	struct BuffInfo_s *cur_buf_info = NULL;
+	memset(&pbi->param, 0, sizeof(union param_u));
+
+#ifdef SUPPORT_4K2K
+	cur_buf_info = &amvvp9_workbuff_spec[1];/* 4k2k work space */
+#else
+	cur_buf_info = &amvvp9_workbuff_spec[0];/* 1080p work space */
+#endif
+
+	init_buff_spec(cur_buf_info);
+#ifdef VP9_10B_MMU
+	init_mmu_spec();
+#endif
+
+	pbi->mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)
+	    & (~0xffff);
+	pbi->mc_buf_spec.buf_size = (pbi->mc_buf_spec.buf_end
+	    - pbi->mc_buf_spec.buf_start);
+
+	vp9_bufmgr_init(pbi, cur_buf_info, &pbi->mc_buf_spec);
+
+	pbi->init_pic_w = buf_alloc_width ? buf_alloc_width :
+		(pbi->vvp9_amstream_dec_info.width ?
+		pbi->vvp9_amstream_dec_info.width :
+		pbi->work_space_buf->max_width);
+	pbi->init_pic_h = buf_alloc_height ? buf_alloc_height :
+		(pbi->vvp9_amstream_dec_info.height ?
+		pbi->vvp9_amstream_dec_info.height :
+		pbi->work_space_buf->max_height);
+	init_buf_list(pbi);
+	init_pic_list(pbi);
+
+	pts_unstable = ((unsigned long)(pbi->vvp9_amstream_dec_info.param)
+			& 0x40) >> 6;
+
+	pbi->video_signal_type = 0;
+	video_signal_type = pbi->video_signal_type;
+
+	if ((debug & VP9_DEBUG_SEND_PARAM_WITH_REG) == 0) {
+		pbi->rpm_addr = kmalloc(RPM_BUF_SIZE, GFP_KERNEL);
+		if (pbi->rpm_addr == NULL) {
+			pr_err("%s: failed to alloc rpm buffer\n", __func__);
+			return -1;
+		}
+
+		pbi->rpm_phy_addr = dma_map_single(amports_get_dma_device(),
+			pbi->rpm_addr, RPM_BUF_SIZE, DMA_FROM_DEVICE);
+		if (dma_mapping_error(amports_get_dma_device(),
+			pbi->rpm_phy_addr)) {
+			pr_err("%s: failed to map rpm buffer\n", __func__);
+			kfree(pbi->rpm_addr);
+			pbi->rpm_addr = NULL;
+			return -1;
+		}
+
+		pbi->rpm_ptr = pbi->rpm_addr;
+	}
+
+	if (debug & VP9_DEBUG_UCODE) {
+		pbi->lmem_addr = dma_alloc_coherent(amports_get_dma_device(),
+				LMEM_BUF_SIZE,
+				&pbi->lmem_phy_addr, GFP_KERNEL);
+		if (pbi->lmem_addr == NULL) {
+			pr_err("%s: failed to alloc lmem buffer\n", __func__);
+			return -1;
+		}
+/*
+		pbi->lmem_phy_addr = dma_map_single(amports_get_dma_device(),
+			pbi->lmem_addr, LMEM_BUF_SIZE, DMA_BIDIRECTIONAL);
+		if (dma_mapping_error(amports_get_dma_device(),
+			pbi->lmem_phy_addr)) {
+			pr_err("%s: failed to map lmem buffer\n", __func__);
+			kfree(pbi->lmem_addr);
+			pbi->lmem_addr = NULL;
+			return -1;
+		}
+*/
+		pbi->lmem_ptr = pbi->lmem_addr;
+	}
+	pbi->prob_buffer_addr = dma_alloc_coherent(amports_get_dma_device(),
+				PROB_BUF_SIZE,
+				&pbi->prob_buffer_phy_addr, GFP_KERNEL);
+	if (pbi->prob_buffer_addr == NULL) {
+		pr_err("%s: failed to alloc prob_buffer\n", __func__);
+		return -1;
+	}
+/*	pbi->prob_buffer_phy_addr = dma_map_single(amports_get_dma_device(),
+	pbi->prob_buffer_addr, PROB_BUF_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(amports_get_dma_device(),
+	pbi->prob_buffer_phy_addr)) {
+		pr_err("%s: failed to map prob_buffer\n", __func__);
+		kfree(pbi->prob_buffer_addr);
+		pbi->prob_buffer_addr = NULL;
+		return -1;
+	}
+*/
+	pbi->count_buffer_addr = dma_alloc_coherent(amports_get_dma_device(),
+				COUNT_BUF_SIZE,
+				&pbi->count_buffer_phy_addr, GFP_KERNEL);
+	if (pbi->count_buffer_addr == NULL) {
+		pr_err("%s: failed to alloc count_buffer\n", __func__);
+		return -1;
+	}
+/*	pbi->count_buffer_phy_addr = dma_map_single(amports_get_dma_device(),
+	pbi->count_buffer_addr, COUNT_BUF_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(amports_get_dma_device(),
+		pbi->count_buffer_phy_addr)) {
+		pr_err("%s: failed to map count_buffer\n", __func__);
+		kfree(pbi->count_buffer_addr);
+		pbi->count_buffer_addr = NULL;
+		return -1;
+	}
+*/
+#ifdef VP9_10B_MMU
+	pbi->frame_mmu_map_addr = dma_alloc_coherent(amports_get_dma_device(),
+				FRAME_MMU_MAP_SIZE,
+				&pbi->frame_mmu_map_phy_addr, GFP_KERNEL);
+	if (pbi->frame_mmu_map_addr == NULL) {
+		pr_err("%s: failed to alloc count_buffer\n", __func__);
+		return -1;
+	}
+/*	pbi->frame_mmu_map_phy_addr = dma_map_single(amports_get_dma_device(),
+	pbi->frame_mmu_map_addr, FRAME_MMU_MAP_SIZE, DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(amports_get_dma_device(),
+	pbi->frame_mmu_map_phy_addr)) {
+		pr_err("%s: failed to map count_buffer\n", __func__);
+		kfree(pbi->frame_mmu_map_addr);
+		pbi->frame_mmu_map_addr = NULL;
+		return -1;
+	}*/
+#endif
+
+	ret = 0;
+	return ret;
+}
+
+/********************************************
+ *  Mailbox command
+ ********************************************/
+#define CMD_FINISHED               0
+#define CMD_ALLOC_VIEW             1
+#define CMD_FRAME_DISPLAY          3
+#define CMD_DEBUG                  10
+
+
+#define DECODE_BUFFER_NUM_MAX    32
+#define DISPLAY_BUFFER_NUM       6
+
+#define video_domain_addr(adr) (adr&0x7fffffff)
+#define DECODER_WORK_SPACE_SIZE 0x800000
+
+#define spec2canvas(x)  \
+	(((x)->uv_canvas_index << 16) | \
+	 ((x)->uv_canvas_index << 8)  | \
+	 ((x)->y_canvas_index << 0))
+
+
+static void set_canvas(struct PIC_BUFFER_CONFIG_s *pic_config)
+{
+	int canvas_w = ALIGN(pic_config->y_crop_width, 64)/4;
+	int canvas_h = ALIGN(pic_config->y_crop_height, 32)/4;
+	int blkmode = mem_map_mode;
+	/*CANVAS_BLKMODE_64X32*/
+	if	(double_write_mode) {
+		canvas_w = pic_config->y_crop_width;
+		canvas_h = pic_config->y_crop_height;
+		if (double_write_mode == 2) {
+			canvas_w >>= 2;
+			canvas_h >>= 2;
+		}
+
+		if (mem_map_mode == 0)
+			canvas_w = ALIGN(canvas_w, 32);
+		else
+			canvas_w = ALIGN(canvas_w, 64);
+		canvas_h = ALIGN(canvas_h, 32);
+
+		pic_config->y_canvas_index = 128 + pic_config->index * 2;
+		pic_config->uv_canvas_index = 128 + pic_config->index * 2 + 1;
+
+		canvas_config_ex(pic_config->y_canvas_index,
+			pic_config->dw_y_adr, canvas_w, canvas_h,
+			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+		canvas_config_ex(pic_config->uv_canvas_index,
+			pic_config->dw_u_v_adr,	canvas_w, canvas_h,
+			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+	} else {
+		pic_config->y_canvas_index = 128 + pic_config->index;
+		pic_config->uv_canvas_index = 128 + pic_config->index;
+
+		canvas_config_ex(pic_config->y_canvas_index,
+			pic_config->mc_y_adr, canvas_w, canvas_h,
+			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+		canvas_config_ex(pic_config->uv_canvas_index,
+		pic_config->mc_u_v_adr,	canvas_w, canvas_h,
+			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+	}
+
+}
+
+
+static void set_frame_info(struct VP9Decoder_s *pbi, struct vframe_s *vf)
+{
+	unsigned int ar;
+
+	vf->duration = pbi->frame_dur;
+	vf->duration_pulldown = 0;
+	vf->flag = 0;
+
+	ar = min_t(u32, pbi->frame_ar, DISP_RATIO_ASPECT_RATIO_MAX);
+	vf->ratio_control = (ar << DISP_RATIO_ASPECT_RATIO_BIT);
+
+	return;
+}
+
+static int vvp9_vf_states(struct vframe_states *states, void *op_arg)
+{
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)op_arg;
+
+	states->vf_pool_size = VF_POOL_SIZE;
+	states->buf_free_num = kfifo_len(&pbi->newframe_q);
+	states->buf_avail_num = kfifo_len(&pbi->display_q);
+
+	if (step == 2)
+		states->buf_avail_num = 0;
+	return 0;
+}
+
+static struct vframe_s *vvp9_vf_peek(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)op_arg;
+	if (step == 2)
+		return NULL;
+
+	if (kfifo_peek(&pbi->display_q, &vf))
+		return vf;
+
+	return NULL;
+}
+
+static struct vframe_s *vvp9_vf_get(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)op_arg;
+	if (step == 2)
+		return NULL;
+	else if (step == 1)
+			step = 2;
+
+	if (kfifo_get(&pbi->display_q, &vf)) {
+		uint8_t index = vf->index & 0xff;
+		 if (index >= 0	&& index < FRAME_BUFFERS)
+			return vf;
+	}
+	return NULL;
+}
+
+static void vvp9_vf_put(struct vframe_s *vf, void *op_arg)
+{
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)op_arg;
+	uint8_t index = vf->index & 0xff;
+
+	kfifo_put(&pbi->newframe_q, (const struct vframe_s *)vf);
+
+	if (index >= 0
+		&& index < FRAME_BUFFERS) {
+		ulong spin_flags;
+		struct VP9_Common_s *cm = &pbi->common;
+		struct BufferPool_s *const pool = cm->buffer_pool;
+		spin_lock_irqsave(&lock, spin_flags);
+		if (pool->frame_bufs[index].buf.vf_ref > 0)
+			pool->frame_bufs[index].buf.vf_ref--;
+		spin_unlock_irqrestore(&lock, spin_flags);
+		if (pbi->wait_buf)
+			WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG,
+						0x1);
+
+	}
+
+}
+
+static int vvp9_event_cb(int type, void *data, void *private_data)
+{
+	if (type & VFRAME_EVENT_RECEIVER_RESET) {
+#if 0
+		unsigned long flags;
+		amhevc_stop();
+#ifndef CONFIG_POST_PROCESS_MANAGER
+		vf_light_unreg_provider(&vvp9_vf_prov);
+#endif
+		spin_lock_irqsave(&pbi->lock, flags);
+		vvp9_local_init();
+		vvp9_prot_init();
+		spin_unlock_irqrestore(&pbi->lock, flags);
+#ifndef CONFIG_POST_PROCESS_MANAGER
+		vf_reg_provider(&vvp9_vf_prov);
+#endif
+		amhevc_start();
+#endif
+	}
+
+	return 0;
+}
+
+void inc_vf_ref(struct VP9Decoder_s *pbi, int index)
+{
+	struct VP9_Common_s *cm = &pbi->common;
+	cm->buffer_pool->frame_bufs[index].buf.vf_ref++;
+
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("%s index = %d new vf_ref = %d\r\n",
+			__func__, index,
+			cm->buffer_pool->frame_bufs[index].buf.vf_ref);
+}
+
+
+static int prepare_display_buf(struct VP9Decoder_s *pbi,
+				struct PIC_BUFFER_CONFIG_s *pic_config)
+{
+	struct vframe_s *vf = NULL;
+	int stream_offset = pic_config->stream_offset;
+	unsigned short slice_type = pic_config->slice_type;
+
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("%s index = %d\r\n", __func__, pic_config->index);
+	if (kfifo_get(&pbi->newframe_q, &vf) == 0) {
+		pr_info("fatal error, no available buffer slot.");
+		return -1;
+	}
+
+	if (double_write_mode) {
+		set_canvas(pic_config);
+	}
+	if (vf) {
+		/* if (pts_lookup_offset(PTS_TYPE_VIDEO,
+		   stream_offset, &vf->pts, 0) != 0) { */
+		if (pts_lookup_offset_us64
+			(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0,
+			 &vf->pts_us64) != 0) {
+#ifdef DEBUG_PTS
+			pbi->pts_missed++;
+#endif
+			vf->pts = 0;
+			vf->pts_us64 = 0;
+		}
+#ifdef DEBUG_PTS
+		else
+			pbi->pts_hit++;
+#endif
+		if (pts_unstable)
+			pbi->pts_mode = PTS_NONE_REF_USE_DURATION;
+
+		if ((pbi->pts_mode == PTS_NORMAL) && (vf->pts != 0)
+			&& pbi->get_frame_dur) {
+			int pts_diff = (int)vf->pts - pbi->last_lookup_pts;
+
+			if (pts_diff < 0) {
+				pbi->pts_mode_switching_count++;
+				pbi->pts_mode_recovery_count = 0;
+
+				if (pbi->pts_mode_switching_count >=
+					PTS_MODE_SWITCHING_THRESHOLD) {
+					pbi->pts_mode =
+						PTS_NONE_REF_USE_DURATION;
+					pr_info
+					("HEVC: switch to n_d mode.\n");
+				}
+
+			} else {
+				int p = PTS_MODE_SWITCHING_RECOVERY_THREASHOLD;
+				pbi->pts_mode_recovery_count++;
+				if (pbi->pts_mode_recovery_count > p) {
+					pbi->pts_mode_switching_count = 0;
+					pbi->pts_mode_recovery_count = 0;
+				}
+			}
+		}
+
+		if (vf->pts != 0)
+			pbi->last_lookup_pts = vf->pts;
+
+		if ((pbi->pts_mode == PTS_NONE_REF_USE_DURATION)
+			&& (slice_type != KEY_FRAME))
+			vf->pts = pbi->last_pts + DUR2PTS(pbi->frame_dur);
+		pbi->last_pts = vf->pts;
+
+		if (vf->pts_us64 != 0)
+			pbi->last_lookup_pts_us64 = vf->pts_us64;
+
+		if ((pbi->pts_mode == PTS_NONE_REF_USE_DURATION)
+			&& (slice_type != KEY_FRAME)) {
+			vf->pts_us64 =
+				pbi->last_pts_us64 +
+				(DUR2PTS(pbi->frame_dur) * 100 / 9);
+		}
+		pbi->last_pts_us64 = vf->pts_us64;
+		if ((debug & VP9_DEBUG_OUT_PTS) != 0) {
+			pr_info
+			("VP9 dec out pts: vf->pts=%d, vf->pts_us64 = %lld\n",
+			 vf->pts, vf->pts_us64);
+		}
+
+		vf->index = 0xff00 | pic_config->index;
+#if 1
+/*SUPPORT_10BIT*/
+		if (double_write_mode & 0x10) {
+			/* double write only */
+			vf->compBodyAddr = 0;
+			vf->compHeadAddr = 0;
+		} else {
+			vf->compBodyAddr = pic_config->mc_y_adr; /*body adr*/
+			vf->compHeadAddr = pic_config->mc_y_adr +
+						pic_config->comp_body_size;
+					/*head adr*/
+		}
+		if (double_write_mode) {
+			vf->type = VIDTYPE_PROGRESSIVE |
+				VIDTYPE_VIU_FIELD;
+			vf->type |= VIDTYPE_VIU_NV21;
+			vf->canvas0Addr = vf->canvas1Addr =
+				spec2canvas(pic_config);
+		} else {
+			vf->canvas0Addr = vf->canvas1Addr = 0;
+			vf->type = VIDTYPE_COMPRESS | VIDTYPE_VIU_FIELD;
+			switch (pic_config->bit_depth) {
+			case VPX_BITS_8:
+				vf->bitdepth = BITDEPTH_Y8 |
+					BITDEPTH_U8 | BITDEPTH_V8;
+				break;
+			case VPX_BITS_10:
+			case VPX_BITS_12:
+				vf->bitdepth = BITDEPTH_Y10 |
+					BITDEPTH_U10 | BITDEPTH_V10;
+				break;
+			default:
+				vf->bitdepth = BITDEPTH_Y10 |
+					BITDEPTH_U10 | BITDEPTH_V10;
+				break;
+			}
+			if (pic_config->bit_depth == VPX_BITS_8)
+				vf->bitdepth |= BITDEPTH_SAVING_MODE;
+	}
+#else
+		vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
+		vf->type |= VIDTYPE_VIU_NV21;
+		vf->canvas0Addr = vf->canvas1Addr = spec2canvas(pic_config);
+#endif
+		set_frame_info(pbi, vf);
+		/* if((vf->width!=pic_config->width)|
+			(vf->height!=pic_config->height)) */
+		/* pr_info("aaa: %d/%d, %d/%d\n",
+		   vf->width,vf->height, pic_config->width,
+			pic_config->height); */
+		if (double_write_mode == 2) {
+			vf->width = pic_config->y_crop_width/4;
+			vf->height = pic_config->y_crop_height/4;
+		} else {
+			vf->width = pic_config->y_crop_width;
+			vf->height = pic_config->y_crop_height;
+		}
+		if (force_w_h != 0) {
+			vf->width = (force_w_h >> 16) & 0xffff;
+			vf->height = force_w_h & 0xffff;
+		}
+		vf->compWidth = pic_config->y_crop_width;
+		vf->compHeight = pic_config->y_crop_height;
+		if (force_fps & 0x100) {
+			u32 rate = force_fps & 0xff;
+			if (rate)
+				vf->duration = 96000/rate;
+			else
+				vf->duration = 0;
+		}
+		if ((debug & VP9_DEBUG_VF_REF) == 0)
+			inc_vf_ref(pbi, pic_config->index);
+		kfifo_put(&pbi->display_q, (const struct vframe_s *)vf);
+		vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+	}
+
+	return 0;
+}
+
+static void get_rpm_param(union param_u *params)
+{
+	int i;
+	unsigned int data32;
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("enter %s\r\n", __func__);
+	for (i = 0; i < 128; i++) {
+		do {
+			data32 = READ_VREG(RPM_CMD_REG);
+			/*pr_info("%x\n", data32);*/
+		} while ((data32 & 0x10000) == 0);
+		params->l.data[i] = data32&0xffff;
+		/*pr_info("%x\n", data32);*/
+		WRITE_VREG(RPM_CMD_REG, 0);
+	}
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("leave %s\r\n", __func__);
+}
+
+static irqreturn_t vvp9_isr(int irq, void *data)
+{
+	int i;
+	unsigned int dec_status;
+	int ret;
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)data;
+	unsigned int adapt_prob_status;
+	struct VP9_Common_s *const cm = &pbi->common;
+	dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
+	adapt_prob_status = READ_VREG(VP9_ADAPT_PROB_REG);
+	if (pbi->init_flag == 0)
+		return IRQ_HANDLED;
+
+	pbi->process_busy = 1;
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("vp9 isr dec status  = %d\n", dec_status);
+
+	if (debug & VP9_DEBUG_UCODE) {
+		if (READ_HREG(DEBUG_REG1) & 0x10000) {
+			dma_sync_single_for_cpu(
+				amports_get_dma_device(),
+				pbi->lmem_phy_addr,
+				LMEM_BUF_SIZE,
+				DMA_FROM_DEVICE);
+
+			pr_info("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
+			for (i = 0; i < 0x400; i += 4) {
+				int ii;
+				if ((i & 0xf) == 0)
+					pr_info("%03x: ", i);
+				for (ii = 0; ii < 4; ii++) {
+					pr_info("%04x ",
+						   pbi->lmem_ptr[i + 3 - ii]);
+				}
+				if (((i + ii) & 0xf) == 0)
+					pr_info("\n");
+			}
+			WRITE_HREG(DEBUG_REG1, 0);
+		} else if (READ_HREG(DEBUG_REG1) != 0) {
+			pr_info("dbg%x: %x\n", READ_HREG(DEBUG_REG1),
+				   READ_HREG(DEBUG_REG2));
+			WRITE_HREG(DEBUG_REG1, 0);
+			pbi->process_busy = 0;
+			return IRQ_HANDLED;
+		}
+
+	}
+
+	if (pbi->error_flag == 1) {
+		pbi->error_flag = 2;
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	} else if (pbi->error_flag == 3) {
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+
+	if (is_buffer_empty(cm)) {
+		/*
+		if (pbi->wait_buf == 0)
+			pr_info("set wait_buf to 1\r\n");
+		*/
+		pbi->wait_buf = 1;
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+
+	/*if (pbi->wait_buf)
+		pr_info("set wait_buf to 0\r\n");
+	*/
+	pbi->wait_buf = 0;
+
+	if ((adapt_prob_status & 0xff) == 0xfd) {
+		/*VP9_REQ_ADAPT_PROB*/
+	int pre_fc = (cm->frame_type == KEY_FRAME) ? 1 : 0;
+	uint8_t *prev_prob_b =
+		((uint8_t *)pbi->prob_buffer_addr) +
+		((adapt_prob_status >> 8) * 0x1000);
+	uint8_t *cur_prob_b =
+		((uint8_t *)pbi->prob_buffer_addr) + 0x4000;
+	uint8_t *count_b = (uint8_t *)pbi->count_buffer_addr;
+
+	adapt_coef_probs(pbi->pic_count, (cm->last_frame_type == KEY_FRAME),
+			pre_fc, (adapt_prob_status >> 8),
+			(unsigned int *)prev_prob_b,
+			(unsigned int *)cur_prob_b, (unsigned int *)count_b);
+
+	memcpy(prev_prob_b, cur_prob_b, PROB_SIZE);
+	WRITE_VREG(VP9_ADAPT_PROB_REG, 0);
+	pbi->pic_count += 1;
+
+	/*return IRQ_HANDLED;*/
+	}
+
+	if (dec_status == VP9_EOS) {
+		pr_info("VP9_EOS, flush buffer\r\n");
+
+		vp9_bufmgr_postproc(pbi);
+
+		pr_info("send VP9_10B_DISCARD_NAL\r\n");
+		WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DISCARD_NAL);
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+
+	if (dec_status != VP9_HEAD_PARSER_DONE) {
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+	if (pbi->frame_count > 0)
+		vp9_bufmgr_postproc(pbi);
+
+	if (debug & VP9_DEBUG_SEND_PARAM_WITH_REG) {
+		get_rpm_param(&vp9_param);
+	} else {
+		dma_sync_single_for_cpu(
+			amports_get_dma_device(),
+			pbi->rpm_phy_addr,
+			RPM_BUF_SIZE,
+			DMA_FROM_DEVICE);
+
+		for (i = 0; i < (RPM_END - RPM_BEGIN); i += 4) {
+			int ii;
+			for (ii = 0; ii < 4; ii++)
+				vp9_param.l.data[i + ii] =
+					pbi->rpm_ptr[i + 3 - ii];
+		   }
+	}
+if (debug & VP9_DEBUG_BUFMGR_MORE) {
+	pr_info("vp9_param: (%d)\n", pbi->slice_idx);
+	pbi->slice_idx++;
+	for (i = 0; i < (RPM_END-RPM_BEGIN); i++) {
+		pr_info("%04x ", vp9_param.l.data[i]);
+		if (((i + 1) & 0xf) == 0)
+			pr_info("\n");
+	}
+	pr_info("=============param==========\r\n");
+	pr_info("profile               %x\r\n", vp9_param.p.profile);
+	pr_info("show_existing_frame   %x\r\n",
+		vp9_param.p.show_existing_frame);
+	pr_info("frame_to_show_idx     %x\r\n",
+		vp9_param.p.frame_to_show_idx);
+	pr_info("frame_type            %x\r\n", vp9_param.p.frame_type);
+	pr_info("show_frame            %x\r\n", vp9_param.p.show_frame);
+	pr_info("e.r.r.o.r_resilient_mode  %x\r\n",
+		vp9_param.p.error_resilient_mode);
+	pr_info("intra_only            %x\r\n", vp9_param.p.intra_only);
+	pr_info("display_size_present  %x\r\n",
+		vp9_param.p.display_size_present);
+	pr_info("reset_frame_context   %x\r\n",
+		vp9_param.p.reset_frame_context);
+	pr_info("refresh_frame_flags   %x\r\n",
+		vp9_param.p.refresh_frame_flags);
+	pr_info("bit_depth             %x\r\n", vp9_param.p.bit_depth);
+	pr_info("width                 %x\r\n", vp9_param.p.width);
+	pr_info("height                %x\r\n", vp9_param.p.height);
+	pr_info("display_width         %x\r\n", vp9_param.p.display_width);
+	pr_info("display_height        %x\r\n", vp9_param.p.display_height);
+	pr_info("ref_info              %x\r\n", vp9_param.p.ref_info);
+	pr_info("same_frame_size       %x\r\n", vp9_param.p.same_frame_size);
+if (debug & VP9_DEBUG_DBG_LF_PRINT) {
+	pr_info("mode_ref_delta_enabled: 0x%x\r\n",
+		vp9_param.p.mode_ref_delta_enabled);
+	pr_info("sharpness_level: 0x%x\r\n",
+		vp9_param.p.sharpness_level);
+	pr_info("ref_deltas: 0x%x, 0x%x, 0x%x, 0x%x\r\n",
+		vp9_param.p.ref_deltas[0], vp9_param.p.ref_deltas[1],
+		vp9_param.p.ref_deltas[2], vp9_param.p.ref_deltas[3]);
+	pr_info("mode_deltas: 0x%x, 0x%x\r\n", vp9_param.p.mode_deltas[0],
+		vp9_param.p.mode_deltas[1]);
+	pr_info("filter_level: 0x%x\r\n", vp9_param.p.filter_level);
+	pr_info("seg_enabled: 0x%x\r\n", vp9_param.p.seg_enabled);
+	pr_info("seg_abs_delta: 0x%x\r\n", vp9_param.p.seg_abs_delta);
+	pr_info("seg_lf_feature_enabled: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n",
+		(vp9_param.p.seg_lf_info[0]>>15 & 1),
+		(vp9_param.p.seg_lf_info[1]>>15 & 1),
+		(vp9_param.p.seg_lf_info[2]>>15 & 1),
+		(vp9_param.p.seg_lf_info[3]>>15 & 1),
+		(vp9_param.p.seg_lf_info[4]>>15 & 1),
+		(vp9_param.p.seg_lf_info[5]>>15 & 1),
+		(vp9_param.p.seg_lf_info[6]>>15 & 1),
+		(vp9_param.p.seg_lf_info[7]>>15 & 1));
+		pr_info("seg_lf_feature_data: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n",
+		(vp9_param.p.seg_lf_info[0] & 0x13f),
+		(vp9_param.p.seg_lf_info[1] & 0x13f),
+		(vp9_param.p.seg_lf_info[2] & 0x13f),
+		(vp9_param.p.seg_lf_info[3] & 0x13f),
+		(vp9_param.p.seg_lf_info[4] & 0x13f),
+		(vp9_param.p.seg_lf_info[5] & 0x13f),
+		(vp9_param.p.seg_lf_info[6] & 0x13f),
+		(vp9_param.p.seg_lf_info[7] & 0x13f));
+	}
+	pr_info("\r\n");
+	}
+
+	bit_depth_luma = vp9_param.p.bit_depth;
+	bit_depth_chroma = vp9_param.p.bit_depth;
+
+	ret = vp9_bufmgr_process(pbi, &vp9_param);
+	if (ret < 0) {
+		pr_info("vp9_bufmgr_process=> %d, VP9_10B_DISCARD_NAL\r\n",
+		 ret);
+		WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DISCARD_NAL);
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	} else if (ret == 0) {
+		pbi->frame_count++;
+		/*pr_info("Decode Frame Data %d\n", pbi->frame_count);*/
+		config_pic_size(pbi, vp9_param.p.bit_depth);
+		if ((pbi->common.frame_type != KEY_FRAME)
+			&& (!pbi->common.intra_only)) {
+			config_mc_buffer(pbi, vp9_param.p.bit_depth);
+			config_mpred_hw(pbi);
+	} else {
+		clear_mpred_hw(pbi);
+	}
+#ifdef MCRCC_ENABLE
+	config_mcrcc_axi_hw(pbi);
+#endif
+	config_sao_hw(pbi, &vp9_param);
+
+#ifdef VP9_LPF_LVL_UPDATE
+    /*
+     * Get loop filter related picture level parameters from Parser
+     */
+	lf->mode_ref_delta_enabled = vp9_param.p.mode_ref_delta_enabled;
+	lf->sharpness_level = vp9_param.p.sharpness_level;
+	for (i = 0; i < 4; i++)
+		lf->ref_deltas[i] = vp9_param.p.ref_deltas[i];
+	for (i = 0; i < 2; i++)
+		lf->mode_deltas[i] = vp9_param.p.mode_deltas[i];
+	default_filt_lvl = vp9_param.p.filter_level;
+	seg_4lf->enabled = vp9_param.p.seg_enabled;
+	seg_4lf->abs_delta = vp9_param.p.seg_abs_delta;
+	for (i = 0; i < MAX_SEGMENTS; i++)
+		seg_4lf->feature_mask[i] = (vp9_param.p.seg_lf_info[i] &
+		0x8000) ? (1 << SEG_LVL_ALT_LF) : 0;
+		for (i = 0; i < MAX_SEGMENTS; i++)
+			seg_4lf->feature_data[i][SEG_LVL_ALT_LF]
+			= (vp9_param.p.seg_lf_info[i]
+			& 0x100) ? -(vp9_param.p.seg_lf_info[i]
+			& 0x3f) : (vp9_param.p.seg_lf_info[i] & 0x3f);
+	/*
+	* Update loop filter Thr/Lvl table for every frame
+	*/
+	/*pr_info
+	("vp9_loop_filter (run before every frame decoding start)\n");*/
+	vp9_loop_filter_frame_init(seg_4lf, lfi, lf, default_filt_lvl);
+#endif
+	/*pr_info("HEVC_DEC_STATUS_REG <= VP9_10B_DECODE_SLICE\n");*/
+
+	WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DECODE_SLICE);
+	} else {
+	pr_info("Skip search next start code\n");
+	cm->prev_fb_idx = INVALID_IDX;
+	/*skip, search next start code*/
+	WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DECODE_SLICE);
+	}
+	pbi->process_busy = 0;
+	return IRQ_HANDLED;
+}
+
+static void vvp9_put_timer_func(unsigned long arg)
+{
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)arg;
+	struct timer_list *timer = &pbi->timer;
+	uint8_t empty_flag;
+	unsigned int buf_level;
+
+	enum receviver_start_e state = RECEIVER_INACTIVE;
+	if (pbi->init_flag == 0) {
+		if (pbi->stat & STAT_TIMER_ARM) {
+			timer->expires = jiffies + PUT_INTERVAL;
+			add_timer(&pbi->timer);
+		}
+		return;
+	}
+	if (vf_get_receiver(PROVIDER_NAME)) {
+		state =
+			vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_QUREY_STATE, NULL);
+		if ((state == RECEIVER_STATE_NULL)
+			|| (state == RECEIVER_STATE_NONE))
+			state = RECEIVER_INACTIVE;
+	} else
+		state = RECEIVER_INACTIVE;
+
+	empty_flag = (READ_VREG(HEVC_PARSER_INT_STATUS) >> 6) & 0x1;
+	/* error watchdog */
+	if (empty_flag == 0) {
+		/* decoder has input */
+		if ((debug & VP9_DEBUG_DIS_LOC_ERROR_PROC) == 0) {
+
+			buf_level = READ_VREG(HEVC_STREAM_LEVEL);
+			/* receiver has no buffer to recycle */
+			if ((state == RECEIVER_INACTIVE) &&
+				(kfifo_is_empty(&pbi->display_q) &&
+				 buf_level > 0x200)
+				) {
+					WRITE_VREG
+					(HEVC_ASSIST_MBOX1_IRQ_REG,
+					 0x1);
+			}
+		}
+
+		if ((debug & VP9_DEBUG_DIS_SYS_ERROR_PROC) == 0) {
+			/* receiver has no buffer to recycle */
+			/*if ((state == RECEIVER_INACTIVE) &&
+				(kfifo_is_empty(&pbi->display_q))) {
+			pr_info("vp9 something error,need reset\n");
+			}*/
+		}
+	}
+
+	if (decode_stop_pos != decode_stop_pos_pre) {
+		WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+		decode_stop_pos_pre = decode_stop_pos;
+	}
+
+	if (debug & VP9_DEBUG_DUMP_PIC_LIST) {
+		dump_pic_list(pbi);
+		debug &= ~VP9_DEBUG_DUMP_PIC_LIST;
+	}
+	if (debug & VP9_DEBUG_TRIG_SLICE_SEGMENT_PROC) {
+		WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
+		debug &= ~VP9_DEBUG_TRIG_SLICE_SEGMENT_PROC;
+	}
+	/*if (debug & VP9_DEBUG_HW_RESET) {
+	}*/
+	if (debug & VP9_DEBUG_ERROR_TRIG) {
+		WRITE_VREG(DECODE_STOP_POS, 1);
+		debug &= ~VP9_DEBUG_ERROR_TRIG;
+	}
+
+	if (radr != 0) {
+		if (rval != 0) {
+			WRITE_VREG(radr, rval);
+			pr_info("WRITE_VREG(%x,%x)\n", radr, rval);
+		} else
+			pr_info("READ_VREG(%x)=%x\n", radr, READ_VREG(radr));
+		rval = 0;
+		radr = 0;
+	}
+	if (dbg_cmd != 0) {
+		if (dbg_cmd == 1) {
+			u32 disp_laddr;
+			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB &&
+				double_write_mode == 0) {
+				disp_laddr =
+					READ_VCBUS_REG(AFBC_BODY_BADDR) << 4;
+			} else {
+				struct canvas_s cur_canvas;
+				canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0)
+					& 0xff), &cur_canvas);
+				disp_laddr = cur_canvas.addr;
+			}
+			pr_info("current displayed buffer address %x\r\n",
+				disp_laddr);
+		}
+		dbg_cmd = 0;
+	}
+	/*don't changed at start.*/
+	if (pbi->get_frame_dur && pbi->show_frame_num > 60 &&
+		pbi->frame_dur > 0 && pbi->saved_resolution !=
+		frame_width * frame_height *
+			(96000 / pbi->frame_dur)) {
+		int fps = 96000 / pbi->frame_dur;
+		if (hevc_source_changed(VFORMAT_VP9,
+			frame_width, frame_height, fps) > 0)
+			pbi->saved_resolution = frame_width *
+			frame_height * fps;
+	}
+
+	timer->expires = jiffies + PUT_INTERVAL;
+	add_timer(timer);
+}
+
+
+int vvp9_dec_status(struct vdec_status *vstatus)
+{
+	struct VP9Decoder_s *pbi = &gHevc;
+	vstatus->width = frame_width;
+	vstatus->height = frame_height;
+	if (pbi->frame_dur != 0)
+		vstatus->fps = 96000 / pbi->frame_dur;
+	else
+		vstatus->fps = -1;
+	vstatus->error_count = 0;
+	vstatus->status = pbi->stat | pbi->fatal_error;
+	return 0;
+}
+
+#if 0
+static void VP9_DECODE_INIT(void)
+{
+	/* enable vp9 clocks */
+	WRITE_VREG(DOS_GCLK_EN3, 0xffffffff);
+	/* *************************************************************** */
+	/* Power ON HEVC */
+	/* *************************************************************** */
+	/* Powerup HEVC */
+	WRITE_VREG(AO_RTI_GEN_PWR_SLEEP0,
+			READ_VREG(AO_RTI_GEN_PWR_SLEEP0) & (~(0x3 << 6)));
+	WRITE_VREG(DOS_MEM_PD_HEVC, 0x0);
+	WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3) | (0x3ffff << 2));
+	WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3) & (~(0x3ffff << 2)));
+	/* remove isolations */
+	WRITE_VREG(AO_RTI_GEN_PWR_ISO0,
+			READ_VREG(AO_RTI_GEN_PWR_ISO0) & (~(0x3 << 10)));
+
+}
+#endif
+
+static void vvp9_prot_init(struct VP9Decoder_s *pbi)
+{
+	unsigned int data32;
+	/* VP9_DECODE_INIT(); */
+	vp9_config_work_space_hw(pbi);
+	init_pic_list_hw(pbi);
+
+	vp9_init_decoder_hw();
+
+#ifdef VP9_LPF_LVL_UPDATE
+	vp9_loop_filter_init();
+#endif
+
+#if 1
+		if (debug & VP9_DEBUG_BUFMGR)
+			pr_info("[test.c] Enable BitStream Fetch\n");
+			data32 = READ_VREG(HEVC_STREAM_CONTROL);
+			data32 = data32 |
+				(1 << 0)/*stream_fetch_enable*/
+				;
+			WRITE_VREG(HEVC_STREAM_CONTROL, data32);
+			data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+			if (data32 != 0x00000100) {
+				/*print_scratch_error(29);*/
+				return;
+			}
+			data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+			if (data32 != 0x00000300) {
+				/*print_scratch_error(30);*/
+				return;
+			}
+			WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
+			WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
+			data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+			if (data32 != 0x12345678) {
+				/*print_scratch_error(31);*/
+				return;
+			}
+			data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+			if (data32 != 0x9abcdef0) {
+				/*print_scratch_error(32);*/
+				return;
+			}
+			WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x000000001);
+			WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
+#endif
+
+
+
+	WRITE_VREG(HEVC_WAIT_FLAG, 1);
+
+	/* WRITE_VREG(HEVC_MPSR, 1); */
+
+	/* clear mailbox interrupt */
+	WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
+
+	/* enable mailbox interrupt */
+	WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 1);
+
+	/* disable PSCALE for hardware sharing */
+	WRITE_VREG(HEVC_PSCALE_CTRL, 0);
+
+	if (debug & VP9_DEBUG_UCODE)
+		WRITE_VREG(DEBUG_REG1, 0x1);
+	else
+		WRITE_VREG(DEBUG_REG1, 0x0);
+	/*check vps/sps/pps/i-slice in ucode*/
+	WRITE_VREG(NAL_SEARCH_CTL, 0x8);
+
+	WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+	pr_info("vp9 prot init done\n");
+
+}
+
+static int vvp9_local_init(struct VP9Decoder_s *pbi)
+{
+	int i;
+	int ret;
+	int width, height;
+#ifdef DEBUG_PTS
+	pbi->pts_missed = 0;
+	pbi->pts_hit = 0;
+#endif
+	pbi->saved_resolution = 0;
+	pbi->get_frame_dur = false;
+	width = pbi->vvp9_amstream_dec_info.width;
+	height = pbi->vvp9_amstream_dec_info.height;
+	pbi->frame_dur =
+		(pbi->vvp9_amstream_dec_info.rate ==
+		 0) ? 3600 : pbi->vvp9_amstream_dec_info.rate;
+	if (width && height)
+		pbi->frame_ar = height * 0x100 / width;
+/*
+TODO:FOR VERSION
+*/
+	pr_info("vp9: ver (%d,%d) decinfo: %dx%d rate=%d\n", vp9_version,
+		   0, width, height, pbi->frame_dur);
+
+	if (pbi->frame_dur == 0)
+		pbi->frame_dur = 96000 / 24;
+
+	INIT_KFIFO(pbi->display_q);
+	INIT_KFIFO(pbi->newframe_q);
+
+
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		const struct vframe_s *vf = &pbi->vfpool[i];
+		pbi->vfpool[i].index = -1;
+		kfifo_put(&pbi->newframe_q, vf);
+	}
+
+
+	ret = vp9_local_init(pbi);
+
+	return ret;
+}
+
+static s32 vvp9_init(struct VP9Decoder_s *pbi)
+{
+	init_timer(&pbi->timer);
+
+	pbi->stat |= STAT_TIMER_INIT;
+
+	if (vvp9_local_init(pbi) < 0)
+		return -EBUSY;
+
+	amhevc_enable();
+	if (debug & VP9_DEBUG_LOAD_UCODE_FROM_FILE) {
+		pr_info("load ucode from file of vvp9_mc_debug\n");
+		if (amhevc_loadmc_ex(VFORMAT_VP9,
+				"vvp9_mc_debug", NULL) < 0) {
+			amhevc_disable();
+			return -EBUSY;
+		}
+#if 0
+	} else if (double_write_mode & 0x10) {
+		pr_info("load ucode from file of vvp9_mc_dw\n");
+		if (amhevc_loadmc_ex(VFORMAT_VP9,
+				"vvp9_mc_dw", NULL) < 0) {
+			amhevc_disable();
+			return -EBUSY;
+		}
+#endif
+	} else if (amhevc_loadmc_ex(VFORMAT_VP9, "vvp9_mc", NULL) < 0) {
+		amhevc_disable();
+		return -EBUSY;
+	}
+	pbi->stat |= STAT_MC_LOAD;
+
+	/* enable AMRISC side protocol */
+	vvp9_prot_init(pbi);
+
+	if (vdec_request_irq(VDEC_IRQ_1, vvp9_isr,
+				"vvp9-irq", (void *)pbi)) {
+		pr_info("vvp9 irq register error.\n");
+		amhevc_disable();
+		return -ENOENT;
+	}
+
+	pbi->stat |= STAT_ISR_REG;
+
+	vf_provider_init(&vvp9_vf_prov, PROVIDER_NAME, &vvp9_vf_provider,
+					 pbi);
+	vf_reg_provider(&vvp9_vf_prov);
+	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_START, NULL);
+
+	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
+	(void *)((unsigned long)pbi->frame_dur));
+
+	pbi->stat |= STAT_VF_HOOK;
+
+	pbi->timer.data = (ulong)pbi;
+	pbi->timer.function = vvp9_put_timer_func;
+	pbi->timer.expires = jiffies + PUT_INTERVAL;
+
+
+	add_timer(&pbi->timer);
+
+	pbi->stat |= STAT_TIMER_ARM;
+
+	/* pbi->stat |= STAT_KTHREAD; */
+
+	amhevc_start();
+
+	pbi->stat |= STAT_VDEC_RUN;
+
+	set_vdec_func(&vvp9_dec_status);
+
+	pbi->init_flag = 1;
+	pbi->process_busy = 0;
+	pr_info("%d, vvp9_init, RP=0x%x\n",
+		__LINE__, READ_VREG(HEVC_STREAM_RD_PTR));
+	return 0;
+}
+
+static int vvp9_stop(struct VP9Decoder_s *pbi)
+{
+
+	pbi->init_flag = 0;
+
+	if ((debug & VP9_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP) == 0) {
+		int wait_timeout_count = 0;
+		while ((READ_VREG(HEVC_DEC_STATUS_REG) ==
+			   VP9_10B_DECODE_SLICE &&
+				wait_timeout_count < 10) ||
+				pbi->process_busy){
+			wait_timeout_count++;
+			msleep(20);
+		}
+	}
+
+	if (pbi->stat & STAT_VDEC_RUN) {
+		amhevc_stop();
+		pbi->stat &= ~STAT_VDEC_RUN;
+	}
+
+	if (pbi->stat & STAT_ISR_REG) {
+		WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
+		vdec_free_irq(VDEC_IRQ_1, (void *)pbi);
+		pbi->stat &= ~STAT_ISR_REG;
+	}
+
+	if (pbi->stat & STAT_TIMER_ARM) {
+		del_timer_sync(&pbi->timer);
+		pbi->stat &= ~STAT_TIMER_ARM;
+	}
+
+	if (pbi->stat & STAT_VF_HOOK) {
+		vf_notify_receiver(PROVIDER_NAME,
+				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
+
+		vf_unreg_provider(&vvp9_vf_prov);
+		pbi->stat &= ~STAT_VF_HOOK;
+	}
+
+	vp9_local_uninit(pbi);
+
+	if (use_cma) {
+		/*USE_BUF_BLOCK*/
+		uninit_buf_list(pbi);
+		pr_info("uninit list\n");
+	}
+
+	amhevc_disable();
+
+	return 0;
+}
+
+static int amvdec_vp9_probe(struct platform_device *pdev)
+{
+	struct vdec_dev_reg_s *pdata =
+		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	int i;
+	u32 predisp_addr;
+	unsigned long pre_last_frame_alloc_addr, pre_last_frame_alloc_size;
+	struct BUF_s BUF[MAX_BUF_NUM];
+	struct VP9Decoder_s *pbi = &gHevc;
+	mutex_lock(&vvp9_mutex);
+	predisp_addr = pbi->predisp_addr;
+	pre_last_frame_alloc_addr = pbi->pre_last_frame_alloc_addr;
+	pre_last_frame_alloc_size = pbi->pre_last_frame_alloc_size;
+	memcpy(&BUF[0], &pbi->m_BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
+	memset(pbi, 0, sizeof(VP9Decoder));
+	memcpy(&pbi->m_BUF[0], &BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
+	pbi->predisp_addr = predisp_addr;
+	pbi->pre_last_frame_alloc_addr = pre_last_frame_alloc_addr;
+	pbi->pre_last_frame_alloc_size = pre_last_frame_alloc_size;
+
+	pbi->init_flag = 0;
+	pbi->fatal_error = 0;
+	pbi->show_frame_num = 0;
+	if (pdata == NULL) {
+		pr_info("\namvdec_vp9 memory resource undefined.\n");
+		mutex_unlock(&vvp9_mutex);
+		return -EFAULT;
+	}
+
+	pbi->mc_buf_spec.buf_end = pdata->mem_end + 1;
+	for (i = 0; i < WORK_BUF_SPEC_NUM; i++)
+		amvvp9_workbuff_spec[i].start_adr = pdata->mem_start;
+
+	if (debug) {
+		pr_info("===VP9 decoder mem resource 0x%lx -- 0x%lx\n",
+			   pdata->mem_start, pdata->mem_end + 1);
+	}
+
+	if (pdata->sys_info)
+		pbi->vvp9_amstream_dec_info = *pdata->sys_info;
+	else {
+		pbi->vvp9_amstream_dec_info.width = 0;
+		pbi->vvp9_amstream_dec_info.height = 0;
+		pbi->vvp9_amstream_dec_info.rate = 30;
+	}
+
+	cma_dev = pdata->cma_dev;
+
+	if (vvp9_init(pbi) < 0) {
+		pr_info("\namvdec_vp9 init failed.\n");
+		vp9_local_uninit(pbi);
+		mutex_unlock(&vvp9_mutex);
+		return -ENODEV;
+	}
+	/*set the max clk for smooth playing...*/
+	hevc_source_changed(VFORMAT_VP9,
+			4096, 2048, 60);
+	mutex_unlock(&vvp9_mutex);
+
+	return 0;
+}
+
+static int amvdec_vp9_remove(struct platform_device *pdev)
+{
+	struct VP9Decoder_s *pbi = &gHevc;
+	if (debug)
+		pr_info("amvdec_vp9_remove\n");
+
+	mutex_lock(&vvp9_mutex);
+
+	vvp9_stop(pbi);
+
+
+	hevc_source_changed(VFORMAT_VP9, 0, 0, 0);
+
+
+#ifdef DEBUG_PTS
+	pr_info("pts missed %ld, pts hit %ld, duration %d\n",
+		   pbi->pts_missed, pbi->pts_hit, pbi->frame_dur);
+#endif
+
+	mutex_unlock(&vvp9_mutex);
+
+	return 0;
+}
+
+/****************************************/
+
+static struct platform_driver amvdec_vp9_driver = {
+	.probe = amvdec_vp9_probe,
+	.remove = amvdec_vp9_remove,
+#ifdef CONFIG_PM
+	.suspend = amvdec_suspend,
+	.resume = amvdec_resume,
+#endif
+	.driver = {
+		.name = DRIVER_NAME,
+	}
+};
+
+static struct codec_profile_t amvdec_vp9_profile = {
+	.name = "vp9",
+	.profile = ""
+};
+
+static int __init amvdec_vp9_driver_init_module(void)
+{
+	pr_debug("amvdec_vp9 module init\n");
+	error_handle_policy = 0;
+
+#ifdef ERROR_HANDLE_DEBUG
+	dbg_nal_skip_flag = 0;
+	dbg_nal_skip_count = 0;
+#endif
+	decode_stop_pos = 0;
+	decode_stop_pos_pre = 0;
+	decode_pic_begin = 0;
+	slice_parse_begin = 0;
+	step = 0;
+	buf_alloc_size = 0;
+
+	if (platform_driver_register(&amvdec_vp9_driver)) {
+		pr_err("failed to register amvdec_vp9 driver\n");
+		return -ENODEV;
+	}
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+		amvdec_vp9_profile.profile =
+			"4k, 10bit, dwrite, compressed";
+	} else {
+		amvdec_vp9_profile.name = "vp9_unsupport";
+	}
+
+	vcodec_profile_register(&amvdec_vp9_profile);
+
+	return 0;
+}
+
+static void __exit amvdec_vp9_driver_remove_module(void)
+{
+	pr_debug("amvdec_vp9 module remove.\n");
+
+	platform_driver_unregister(&amvdec_vp9_driver);
+}
+
+/****************************************/
+/*
+module_param(stat, uint, 0664);
+MODULE_PARM_DESC(stat, "\n amvdec_vp9 stat\n");
+*/
+module_param(use_cma, uint, 0664);
+MODULE_PARM_DESC(use_cma, "\n amvdec_vp9 use_cma\n");
+
+module_param(bit_depth_luma, uint, 0664);
+MODULE_PARM_DESC(bit_depth_luma, "\n amvdec_vp9 bit_depth_luma\n");
+
+module_param(bit_depth_chroma, uint, 0664);
+MODULE_PARM_DESC(bit_depth_chroma, "\n amvdec_vp9 bit_depth_chroma\n");
+
+module_param(frame_width, uint, 0664);
+MODULE_PARM_DESC(frame_width, "\n amvdec_vp9 frame_width\n");
+
+module_param(frame_height, uint, 0664);
+MODULE_PARM_DESC(frame_height, "\n amvdec_vp9 frame_height\n");
+
+module_param(debug, uint, 0664);
+MODULE_PARM_DESC(debug, "\n amvdec_vp9 debug\n");
+
+module_param(radr, uint, 0664);
+MODULE_PARM_DESC(radr, "\nradr\n");
+
+module_param(rval, uint, 0664);
+MODULE_PARM_DESC(rval, "\nrval\n");
+
+module_param(dbg_cmd, uint, 0664);
+MODULE_PARM_DESC(dbg_cmd, "\dbg_cmd\n");
+
+module_param(dbg_skip_decode_index, uint, 0664);
+MODULE_PARM_DESC(dbg_skip_decode_index, "\dbg_skip_decode_index\n");
+
+module_param(endian, uint, 0664);
+MODULE_PARM_DESC(endian, "\nrval\n");
+
+module_param(step, uint, 0664);
+MODULE_PARM_DESC(step, "\n amvdec_vp9 step\n");
+
+module_param(decode_stop_pos, uint, 0664);
+MODULE_PARM_DESC(decode_stop_pos, "\n amvdec_vp9 decode_stop_pos\n");
+
+module_param(decode_pic_begin, uint, 0664);
+MODULE_PARM_DESC(decode_pic_begin, "\n amvdec_vp9 decode_pic_begin\n");
+
+module_param(slice_parse_begin, uint, 0664);
+MODULE_PARM_DESC(slice_parse_begin, "\n amvdec_vp9 slice_parse_begin\n");
+
+module_param(i_only_flag, uint, 0664);
+MODULE_PARM_DESC(i_only_flag, "\n amvdec_vp9 i_only_flag\n");
+
+module_param(error_handle_policy, uint, 0664);
+MODULE_PARM_DESC(error_handle_policy, "\n amvdec_vp9 error_handle_policy\n");
+
+module_param(buf_alloc_width, uint, 0664);
+MODULE_PARM_DESC(buf_alloc_width, "\n buf_alloc_width\n");
+
+module_param(buf_alloc_height, uint, 0664);
+MODULE_PARM_DESC(buf_alloc_height, "\n buf_alloc_height\n");
+
+module_param(buf_alloc_depth, uint, 0664);
+MODULE_PARM_DESC(buf_alloc_depth, "\n buf_alloc_depth\n");
+
+module_param(buf_alloc_size, uint, 0664);
+MODULE_PARM_DESC(buf_alloc_size, "\n buf_alloc_size\n");
+
+module_param(buffer_mode, uint, 0664);
+MODULE_PARM_DESC(buffer_mode, "\n buffer_mode\n");
+
+module_param(buffer_mode_dbg, uint, 0664);
+MODULE_PARM_DESC(buffer_mode_dbg, "\n buffer_mode_dbg\n");
+/*USE_BUF_BLOCK*/
+module_param(max_buf_num, uint, 0664);
+MODULE_PARM_DESC(max_buf_num, "\n max_buf_num\n");
+
+module_param(dynamic_buf_num_margin, uint, 0664);
+MODULE_PARM_DESC(dynamic_buf_num_margin, "\n dynamic_buf_num_margin\n");
+/**/
+
+module_param(mem_map_mode, uint, 0664);
+MODULE_PARM_DESC(mem_map_mode, "\n mem_map_mode\n");
+
+#ifdef SUPPORT_10BIT
+module_param(double_write_mode, uint, 0664);
+MODULE_PARM_DESC(double_write_mode, "\n double_write_mode\n");
+
+module_param(enable_mem_saving, uint, 0664);
+MODULE_PARM_DESC(enable_mem_saving, "\n enable_mem_saving\n");
+
+module_param(force_w_h, uint, 0664);
+MODULE_PARM_DESC(force_w_h, "\n force_w_h\n");
+#endif
+
+module_param(force_fps, uint, 0664);
+MODULE_PARM_DESC(force_fps, "\n force_fps\n");
+
+module_param(max_decoding_time, uint, 0664);
+MODULE_PARM_DESC(max_decoding_time, "\n max_decoding_time\n");
+
+module_init(amvdec_vp9_driver_init_module);
+module_exit(amvdec_vp9_driver_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC vp9 Video Decoder Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <tim.yao@amlogic.com>");
diff --git a/drivers/amlogic/amports/vvp9.h b/drivers/amlogic/amports/vvp9.h
new file mode 100644
index 0000000..1413f71
--- /dev/null
+++ b/drivers/amlogic/amports/vvp9.h
@@ -0,0 +1,32 @@
+/*
+ * drivers/amlogic/amports/vvp9.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef VVP9_H
+#define VVP9_H
+
+#ifdef VP9_10B_MMU
+void init_mmu_spec(void);
+void alloc_mmu(int cur_buf_idx, int pic_width, int pic_height,
+		unsigned short bit_depth, unsigned int *mmu_index_adr);
+void release_unused_4k(long used_4k_num, int cur_buf_idx);
+void release_buffer_4k(int cur_buf_idx);
+int  compute_losless_comp_body_size(int width, int height,
+		unsigned char bit_depth_10);
+#endif
+void adapt_coef_probs(int pic_count, int prev_kf, int cur_kf, int pre_fc,
+unsigned int *prev_prob, unsigned int *cur_prob, unsigned int *count);
+#endif
-- 
1.9.1

